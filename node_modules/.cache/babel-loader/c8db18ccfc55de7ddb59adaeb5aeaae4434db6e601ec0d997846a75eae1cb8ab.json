{"ast":null,"code":"import _construct from \"/Users/priyadeliwala/Desktop/sales-dashboard/node_modules/@babel/runtime/helpers/esm/construct.js\";\nimport _classCallCheck from \"/Users/priyadeliwala/Desktop/sales-dashboard/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/priyadeliwala/Desktop/sales-dashboard/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _callSuper from \"/Users/priyadeliwala/Desktop/sales-dashboard/node_modules/@babel/runtime/helpers/esm/callSuper.js\";\nimport _inherits from \"/Users/priyadeliwala/Desktop/sales-dashboard/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport { addClass, getScrollbarWidth, getScrollLeft, getMaximumScrollLeft, getWindowScrollTop, hasClass, outerWidth, removeClass, setOverlayPosition, resetCssTransform } from \"../../../../helpers/dom/element.mjs\";\nimport InlineStartOverlayTable from \"../table/inlineStart.mjs\";\nimport { Overlay } from \"./_base.mjs\";\nimport { CORNER_DEFAULT_STYLE } from \"../selection/index.mjs\";\nimport { CLONE_INLINE_START } from \"./constants.mjs\";\n/**\n * @class InlineStartOverlay\n */\nexport var InlineStartOverlay = /*#__PURE__*/function (_Overlay) {\n  /**\n   * @param {Walkontable} wotInstance The Walkontable instance. @TODO refactoring: check if can be deleted.\n   * @param {FacadeGetter} facadeGetter Function which return proper facade.\n   * @param {Settings} wtSettings The Walkontable settings.\n   * @param {DomBindings} domBindings Dom elements bound to the current instance.\n   */\n  function InlineStartOverlay(wotInstance, facadeGetter, wtSettings, domBindings) {\n    _classCallCheck(this, InlineStartOverlay);\n    return _callSuper(this, InlineStartOverlay, [wotInstance, facadeGetter, CLONE_INLINE_START, wtSettings, domBindings]);\n  }\n\n  /**\n   * Factory method to create a subclass of `Table` that is relevant to this overlay.\n   *\n   * @see Table#constructor\n   * @param {...*} args Parameters that will be forwarded to the `Table` constructor.\n   * @returns {InlineStartOverlayTable}\n   */\n  _inherits(InlineStartOverlay, _Overlay);\n  return _createClass(InlineStartOverlay, [{\n    key: \"createTable\",\n    value: function createTable() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return _construct(InlineStartOverlayTable, args);\n    }\n\n    /**\n     * Checks if overlay should be fully rendered.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"shouldBeRendered\",\n    value: function shouldBeRendered() {\n      return this.wtSettings.getSetting('shouldRenderInlineStartOverlay');\n    }\n\n    /**\n     * Updates the left overlay position.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"resetFixedPosition\",\n    value: function resetFixedPosition() {\n      var wtTable = this.wot.wtTable;\n      if (!this.needFullRender || !this.shouldBeRendered() || !wtTable.holder.parentNode) {\n        // removed from DOM\n        return false;\n      }\n      var rootWindow = this.domBindings.rootWindow;\n      var overlayRoot = this.clone.wtTable.holder.parentNode;\n      var preventOverflow = this.wtSettings.getSetting('preventOverflow');\n      var overlayPosition = 0;\n      if (this.trimmingContainer === rootWindow && (!preventOverflow || preventOverflow !== 'horizontal')) {\n        overlayPosition = this.getOverlayOffset() * (this.isRtl() ? -1 : 1);\n        setOverlayPosition(overlayRoot, \"\".concat(overlayPosition, \"px\"), '0px');\n      } else {\n        overlayPosition = this.getScrollPosition();\n        resetCssTransform(overlayRoot);\n      }\n      var positionChanged = this.adjustHeaderBordersPosition(overlayPosition);\n      this.adjustElementsSize();\n      return positionChanged;\n    }\n\n    /**\n     * Sets the main overlay's horizontal scroll position.\n     *\n     * @param {number} pos The scroll position.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"setScrollPosition\",\n    value: function setScrollPosition(pos) {\n      var rootWindow = this.domBindings.rootWindow;\n      var result = false;\n      if (this.isRtl()) {\n        pos = -pos;\n      }\n      if (this.mainTableScrollableElement === rootWindow && rootWindow.scrollX !== pos) {\n        rootWindow.scrollTo(pos, getWindowScrollTop(rootWindow));\n        result = true;\n      } else if (this.mainTableScrollableElement.scrollLeft !== pos) {\n        this.mainTableScrollableElement.scrollLeft = pos;\n        result = true;\n      }\n      return result;\n    }\n\n    /**\n     * Triggers onScroll hook callback.\n     */\n  }, {\n    key: \"onScroll\",\n    value: function onScroll() {\n      this.wtSettings.getSetting('onScrollVertically');\n    }\n\n    /**\n     * Calculates total sum cells width.\n     *\n     * @param {number} from Column index which calculates started from.\n     * @param {number} to Column index where calculation is finished.\n     * @returns {number} Width sum.\n     */\n  }, {\n    key: \"sumCellSizes\",\n    value: function sumCellSizes(from, to) {\n      var defaultColumnWidth = this.wtSettings.getSetting('defaultColumnWidth');\n      var column = from;\n      var sum = 0;\n      while (column < to) {\n        sum += this.wot.wtTable.getStretchedColumnWidth(column) || defaultColumnWidth;\n        column += 1;\n      }\n      return sum;\n    }\n\n    /**\n     * Adjust overlay root element, children and master table element sizes (width, height).\n     */\n  }, {\n    key: \"adjustElementsSize\",\n    value: function adjustElementsSize() {\n      this.updateTrimmingContainer();\n      if (this.needFullRender) {\n        this.adjustRootElementSize();\n        this.adjustRootChildrenSize();\n      }\n    }\n\n    /**\n     * Adjust overlay root element size (width and height).\n     */\n  }, {\n    key: \"adjustRootElementSize\",\n    value: function adjustRootElementSize() {\n      var wtTable = this.wot.wtTable;\n      var _this$domBindings = this.domBindings,\n        rootDocument = _this$domBindings.rootDocument,\n        rootWindow = _this$domBindings.rootWindow;\n      var scrollbarHeight = getScrollbarWidth(rootDocument);\n      var overlayRoot = this.clone.wtTable.holder.parentNode;\n      var overlayRootStyle = overlayRoot.style;\n      var preventOverflow = this.wtSettings.getSetting('preventOverflow');\n      if (this.trimmingContainer !== rootWindow || preventOverflow === 'vertical') {\n        var height = this.wot.wtViewport.getWorkspaceHeight();\n        if (this.wot.wtOverlays.hasScrollbarBottom) {\n          height -= scrollbarHeight;\n        }\n        height = Math.min(height, wtTable.wtRootElement.scrollHeight);\n        overlayRootStyle.height = \"\".concat(height, \"px\");\n      } else {\n        overlayRootStyle.height = '';\n      }\n      this.clone.wtTable.holder.style.height = overlayRootStyle.height;\n      var tableWidth = outerWidth(this.clone.wtTable.TABLE);\n      overlayRootStyle.width = \"\".concat(tableWidth, \"px\");\n    }\n\n    /**\n     * Adjust overlay root childs size.\n     */\n  }, {\n    key: \"adjustRootChildrenSize\",\n    value: function adjustRootChildrenSize() {\n      var holder = this.clone.wtTable.holder;\n      var selectionCornerOffset = this.wot.selectionManager.getFocusSelection() ? parseInt(CORNER_DEFAULT_STYLE.width, 10) / 2 : 0;\n      this.clone.wtTable.hider.style.height = this.hider.style.height;\n      holder.style.height = holder.parentNode.style.height;\n      // Add selection corner protruding part to the holder total width to make sure that\n      // borders' corner won't be cut after horizontal scroll (#6937).\n      holder.style.width = \"\".concat(parseInt(holder.parentNode.style.width, 10) + selectionCornerOffset, \"px\");\n    }\n\n    /**\n     * Adjust the overlay dimensions and position.\n     */\n  }, {\n    key: \"applyToDOM\",\n    value: function applyToDOM() {\n      var total = this.wtSettings.getSetting('totalColumns');\n      var styleProperty = this.isRtl() ? 'right' : 'left';\n      if (typeof this.wot.wtViewport.columnsRenderCalculator.startPosition === 'number') {\n        this.spreader.style[styleProperty] = \"\".concat(this.wot.wtViewport.columnsRenderCalculator.startPosition, \"px\");\n      } else if (total === 0) {\n        this.spreader.style[styleProperty] = '0';\n      } else {\n        throw new Error('Incorrect value of the columnsRenderCalculator');\n      }\n      if (this.isRtl()) {\n        this.spreader.style.left = '';\n      } else {\n        this.spreader.style.right = '';\n      }\n      if (this.needFullRender) {\n        this.syncOverlayOffset();\n      }\n    }\n\n    /**\n     * Synchronize calculated top position to an element.\n     */\n  }, {\n    key: \"syncOverlayOffset\",\n    value: function syncOverlayOffset() {\n      if (typeof this.wot.wtViewport.rowsRenderCalculator.startPosition === 'number') {\n        this.clone.wtTable.spreader.style.top = \"\".concat(this.wot.wtViewport.rowsRenderCalculator.startPosition, \"px\");\n      } else {\n        this.clone.wtTable.spreader.style.top = '';\n      }\n    }\n\n    /**\n     * Scrolls horizontally to a column at the left edge of the viewport.\n     *\n     * @param {number} sourceCol  Column index which you want to scroll to.\n     * @param {boolean} [beyondRendered]  If `true`, scrolls according to the right\n     *                                    edge (left edge is by default).\n     * @returns {boolean}\n     */\n  }, {\n    key: \"scrollTo\",\n    value: function scrollTo(sourceCol, beyondRendered) {\n      var wtSettings = this.wtSettings;\n      var rowHeaders = wtSettings.getSetting('rowHeaders');\n      var fixedColumnsStart = wtSettings.getSetting('fixedColumnsStart');\n      var sourceInstance = this.wot.cloneSource ? this.wot.cloneSource : this.wot;\n      var mainHolder = sourceInstance.wtTable.holder;\n      var rowHeaderBorderCompensation = fixedColumnsStart === 0 && rowHeaders.length > 0 && !hasClass(mainHolder.parentNode, 'innerBorderInlineStart') ? 1 : 0;\n      var newX = this.getTableParentOffset();\n      var scrollbarCompensation = 0;\n      if (beyondRendered) {\n        var columnWidth = this.wot.wtTable.getColumnWidth(sourceCol);\n        var viewportWidth = this.wot.wtViewport.getViewportWidth();\n        if (columnWidth > viewportWidth) {\n          beyondRendered = false;\n        }\n      }\n      if (beyondRendered && mainHolder.offsetWidth !== mainHolder.clientWidth) {\n        scrollbarCompensation = getScrollbarWidth(this.domBindings.rootDocument);\n      }\n      if (beyondRendered) {\n        newX += this.sumCellSizes(0, sourceCol + 1);\n        newX -= this.wot.wtViewport.getViewportWidth();\n        // Compensate for the right header border if scrolled from the absolute left.\n        newX += rowHeaderBorderCompensation;\n      } else {\n        newX += this.sumCellSizes(this.wtSettings.getSetting('fixedColumnsStart'), sourceCol);\n      }\n      newX += scrollbarCompensation;\n\n      // If the table is scrolled all the way left when starting the scroll and going to be scrolled to the far right,\n      // we need to compensate for the potential header border width.\n      if (getMaximumScrollLeft(this.mainTableScrollableElement) === newX - rowHeaderBorderCompensation && rowHeaderBorderCompensation > 0) {\n        this.wot.wtOverlays.expandHiderHorizontallyBy(rowHeaderBorderCompensation);\n      }\n      return this.setScrollPosition(newX);\n    }\n\n    /**\n     * Gets table parent left position.\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"getTableParentOffset\",\n    value: function getTableParentOffset() {\n      var preventOverflow = this.wtSettings.getSetting('preventOverflow');\n      var offset = 0;\n      if (!preventOverflow && this.trimmingContainer === this.domBindings.rootWindow) {\n        offset = this.wot.wtTable.holderOffset.left;\n      }\n      return offset;\n    }\n\n    /**\n     * Gets the main overlay's horizontal scroll position.\n     *\n     * @returns {number} Main table's horizontal scroll position.\n     */\n  }, {\n    key: \"getScrollPosition\",\n    value: function getScrollPosition() {\n      return Math.abs(getScrollLeft(this.mainTableScrollableElement, this.domBindings.rootWindow));\n    }\n\n    /**\n     * Gets the main overlay's horizontal overlay offset.\n     *\n     * @returns {number} Main table's horizontal overlay offset.\n     */\n  }, {\n    key: \"getOverlayOffset\",\n    value: function getOverlayOffset() {\n      var rootWindow = this.domBindings.rootWindow;\n      var preventOverflow = this.wtSettings.getSetting('preventOverflow');\n      var overlayOffset = 0;\n      if (this.trimmingContainer === rootWindow && (!preventOverflow || preventOverflow !== 'horizontal')) {\n        if (this.isRtl()) {\n          overlayOffset = Math.abs(Math.min(this.getTableParentOffset() - this.getScrollPosition(), 0));\n        } else {\n          overlayOffset = Math.max(this.getScrollPosition() - this.getTableParentOffset(), 0);\n        }\n        var rootWidth = this.wot.wtTable.getTotalWidth();\n        var overlayRootWidth = this.clone.wtTable.getTotalWidth();\n        var maxOffset = rootWidth - overlayRootWidth;\n        if (overlayOffset > maxOffset) {\n          overlayOffset = 0;\n        }\n      }\n      return overlayOffset;\n    }\n\n    /**\n     * Adds css classes to hide the header border's header (cell-selection border hiding issue).\n     *\n     * @param {number} position Header X position if trimming container is window or scroll top if not.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"adjustHeaderBordersPosition\",\n    value: function adjustHeaderBordersPosition(position) {\n      var wtSettings = this.wtSettings;\n      var masterParent = this.wot.wtTable.holder.parentNode;\n      var rowHeaders = wtSettings.getSetting('rowHeaders');\n      var fixedColumnsStart = wtSettings.getSetting('fixedColumnsStart');\n      var totalRows = wtSettings.getSetting('totalRows');\n      var preventVerticalOverflow = wtSettings.getSetting('preventOverflow') === 'vertical';\n      if (totalRows) {\n        removeClass(masterParent, 'emptyRows');\n      } else {\n        addClass(masterParent, 'emptyRows');\n      }\n      var positionChanged = false;\n      if (!preventVerticalOverflow) {\n        if (fixedColumnsStart && !rowHeaders.length) {\n          // \"innerBorderLeft\" is for backward compatibility\n          addClass(masterParent, 'innerBorderLeft innerBorderInlineStart');\n        } else if (!fixedColumnsStart && rowHeaders.length) {\n          var previousState = hasClass(masterParent, 'innerBorderInlineStart');\n          if (position) {\n            addClass(masterParent, 'innerBorderLeft innerBorderInlineStart');\n            positionChanged = !previousState;\n          } else {\n            removeClass(masterParent, 'innerBorderLeft innerBorderInlineStart');\n            positionChanged = previousState;\n          }\n        }\n      }\n      return positionChanged;\n    }\n  }]);\n}(Overlay);","map":{"version":3,"names":["addClass","getScrollbarWidth","getScrollLeft","getMaximumScrollLeft","getWindowScrollTop","hasClass","outerWidth","removeClass","setOverlayPosition","resetCssTransform","InlineStartOverlayTable","Overlay","CORNER_DEFAULT_STYLE","CLONE_INLINE_START","InlineStartOverlay","_Overlay","wotInstance","facadeGetter","wtSettings","domBindings","_classCallCheck","_callSuper","_inherits","_createClass","key","value","createTable","_len","arguments","length","args","Array","_key","_construct","shouldBeRendered","getSetting","resetFixedPosition","wtTable","wot","needFullRender","holder","parentNode","rootWindow","overlayRoot","clone","preventOverflow","overlayPosition","trimmingContainer","getOverlayOffset","isRtl","concat","getScrollPosition","positionChanged","adjustHeaderBordersPosition","adjustElementsSize","setScrollPosition","pos","result","mainTableScrollableElement","scrollX","scrollTo","scrollLeft","onScroll","sumCellSizes","from","to","defaultColumnWidth","column","sum","getStretchedColumnWidth","updateTrimmingContainer","adjustRootElementSize","adjustRootChildrenSize","_this$domBindings","rootDocument","scrollbarHeight","overlayRootStyle","style","height","wtViewport","getWorkspaceHeight","wtOverlays","hasScrollbarBottom","Math","min","wtRootElement","scrollHeight","tableWidth","TABLE","width","selectionCornerOffset","selectionManager","getFocusSelection","parseInt","hider","applyToDOM","total","styleProperty","columnsRenderCalculator","startPosition","spreader","Error","left","right","syncOverlayOffset","rowsRenderCalculator","top","sourceCol","beyondRendered","rowHeaders","fixedColumnsStart","sourceInstance","cloneSource","mainHolder","rowHeaderBorderCompensation","newX","getTableParentOffset","scrollbarCompensation","columnWidth","getColumnWidth","viewportWidth","getViewportWidth","offsetWidth","clientWidth","expandHiderHorizontallyBy","offset","holderOffset","abs","overlayOffset","max","rootWidth","getTotalWidth","overlayRootWidth","maxOffset","position","masterParent","totalRows","preventVerticalOverflow","previousState"],"sources":["/Users/priyadeliwala/node_modules/handsontable/3rdparty/walkontable/src/overlay/inlineStart.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nimport { addClass, getScrollbarWidth, getScrollLeft, getMaximumScrollLeft, getWindowScrollTop, hasClass, outerWidth, removeClass, setOverlayPosition, resetCssTransform } from \"../../../../helpers/dom/element.mjs\";\nimport InlineStartOverlayTable from \"../table/inlineStart.mjs\";\nimport { Overlay } from \"./_base.mjs\";\nimport { CORNER_DEFAULT_STYLE } from \"../selection/index.mjs\";\nimport { CLONE_INLINE_START } from \"./constants.mjs\";\n/**\n * @class InlineStartOverlay\n */\nexport class InlineStartOverlay extends Overlay {\n  /**\n   * @param {Walkontable} wotInstance The Walkontable instance. @TODO refactoring: check if can be deleted.\n   * @param {FacadeGetter} facadeGetter Function which return proper facade.\n   * @param {Settings} wtSettings The Walkontable settings.\n   * @param {DomBindings} domBindings Dom elements bound to the current instance.\n   */\n  constructor(wotInstance, facadeGetter, wtSettings, domBindings) {\n    super(wotInstance, facadeGetter, CLONE_INLINE_START, wtSettings, domBindings);\n  }\n\n  /**\n   * Factory method to create a subclass of `Table` that is relevant to this overlay.\n   *\n   * @see Table#constructor\n   * @param {...*} args Parameters that will be forwarded to the `Table` constructor.\n   * @returns {InlineStartOverlayTable}\n   */\n  createTable() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return new InlineStartOverlayTable(...args);\n  }\n\n  /**\n   * Checks if overlay should be fully rendered.\n   *\n   * @returns {boolean}\n   */\n  shouldBeRendered() {\n    return this.wtSettings.getSetting('shouldRenderInlineStartOverlay');\n  }\n\n  /**\n   * Updates the left overlay position.\n   *\n   * @returns {boolean}\n   */\n  resetFixedPosition() {\n    const {\n      wtTable\n    } = this.wot;\n    if (!this.needFullRender || !this.shouldBeRendered() || !wtTable.holder.parentNode) {\n      // removed from DOM\n      return false;\n    }\n    const {\n      rootWindow\n    } = this.domBindings;\n    const overlayRoot = this.clone.wtTable.holder.parentNode;\n    const preventOverflow = this.wtSettings.getSetting('preventOverflow');\n    let overlayPosition = 0;\n    if (this.trimmingContainer === rootWindow && (!preventOverflow || preventOverflow !== 'horizontal')) {\n      overlayPosition = this.getOverlayOffset() * (this.isRtl() ? -1 : 1);\n      setOverlayPosition(overlayRoot, `${overlayPosition}px`, '0px');\n    } else {\n      overlayPosition = this.getScrollPosition();\n      resetCssTransform(overlayRoot);\n    }\n    const positionChanged = this.adjustHeaderBordersPosition(overlayPosition);\n    this.adjustElementsSize();\n    return positionChanged;\n  }\n\n  /**\n   * Sets the main overlay's horizontal scroll position.\n   *\n   * @param {number} pos The scroll position.\n   * @returns {boolean}\n   */\n  setScrollPosition(pos) {\n    const {\n      rootWindow\n    } = this.domBindings;\n    let result = false;\n    if (this.isRtl()) {\n      pos = -pos;\n    }\n    if (this.mainTableScrollableElement === rootWindow && rootWindow.scrollX !== pos) {\n      rootWindow.scrollTo(pos, getWindowScrollTop(rootWindow));\n      result = true;\n    } else if (this.mainTableScrollableElement.scrollLeft !== pos) {\n      this.mainTableScrollableElement.scrollLeft = pos;\n      result = true;\n    }\n    return result;\n  }\n\n  /**\n   * Triggers onScroll hook callback.\n   */\n  onScroll() {\n    this.wtSettings.getSetting('onScrollVertically');\n  }\n\n  /**\n   * Calculates total sum cells width.\n   *\n   * @param {number} from Column index which calculates started from.\n   * @param {number} to Column index where calculation is finished.\n   * @returns {number} Width sum.\n   */\n  sumCellSizes(from, to) {\n    const defaultColumnWidth = this.wtSettings.getSetting('defaultColumnWidth');\n    let column = from;\n    let sum = 0;\n    while (column < to) {\n      sum += this.wot.wtTable.getStretchedColumnWidth(column) || defaultColumnWidth;\n      column += 1;\n    }\n    return sum;\n  }\n\n  /**\n   * Adjust overlay root element, children and master table element sizes (width, height).\n   */\n  adjustElementsSize() {\n    this.updateTrimmingContainer();\n    if (this.needFullRender) {\n      this.adjustRootElementSize();\n      this.adjustRootChildrenSize();\n    }\n  }\n\n  /**\n   * Adjust overlay root element size (width and height).\n   */\n  adjustRootElementSize() {\n    const {\n      wtTable\n    } = this.wot;\n    const {\n      rootDocument,\n      rootWindow\n    } = this.domBindings;\n    const scrollbarHeight = getScrollbarWidth(rootDocument);\n    const overlayRoot = this.clone.wtTable.holder.parentNode;\n    const overlayRootStyle = overlayRoot.style;\n    const preventOverflow = this.wtSettings.getSetting('preventOverflow');\n    if (this.trimmingContainer !== rootWindow || preventOverflow === 'vertical') {\n      let height = this.wot.wtViewport.getWorkspaceHeight();\n      if (this.wot.wtOverlays.hasScrollbarBottom) {\n        height -= scrollbarHeight;\n      }\n      height = Math.min(height, wtTable.wtRootElement.scrollHeight);\n      overlayRootStyle.height = `${height}px`;\n    } else {\n      overlayRootStyle.height = '';\n    }\n    this.clone.wtTable.holder.style.height = overlayRootStyle.height;\n    const tableWidth = outerWidth(this.clone.wtTable.TABLE);\n    overlayRootStyle.width = `${tableWidth}px`;\n  }\n\n  /**\n   * Adjust overlay root childs size.\n   */\n  adjustRootChildrenSize() {\n    const {\n      holder\n    } = this.clone.wtTable;\n    const selectionCornerOffset = this.wot.selectionManager.getFocusSelection() ? parseInt(CORNER_DEFAULT_STYLE.width, 10) / 2 : 0;\n    this.clone.wtTable.hider.style.height = this.hider.style.height;\n    holder.style.height = holder.parentNode.style.height;\n    // Add selection corner protruding part to the holder total width to make sure that\n    // borders' corner won't be cut after horizontal scroll (#6937).\n    holder.style.width = `${parseInt(holder.parentNode.style.width, 10) + selectionCornerOffset}px`;\n  }\n\n  /**\n   * Adjust the overlay dimensions and position.\n   */\n  applyToDOM() {\n    const total = this.wtSettings.getSetting('totalColumns');\n    const styleProperty = this.isRtl() ? 'right' : 'left';\n    if (typeof this.wot.wtViewport.columnsRenderCalculator.startPosition === 'number') {\n      this.spreader.style[styleProperty] = `${this.wot.wtViewport.columnsRenderCalculator.startPosition}px`;\n    } else if (total === 0) {\n      this.spreader.style[styleProperty] = '0';\n    } else {\n      throw new Error('Incorrect value of the columnsRenderCalculator');\n    }\n    if (this.isRtl()) {\n      this.spreader.style.left = '';\n    } else {\n      this.spreader.style.right = '';\n    }\n    if (this.needFullRender) {\n      this.syncOverlayOffset();\n    }\n  }\n\n  /**\n   * Synchronize calculated top position to an element.\n   */\n  syncOverlayOffset() {\n    if (typeof this.wot.wtViewport.rowsRenderCalculator.startPosition === 'number') {\n      this.clone.wtTable.spreader.style.top = `${this.wot.wtViewport.rowsRenderCalculator.startPosition}px`;\n    } else {\n      this.clone.wtTable.spreader.style.top = '';\n    }\n  }\n\n  /**\n   * Scrolls horizontally to a column at the left edge of the viewport.\n   *\n   * @param {number} sourceCol  Column index which you want to scroll to.\n   * @param {boolean} [beyondRendered]  If `true`, scrolls according to the right\n   *                                    edge (left edge is by default).\n   * @returns {boolean}\n   */\n  scrollTo(sourceCol, beyondRendered) {\n    const {\n      wtSettings\n    } = this;\n    const rowHeaders = wtSettings.getSetting('rowHeaders');\n    const fixedColumnsStart = wtSettings.getSetting('fixedColumnsStart');\n    const sourceInstance = this.wot.cloneSource ? this.wot.cloneSource : this.wot;\n    const mainHolder = sourceInstance.wtTable.holder;\n    const rowHeaderBorderCompensation = fixedColumnsStart === 0 && rowHeaders.length > 0 && !hasClass(mainHolder.parentNode, 'innerBorderInlineStart') ? 1 : 0;\n    let newX = this.getTableParentOffset();\n    let scrollbarCompensation = 0;\n    if (beyondRendered) {\n      const columnWidth = this.wot.wtTable.getColumnWidth(sourceCol);\n      const viewportWidth = this.wot.wtViewport.getViewportWidth();\n      if (columnWidth > viewportWidth) {\n        beyondRendered = false;\n      }\n    }\n    if (beyondRendered && mainHolder.offsetWidth !== mainHolder.clientWidth) {\n      scrollbarCompensation = getScrollbarWidth(this.domBindings.rootDocument);\n    }\n    if (beyondRendered) {\n      newX += this.sumCellSizes(0, sourceCol + 1);\n      newX -= this.wot.wtViewport.getViewportWidth();\n      // Compensate for the right header border if scrolled from the absolute left.\n      newX += rowHeaderBorderCompensation;\n    } else {\n      newX += this.sumCellSizes(this.wtSettings.getSetting('fixedColumnsStart'), sourceCol);\n    }\n    newX += scrollbarCompensation;\n\n    // If the table is scrolled all the way left when starting the scroll and going to be scrolled to the far right,\n    // we need to compensate for the potential header border width.\n    if (getMaximumScrollLeft(this.mainTableScrollableElement) === newX - rowHeaderBorderCompensation && rowHeaderBorderCompensation > 0) {\n      this.wot.wtOverlays.expandHiderHorizontallyBy(rowHeaderBorderCompensation);\n    }\n    return this.setScrollPosition(newX);\n  }\n\n  /**\n   * Gets table parent left position.\n   *\n   * @returns {number}\n   */\n  getTableParentOffset() {\n    const preventOverflow = this.wtSettings.getSetting('preventOverflow');\n    let offset = 0;\n    if (!preventOverflow && this.trimmingContainer === this.domBindings.rootWindow) {\n      offset = this.wot.wtTable.holderOffset.left;\n    }\n    return offset;\n  }\n\n  /**\n   * Gets the main overlay's horizontal scroll position.\n   *\n   * @returns {number} Main table's horizontal scroll position.\n   */\n  getScrollPosition() {\n    return Math.abs(getScrollLeft(this.mainTableScrollableElement, this.domBindings.rootWindow));\n  }\n\n  /**\n   * Gets the main overlay's horizontal overlay offset.\n   *\n   * @returns {number} Main table's horizontal overlay offset.\n   */\n  getOverlayOffset() {\n    const {\n      rootWindow\n    } = this.domBindings;\n    const preventOverflow = this.wtSettings.getSetting('preventOverflow');\n    let overlayOffset = 0;\n    if (this.trimmingContainer === rootWindow && (!preventOverflow || preventOverflow !== 'horizontal')) {\n      if (this.isRtl()) {\n        overlayOffset = Math.abs(Math.min(this.getTableParentOffset() - this.getScrollPosition(), 0));\n      } else {\n        overlayOffset = Math.max(this.getScrollPosition() - this.getTableParentOffset(), 0);\n      }\n      const rootWidth = this.wot.wtTable.getTotalWidth();\n      const overlayRootWidth = this.clone.wtTable.getTotalWidth();\n      const maxOffset = rootWidth - overlayRootWidth;\n      if (overlayOffset > maxOffset) {\n        overlayOffset = 0;\n      }\n    }\n    return overlayOffset;\n  }\n\n  /**\n   * Adds css classes to hide the header border's header (cell-selection border hiding issue).\n   *\n   * @param {number} position Header X position if trimming container is window or scroll top if not.\n   * @returns {boolean}\n   */\n  adjustHeaderBordersPosition(position) {\n    const {\n      wtSettings\n    } = this;\n    const masterParent = this.wot.wtTable.holder.parentNode;\n    const rowHeaders = wtSettings.getSetting('rowHeaders');\n    const fixedColumnsStart = wtSettings.getSetting('fixedColumnsStart');\n    const totalRows = wtSettings.getSetting('totalRows');\n    const preventVerticalOverflow = wtSettings.getSetting('preventOverflow') === 'vertical';\n    if (totalRows) {\n      removeClass(masterParent, 'emptyRows');\n    } else {\n      addClass(masterParent, 'emptyRows');\n    }\n    let positionChanged = false;\n    if (!preventVerticalOverflow) {\n      if (fixedColumnsStart && !rowHeaders.length) {\n        // \"innerBorderLeft\" is for backward compatibility\n        addClass(masterParent, 'innerBorderLeft innerBorderInlineStart');\n      } else if (!fixedColumnsStart && rowHeaders.length) {\n        const previousState = hasClass(masterParent, 'innerBorderInlineStart');\n        if (position) {\n          addClass(masterParent, 'innerBorderLeft innerBorderInlineStart');\n          positionChanged = !previousState;\n        } else {\n          removeClass(masterParent, 'innerBorderLeft innerBorderInlineStart');\n          positionChanged = previousState;\n        }\n      }\n    }\n    return positionChanged;\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}