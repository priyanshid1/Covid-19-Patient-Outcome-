{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nimport GlobalMeta from \"./metaLayers/globalMeta.mjs\";\nimport TableMeta from \"./metaLayers/tableMeta.mjs\";\nimport ColumnMeta from \"./metaLayers/columnMeta.mjs\";\nimport CellMeta from \"./metaLayers/cellMeta.mjs\";\nimport localHooks from \"../../mixins/localHooks.mjs\";\nimport { mixin } from \"../../helpers/object.mjs\";\n/**\n * With the Meta Manager class, it can be possible to manage with meta objects for different layers in\n * one place. All coordinates used to fetch, updating, removing, or creating rows or columns have to\n * be passed as physical values.\n *\n * The diagram of the meta layers:\n * +-------------+.\n * │ GlobalMeta  │\n * │ (prototype) │\n * +-------------+\\\n *       │         \\\n *       │          \\\n *      \\│/         _\\|\n * +-------------+    +-------------+.\n * │ TableMeta   │    │ ColumnMeta  │\n * │ (instance)  │    │ (prototype) │\n * +-------------+    +-------------+.\n *                         │\n *                         │\n *                        \\│/\n *                    +-------------+.\n *                    │  CellMeta   │\n *                    │ (instance)  │\n *                    +-------------+.\n *\n * A more detailed description of the specific layers can be found in the \"metaLayers/\" modules description.\n */\n\nvar MetaManager = /*#__PURE__*/function () {\n  function MetaManager(hot) {\n    var _this = this;\n    var customSettings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var metaMods = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    _classCallCheck(this, MetaManager);\n\n    /**\n     * @type {Handsontable}\n     */\n    this.hot = hot;\n    /**\n     * @type {GlobalMeta}\n     */\n\n    this.globalMeta = new GlobalMeta(hot);\n    this.globalMeta.updateMeta(customSettings);\n    /**\n     * @type {TableMeta}\n     */\n\n    this.tableMeta = new TableMeta(this.globalMeta);\n    /**\n     * @type {ColumnMeta}\n     */\n\n    this.columnMeta = new ColumnMeta(this.globalMeta);\n    /**\n     * @type {CellMeta}\n     */\n\n    this.cellMeta = new CellMeta(this.columnMeta);\n    metaMods.forEach(function (ModifierClass) {\n      return new ModifierClass(_this);\n    });\n  }\n  /**\n   * Gets the global meta object that is a root of all default settings, which are recognizable by Handsontable.\n   * Other layers inherites all properties from this. Adding, removing, or changing property in that\n   * object has a direct reflection to all layers.\n   *\n   * @returns {object}\n   */\n\n  _createClass(MetaManager, [{\n    key: \"getGlobalMeta\",\n    value: function getGlobalMeta() {\n      return this.globalMeta.getMeta();\n    }\n    /**\n     * Updates global settings object by merging settings with the current state.\n     *\n     * @param {object} settings An object to merge with.\n     */\n  }, {\n    key: \"updateGlobalMeta\",\n    value: function updateGlobalMeta(settings) {\n      this.globalMeta.updateMeta(settings);\n    }\n    /**\n     * Gets settings object that was passed in the Handsontable constructor. That layer contains all\n     * default settings inherited from the GlobalMeta layer merged with settings passed by the developer.\n     * Adding, removing, or changing property in that object has no direct reflection on any other layers.\n     *\n     * @returns {object}\n     */\n  }, {\n    key: \"getTableMeta\",\n    value: function getTableMeta() {\n      return this.tableMeta.getMeta();\n    }\n    /**\n     * Updates table settings object by merging settings with the current state.\n     *\n     * @param {object} settings An object to merge with.\n     */\n  }, {\n    key: \"updateTableMeta\",\n    value: function updateTableMeta(settings) {\n      this.tableMeta.updateMeta(settings);\n    }\n    /**\n     * Gets column meta object that is a root of all settings defined in the column property of the Handsontable\n     * settings. Each column in the Handsontable is associated with a unique meta object which identified by\n     * the physical column index. Adding, removing, or changing property in that object has a direct reflection\n     * only for the CellMeta layer. The reflection will be visible only if the property doesn't exist in the lower\n     * layers (prototype lookup).\n     *\n     * @param {number} physicalColumn The physical column index.\n     * @returns {object}\n     */\n  }, {\n    key: \"getColumnMeta\",\n    value: function getColumnMeta(physicalColumn) {\n      return this.columnMeta.getMeta(physicalColumn);\n    }\n    /**\n     * Updates column meta object by merging settings with the current state.\n     *\n     * @param {number} physicalColumn The physical column index which points what column meta object is updated.\n     * @param {object} settings An object to merge with.\n     */\n  }, {\n    key: \"updateColumnMeta\",\n    value: function updateColumnMeta(physicalColumn, settings) {\n      this.columnMeta.updateMeta(physicalColumn, settings);\n    }\n    /**\n     * Gets the cell meta object that is a root of all settings defined for the specific cell rendered by\n     * the Handsontable. Each cell meta inherits settings from higher layers. When a property doesn't\n     * exist in that layer, it is looked up through a prototype to the highest layer. Starting\n     * from CellMeta -> ColumnMeta and ending to GlobalMeta, which stores default settings. Adding,\n     * removing, or changing property in that object has no direct reflection on any other layers.\n     *\n     * @param {number} physicalRow The physical row index.\n     * @param {number} physicalColumn The physical column index.\n     * @param {object} options Additional options that are used to extend the cell meta object.\n     * @param {number} options.visualRow The visual row index of the currently requested cell meta object.\n     * @param {number} options.visualColumn The visual column index of the currently requested cell meta object.\n     * @returns {object}\n     */\n  }, {\n    key: \"getCellMeta\",\n    value: function getCellMeta(physicalRow, physicalColumn, _ref) {\n      var visualRow = _ref.visualRow,\n        visualColumn = _ref.visualColumn;\n      var cellMeta = this.cellMeta.getMeta(physicalRow, physicalColumn);\n      cellMeta.visualRow = visualRow;\n      cellMeta.visualCol = visualColumn;\n      cellMeta.row = physicalRow;\n      cellMeta.col = physicalColumn;\n      this.runLocalHooks('afterGetCellMeta', cellMeta);\n      return cellMeta;\n    }\n    /**\n     * Gets a value (defined by the `key` property) from the cell meta object.\n     *\n     * @param {number} physicalRow The physical row index.\n     * @param {number} physicalColumn The physical column index.\n     * @param {string} key Defines the value that will be returned from the cell meta object.\n     * @returns {*}\n     */\n  }, {\n    key: \"getCellMetaKeyValue\",\n    value: function getCellMetaKeyValue(physicalRow, physicalColumn, key) {\n      if (typeof key !== 'string') {\n        throw new Error('The passed cell meta object key is not a string');\n      }\n      return this.cellMeta.getMeta(physicalRow, physicalColumn, key);\n    }\n    /**\n     * Sets settings object for cell meta object defined by \"key\" property.\n     *\n     * @param {number} physicalRow The physical row index.\n     * @param {number} physicalColumn The physical column index.\n     * @param {string} key The property name to set.\n     * @param {*} value Value to save.\n     */\n  }, {\n    key: \"setCellMeta\",\n    value: function setCellMeta(physicalRow, physicalColumn, key, value) {\n      this.cellMeta.setMeta(physicalRow, physicalColumn, key, value);\n    }\n    /**\n     * Updates cell meta object by merging settings with the current state.\n     *\n     * @param {number} physicalRow The physical row index which points what cell meta object is updated.\n     * @param {number} physicalColumn The physical column index which points what cell meta object is updated.\n     * @param {object} settings An object to merge with.\n     */\n  }, {\n    key: \"updateCellMeta\",\n    value: function updateCellMeta(physicalRow, physicalColumn, settings) {\n      this.cellMeta.updateMeta(physicalRow, physicalColumn, settings);\n    }\n    /**\n     * Removes a property defined by the \"key\" argument from the cell meta object.\n     *\n     * @param {number} physicalRow The physical row index.\n     * @param {number} physicalColumn The physical column index.\n     * @param {string} key The property name to remove.\n     */\n  }, {\n    key: \"removeCellMeta\",\n    value: function removeCellMeta(physicalRow, physicalColumn, key) {\n      this.cellMeta.removeMeta(physicalRow, physicalColumn, key);\n    }\n    /**\n     * Returns all cell meta objects that were created during the Handsontable operation. As cell meta\n     * objects are created lazy, the length of the returned collection depends on how and when the\n     * table has asked for access to that meta objects.\n     *\n     * @returns {object[]}\n     */\n  }, {\n    key: \"getCellsMeta\",\n    value: function getCellsMeta() {\n      return this.cellMeta.getMetas();\n    }\n    /**\n     * Returns all cell meta objects that were created during the Handsontable operation but for\n     * specyfic row index.\n     *\n     * @param {number} physicalRow The physical row index.\n     * @returns {object[]}\n     */\n  }, {\n    key: \"getCellsMetaAtRow\",\n    value: function getCellsMetaAtRow(physicalRow) {\n      return this.cellMeta.getMetasAtRow(physicalRow);\n    }\n    /**\n     * Creates one or more rows at specific position.\n     *\n     * @param {number} physicalRow The physical row index which points from what position the row is added.\n     * @param {number} [amount=1] An amount of rows to add.\n     */\n  }, {\n    key: \"createRow\",\n    value: function createRow(physicalRow) {\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      this.cellMeta.createRow(physicalRow, amount);\n    }\n    /**\n     * Removes one or more rows from the collection.\n     *\n     * @param {number} physicalRow The physical row index which points from what position the row is removed.\n     * @param {number} [amount=1] An amount rows to remove.\n     */\n  }, {\n    key: \"removeRow\",\n    value: function removeRow(physicalRow) {\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      this.cellMeta.removeRow(physicalRow, amount);\n    }\n    /**\n     * Creates one or more columns at specific position.\n     *\n     * @param {number} physicalColumn The physical column index which points from what position the column is added.\n     * @param {number} [amount=1] An amount of columns to add.\n     */\n  }, {\n    key: \"createColumn\",\n    value: function createColumn(physicalColumn) {\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      this.cellMeta.createColumn(physicalColumn, amount);\n      this.columnMeta.createColumn(physicalColumn, amount);\n    }\n    /**\n     * Removes one or more columns from the collection.\n     *\n     * @param {number} physicalColumn The physical column index which points from what position the column is removed.\n     * @param {number} [amount=1] An amount of columns to remove.\n     */\n  }, {\n    key: \"removeColumn\",\n    value: function removeColumn(physicalColumn) {\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      this.cellMeta.removeColumn(physicalColumn, amount);\n      this.columnMeta.removeColumn(physicalColumn, amount);\n    }\n    /**\n     * Clears all saved cell meta objects. It keeps column meta, table meta, and global meta intact.\n     */\n  }, {\n    key: \"clearCellsCache\",\n    value: function clearCellsCache() {\n      this.cellMeta.clearCache();\n    }\n    /**\n     * Clears all saved cell and columns meta objects.\n     */\n  }, {\n    key: \"clearCache\",\n    value: function clearCache() {\n      this.cellMeta.clearCache();\n      this.columnMeta.clearCache();\n    }\n  }]);\n  return MetaManager;\n}();\nexport { MetaManager as default };\nmixin(MetaManager, localHooks);","map":{"version":3,"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","GlobalMeta","TableMeta","ColumnMeta","CellMeta","localHooks","mixin","MetaManager","hot","_this","customSettings","arguments","undefined","metaMods","globalMeta","updateMeta","tableMeta","columnMeta","cellMeta","forEach","ModifierClass","value","getGlobalMeta","getMeta","updateGlobalMeta","settings","getTableMeta","updateTableMeta","getColumnMeta","physicalColumn","updateColumnMeta","getCellMeta","physicalRow","_ref","visualRow","visualColumn","visualCol","row","col","runLocalHooks","getCellMetaKeyValue","Error","setCellMeta","setMeta","updateCellMeta","removeCellMeta","removeMeta","getCellsMeta","getMetas","getCellsMetaAtRow","getMetasAtRow","createRow","amount","removeRow","createColumn","removeColumn","clearCellsCache","clearCache","default"],"sources":["/Users/priyadeliwala/Desktop/sales-dashboard/node_modules/handsontable/dataMap/metaManager/index.mjs"],"sourcesContent":["import \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nimport GlobalMeta from \"./metaLayers/globalMeta.mjs\";\nimport TableMeta from \"./metaLayers/tableMeta.mjs\";\nimport ColumnMeta from \"./metaLayers/columnMeta.mjs\";\nimport CellMeta from \"./metaLayers/cellMeta.mjs\";\nimport localHooks from \"../../mixins/localHooks.mjs\";\nimport { mixin } from \"../../helpers/object.mjs\";\n/**\n * With the Meta Manager class, it can be possible to manage with meta objects for different layers in\n * one place. All coordinates used to fetch, updating, removing, or creating rows or columns have to\n * be passed as physical values.\n *\n * The diagram of the meta layers:\n * +-------------+.\n * │ GlobalMeta  │\n * │ (prototype) │\n * +-------------+\\\n *       │         \\\n *       │          \\\n *      \\│/         _\\|\n * +-------------+    +-------------+.\n * │ TableMeta   │    │ ColumnMeta  │\n * │ (instance)  │    │ (prototype) │\n * +-------------+    +-------------+.\n *                         │\n *                         │\n *                        \\│/\n *                    +-------------+.\n *                    │  CellMeta   │\n *                    │ (instance)  │\n *                    +-------------+.\n *\n * A more detailed description of the specific layers can be found in the \"metaLayers/\" modules description.\n */\n\nvar MetaManager = /*#__PURE__*/function () {\n  function MetaManager(hot) {\n    var _this = this;\n\n    var customSettings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var metaMods = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n    _classCallCheck(this, MetaManager);\n\n    /**\n     * @type {Handsontable}\n     */\n    this.hot = hot;\n    /**\n     * @type {GlobalMeta}\n     */\n\n    this.globalMeta = new GlobalMeta(hot);\n    this.globalMeta.updateMeta(customSettings);\n    /**\n     * @type {TableMeta}\n     */\n\n    this.tableMeta = new TableMeta(this.globalMeta);\n    /**\n     * @type {ColumnMeta}\n     */\n\n    this.columnMeta = new ColumnMeta(this.globalMeta);\n    /**\n     * @type {CellMeta}\n     */\n\n    this.cellMeta = new CellMeta(this.columnMeta);\n    metaMods.forEach(function (ModifierClass) {\n      return new ModifierClass(_this);\n    });\n  }\n  /**\n   * Gets the global meta object that is a root of all default settings, which are recognizable by Handsontable.\n   * Other layers inherites all properties from this. Adding, removing, or changing property in that\n   * object has a direct reflection to all layers.\n   *\n   * @returns {object}\n   */\n\n\n  _createClass(MetaManager, [{\n    key: \"getGlobalMeta\",\n    value: function getGlobalMeta() {\n      return this.globalMeta.getMeta();\n    }\n    /**\n     * Updates global settings object by merging settings with the current state.\n     *\n     * @param {object} settings An object to merge with.\n     */\n\n  }, {\n    key: \"updateGlobalMeta\",\n    value: function updateGlobalMeta(settings) {\n      this.globalMeta.updateMeta(settings);\n    }\n    /**\n     * Gets settings object that was passed in the Handsontable constructor. That layer contains all\n     * default settings inherited from the GlobalMeta layer merged with settings passed by the developer.\n     * Adding, removing, or changing property in that object has no direct reflection on any other layers.\n     *\n     * @returns {object}\n     */\n\n  }, {\n    key: \"getTableMeta\",\n    value: function getTableMeta() {\n      return this.tableMeta.getMeta();\n    }\n    /**\n     * Updates table settings object by merging settings with the current state.\n     *\n     * @param {object} settings An object to merge with.\n     */\n\n  }, {\n    key: \"updateTableMeta\",\n    value: function updateTableMeta(settings) {\n      this.tableMeta.updateMeta(settings);\n    }\n    /**\n     * Gets column meta object that is a root of all settings defined in the column property of the Handsontable\n     * settings. Each column in the Handsontable is associated with a unique meta object which identified by\n     * the physical column index. Adding, removing, or changing property in that object has a direct reflection\n     * only for the CellMeta layer. The reflection will be visible only if the property doesn't exist in the lower\n     * layers (prototype lookup).\n     *\n     * @param {number} physicalColumn The physical column index.\n     * @returns {object}\n     */\n\n  }, {\n    key: \"getColumnMeta\",\n    value: function getColumnMeta(physicalColumn) {\n      return this.columnMeta.getMeta(physicalColumn);\n    }\n    /**\n     * Updates column meta object by merging settings with the current state.\n     *\n     * @param {number} physicalColumn The physical column index which points what column meta object is updated.\n     * @param {object} settings An object to merge with.\n     */\n\n  }, {\n    key: \"updateColumnMeta\",\n    value: function updateColumnMeta(physicalColumn, settings) {\n      this.columnMeta.updateMeta(physicalColumn, settings);\n    }\n    /**\n     * Gets the cell meta object that is a root of all settings defined for the specific cell rendered by\n     * the Handsontable. Each cell meta inherits settings from higher layers. When a property doesn't\n     * exist in that layer, it is looked up through a prototype to the highest layer. Starting\n     * from CellMeta -> ColumnMeta and ending to GlobalMeta, which stores default settings. Adding,\n     * removing, or changing property in that object has no direct reflection on any other layers.\n     *\n     * @param {number} physicalRow The physical row index.\n     * @param {number} physicalColumn The physical column index.\n     * @param {object} options Additional options that are used to extend the cell meta object.\n     * @param {number} options.visualRow The visual row index of the currently requested cell meta object.\n     * @param {number} options.visualColumn The visual column index of the currently requested cell meta object.\n     * @returns {object}\n     */\n\n  }, {\n    key: \"getCellMeta\",\n    value: function getCellMeta(physicalRow, physicalColumn, _ref) {\n      var visualRow = _ref.visualRow,\n          visualColumn = _ref.visualColumn;\n      var cellMeta = this.cellMeta.getMeta(physicalRow, physicalColumn);\n      cellMeta.visualRow = visualRow;\n      cellMeta.visualCol = visualColumn;\n      cellMeta.row = physicalRow;\n      cellMeta.col = physicalColumn;\n      this.runLocalHooks('afterGetCellMeta', cellMeta);\n      return cellMeta;\n    }\n    /**\n     * Gets a value (defined by the `key` property) from the cell meta object.\n     *\n     * @param {number} physicalRow The physical row index.\n     * @param {number} physicalColumn The physical column index.\n     * @param {string} key Defines the value that will be returned from the cell meta object.\n     * @returns {*}\n     */\n\n  }, {\n    key: \"getCellMetaKeyValue\",\n    value: function getCellMetaKeyValue(physicalRow, physicalColumn, key) {\n      if (typeof key !== 'string') {\n        throw new Error('The passed cell meta object key is not a string');\n      }\n\n      return this.cellMeta.getMeta(physicalRow, physicalColumn, key);\n    }\n    /**\n     * Sets settings object for cell meta object defined by \"key\" property.\n     *\n     * @param {number} physicalRow The physical row index.\n     * @param {number} physicalColumn The physical column index.\n     * @param {string} key The property name to set.\n     * @param {*} value Value to save.\n     */\n\n  }, {\n    key: \"setCellMeta\",\n    value: function setCellMeta(physicalRow, physicalColumn, key, value) {\n      this.cellMeta.setMeta(physicalRow, physicalColumn, key, value);\n    }\n    /**\n     * Updates cell meta object by merging settings with the current state.\n     *\n     * @param {number} physicalRow The physical row index which points what cell meta object is updated.\n     * @param {number} physicalColumn The physical column index which points what cell meta object is updated.\n     * @param {object} settings An object to merge with.\n     */\n\n  }, {\n    key: \"updateCellMeta\",\n    value: function updateCellMeta(physicalRow, physicalColumn, settings) {\n      this.cellMeta.updateMeta(physicalRow, physicalColumn, settings);\n    }\n    /**\n     * Removes a property defined by the \"key\" argument from the cell meta object.\n     *\n     * @param {number} physicalRow The physical row index.\n     * @param {number} physicalColumn The physical column index.\n     * @param {string} key The property name to remove.\n     */\n\n  }, {\n    key: \"removeCellMeta\",\n    value: function removeCellMeta(physicalRow, physicalColumn, key) {\n      this.cellMeta.removeMeta(physicalRow, physicalColumn, key);\n    }\n    /**\n     * Returns all cell meta objects that were created during the Handsontable operation. As cell meta\n     * objects are created lazy, the length of the returned collection depends on how and when the\n     * table has asked for access to that meta objects.\n     *\n     * @returns {object[]}\n     */\n\n  }, {\n    key: \"getCellsMeta\",\n    value: function getCellsMeta() {\n      return this.cellMeta.getMetas();\n    }\n    /**\n     * Returns all cell meta objects that were created during the Handsontable operation but for\n     * specyfic row index.\n     *\n     * @param {number} physicalRow The physical row index.\n     * @returns {object[]}\n     */\n\n  }, {\n    key: \"getCellsMetaAtRow\",\n    value: function getCellsMetaAtRow(physicalRow) {\n      return this.cellMeta.getMetasAtRow(physicalRow);\n    }\n    /**\n     * Creates one or more rows at specific position.\n     *\n     * @param {number} physicalRow The physical row index which points from what position the row is added.\n     * @param {number} [amount=1] An amount of rows to add.\n     */\n\n  }, {\n    key: \"createRow\",\n    value: function createRow(physicalRow) {\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      this.cellMeta.createRow(physicalRow, amount);\n    }\n    /**\n     * Removes one or more rows from the collection.\n     *\n     * @param {number} physicalRow The physical row index which points from what position the row is removed.\n     * @param {number} [amount=1] An amount rows to remove.\n     */\n\n  }, {\n    key: \"removeRow\",\n    value: function removeRow(physicalRow) {\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      this.cellMeta.removeRow(physicalRow, amount);\n    }\n    /**\n     * Creates one or more columns at specific position.\n     *\n     * @param {number} physicalColumn The physical column index which points from what position the column is added.\n     * @param {number} [amount=1] An amount of columns to add.\n     */\n\n  }, {\n    key: \"createColumn\",\n    value: function createColumn(physicalColumn) {\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      this.cellMeta.createColumn(physicalColumn, amount);\n      this.columnMeta.createColumn(physicalColumn, amount);\n    }\n    /**\n     * Removes one or more columns from the collection.\n     *\n     * @param {number} physicalColumn The physical column index which points from what position the column is removed.\n     * @param {number} [amount=1] An amount of columns to remove.\n     */\n\n  }, {\n    key: \"removeColumn\",\n    value: function removeColumn(physicalColumn) {\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      this.cellMeta.removeColumn(physicalColumn, amount);\n      this.columnMeta.removeColumn(physicalColumn, amount);\n    }\n    /**\n     * Clears all saved cell meta objects. It keeps column meta, table meta, and global meta intact.\n     */\n\n  }, {\n    key: \"clearCellsCache\",\n    value: function clearCellsCache() {\n      this.cellMeta.clearCache();\n    }\n    /**\n     * Clears all saved cell and columns meta objects.\n     */\n\n  }, {\n    key: \"clearCache\",\n    value: function clearCache() {\n      this.cellMeta.clearCache();\n      this.columnMeta.clearCache();\n    }\n  }]);\n\n  return MetaManager;\n}();\n\nexport { MetaManager as default };\nmixin(MetaManager, localHooks);"],"mappings":"AAGA,SAASA,eAAeA,CAACC,QAAQ,EAAEC,WAAW,EAAE;EAAE,IAAI,EAAED,QAAQ,YAAYC,WAAW,CAAC,EAAE;IAAE,MAAM,IAAIC,SAAS,CAAC,mCAAmC,CAAC;EAAE;AAAE;AAExJ,SAASC,iBAAiBA,CAACC,MAAM,EAAEC,KAAK,EAAE;EAAE,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,KAAK,CAACE,MAAM,EAAED,CAAC,EAAE,EAAE;IAAE,IAAIE,UAAU,GAAGH,KAAK,CAACC,CAAC,CAAC;IAAEE,UAAU,CAACC,UAAU,GAAGD,UAAU,CAACC,UAAU,IAAI,KAAK;IAAED,UAAU,CAACE,YAAY,GAAG,IAAI;IAAE,IAAI,OAAO,IAAIF,UAAU,EAAEA,UAAU,CAACG,QAAQ,GAAG,IAAI;IAAEC,MAAM,CAACC,cAAc,CAACT,MAAM,EAAEI,UAAU,CAACM,GAAG,EAAEN,UAAU,CAAC;EAAE;AAAE;AAE5T,SAASO,YAAYA,CAACd,WAAW,EAAEe,UAAU,EAAEC,WAAW,EAAE;EAAE,IAAID,UAAU,EAAEb,iBAAiB,CAACF,WAAW,CAACiB,SAAS,EAAEF,UAAU,CAAC;EAAE,IAAIC,WAAW,EAAEd,iBAAiB,CAACF,WAAW,EAAEgB,WAAW,CAAC;EAAEL,MAAM,CAACC,cAAc,CAACZ,WAAW,EAAE,WAAW,EAAE;IAAEU,QAAQ,EAAE;EAAM,CAAC,CAAC;EAAE,OAAOV,WAAW;AAAE;AAE5R,OAAOkB,UAAU,MAAM,6BAA6B;AACpD,OAAOC,SAAS,MAAM,4BAA4B;AAClD,OAAOC,UAAU,MAAM,6BAA6B;AACpD,OAAOC,QAAQ,MAAM,2BAA2B;AAChD,OAAOC,UAAU,MAAM,6BAA6B;AACpD,SAASC,KAAK,QAAQ,0BAA0B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIC,WAAW,GAAG,aAAa,YAAY;EACzC,SAASA,WAAWA,CAACC,GAAG,EAAE;IACxB,IAAIC,KAAK,GAAG,IAAI;IAEhB,IAAIC,cAAc,GAAGC,SAAS,CAACtB,MAAM,GAAG,CAAC,IAAIsB,SAAS,CAAC,CAAC,CAAC,KAAKC,SAAS,GAAGD,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;IAC3F,IAAIE,QAAQ,GAAGF,SAAS,CAACtB,MAAM,GAAG,CAAC,IAAIsB,SAAS,CAAC,CAAC,CAAC,KAAKC,SAAS,GAAGD,SAAS,CAAC,CAAC,CAAC,GAAG,EAAE;IAErF9B,eAAe,CAAC,IAAI,EAAE0B,WAAW,CAAC;;IAElC;AACJ;AACA;IACI,IAAI,CAACC,GAAG,GAAGA,GAAG;IACd;AACJ;AACA;;IAEI,IAAI,CAACM,UAAU,GAAG,IAAIb,UAAU,CAACO,GAAG,CAAC;IACrC,IAAI,CAACM,UAAU,CAACC,UAAU,CAACL,cAAc,CAAC;IAC1C;AACJ;AACA;;IAEI,IAAI,CAACM,SAAS,GAAG,IAAId,SAAS,CAAC,IAAI,CAACY,UAAU,CAAC;IAC/C;AACJ;AACA;;IAEI,IAAI,CAACG,UAAU,GAAG,IAAId,UAAU,CAAC,IAAI,CAACW,UAAU,CAAC;IACjD;AACJ;AACA;;IAEI,IAAI,CAACI,QAAQ,GAAG,IAAId,QAAQ,CAAC,IAAI,CAACa,UAAU,CAAC;IAC7CJ,QAAQ,CAACM,OAAO,CAAC,UAAUC,aAAa,EAAE;MACxC,OAAO,IAAIA,aAAa,CAACX,KAAK,CAAC;IACjC,CAAC,CAAC;EACJ;EACA;AACF;AACA;AACA;AACA;AACA;AACA;;EAGEZ,YAAY,CAACU,WAAW,EAAE,CAAC;IACzBX,GAAG,EAAE,eAAe;IACpByB,KAAK,EAAE,SAASC,aAAaA,CAAA,EAAG;MAC9B,OAAO,IAAI,CAACR,UAAU,CAACS,OAAO,CAAC,CAAC;IAClC;IACA;AACJ;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACD3B,GAAG,EAAE,kBAAkB;IACvByB,KAAK,EAAE,SAASG,gBAAgBA,CAACC,QAAQ,EAAE;MACzC,IAAI,CAACX,UAAU,CAACC,UAAU,CAACU,QAAQ,CAAC;IACtC;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACD7B,GAAG,EAAE,cAAc;IACnByB,KAAK,EAAE,SAASK,YAAYA,CAAA,EAAG;MAC7B,OAAO,IAAI,CAACV,SAAS,CAACO,OAAO,CAAC,CAAC;IACjC;IACA;AACJ;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACD3B,GAAG,EAAE,iBAAiB;IACtByB,KAAK,EAAE,SAASM,eAAeA,CAACF,QAAQ,EAAE;MACxC,IAAI,CAACT,SAAS,CAACD,UAAU,CAACU,QAAQ,CAAC;IACrC;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACD7B,GAAG,EAAE,eAAe;IACpByB,KAAK,EAAE,SAASO,aAAaA,CAACC,cAAc,EAAE;MAC5C,OAAO,IAAI,CAACZ,UAAU,CAACM,OAAO,CAACM,cAAc,CAAC;IAChD;IACA;AACJ;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACDjC,GAAG,EAAE,kBAAkB;IACvByB,KAAK,EAAE,SAASS,gBAAgBA,CAACD,cAAc,EAAEJ,QAAQ,EAAE;MACzD,IAAI,CAACR,UAAU,CAACF,UAAU,CAACc,cAAc,EAAEJ,QAAQ,CAAC;IACtD;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACD7B,GAAG,EAAE,aAAa;IAClByB,KAAK,EAAE,SAASU,WAAWA,CAACC,WAAW,EAAEH,cAAc,EAAEI,IAAI,EAAE;MAC7D,IAAIC,SAAS,GAAGD,IAAI,CAACC,SAAS;QAC1BC,YAAY,GAAGF,IAAI,CAACE,YAAY;MACpC,IAAIjB,QAAQ,GAAG,IAAI,CAACA,QAAQ,CAACK,OAAO,CAACS,WAAW,EAAEH,cAAc,CAAC;MACjEX,QAAQ,CAACgB,SAAS,GAAGA,SAAS;MAC9BhB,QAAQ,CAACkB,SAAS,GAAGD,YAAY;MACjCjB,QAAQ,CAACmB,GAAG,GAAGL,WAAW;MAC1Bd,QAAQ,CAACoB,GAAG,GAAGT,cAAc;MAC7B,IAAI,CAACU,aAAa,CAAC,kBAAkB,EAAErB,QAAQ,CAAC;MAChD,OAAOA,QAAQ;IACjB;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACDtB,GAAG,EAAE,qBAAqB;IAC1ByB,KAAK,EAAE,SAASmB,mBAAmBA,CAACR,WAAW,EAAEH,cAAc,EAAEjC,GAAG,EAAE;MACpE,IAAI,OAAOA,GAAG,KAAK,QAAQ,EAAE;QAC3B,MAAM,IAAI6C,KAAK,CAAC,iDAAiD,CAAC;MACpE;MAEA,OAAO,IAAI,CAACvB,QAAQ,CAACK,OAAO,CAACS,WAAW,EAAEH,cAAc,EAAEjC,GAAG,CAAC;IAChE;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACDA,GAAG,EAAE,aAAa;IAClByB,KAAK,EAAE,SAASqB,WAAWA,CAACV,WAAW,EAAEH,cAAc,EAAEjC,GAAG,EAAEyB,KAAK,EAAE;MACnE,IAAI,CAACH,QAAQ,CAACyB,OAAO,CAACX,WAAW,EAAEH,cAAc,EAAEjC,GAAG,EAAEyB,KAAK,CAAC;IAChE;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACDzB,GAAG,EAAE,gBAAgB;IACrByB,KAAK,EAAE,SAASuB,cAAcA,CAACZ,WAAW,EAAEH,cAAc,EAAEJ,QAAQ,EAAE;MACpE,IAAI,CAACP,QAAQ,CAACH,UAAU,CAACiB,WAAW,EAAEH,cAAc,EAAEJ,QAAQ,CAAC;IACjE;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACD7B,GAAG,EAAE,gBAAgB;IACrByB,KAAK,EAAE,SAASwB,cAAcA,CAACb,WAAW,EAAEH,cAAc,EAAEjC,GAAG,EAAE;MAC/D,IAAI,CAACsB,QAAQ,CAAC4B,UAAU,CAACd,WAAW,EAAEH,cAAc,EAAEjC,GAAG,CAAC;IAC5D;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACDA,GAAG,EAAE,cAAc;IACnByB,KAAK,EAAE,SAAS0B,YAAYA,CAAA,EAAG;MAC7B,OAAO,IAAI,CAAC7B,QAAQ,CAAC8B,QAAQ,CAAC,CAAC;IACjC;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACDpD,GAAG,EAAE,mBAAmB;IACxByB,KAAK,EAAE,SAAS4B,iBAAiBA,CAACjB,WAAW,EAAE;MAC7C,OAAO,IAAI,CAACd,QAAQ,CAACgC,aAAa,CAAClB,WAAW,CAAC;IACjD;IACA;AACJ;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACDpC,GAAG,EAAE,WAAW;IAChByB,KAAK,EAAE,SAAS8B,SAASA,CAACnB,WAAW,EAAE;MACrC,IAAIoB,MAAM,GAAGzC,SAAS,CAACtB,MAAM,GAAG,CAAC,IAAIsB,SAAS,CAAC,CAAC,CAAC,KAAKC,SAAS,GAAGD,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC;MAClF,IAAI,CAACO,QAAQ,CAACiC,SAAS,CAACnB,WAAW,EAAEoB,MAAM,CAAC;IAC9C;IACA;AACJ;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACDxD,GAAG,EAAE,WAAW;IAChByB,KAAK,EAAE,SAASgC,SAASA,CAACrB,WAAW,EAAE;MACrC,IAAIoB,MAAM,GAAGzC,SAAS,CAACtB,MAAM,GAAG,CAAC,IAAIsB,SAAS,CAAC,CAAC,CAAC,KAAKC,SAAS,GAAGD,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC;MAClF,IAAI,CAACO,QAAQ,CAACmC,SAAS,CAACrB,WAAW,EAAEoB,MAAM,CAAC;IAC9C;IACA;AACJ;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACDxD,GAAG,EAAE,cAAc;IACnByB,KAAK,EAAE,SAASiC,YAAYA,CAACzB,cAAc,EAAE;MAC3C,IAAIuB,MAAM,GAAGzC,SAAS,CAACtB,MAAM,GAAG,CAAC,IAAIsB,SAAS,CAAC,CAAC,CAAC,KAAKC,SAAS,GAAGD,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC;MAClF,IAAI,CAACO,QAAQ,CAACoC,YAAY,CAACzB,cAAc,EAAEuB,MAAM,CAAC;MAClD,IAAI,CAACnC,UAAU,CAACqC,YAAY,CAACzB,cAAc,EAAEuB,MAAM,CAAC;IACtD;IACA;AACJ;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACDxD,GAAG,EAAE,cAAc;IACnByB,KAAK,EAAE,SAASkC,YAAYA,CAAC1B,cAAc,EAAE;MAC3C,IAAIuB,MAAM,GAAGzC,SAAS,CAACtB,MAAM,GAAG,CAAC,IAAIsB,SAAS,CAAC,CAAC,CAAC,KAAKC,SAAS,GAAGD,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC;MAClF,IAAI,CAACO,QAAQ,CAACqC,YAAY,CAAC1B,cAAc,EAAEuB,MAAM,CAAC;MAClD,IAAI,CAACnC,UAAU,CAACsC,YAAY,CAAC1B,cAAc,EAAEuB,MAAM,CAAC;IACtD;IACA;AACJ;AACA;EAEE,CAAC,EAAE;IACDxD,GAAG,EAAE,iBAAiB;IACtByB,KAAK,EAAE,SAASmC,eAAeA,CAAA,EAAG;MAChC,IAAI,CAACtC,QAAQ,CAACuC,UAAU,CAAC,CAAC;IAC5B;IACA;AACJ;AACA;EAEE,CAAC,EAAE;IACD7D,GAAG,EAAE,YAAY;IACjByB,KAAK,EAAE,SAASoC,UAAUA,CAAA,EAAG;MAC3B,IAAI,CAACvC,QAAQ,CAACuC,UAAU,CAAC,CAAC;MAC1B,IAAI,CAACxC,UAAU,CAACwC,UAAU,CAAC,CAAC;IAC9B;EACF,CAAC,CAAC,CAAC;EAEH,OAAOlD,WAAW;AACpB,CAAC,CAAC,CAAC;AAEH,SAASA,WAAW,IAAImD,OAAO;AAC/BpD,KAAK,CAACC,WAAW,EAAEF,UAAU,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}