{"ast":null,"code":"import _classCallCheck from \"/Users/priyadeliwala/Desktop/sales-dashboard/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/priyadeliwala/Desktop/sales-dashboard/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nimport { getScrollableElement, getTrimmingContainer, getScrollbarWidth, setAttribute } from \"../../../../helpers/dom/element.mjs\";\nimport { defineGetter } from \"../../../../helpers/object.mjs\";\nimport { warn } from \"../../../../helpers/console.mjs\";\nimport { CLONE_TYPES, CLONE_CLASS_NAMES, CLONE_TOP, CLONE_INLINE_START } from \"./constants.mjs\";\nimport Clone from \"../core/clone.mjs\";\nimport { A11Y_PRESENTATION } from \"../../../../helpers/a11y.mjs\";\n/**\n * Creates an overlay over the original Walkontable instance. The overlay renders the clone of the original Walkontable\n * and (optionally) implements behavior needed for native horizontal and vertical scrolling.\n *\n * @abstract\n * @class Overlay\n * @property {Walkontable} wot The Walkontable instance.\n */\nexport var Overlay = /*#__PURE__*/function () {\n  /**\n   * @param {Walkontable} wotInstance The Walkontable instance. @TODO refactoring: check if can be deleted.\n   * @param {FacadeGetter} facadeGetter Function which return proper facade.\n   * @param {CLONE_TYPES_ENUM} type The overlay type name (clone name).\n   * @param {Settings} wtSettings The Walkontable settings.\n   * @param {DomBindings} domBindings Dom elements bound to the current instance.\n   */\n  function Overlay(wotInstance, facadeGetter, type, wtSettings, domBindings) {\n    _classCallCheck(this, Overlay);\n    /**\n     *  The Walkontable settings.\n     *\n     * @private\n     * @type {Settings}\n     */\n    _defineProperty(this, \"wtSettings\", null);\n    defineGetter(this, 'wot', wotInstance, {\n      writable: false\n    });\n    this.domBindings = domBindings;\n    this.facadeGetter = facadeGetter;\n    this.wtSettings = wtSettings;\n    var _this$wot$wtTable = this.wot.wtTable,\n      TABLE = _this$wot$wtTable.TABLE,\n      hider = _this$wot$wtTable.hider,\n      spreader = _this$wot$wtTable.spreader,\n      holder = _this$wot$wtTable.holder,\n      wtRootElement = _this$wot$wtTable.wtRootElement; // todo ioc\n\n    // legacy support, deprecated in the future\n    this.instance = this.wot;\n    this.type = type;\n    this.mainTableScrollableElement = null;\n    this.TABLE = TABLE;\n    this.hider = hider;\n    this.spreader = spreader;\n    this.holder = holder;\n    this.wtRootElement = wtRootElement;\n    this.trimmingContainer = getTrimmingContainer(this.hider.parentNode.parentNode);\n    this.needFullRender = this.shouldBeRendered();\n    this.clone = this.makeClone();\n  }\n\n  /**\n   * Checks if the overlay rendering state has changed.\n   *\n   * @returns {boolean}\n   */\n  return _createClass(Overlay, [{\n    key: \"hasRenderingStateChanged\",\n    value: function hasRenderingStateChanged() {\n      return this.needFullRender !== this.shouldBeRendered();\n    }\n\n    /**\n     * Updates internal state with an information about the need of full rendering of the overlay in the next draw cycles.\n     *\n     * If the state is changed to render the overlay, the `needFullRender` property is set to `true` which means that\n     * the overlay will be fully rendered in the current draw cycle. If the state is changed to not render the overlay,\n     * the `needFullRender` property is set to `false` which means that the overlay will be fully rendered in the\n     * current draw cycle but it will not be rendered in the next draw cycles.\n     *\n     * @param {'before' | 'after'} drawPhase The phase of the rendering process.\n     */\n  }, {\n    key: \"updateStateOfRendering\",\n    value: function updateStateOfRendering(drawPhase) {\n      if (drawPhase === 'before' && this.shouldBeRendered()) {\n        this.needFullRender = true;\n      } else if (drawPhase === 'after' && !this.shouldBeRendered()) {\n        this.needFullRender = false;\n      }\n    }\n\n    /**\n     * Checks if overlay should be fully rendered.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"shouldBeRendered\",\n    value: function shouldBeRendered() {\n      return true;\n    }\n\n    /**\n     * Update the trimming container.\n     */\n  }, {\n    key: \"updateTrimmingContainer\",\n    value: function updateTrimmingContainer() {\n      this.trimmingContainer = getTrimmingContainer(this.hider.parentNode.parentNode);\n    }\n\n    /**\n     * Update the main scrollable element.\n     */\n  }, {\n    key: \"updateMainScrollableElement\",\n    value: function updateMainScrollableElement() {\n      var wtTable = this.wot.wtTable;\n      var rootWindow = this.domBindings.rootWindow;\n      if (rootWindow.getComputedStyle(wtTable.wtRootElement.parentNode).getPropertyValue('overflow') === 'hidden') {\n        this.mainTableScrollableElement = this.wot.wtTable.holder;\n      } else {\n        this.mainTableScrollableElement = getScrollableElement(wtTable.TABLE);\n      }\n    }\n\n    /**\n     * Calculates coordinates of the provided element, relative to the root Handsontable element.\n     * NOTE: The element needs to be a child of the overlay in order for the method to work correctly.\n     *\n     * @param {HTMLElement} element The cell element to calculate the position for.\n     * @param {number} rowIndex Visual row index.\n     * @param {number} columnIndex Visual column index.\n     * @returns {{top: number, start: number}|undefined}\n     */\n  }, {\n    key: \"getRelativeCellPosition\",\n    value: function getRelativeCellPosition(element, rowIndex, columnIndex) {\n      if (this.clone.wtTable.holder.contains(element) === false) {\n        warn(\"The provided element is not a child of the \".concat(this.type, \" overlay\"));\n        return;\n      }\n      var windowScroll = this.mainTableScrollableElement === this.domBindings.rootWindow;\n      var fixedColumnStart = columnIndex < this.wtSettings.getSetting('fixedColumnsStart');\n      var fixedRowTop = rowIndex < this.wtSettings.getSetting('fixedRowsTop');\n      var fixedRowBottom = rowIndex >= this.wtSettings.getSetting('totalRows') - this.wtSettings.getSetting('fixedRowsBottom');\n      var spreader = this.clone.wtTable.spreader;\n      var spreaderOffset = {\n        start: this.getRelativeStartPosition(spreader),\n        top: spreader.offsetTop\n      };\n      var elementOffset = {\n        start: this.getRelativeStartPosition(element),\n        top: element.offsetTop\n      };\n      var offsetObject = null;\n      if (windowScroll) {\n        offsetObject = this.getRelativeCellPositionWithinWindow(fixedRowTop, fixedColumnStart, elementOffset, spreaderOffset);\n      } else {\n        offsetObject = this.getRelativeCellPositionWithinHolder(fixedRowTop, fixedRowBottom, fixedColumnStart, elementOffset, spreaderOffset);\n      }\n      return offsetObject;\n    }\n\n    /**\n     * Get inline start value depending of direction.\n     *\n     * @param {HTMLElement} el Element.\n     * @returns {number}\n     */\n  }, {\n    key: \"getRelativeStartPosition\",\n    value: function getRelativeStartPosition(el) {\n      return this.isRtl() ? el.offsetParent.offsetWidth - el.offsetLeft - el.offsetWidth : el.offsetLeft;\n    }\n\n    /**\n     * Calculates coordinates of the provided element, relative to the root Handsontable element within a table with window\n     * as a scrollable element.\n     *\n     * @private\n     * @param {boolean} onFixedRowTop `true` if the coordinates point to a place within the top fixed rows.\n     * @param {boolean} onFixedColumn `true` if the coordinates point to a place within the fixed columns.\n     * @param {number} elementOffset Offset position of the cell element.\n     * @param {number} spreaderOffset Offset position of the spreader element.\n     * @returns {{top: number, left: number}}\n     */\n  }, {\n    key: \"getRelativeCellPositionWithinWindow\",\n    value: function getRelativeCellPositionWithinWindow(onFixedRowTop, onFixedColumn, elementOffset, spreaderOffset) {\n      var absoluteRootElementPosition = this.wot.wtTable.wtRootElement.getBoundingClientRect(); // todo refactoring: DEMETER\n      var horizontalOffset = 0;\n      var verticalOffset = 0;\n      if (!onFixedColumn) {\n        horizontalOffset = spreaderOffset.start;\n      } else {\n        var absoluteRootElementStartPosition = absoluteRootElementPosition.left;\n        if (this.isRtl()) {\n          absoluteRootElementStartPosition = this.domBindings.rootWindow.innerWidth - (absoluteRootElementPosition.left + absoluteRootElementPosition.width + getScrollbarWidth());\n        }\n        horizontalOffset = absoluteRootElementStartPosition <= 0 ? -1 * absoluteRootElementStartPosition : 0;\n      }\n      if (onFixedRowTop) {\n        var absoluteOverlayPosition = this.clone.wtTable.TABLE.getBoundingClientRect();\n        verticalOffset = absoluteOverlayPosition.top - absoluteRootElementPosition.top;\n      } else {\n        verticalOffset = spreaderOffset.top;\n      }\n      return {\n        start: elementOffset.start + horizontalOffset,\n        top: elementOffset.top + verticalOffset\n      };\n    }\n\n    /**\n     * Calculates coordinates of the provided element, relative to the root Handsontable element within a table with window\n     * as a scrollable element.\n     *\n     * @private\n     * @param {boolean} onFixedRowTop `true` if the coordinates point to a place within the top fixed rows.\n     * @param {boolean} onFixedRowBottom `true` if the coordinates point to a place within the bottom fixed rows.\n     * @param {boolean} onFixedColumn `true` if the coordinates point to a place within the fixed columns.\n     * @param {number} elementOffset Offset position of the cell element.\n     * @param {number} spreaderOffset Offset position of the spreader element.\n     * @returns {{top: number, left: number}}\n     */\n  }, {\n    key: \"getRelativeCellPositionWithinHolder\",\n    value: function getRelativeCellPositionWithinHolder(onFixedRowTop, onFixedRowBottom, onFixedColumn, elementOffset, spreaderOffset) {\n      var tableScrollPosition = {\n        horizontal: this.wot.wtOverlays.inlineStartOverlay.getScrollPosition(),\n        vertical: this.wot.wtOverlays.topOverlay.getScrollPosition()\n      };\n      var horizontalOffset = 0;\n      var verticalOffset = 0;\n      if (!onFixedColumn) {\n        horizontalOffset = tableScrollPosition.horizontal - spreaderOffset.start;\n      }\n      if (onFixedRowBottom) {\n        var absoluteRootElementPosition = this.wot.wtTable.wtRootElement.getBoundingClientRect(); // todo refactoring: DEMETER\n        var absoluteOverlayPosition = this.clone.wtTable.TABLE.getBoundingClientRect(); // todo refactoring: DEMETER\n\n        verticalOffset = absoluteOverlayPosition.top * -1 + absoluteRootElementPosition.top;\n      } else if (!onFixedRowTop) {\n        verticalOffset = tableScrollPosition.vertical - spreaderOffset.top;\n      }\n      return {\n        start: elementOffset.start - horizontalOffset,\n        top: elementOffset.top - verticalOffset\n      };\n    }\n\n    /**\n     * Make a clone of table for overlay.\n     *\n     * @returns {Clone}\n     */\n  }, {\n    key: \"makeClone\",\n    value: function makeClone() {\n      if (CLONE_TYPES.indexOf(this.type) === -1) {\n        throw new Error(\"Clone type \\\"\".concat(this.type, \"\\\" is not supported.\"));\n      }\n      var _this$wot = this.wot,\n        wtTable = _this$wot.wtTable,\n        wtSettings = _this$wot.wtSettings;\n      var _this$domBindings = this.domBindings,\n        rootDocument = _this$domBindings.rootDocument,\n        rootWindow = _this$domBindings.rootWindow;\n      var clone = rootDocument.createElement('div');\n      var clonedTable = rootDocument.createElement('table');\n      var tableParent = wtTable.wtRootElement.parentNode;\n      clone.className = \"\".concat(CLONE_CLASS_NAMES.get(this.type), \" handsontable\");\n      clone.setAttribute('dir', this.isRtl() ? 'rtl' : 'ltr');\n      clone.style.position = 'absolute';\n      clone.style.top = 0;\n      clone.style.overflow = 'visible';\n      if (this.isRtl()) {\n        clone.style.right = 0;\n      } else {\n        clone.style.left = 0;\n      }\n      if (wtSettings.getSetting('ariaTags')) {\n        setAttribute(clone, [A11Y_PRESENTATION()]);\n      }\n      clonedTable.className = wtTable.TABLE.className;\n\n      // Clone the main table's `role` attribute to the cloned table.\n      var mainTableRole = wtTable.TABLE.getAttribute('role');\n      if (mainTableRole) {\n        clonedTable.setAttribute('role', wtTable.TABLE.getAttribute('role'));\n      }\n      clone.appendChild(clonedTable);\n      tableParent.appendChild(clone);\n      var preventOverflow = this.wtSettings.getSetting('preventOverflow');\n      if (preventOverflow === true || preventOverflow === 'horizontal' && this.type === CLONE_TOP || preventOverflow === 'vertical' && this.type === CLONE_INLINE_START) {\n        this.mainTableScrollableElement = rootWindow;\n      } else if (rootWindow.getComputedStyle(tableParent).getPropertyValue('overflow') === 'hidden') {\n        this.mainTableScrollableElement = wtTable.holder;\n      } else {\n        this.mainTableScrollableElement = getScrollableElement(wtTable.TABLE);\n      }\n\n      // Create a new instance of the Walkontable class\n      return new Clone(clonedTable, this.wtSettings, {\n        // todo ioc factory\n        source: this.wot,\n        overlay: this,\n        viewport: this.wot.wtViewport,\n        // todo ioc , or factor func if used only here\n        event: this.wot.wtEvent,\n        // todo ioc , or factory func if used only here\n        selectionManager: this.wot.selectionManager // todo ioc , or factory func if used only here\n      });\n    }\n\n    /**\n     * Refresh/Redraw overlay.\n     *\n     * @param {boolean} [fastDraw=false] When `true`, try to refresh only the positions of borders without rerendering\n     *                                   the data. It will only work if Table.draw() does not force\n     *                                   rendering anyway.\n     */\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      var fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      if (this.needFullRender) {\n        this.clone.draw(fastDraw);\n      }\n    }\n\n    /**\n     * Reset overlay styles to initial values.\n     */\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      var holder = this.clone.wtTable.holder; // todo refactoring: DEMETER\n      var hider = this.clone.wtTable.hider; // todo refactoring: DEMETER\n      var holderStyle = holder.style;\n      var hiderStyle = hider.style;\n      var rootStyle = holder.parentNode.style;\n      [holderStyle, hiderStyle, rootStyle].forEach(function (style) {\n        style.width = '';\n        style.height = '';\n      });\n    }\n\n    /**\n     * Determine if Walkontable is running in RTL mode.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isRtl\",\n    value: function isRtl() {\n      return this.wtSettings.getSetting('rtlMode');\n    }\n\n    /**\n     * Destroy overlay instance.\n     */\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.clone.eventManager.destroy(); // todo check if it is good place for that operation\n    }\n  }]);\n}();","map":{"version":3,"names":["_defineProperty","e","r","t","_toPropertyKey","Object","defineProperty","value","enumerable","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","TypeError","String","Number","getScrollableElement","getTrimmingContainer","getScrollbarWidth","setAttribute","defineGetter","warn","CLONE_TYPES","CLONE_CLASS_NAMES","CLONE_TOP","CLONE_INLINE_START","Clone","A11Y_PRESENTATION","Overlay","wotInstance","facadeGetter","type","wtSettings","domBindings","_classCallCheck","_this$wot$wtTable","wot","wtTable","TABLE","hider","spreader","holder","wtRootElement","instance","mainTableScrollableElement","trimmingContainer","parentNode","needFullRender","shouldBeRendered","clone","makeClone","_createClass","key","hasRenderingStateChanged","updateStateOfRendering","drawPhase","updateTrimmingContainer","updateMainScrollableElement","rootWindow","getComputedStyle","getPropertyValue","getRelativeCellPosition","element","rowIndex","columnIndex","contains","concat","windowScroll","fixedColumnStart","getSetting","fixedRowTop","fixedRowBottom","spreaderOffset","start","getRelativeStartPosition","top","offsetTop","elementOffset","offsetObject","getRelativeCellPositionWithinWindow","getRelativeCellPositionWithinHolder","el","isRtl","offsetParent","offsetWidth","offsetLeft","onFixedRowTop","onFixedColumn","absoluteRootElementPosition","getBoundingClientRect","horizontalOffset","verticalOffset","absoluteRootElementStartPosition","left","innerWidth","width","absoluteOverlayPosition","onFixedRowBottom","tableScrollPosition","horizontal","wtOverlays","inlineStartOverlay","getScrollPosition","vertical","topOverlay","indexOf","Error","_this$wot","_this$domBindings","rootDocument","createElement","clonedTable","tableParent","className","get","style","position","overflow","right","mainTableRole","getAttribute","appendChild","preventOverflow","source","overlay","viewport","wtViewport","event","wtEvent","selectionManager","refresh","fastDraw","arguments","length","undefined","draw","reset","holderStyle","hiderStyle","rootStyle","forEach","height","destroy","eventManager"],"sources":["/Users/priyadeliwala/node_modules/handsontable/3rdparty/walkontable/src/overlay/_base.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport { getScrollableElement, getTrimmingContainer, getScrollbarWidth, setAttribute } from \"../../../../helpers/dom/element.mjs\";\nimport { defineGetter } from \"../../../../helpers/object.mjs\";\nimport { warn } from \"../../../../helpers/console.mjs\";\nimport { CLONE_TYPES, CLONE_CLASS_NAMES, CLONE_TOP, CLONE_INLINE_START } from \"./constants.mjs\";\nimport Clone from \"../core/clone.mjs\";\nimport { A11Y_PRESENTATION } from \"../../../../helpers/a11y.mjs\";\n/**\n * Creates an overlay over the original Walkontable instance. The overlay renders the clone of the original Walkontable\n * and (optionally) implements behavior needed for native horizontal and vertical scrolling.\n *\n * @abstract\n * @class Overlay\n * @property {Walkontable} wot The Walkontable instance.\n */\nexport class Overlay {\n  /**\n   * @param {Walkontable} wotInstance The Walkontable instance. @TODO refactoring: check if can be deleted.\n   * @param {FacadeGetter} facadeGetter Function which return proper facade.\n   * @param {CLONE_TYPES_ENUM} type The overlay type name (clone name).\n   * @param {Settings} wtSettings The Walkontable settings.\n   * @param {DomBindings} domBindings Dom elements bound to the current instance.\n   */\n  constructor(wotInstance, facadeGetter, type, wtSettings, domBindings) {\n    /**\n     *  The Walkontable settings.\n     *\n     * @private\n     * @type {Settings}\n     */\n    _defineProperty(this, \"wtSettings\", null);\n    defineGetter(this, 'wot', wotInstance, {\n      writable: false\n    });\n    this.domBindings = domBindings;\n    this.facadeGetter = facadeGetter;\n    this.wtSettings = wtSettings;\n    const {\n      TABLE,\n      hider,\n      spreader,\n      holder,\n      wtRootElement\n    } = this.wot.wtTable; // todo ioc\n\n    // legacy support, deprecated in the future\n    this.instance = this.wot;\n    this.type = type;\n    this.mainTableScrollableElement = null;\n    this.TABLE = TABLE;\n    this.hider = hider;\n    this.spreader = spreader;\n    this.holder = holder;\n    this.wtRootElement = wtRootElement;\n    this.trimmingContainer = getTrimmingContainer(this.hider.parentNode.parentNode);\n    this.needFullRender = this.shouldBeRendered();\n    this.clone = this.makeClone();\n  }\n\n  /**\n   * Checks if the overlay rendering state has changed.\n   *\n   * @returns {boolean}\n   */\n  hasRenderingStateChanged() {\n    return this.needFullRender !== this.shouldBeRendered();\n  }\n\n  /**\n   * Updates internal state with an information about the need of full rendering of the overlay in the next draw cycles.\n   *\n   * If the state is changed to render the overlay, the `needFullRender` property is set to `true` which means that\n   * the overlay will be fully rendered in the current draw cycle. If the state is changed to not render the overlay,\n   * the `needFullRender` property is set to `false` which means that the overlay will be fully rendered in the\n   * current draw cycle but it will not be rendered in the next draw cycles.\n   *\n   * @param {'before' | 'after'} drawPhase The phase of the rendering process.\n   */\n  updateStateOfRendering(drawPhase) {\n    if (drawPhase === 'before' && this.shouldBeRendered()) {\n      this.needFullRender = true;\n    } else if (drawPhase === 'after' && !this.shouldBeRendered()) {\n      this.needFullRender = false;\n    }\n  }\n\n  /**\n   * Checks if overlay should be fully rendered.\n   *\n   * @returns {boolean}\n   */\n  shouldBeRendered() {\n    return true;\n  }\n\n  /**\n   * Update the trimming container.\n   */\n  updateTrimmingContainer() {\n    this.trimmingContainer = getTrimmingContainer(this.hider.parentNode.parentNode);\n  }\n\n  /**\n   * Update the main scrollable element.\n   */\n  updateMainScrollableElement() {\n    const {\n      wtTable\n    } = this.wot;\n    const {\n      rootWindow\n    } = this.domBindings;\n    if (rootWindow.getComputedStyle(wtTable.wtRootElement.parentNode).getPropertyValue('overflow') === 'hidden') {\n      this.mainTableScrollableElement = this.wot.wtTable.holder;\n    } else {\n      this.mainTableScrollableElement = getScrollableElement(wtTable.TABLE);\n    }\n  }\n\n  /**\n   * Calculates coordinates of the provided element, relative to the root Handsontable element.\n   * NOTE: The element needs to be a child of the overlay in order for the method to work correctly.\n   *\n   * @param {HTMLElement} element The cell element to calculate the position for.\n   * @param {number} rowIndex Visual row index.\n   * @param {number} columnIndex Visual column index.\n   * @returns {{top: number, start: number}|undefined}\n   */\n  getRelativeCellPosition(element, rowIndex, columnIndex) {\n    if (this.clone.wtTable.holder.contains(element) === false) {\n      warn(`The provided element is not a child of the ${this.type} overlay`);\n      return;\n    }\n    const windowScroll = this.mainTableScrollableElement === this.domBindings.rootWindow;\n    const fixedColumnStart = columnIndex < this.wtSettings.getSetting('fixedColumnsStart');\n    const fixedRowTop = rowIndex < this.wtSettings.getSetting('fixedRowsTop');\n    const fixedRowBottom = rowIndex >= this.wtSettings.getSetting('totalRows') - this.wtSettings.getSetting('fixedRowsBottom');\n    const spreader = this.clone.wtTable.spreader;\n    const spreaderOffset = {\n      start: this.getRelativeStartPosition(spreader),\n      top: spreader.offsetTop\n    };\n    const elementOffset = {\n      start: this.getRelativeStartPosition(element),\n      top: element.offsetTop\n    };\n    let offsetObject = null;\n    if (windowScroll) {\n      offsetObject = this.getRelativeCellPositionWithinWindow(fixedRowTop, fixedColumnStart, elementOffset, spreaderOffset);\n    } else {\n      offsetObject = this.getRelativeCellPositionWithinHolder(fixedRowTop, fixedRowBottom, fixedColumnStart, elementOffset, spreaderOffset);\n    }\n    return offsetObject;\n  }\n\n  /**\n   * Get inline start value depending of direction.\n   *\n   * @param {HTMLElement} el Element.\n   * @returns {number}\n   */\n  getRelativeStartPosition(el) {\n    return this.isRtl() ? el.offsetParent.offsetWidth - el.offsetLeft - el.offsetWidth : el.offsetLeft;\n  }\n\n  /**\n   * Calculates coordinates of the provided element, relative to the root Handsontable element within a table with window\n   * as a scrollable element.\n   *\n   * @private\n   * @param {boolean} onFixedRowTop `true` if the coordinates point to a place within the top fixed rows.\n   * @param {boolean} onFixedColumn `true` if the coordinates point to a place within the fixed columns.\n   * @param {number} elementOffset Offset position of the cell element.\n   * @param {number} spreaderOffset Offset position of the spreader element.\n   * @returns {{top: number, left: number}}\n   */\n  getRelativeCellPositionWithinWindow(onFixedRowTop, onFixedColumn, elementOffset, spreaderOffset) {\n    const absoluteRootElementPosition = this.wot.wtTable.wtRootElement.getBoundingClientRect(); // todo refactoring: DEMETER\n    let horizontalOffset = 0;\n    let verticalOffset = 0;\n    if (!onFixedColumn) {\n      horizontalOffset = spreaderOffset.start;\n    } else {\n      let absoluteRootElementStartPosition = absoluteRootElementPosition.left;\n      if (this.isRtl()) {\n        absoluteRootElementStartPosition = this.domBindings.rootWindow.innerWidth - (absoluteRootElementPosition.left + absoluteRootElementPosition.width + getScrollbarWidth());\n      }\n      horizontalOffset = absoluteRootElementStartPosition <= 0 ? -1 * absoluteRootElementStartPosition : 0;\n    }\n    if (onFixedRowTop) {\n      const absoluteOverlayPosition = this.clone.wtTable.TABLE.getBoundingClientRect();\n      verticalOffset = absoluteOverlayPosition.top - absoluteRootElementPosition.top;\n    } else {\n      verticalOffset = spreaderOffset.top;\n    }\n    return {\n      start: elementOffset.start + horizontalOffset,\n      top: elementOffset.top + verticalOffset\n    };\n  }\n\n  /**\n   * Calculates coordinates of the provided element, relative to the root Handsontable element within a table with window\n   * as a scrollable element.\n   *\n   * @private\n   * @param {boolean} onFixedRowTop `true` if the coordinates point to a place within the top fixed rows.\n   * @param {boolean} onFixedRowBottom `true` if the coordinates point to a place within the bottom fixed rows.\n   * @param {boolean} onFixedColumn `true` if the coordinates point to a place within the fixed columns.\n   * @param {number} elementOffset Offset position of the cell element.\n   * @param {number} spreaderOffset Offset position of the spreader element.\n   * @returns {{top: number, left: number}}\n   */\n  getRelativeCellPositionWithinHolder(onFixedRowTop, onFixedRowBottom, onFixedColumn, elementOffset, spreaderOffset) {\n    const tableScrollPosition = {\n      horizontal: this.wot.wtOverlays.inlineStartOverlay.getScrollPosition(),\n      vertical: this.wot.wtOverlays.topOverlay.getScrollPosition()\n    };\n    let horizontalOffset = 0;\n    let verticalOffset = 0;\n    if (!onFixedColumn) {\n      horizontalOffset = tableScrollPosition.horizontal - spreaderOffset.start;\n    }\n    if (onFixedRowBottom) {\n      const absoluteRootElementPosition = this.wot.wtTable.wtRootElement.getBoundingClientRect(); // todo refactoring: DEMETER\n      const absoluteOverlayPosition = this.clone.wtTable.TABLE.getBoundingClientRect(); // todo refactoring: DEMETER\n\n      verticalOffset = absoluteOverlayPosition.top * -1 + absoluteRootElementPosition.top;\n    } else if (!onFixedRowTop) {\n      verticalOffset = tableScrollPosition.vertical - spreaderOffset.top;\n    }\n    return {\n      start: elementOffset.start - horizontalOffset,\n      top: elementOffset.top - verticalOffset\n    };\n  }\n\n  /**\n   * Make a clone of table for overlay.\n   *\n   * @returns {Clone}\n   */\n  makeClone() {\n    if (CLONE_TYPES.indexOf(this.type) === -1) {\n      throw new Error(`Clone type \"${this.type}\" is not supported.`);\n    }\n    const {\n      wtTable,\n      wtSettings\n    } = this.wot;\n    const {\n      rootDocument,\n      rootWindow\n    } = this.domBindings;\n    const clone = rootDocument.createElement('div');\n    const clonedTable = rootDocument.createElement('table');\n    const tableParent = wtTable.wtRootElement.parentNode;\n    clone.className = `${CLONE_CLASS_NAMES.get(this.type)} handsontable`;\n    clone.setAttribute('dir', this.isRtl() ? 'rtl' : 'ltr');\n    clone.style.position = 'absolute';\n    clone.style.top = 0;\n    clone.style.overflow = 'visible';\n    if (this.isRtl()) {\n      clone.style.right = 0;\n    } else {\n      clone.style.left = 0;\n    }\n    if (wtSettings.getSetting('ariaTags')) {\n      setAttribute(clone, [A11Y_PRESENTATION()]);\n    }\n    clonedTable.className = wtTable.TABLE.className;\n\n    // Clone the main table's `role` attribute to the cloned table.\n    const mainTableRole = wtTable.TABLE.getAttribute('role');\n    if (mainTableRole) {\n      clonedTable.setAttribute('role', wtTable.TABLE.getAttribute('role'));\n    }\n    clone.appendChild(clonedTable);\n    tableParent.appendChild(clone);\n    const preventOverflow = this.wtSettings.getSetting('preventOverflow');\n    if (preventOverflow === true || preventOverflow === 'horizontal' && this.type === CLONE_TOP || preventOverflow === 'vertical' && this.type === CLONE_INLINE_START) {\n      this.mainTableScrollableElement = rootWindow;\n    } else if (rootWindow.getComputedStyle(tableParent).getPropertyValue('overflow') === 'hidden') {\n      this.mainTableScrollableElement = wtTable.holder;\n    } else {\n      this.mainTableScrollableElement = getScrollableElement(wtTable.TABLE);\n    }\n\n    // Create a new instance of the Walkontable class\n    return new Clone(clonedTable, this.wtSettings, {\n      // todo ioc factory\n      source: this.wot,\n      overlay: this,\n      viewport: this.wot.wtViewport,\n      // todo ioc , or factor func if used only here\n      event: this.wot.wtEvent,\n      // todo ioc , or factory func if used only here\n      selectionManager: this.wot.selectionManager // todo ioc , or factory func if used only here\n    });\n  }\n\n  /**\n   * Refresh/Redraw overlay.\n   *\n   * @param {boolean} [fastDraw=false] When `true`, try to refresh only the positions of borders without rerendering\n   *                                   the data. It will only work if Table.draw() does not force\n   *                                   rendering anyway.\n   */\n  refresh() {\n    let fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (this.needFullRender) {\n      this.clone.draw(fastDraw);\n    }\n  }\n\n  /**\n   * Reset overlay styles to initial values.\n   */\n  reset() {\n    const holder = this.clone.wtTable.holder; // todo refactoring: DEMETER\n    const hider = this.clone.wtTable.hider; // todo refactoring: DEMETER\n    const holderStyle = holder.style;\n    const hiderStyle = hider.style;\n    const rootStyle = holder.parentNode.style;\n    [holderStyle, hiderStyle, rootStyle].forEach(style => {\n      style.width = '';\n      style.height = '';\n    });\n  }\n\n  /**\n   * Determine if Walkontable is running in RTL mode.\n   *\n   * @returns {boolean}\n   */\n  isRtl() {\n    return this.wtSettings.getSetting('rtlMode');\n  }\n\n  /**\n   * Destroy overlay instance.\n   */\n  destroy() {\n    this.clone.eventManager.destroy(); // todo check if it is good place for that operation\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}