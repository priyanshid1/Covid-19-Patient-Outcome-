{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nimport CellCoords from \"./../cell/coords.mjs\";\n/**\n * CellRange holds cell coordinates as {@link CellCoords} instances. This object represent unit of the selection layer which\n * can contains multiple contiquous cells or single cell.\n *\n * @util\n */\n\nvar CellRange = /*#__PURE__*/function () {\n  function CellRange(highlight) {\n    var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : highlight;\n    var to = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : highlight;\n    _classCallCheck(this, CellRange);\n\n    /**\n     * Used to draw bold border around a cell where selection was started and to edit the cell\n     * when you press Enter. The highlight cannot point to headers (negative values) so its\n     * coordinates object is normalized while assigning.\n     *\n     * @type {CellCoords}\n     */\n    this.highlight = highlight.clone().normalize();\n    /**\n     * Usually the same as highlight, but in Excel there is distinction - one can change\n     * highlight within a selection.\n     *\n     * @type {CellCoords}\n     */\n\n    this.from = from.clone();\n    /**\n     * End selection.\n     *\n     * @type {CellCoords}\n     */\n\n    this.to = to.clone();\n  }\n  /**\n   * Set the new coordinates for highlighting selection.\n   *\n   * @param {CellCoords} coords Coordinates to use.\n   * @returns {CellRange}\n   */\n\n  _createClass(CellRange, [{\n    key: \"setHighlight\",\n    value: function setHighlight(coords) {\n      this.highlight = coords.clone().normalize();\n      return this;\n    }\n    /**\n     * Set the new coordinates where selection starts from.\n     *\n     * @param {CellCoords} coords Coordinates to use.\n     * @returns {CellRange}\n     */\n  }, {\n    key: \"setFrom\",\n    value: function setFrom(coords) {\n      this.from = coords.clone();\n      return this;\n    }\n    /**\n     * Set new coordinates where selection ends from.\n     *\n     * @param {CellCoords} coords Coordinates to use.\n     * @returns {CellRange}\n     */\n  }, {\n    key: \"setTo\",\n    value: function setTo(coords) {\n      this.to = coords.clone();\n      return this;\n    }\n    /**\n     * Checks if given coordinates are valid in context of a given Walkontable instance.\n     *\n     * @param {Walkontable} wot The Walkontable instance.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isValid\",\n    value: function isValid(wot) {\n      return this.from.isValid(wot) && this.to.isValid(wot);\n    }\n    /**\n     * Checks if this cell range is restricted to one cell.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isSingle\",\n    value: function isSingle() {\n      return this.from.row >= 0 && this.from.row === this.to.row && this.from.col >= 0 && this.from.col === this.to.col;\n    }\n    /**\n     * Returns selected range height (in number of rows including rows' headers).\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"getOuterHeight\",\n    value: function getOuterHeight() {\n      return Math.max(this.from.row, this.to.row) - Math.min(this.from.row, this.to.row) + 1;\n    }\n    /**\n     * Returns selected range width (in number of columns including columns' headers).\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"getOuterWidth\",\n    value: function getOuterWidth() {\n      return Math.max(this.from.col, this.to.col) - Math.min(this.from.col, this.to.col) + 1;\n    }\n    /**\n     * Returns selected range height (in number of rows excluding rows' headers).\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"getHeight\",\n    value: function getHeight() {\n      var fromRow = Math.max(this.from.row, 0);\n      var toRow = Math.max(this.to.row, 0);\n      return Math.max(fromRow, toRow) - Math.min(fromRow, toRow) + 1;\n    }\n    /**\n     * Returns selected range width (in number of columns excluding columns' headers).\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"getWidth\",\n    value: function getWidth() {\n      var fromCol = Math.max(this.from.col, 0);\n      var toCol = Math.max(this.to.col, 0);\n      return Math.max(fromCol, toCol) - Math.min(fromCol, toCol) + 1;\n    }\n    /**\n     * Checks if given cell coordinates are within `from` and `to` cell coordinates of this range.\n     *\n     * @param {CellCoords} cellCoords The cell coordinates to check.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"includes\",\n    value: function includes(cellCoords) {\n      var row = cellCoords.row,\n        col = cellCoords.col;\n      var topLeft = this.getOuterTopLeftCorner();\n      var bottomRight = this.getOuterBottomRightCorner();\n      return topLeft.row <= row && bottomRight.row >= row && topLeft.col <= col && bottomRight.col >= col;\n    }\n    /**\n     * Checks if given range is within of this range.\n     *\n     * @param {CellRange} cellRange The cells range to check.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"includesRange\",\n    value: function includesRange(cellRange) {\n      return this.includes(cellRange.getOuterTopLeftCorner()) && this.includes(cellRange.getOuterBottomRightCorner());\n    }\n    /**\n     * Checks if given range is equal to this range.\n     *\n     * @param {CellRange} cellRange The cells range to check.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(cellRange) {\n      return Math.min(this.from.row, this.to.row) === Math.min(cellRange.from.row, cellRange.to.row) && Math.max(this.from.row, this.to.row) === Math.max(cellRange.from.row, cellRange.to.row) && Math.min(this.from.col, this.to.col) === Math.min(cellRange.from.col, cellRange.to.col) && Math.max(this.from.col, this.to.col) === Math.max(cellRange.from.col, cellRange.to.col);\n    }\n    /**\n     * Checks if tested range overlaps with the range. Range A is considered to to be overlapping with range B\n     * if intersection of A and B or B and A is not empty.\n     *\n     * @param {CellRange} cellRange The cells range to check.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"overlaps\",\n    value: function overlaps(cellRange) {\n      return cellRange.isSouthEastOf(this.getOuterTopLeftCorner()) && cellRange.isNorthWestOf(this.getOuterBottomRightCorner());\n    }\n    /**\n     * Checks if tested coordinates are positioned in south-east from this cell range.\n     *\n     * @param {CellRange} cellRange The cells range to check.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isSouthEastOf\",\n    value: function isSouthEastOf(cellRange) {\n      return this.getOuterTopLeftCorner().isSouthEastOf(cellRange) || this.getOuterBottomRightCorner().isSouthEastOf(cellRange);\n    }\n    /**\n     * Checks if tested coordinates are positioned in north-west from this cell range.\n     *\n     * @param {CellRange} cellRange The cells range to check.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isNorthWestOf\",\n    value: function isNorthWestOf(cellRange) {\n      return this.getOuterTopLeftCorner().isNorthWestOf(cellRange) || this.getOuterBottomRightCorner().isNorthWestOf(cellRange);\n    }\n    /**\n     * Returns `true` if the provided range is overlapping the current range horizontally (e.g. The current range's last\n     * column is 5 and the provided range's first column is 3).\n     *\n     * @param {CellRange} cellRange The cells range to check.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isOverlappingHorizontally\",\n    value: function isOverlappingHorizontally(cellRange) {\n      return this.getOuterTopRightCorner().col >= cellRange.getOuterTopLeftCorner().col && this.getOuterTopRightCorner().col <= cellRange.getOuterTopRightCorner().col || this.getOuterTopLeftCorner().col <= cellRange.getOuterTopRightCorner().col && this.getOuterTopLeftCorner().col >= cellRange.getOuterTopLeftCorner().col;\n    }\n    /**\n     * Returns `true` if the provided range is overlapping the current range vertically (e.g. The current range's last\n     *  row is 5 and the provided range's first row is 3).\n     *\n     * @param {CellRange} cellRange The cells range to check.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isOverlappingVertically\",\n    value: function isOverlappingVertically(cellRange) {\n      return this.getOuterBottomRightCorner().row >= cellRange.getOuterTopRightCorner().row && this.getOuterBottomRightCorner().row <= cellRange.getOuterBottomRightCorner().row || this.getOuterTopRightCorner().row <= cellRange.getOuterBottomRightCorner().row && this.getOuterTopRightCorner().row >= cellRange.getOuterTopRightCorner().row;\n    }\n    /**\n     * Adds a cell to a range (only if exceeds corners of the range). Returns information if range was expanded.\n     *\n     * @param {CellCoords} cellCoords The cell coordinates.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"expand\",\n    value: function expand(cellCoords) {\n      var topLeft = this.getOuterTopLeftCorner();\n      var bottomRight = this.getOuterBottomRightCorner();\n      if (cellCoords.row < topLeft.row || cellCoords.col < topLeft.col || cellCoords.row > bottomRight.row || cellCoords.col > bottomRight.col) {\n        this.from = new CellCoords(Math.min(topLeft.row, cellCoords.row), Math.min(topLeft.col, cellCoords.col));\n        this.to = new CellCoords(Math.max(bottomRight.row, cellCoords.row), Math.max(bottomRight.col, cellCoords.col));\n        return true;\n      }\n      return false;\n    }\n    /**\n     * Expand the current object by the range passed in the first argument.\n     *\n     * @param {CellRange} expandingRange Object extending the range.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"expandByRange\",\n    value: function expandByRange(expandingRange) {\n      if (this.includesRange(expandingRange) || !this.overlaps(expandingRange)) {\n        return false;\n      }\n      var topLeft = this.getOuterTopLeftCorner();\n      var bottomRight = this.getOuterBottomRightCorner();\n      var initialDirection = this.getDirection();\n      var expandingTopLeft = expandingRange.getOuterTopLeftCorner();\n      var expandingBottomRight = expandingRange.getOuterBottomRightCorner();\n      var resultTopRow = Math.min(topLeft.row, expandingTopLeft.row);\n      var resultTopCol = Math.min(topLeft.col, expandingTopLeft.col);\n      var resultBottomRow = Math.max(bottomRight.row, expandingBottomRight.row);\n      var resultBottomCol = Math.max(bottomRight.col, expandingBottomRight.col);\n      var finalFrom = new CellCoords(resultTopRow, resultTopCol);\n      var finalTo = new CellCoords(resultBottomRow, resultBottomCol);\n      this.from = finalFrom;\n      this.to = finalTo;\n      this.setDirection(initialDirection);\n      if (this.highlight.row === this.getOuterBottomRightCorner().row && this.getVerticalDirection() === 'N-S') {\n        this.flipDirectionVertically();\n      }\n      if (this.highlight.col === this.getOuterTopRightCorner().col && this.getHorizontalDirection() === 'W-E') {\n        this.flipDirectionHorizontally();\n      }\n      return true;\n    }\n    /**\n     * Gets the direction of the selection.\n     *\n     * @returns {string} Returns one of the values: `'NW-SE'`, `'NE-SW'`, `'SE-NW'`, `'SW-NE'`.\n     */\n  }, {\n    key: \"getDirection\",\n    value: function getDirection() {\n      if (this.from.isNorthWestOf(this.to)) {\n        // NorthWest - SouthEast\n        return 'NW-SE';\n      } else if (this.from.isNorthEastOf(this.to)) {\n        // NorthEast - SouthWest\n        return 'NE-SW';\n      } else if (this.from.isSouthEastOf(this.to)) {\n        // SouthEast - NorthWest\n        return 'SE-NW';\n      } else if (this.from.isSouthWestOf(this.to)) {\n        // SouthWest - NorthEast\n        return 'SW-NE';\n      }\n    }\n    /**\n     * Sets the direction of the selection.\n     *\n     * @param {string} direction One of the values: `'NW-SE'`, `'NE-SW'`, `'SE-NW'`, `'SW-NE'`.\n     */\n  }, {\n    key: \"setDirection\",\n    value: function setDirection(direction) {\n      switch (direction) {\n        case 'NW-SE':\n          var _ref = [this.getOuterTopLeftCorner(), this.getOuterBottomRightCorner()];\n          this.from = _ref[0];\n          this.to = _ref[1];\n          break;\n        case 'NE-SW':\n          var _ref2 = [this.getOuterTopRightCorner(), this.getOuterBottomLeftCorner()];\n          this.from = _ref2[0];\n          this.to = _ref2[1];\n          break;\n        case 'SE-NW':\n          var _ref3 = [this.getOuterBottomRightCorner(), this.getOuterTopLeftCorner()];\n          this.from = _ref3[0];\n          this.to = _ref3[1];\n          break;\n        case 'SW-NE':\n          var _ref4 = [this.getOuterBottomLeftCorner(), this.getOuterTopRightCorner()];\n          this.from = _ref4[0];\n          this.to = _ref4[1];\n          break;\n        default:\n          break;\n      }\n    }\n    /**\n     * Gets the vertical direction of the range.\n     *\n     * @returns {string} Returns one of the values: `N-S` (north->south), `S-N` (south->north).\n     */\n  }, {\n    key: \"getVerticalDirection\",\n    value: function getVerticalDirection() {\n      return ['NE-SW', 'NW-SE'].indexOf(this.getDirection()) > -1 ? 'N-S' : 'S-N';\n    }\n    /**\n     * Gets the horizontal direction of the range.\n     *\n     * @returns {string} Returns one of the values: `W-E` (west->east), `E-W` (east->west).\n     */\n  }, {\n    key: \"getHorizontalDirection\",\n    value: function getHorizontalDirection() {\n      return ['NW-SE', 'SW-NE'].indexOf(this.getDirection()) > -1 ? 'W-E' : 'E-W';\n    }\n    /**\n     * Flip the direction vertically. (e.g. `NW-SE` changes to `SW-NE`).\n     */\n  }, {\n    key: \"flipDirectionVertically\",\n    value: function flipDirectionVertically() {\n      var direction = this.getDirection();\n      switch (direction) {\n        case 'NW-SE':\n          this.setDirection('SW-NE');\n          break;\n        case 'NE-SW':\n          this.setDirection('SE-NW');\n          break;\n        case 'SE-NW':\n          this.setDirection('NE-SW');\n          break;\n        case 'SW-NE':\n          this.setDirection('NW-SE');\n          break;\n        default:\n          break;\n      }\n    }\n    /**\n     * Flip the direction horizontally. (e.g. `NW-SE` changes to `NE-SW`).\n     */\n  }, {\n    key: \"flipDirectionHorizontally\",\n    value: function flipDirectionHorizontally() {\n      var direction = this.getDirection();\n      switch (direction) {\n        case 'NW-SE':\n          this.setDirection('NE-SW');\n          break;\n        case 'NE-SW':\n          this.setDirection('NW-SE');\n          break;\n        case 'SE-NW':\n          this.setDirection('SW-NE');\n          break;\n        case 'SW-NE':\n          this.setDirection('SE-NW');\n          break;\n        default:\n          break;\n      }\n    }\n    /**\n     * Gets the top left corner of this range. If the corner contains header coordinates\n     * (negative values), the corner coordinates will be normalized to 0.\n     *\n     * @returns {CellCoords}\n     */\n  }, {\n    key: \"getTopLeftCorner\",\n    value: function getTopLeftCorner() {\n      return new CellCoords(Math.min(this.from.row, this.to.row), Math.min(this.from.col, this.to.col)).normalize();\n    }\n    /**\n     * Gets the bottom right corner of this range. If the corner contains header coordinates\n     * (negative values), the corner coordinates will be normalized to 0.\n     *\n     * @returns {CellCoords}\n     */\n  }, {\n    key: \"getBottomRightCorner\",\n    value: function getBottomRightCorner() {\n      return new CellCoords(Math.max(this.from.row, this.to.row), Math.max(this.from.col, this.to.col)).normalize();\n    }\n    /**\n     * Gets the top right corner of this range. If the corner contains header coordinates\n     * (negative values), the corner coordinates will be normalized to 0.\n     *\n     * @returns {CellCoords}\n     */\n  }, {\n    key: \"getTopRightCorner\",\n    value: function getTopRightCorner() {\n      return new CellCoords(Math.min(this.from.row, this.to.row), Math.max(this.from.col, this.to.col)).normalize();\n    }\n    /**\n     * Gets the bottom left corner of this range. If the corner contains header coordinates\n     * (negative values), the corner coordinates will be normalized to 0.\n     *\n     * @returns {CellCoords}\n     */\n  }, {\n    key: \"getBottomLeftCorner\",\n    value: function getBottomLeftCorner() {\n      return new CellCoords(Math.max(this.from.row, this.to.row), Math.min(this.from.col, this.to.col)).normalize();\n    }\n    /**\n     * Gets the top left corner of this range. If the corner contains header coordinates\n     * (negative values), then the top and left coordinates will be pointed to that header.\n     *\n     * @returns {CellCoords}\n     */\n  }, {\n    key: \"getOuterTopLeftCorner\",\n    value: function getOuterTopLeftCorner() {\n      return new CellCoords(Math.min(this.from.row, this.to.row), Math.min(this.from.col, this.to.col));\n    }\n    /**\n     * Gets the bottom right corner of this range.\n     *\n     * @returns {CellCoords}\n     */\n  }, {\n    key: \"getOuterBottomRightCorner\",\n    value: function getOuterBottomRightCorner() {\n      return new CellCoords(Math.max(this.from.row, this.to.row), Math.max(this.from.col, this.to.col));\n    }\n    /**\n     * Gets the top right corner of this range. If the corner contains header coordinates\n     * (negative values), then the top coordinate will be pointed to that header.\n     *\n     * @returns {CellCoords}\n     */\n  }, {\n    key: \"getOuterTopRightCorner\",\n    value: function getOuterTopRightCorner() {\n      return new CellCoords(Math.min(this.from.row, this.to.row), Math.max(this.from.col, this.to.col));\n    }\n    /**\n     * Gets the bottom left corner of this range. If the corner contains header coordinates\n     * (negative values), then the left coordinate will be pointed to that header.\n     *\n     * @returns {CellCoords}\n     */\n  }, {\n    key: \"getOuterBottomLeftCorner\",\n    value: function getOuterBottomLeftCorner() {\n      return new CellCoords(Math.max(this.from.row, this.to.row), Math.min(this.from.col, this.to.col));\n    }\n    /**\n     * Checks if coordinates match to one of the 4th corners of this range.\n     *\n     * @param {CellCoords} coords Cell coordinates to check.\n     * @param {CellRange} [expandedRange] The cells range to compare with.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isCorner\",\n    value: function isCorner(coords, expandedRange) {\n      if (expandedRange && expandedRange.includes(coords) && (this.getOuterTopLeftCorner().isEqual(new CellCoords(expandedRange.from.row, expandedRange.from.col)) || this.getOuterTopRightCorner().isEqual(new CellCoords(expandedRange.from.row, expandedRange.to.col)) || this.getOuterBottomLeftCorner().isEqual(new CellCoords(expandedRange.to.row, expandedRange.from.col)) || this.getOuterBottomRightCorner().isEqual(new CellCoords(expandedRange.to.row, expandedRange.to.col)))) {\n        return true;\n      }\n      return coords.isEqual(this.getOuterTopLeftCorner()) || coords.isEqual(this.getOuterTopRightCorner()) || coords.isEqual(this.getOuterBottomLeftCorner()) || coords.isEqual(this.getOuterBottomRightCorner());\n    }\n    /**\n     * Gets coordinates of the corner which is opposite to the matched. When the passed coordinates matched to the\n     * bottom-right corner of this range then the coordinates for top-left will be returned.\n     *\n     * @param {CellCoords} coords Cell coordinates to check.\n     * @param {CellRange} [expandedRange] The cells range to compare with.\n     * @returns {CellCoords}\n     */\n  }, {\n    key: \"getOppositeCorner\",\n    value: function getOppositeCorner(coords, expandedRange) {\n      if (!(coords instanceof CellCoords)) {\n        return false;\n      }\n      if (expandedRange) {\n        if (expandedRange.includes(coords)) {\n          if (this.getOuterTopLeftCorner().isEqual(new CellCoords(expandedRange.from.row, expandedRange.from.col))) {\n            return this.getOuterBottomRightCorner();\n          }\n          if (this.getOuterTopRightCorner().isEqual(new CellCoords(expandedRange.from.row, expandedRange.to.col))) {\n            return this.getOuterBottomLeftCorner();\n          }\n          if (this.getOuterBottomLeftCorner().isEqual(new CellCoords(expandedRange.to.row, expandedRange.from.col))) {\n            return this.getOuterTopRightCorner();\n          }\n          if (this.getOuterBottomRightCorner().isEqual(new CellCoords(expandedRange.to.row, expandedRange.to.col))) {\n            return this.getOuterTopLeftCorner();\n          }\n        }\n      }\n      if (coords.isEqual(this.getOuterBottomRightCorner())) {\n        return this.getOuterTopLeftCorner();\n      } else if (coords.isEqual(this.getOuterTopLeftCorner())) {\n        return this.getOuterBottomRightCorner();\n      } else if (coords.isEqual(this.getOuterTopRightCorner())) {\n        return this.getOuterBottomLeftCorner();\n      } else if (coords.isEqual(this.getOuterBottomLeftCorner())) {\n        return this.getOuterTopRightCorner();\n      }\n    }\n    /**\n     * @param {CellRange} range The cells range to compare with.\n     * @returns {Array}\n     */\n  }, {\n    key: \"getBordersSharedWith\",\n    value: function getBordersSharedWith(range) {\n      if (!this.includesRange(range)) {\n        return [];\n      }\n      var thisBorders = {\n        top: Math.min(this.from.row, this.to.row),\n        bottom: Math.max(this.from.row, this.to.row),\n        left: Math.min(this.from.col, this.to.col),\n        right: Math.max(this.from.col, this.to.col)\n      };\n      var rangeBorders = {\n        top: Math.min(range.from.row, range.to.row),\n        bottom: Math.max(range.from.row, range.to.row),\n        left: Math.min(range.from.col, range.to.col),\n        right: Math.max(range.from.col, range.to.col)\n      };\n      var result = [];\n      if (thisBorders.top === rangeBorders.top) {\n        result.push('top');\n      }\n      if (thisBorders.right === rangeBorders.right) {\n        result.push('right');\n      }\n      if (thisBorders.bottom === rangeBorders.bottom) {\n        result.push('bottom');\n      }\n      if (thisBorders.left === rangeBorders.left) {\n        result.push('left');\n      }\n      return result;\n    }\n    /**\n     * Get inner selected cell coords defined by this range.\n     *\n     * @returns {Array}\n     */\n  }, {\n    key: \"getInner\",\n    value: function getInner() {\n      var topLeft = this.getOuterTopLeftCorner();\n      var bottomRight = this.getOuterBottomRightCorner();\n      var out = [];\n      for (var r = topLeft.row; r <= bottomRight.row; r++) {\n        for (var c = topLeft.col; c <= bottomRight.col; c++) {\n          if (!(this.from.row === r && this.from.col === c) && !(this.to.row === r && this.to.col === c)) {\n            out.push(new CellCoords(r, c));\n          }\n        }\n      }\n      return out;\n    }\n    /**\n     * Get all selected cell coords defined by this range.\n     *\n     * @returns {Array}\n     */\n  }, {\n    key: \"getAll\",\n    value: function getAll() {\n      var topLeft = this.getOuterTopLeftCorner();\n      var bottomRight = this.getOuterBottomRightCorner();\n      var out = [];\n      for (var r = topLeft.row; r <= bottomRight.row; r++) {\n        for (var c = topLeft.col; c <= bottomRight.col; c++) {\n          if (topLeft.row === r && topLeft.col === c) {\n            out.push(topLeft);\n          } else if (bottomRight.row === r && bottomRight.col === c) {\n            out.push(bottomRight);\n          } else {\n            out.push(new CellCoords(r, c));\n          }\n        }\n      }\n      return out;\n    }\n    /**\n     * Runs a callback function against all cells in the range. You can break the iteration by returning\n     * `false` in the callback function.\n     *\n     * @param {Function} callback The callback function.\n     */\n  }, {\n    key: \"forAll\",\n    value: function forAll(callback) {\n      var topLeft = this.getOuterTopLeftCorner();\n      var bottomRight = this.getOuterBottomRightCorner();\n      for (var r = topLeft.row; r <= bottomRight.row; r++) {\n        for (var c = topLeft.col; c <= bottomRight.col; c++) {\n          var breakIteration = callback(r, c);\n          if (breakIteration === false) {\n            return;\n          }\n        }\n      }\n    }\n    /**\n     * Clones the range coordinates.\n     *\n     * @returns {CellRange}\n     */\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new CellRange(this.highlight, this.from, this.to);\n    }\n    /**\n     * Convert CellRange to literal object.\n     *\n     * @returns {object} Returns a literal object with `from` and `to` properties which each of that object\n     *                  contains `row` and `col` keys.\n     */\n  }, {\n    key: \"toObject\",\n    value: function toObject() {\n      return {\n        from: this.from.toObject(),\n        to: this.to.toObject()\n      };\n    }\n  }]);\n  return CellRange;\n}();\nexport default CellRange;","map":{"version":3,"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","CellCoords","CellRange","highlight","from","arguments","undefined","to","clone","normalize","value","setHighlight","coords","setFrom","setTo","isValid","wot","isSingle","row","col","getOuterHeight","Math","max","min","getOuterWidth","getHeight","fromRow","toRow","getWidth","fromCol","toCol","includes","cellCoords","topLeft","getOuterTopLeftCorner","bottomRight","getOuterBottomRightCorner","includesRange","cellRange","isEqual","overlaps","isSouthEastOf","isNorthWestOf","isOverlappingHorizontally","getOuterTopRightCorner","isOverlappingVertically","expand","expandByRange","expandingRange","initialDirection","getDirection","expandingTopLeft","expandingBottomRight","resultTopRow","resultTopCol","resultBottomRow","resultBottomCol","finalFrom","finalTo","setDirection","getVerticalDirection","flipDirectionVertically","getHorizontalDirection","flipDirectionHorizontally","isNorthEastOf","isSouthWestOf","direction","_ref","_ref2","getOuterBottomLeftCorner","_ref3","_ref4","indexOf","getTopLeftCorner","getBottomRightCorner","getTopRightCorner","getBottomLeftCorner","isCorner","expandedRange","getOppositeCorner","getBordersSharedWith","range","thisBorders","top","bottom","left","right","rangeBorders","result","push","getInner","out","r","c","getAll","forAll","callback","breakIteration","toObject"],"sources":["/Users/priyadeliwala/Desktop/sales-dashboard/node_modules/handsontable/3rdparty/walkontable/src/cell/range.mjs"],"sourcesContent":["import \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/es.array.index-of.js\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nimport CellCoords from \"./../cell/coords.mjs\";\n/**\n * CellRange holds cell coordinates as {@link CellCoords} instances. This object represent unit of the selection layer which\n * can contains multiple contiquous cells or single cell.\n *\n * @util\n */\n\nvar CellRange = /*#__PURE__*/function () {\n  function CellRange(highlight) {\n    var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : highlight;\n    var to = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : highlight;\n\n    _classCallCheck(this, CellRange);\n\n    /**\n     * Used to draw bold border around a cell where selection was started and to edit the cell\n     * when you press Enter. The highlight cannot point to headers (negative values) so its\n     * coordinates object is normalized while assigning.\n     *\n     * @type {CellCoords}\n     */\n    this.highlight = highlight.clone().normalize();\n    /**\n     * Usually the same as highlight, but in Excel there is distinction - one can change\n     * highlight within a selection.\n     *\n     * @type {CellCoords}\n     */\n\n    this.from = from.clone();\n    /**\n     * End selection.\n     *\n     * @type {CellCoords}\n     */\n\n    this.to = to.clone();\n  }\n  /**\n   * Set the new coordinates for highlighting selection.\n   *\n   * @param {CellCoords} coords Coordinates to use.\n   * @returns {CellRange}\n   */\n\n\n  _createClass(CellRange, [{\n    key: \"setHighlight\",\n    value: function setHighlight(coords) {\n      this.highlight = coords.clone().normalize();\n      return this;\n    }\n    /**\n     * Set the new coordinates where selection starts from.\n     *\n     * @param {CellCoords} coords Coordinates to use.\n     * @returns {CellRange}\n     */\n\n  }, {\n    key: \"setFrom\",\n    value: function setFrom(coords) {\n      this.from = coords.clone();\n      return this;\n    }\n    /**\n     * Set new coordinates where selection ends from.\n     *\n     * @param {CellCoords} coords Coordinates to use.\n     * @returns {CellRange}\n     */\n\n  }, {\n    key: \"setTo\",\n    value: function setTo(coords) {\n      this.to = coords.clone();\n      return this;\n    }\n    /**\n     * Checks if given coordinates are valid in context of a given Walkontable instance.\n     *\n     * @param {Walkontable} wot The Walkontable instance.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isValid\",\n    value: function isValid(wot) {\n      return this.from.isValid(wot) && this.to.isValid(wot);\n    }\n    /**\n     * Checks if this cell range is restricted to one cell.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isSingle\",\n    value: function isSingle() {\n      return this.from.row >= 0 && this.from.row === this.to.row && this.from.col >= 0 && this.from.col === this.to.col;\n    }\n    /**\n     * Returns selected range height (in number of rows including rows' headers).\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: \"getOuterHeight\",\n    value: function getOuterHeight() {\n      return Math.max(this.from.row, this.to.row) - Math.min(this.from.row, this.to.row) + 1;\n    }\n    /**\n     * Returns selected range width (in number of columns including columns' headers).\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: \"getOuterWidth\",\n    value: function getOuterWidth() {\n      return Math.max(this.from.col, this.to.col) - Math.min(this.from.col, this.to.col) + 1;\n    }\n    /**\n     * Returns selected range height (in number of rows excluding rows' headers).\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: \"getHeight\",\n    value: function getHeight() {\n      var fromRow = Math.max(this.from.row, 0);\n      var toRow = Math.max(this.to.row, 0);\n      return Math.max(fromRow, toRow) - Math.min(fromRow, toRow) + 1;\n    }\n    /**\n     * Returns selected range width (in number of columns excluding columns' headers).\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: \"getWidth\",\n    value: function getWidth() {\n      var fromCol = Math.max(this.from.col, 0);\n      var toCol = Math.max(this.to.col, 0);\n      return Math.max(fromCol, toCol) - Math.min(fromCol, toCol) + 1;\n    }\n    /**\n     * Checks if given cell coordinates are within `from` and `to` cell coordinates of this range.\n     *\n     * @param {CellCoords} cellCoords The cell coordinates to check.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"includes\",\n    value: function includes(cellCoords) {\n      var row = cellCoords.row,\n          col = cellCoords.col;\n      var topLeft = this.getOuterTopLeftCorner();\n      var bottomRight = this.getOuterBottomRightCorner();\n      return topLeft.row <= row && bottomRight.row >= row && topLeft.col <= col && bottomRight.col >= col;\n    }\n    /**\n     * Checks if given range is within of this range.\n     *\n     * @param {CellRange} cellRange The cells range to check.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"includesRange\",\n    value: function includesRange(cellRange) {\n      return this.includes(cellRange.getOuterTopLeftCorner()) && this.includes(cellRange.getOuterBottomRightCorner());\n    }\n    /**\n     * Checks if given range is equal to this range.\n     *\n     * @param {CellRange} cellRange The cells range to check.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(cellRange) {\n      return Math.min(this.from.row, this.to.row) === Math.min(cellRange.from.row, cellRange.to.row) && Math.max(this.from.row, this.to.row) === Math.max(cellRange.from.row, cellRange.to.row) && Math.min(this.from.col, this.to.col) === Math.min(cellRange.from.col, cellRange.to.col) && Math.max(this.from.col, this.to.col) === Math.max(cellRange.from.col, cellRange.to.col);\n    }\n    /**\n     * Checks if tested range overlaps with the range. Range A is considered to to be overlapping with range B\n     * if intersection of A and B or B and A is not empty.\n     *\n     * @param {CellRange} cellRange The cells range to check.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"overlaps\",\n    value: function overlaps(cellRange) {\n      return cellRange.isSouthEastOf(this.getOuterTopLeftCorner()) && cellRange.isNorthWestOf(this.getOuterBottomRightCorner());\n    }\n    /**\n     * Checks if tested coordinates are positioned in south-east from this cell range.\n     *\n     * @param {CellRange} cellRange The cells range to check.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isSouthEastOf\",\n    value: function isSouthEastOf(cellRange) {\n      return this.getOuterTopLeftCorner().isSouthEastOf(cellRange) || this.getOuterBottomRightCorner().isSouthEastOf(cellRange);\n    }\n    /**\n     * Checks if tested coordinates are positioned in north-west from this cell range.\n     *\n     * @param {CellRange} cellRange The cells range to check.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isNorthWestOf\",\n    value: function isNorthWestOf(cellRange) {\n      return this.getOuterTopLeftCorner().isNorthWestOf(cellRange) || this.getOuterBottomRightCorner().isNorthWestOf(cellRange);\n    }\n    /**\n     * Returns `true` if the provided range is overlapping the current range horizontally (e.g. The current range's last\n     * column is 5 and the provided range's first column is 3).\n     *\n     * @param {CellRange} cellRange The cells range to check.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isOverlappingHorizontally\",\n    value: function isOverlappingHorizontally(cellRange) {\n      return this.getOuterTopRightCorner().col >= cellRange.getOuterTopLeftCorner().col && this.getOuterTopRightCorner().col <= cellRange.getOuterTopRightCorner().col || this.getOuterTopLeftCorner().col <= cellRange.getOuterTopRightCorner().col && this.getOuterTopLeftCorner().col >= cellRange.getOuterTopLeftCorner().col;\n    }\n    /**\n     * Returns `true` if the provided range is overlapping the current range vertically (e.g. The current range's last\n     *  row is 5 and the provided range's first row is 3).\n     *\n     * @param {CellRange} cellRange The cells range to check.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isOverlappingVertically\",\n    value: function isOverlappingVertically(cellRange) {\n      return this.getOuterBottomRightCorner().row >= cellRange.getOuterTopRightCorner().row && this.getOuterBottomRightCorner().row <= cellRange.getOuterBottomRightCorner().row || this.getOuterTopRightCorner().row <= cellRange.getOuterBottomRightCorner().row && this.getOuterTopRightCorner().row >= cellRange.getOuterTopRightCorner().row;\n    }\n    /**\n     * Adds a cell to a range (only if exceeds corners of the range). Returns information if range was expanded.\n     *\n     * @param {CellCoords} cellCoords The cell coordinates.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"expand\",\n    value: function expand(cellCoords) {\n      var topLeft = this.getOuterTopLeftCorner();\n      var bottomRight = this.getOuterBottomRightCorner();\n\n      if (cellCoords.row < topLeft.row || cellCoords.col < topLeft.col || cellCoords.row > bottomRight.row || cellCoords.col > bottomRight.col) {\n        this.from = new CellCoords(Math.min(topLeft.row, cellCoords.row), Math.min(topLeft.col, cellCoords.col));\n        this.to = new CellCoords(Math.max(bottomRight.row, cellCoords.row), Math.max(bottomRight.col, cellCoords.col));\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * Expand the current object by the range passed in the first argument.\n     *\n     * @param {CellRange} expandingRange Object extending the range.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"expandByRange\",\n    value: function expandByRange(expandingRange) {\n      if (this.includesRange(expandingRange) || !this.overlaps(expandingRange)) {\n        return false;\n      }\n\n      var topLeft = this.getOuterTopLeftCorner();\n      var bottomRight = this.getOuterBottomRightCorner();\n      var initialDirection = this.getDirection();\n      var expandingTopLeft = expandingRange.getOuterTopLeftCorner();\n      var expandingBottomRight = expandingRange.getOuterBottomRightCorner();\n      var resultTopRow = Math.min(topLeft.row, expandingTopLeft.row);\n      var resultTopCol = Math.min(topLeft.col, expandingTopLeft.col);\n      var resultBottomRow = Math.max(bottomRight.row, expandingBottomRight.row);\n      var resultBottomCol = Math.max(bottomRight.col, expandingBottomRight.col);\n      var finalFrom = new CellCoords(resultTopRow, resultTopCol);\n      var finalTo = new CellCoords(resultBottomRow, resultBottomCol);\n      this.from = finalFrom;\n      this.to = finalTo;\n      this.setDirection(initialDirection);\n\n      if (this.highlight.row === this.getOuterBottomRightCorner().row && this.getVerticalDirection() === 'N-S') {\n        this.flipDirectionVertically();\n      }\n\n      if (this.highlight.col === this.getOuterTopRightCorner().col && this.getHorizontalDirection() === 'W-E') {\n        this.flipDirectionHorizontally();\n      }\n\n      return true;\n    }\n    /**\n     * Gets the direction of the selection.\n     *\n     * @returns {string} Returns one of the values: `'NW-SE'`, `'NE-SW'`, `'SE-NW'`, `'SW-NE'`.\n     */\n\n  }, {\n    key: \"getDirection\",\n    value: function getDirection() {\n      if (this.from.isNorthWestOf(this.to)) {\n        // NorthWest - SouthEast\n        return 'NW-SE';\n      } else if (this.from.isNorthEastOf(this.to)) {\n        // NorthEast - SouthWest\n        return 'NE-SW';\n      } else if (this.from.isSouthEastOf(this.to)) {\n        // SouthEast - NorthWest\n        return 'SE-NW';\n      } else if (this.from.isSouthWestOf(this.to)) {\n        // SouthWest - NorthEast\n        return 'SW-NE';\n      }\n    }\n    /**\n     * Sets the direction of the selection.\n     *\n     * @param {string} direction One of the values: `'NW-SE'`, `'NE-SW'`, `'SE-NW'`, `'SW-NE'`.\n     */\n\n  }, {\n    key: \"setDirection\",\n    value: function setDirection(direction) {\n      switch (direction) {\n        case 'NW-SE':\n          var _ref = [this.getOuterTopLeftCorner(), this.getOuterBottomRightCorner()];\n          this.from = _ref[0];\n          this.to = _ref[1];\n          break;\n\n        case 'NE-SW':\n          var _ref2 = [this.getOuterTopRightCorner(), this.getOuterBottomLeftCorner()];\n          this.from = _ref2[0];\n          this.to = _ref2[1];\n          break;\n\n        case 'SE-NW':\n          var _ref3 = [this.getOuterBottomRightCorner(), this.getOuterTopLeftCorner()];\n          this.from = _ref3[0];\n          this.to = _ref3[1];\n          break;\n\n        case 'SW-NE':\n          var _ref4 = [this.getOuterBottomLeftCorner(), this.getOuterTopRightCorner()];\n          this.from = _ref4[0];\n          this.to = _ref4[1];\n          break;\n\n        default:\n          break;\n      }\n    }\n    /**\n     * Gets the vertical direction of the range.\n     *\n     * @returns {string} Returns one of the values: `N-S` (north->south), `S-N` (south->north).\n     */\n\n  }, {\n    key: \"getVerticalDirection\",\n    value: function getVerticalDirection() {\n      return ['NE-SW', 'NW-SE'].indexOf(this.getDirection()) > -1 ? 'N-S' : 'S-N';\n    }\n    /**\n     * Gets the horizontal direction of the range.\n     *\n     * @returns {string} Returns one of the values: `W-E` (west->east), `E-W` (east->west).\n     */\n\n  }, {\n    key: \"getHorizontalDirection\",\n    value: function getHorizontalDirection() {\n      return ['NW-SE', 'SW-NE'].indexOf(this.getDirection()) > -1 ? 'W-E' : 'E-W';\n    }\n    /**\n     * Flip the direction vertically. (e.g. `NW-SE` changes to `SW-NE`).\n     */\n\n  }, {\n    key: \"flipDirectionVertically\",\n    value: function flipDirectionVertically() {\n      var direction = this.getDirection();\n\n      switch (direction) {\n        case 'NW-SE':\n          this.setDirection('SW-NE');\n          break;\n\n        case 'NE-SW':\n          this.setDirection('SE-NW');\n          break;\n\n        case 'SE-NW':\n          this.setDirection('NE-SW');\n          break;\n\n        case 'SW-NE':\n          this.setDirection('NW-SE');\n          break;\n\n        default:\n          break;\n      }\n    }\n    /**\n     * Flip the direction horizontally. (e.g. `NW-SE` changes to `NE-SW`).\n     */\n\n  }, {\n    key: \"flipDirectionHorizontally\",\n    value: function flipDirectionHorizontally() {\n      var direction = this.getDirection();\n\n      switch (direction) {\n        case 'NW-SE':\n          this.setDirection('NE-SW');\n          break;\n\n        case 'NE-SW':\n          this.setDirection('NW-SE');\n          break;\n\n        case 'SE-NW':\n          this.setDirection('SW-NE');\n          break;\n\n        case 'SW-NE':\n          this.setDirection('SE-NW');\n          break;\n\n        default:\n          break;\n      }\n    }\n    /**\n     * Gets the top left corner of this range. If the corner contains header coordinates\n     * (negative values), the corner coordinates will be normalized to 0.\n     *\n     * @returns {CellCoords}\n     */\n\n  }, {\n    key: \"getTopLeftCorner\",\n    value: function getTopLeftCorner() {\n      return new CellCoords(Math.min(this.from.row, this.to.row), Math.min(this.from.col, this.to.col)).normalize();\n    }\n    /**\n     * Gets the bottom right corner of this range. If the corner contains header coordinates\n     * (negative values), the corner coordinates will be normalized to 0.\n     *\n     * @returns {CellCoords}\n     */\n\n  }, {\n    key: \"getBottomRightCorner\",\n    value: function getBottomRightCorner() {\n      return new CellCoords(Math.max(this.from.row, this.to.row), Math.max(this.from.col, this.to.col)).normalize();\n    }\n    /**\n     * Gets the top right corner of this range. If the corner contains header coordinates\n     * (negative values), the corner coordinates will be normalized to 0.\n     *\n     * @returns {CellCoords}\n     */\n\n  }, {\n    key: \"getTopRightCorner\",\n    value: function getTopRightCorner() {\n      return new CellCoords(Math.min(this.from.row, this.to.row), Math.max(this.from.col, this.to.col)).normalize();\n    }\n    /**\n     * Gets the bottom left corner of this range. If the corner contains header coordinates\n     * (negative values), the corner coordinates will be normalized to 0.\n     *\n     * @returns {CellCoords}\n     */\n\n  }, {\n    key: \"getBottomLeftCorner\",\n    value: function getBottomLeftCorner() {\n      return new CellCoords(Math.max(this.from.row, this.to.row), Math.min(this.from.col, this.to.col)).normalize();\n    }\n    /**\n     * Gets the top left corner of this range. If the corner contains header coordinates\n     * (negative values), then the top and left coordinates will be pointed to that header.\n     *\n     * @returns {CellCoords}\n     */\n\n  }, {\n    key: \"getOuterTopLeftCorner\",\n    value: function getOuterTopLeftCorner() {\n      return new CellCoords(Math.min(this.from.row, this.to.row), Math.min(this.from.col, this.to.col));\n    }\n    /**\n     * Gets the bottom right corner of this range.\n     *\n     * @returns {CellCoords}\n     */\n\n  }, {\n    key: \"getOuterBottomRightCorner\",\n    value: function getOuterBottomRightCorner() {\n      return new CellCoords(Math.max(this.from.row, this.to.row), Math.max(this.from.col, this.to.col));\n    }\n    /**\n     * Gets the top right corner of this range. If the corner contains header coordinates\n     * (negative values), then the top coordinate will be pointed to that header.\n     *\n     * @returns {CellCoords}\n     */\n\n  }, {\n    key: \"getOuterTopRightCorner\",\n    value: function getOuterTopRightCorner() {\n      return new CellCoords(Math.min(this.from.row, this.to.row), Math.max(this.from.col, this.to.col));\n    }\n    /**\n     * Gets the bottom left corner of this range. If the corner contains header coordinates\n     * (negative values), then the left coordinate will be pointed to that header.\n     *\n     * @returns {CellCoords}\n     */\n\n  }, {\n    key: \"getOuterBottomLeftCorner\",\n    value: function getOuterBottomLeftCorner() {\n      return new CellCoords(Math.max(this.from.row, this.to.row), Math.min(this.from.col, this.to.col));\n    }\n    /**\n     * Checks if coordinates match to one of the 4th corners of this range.\n     *\n     * @param {CellCoords} coords Cell coordinates to check.\n     * @param {CellRange} [expandedRange] The cells range to compare with.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isCorner\",\n    value: function isCorner(coords, expandedRange) {\n      if (expandedRange && expandedRange.includes(coords) && (this.getOuterTopLeftCorner().isEqual(new CellCoords(expandedRange.from.row, expandedRange.from.col)) || this.getOuterTopRightCorner().isEqual(new CellCoords(expandedRange.from.row, expandedRange.to.col)) || this.getOuterBottomLeftCorner().isEqual(new CellCoords(expandedRange.to.row, expandedRange.from.col)) || this.getOuterBottomRightCorner().isEqual(new CellCoords(expandedRange.to.row, expandedRange.to.col)))) {\n        return true;\n      }\n\n      return coords.isEqual(this.getOuterTopLeftCorner()) || coords.isEqual(this.getOuterTopRightCorner()) || coords.isEqual(this.getOuterBottomLeftCorner()) || coords.isEqual(this.getOuterBottomRightCorner());\n    }\n    /**\n     * Gets coordinates of the corner which is opposite to the matched. When the passed coordinates matched to the\n     * bottom-right corner of this range then the coordinates for top-left will be returned.\n     *\n     * @param {CellCoords} coords Cell coordinates to check.\n     * @param {CellRange} [expandedRange] The cells range to compare with.\n     * @returns {CellCoords}\n     */\n\n  }, {\n    key: \"getOppositeCorner\",\n    value: function getOppositeCorner(coords, expandedRange) {\n      if (!(coords instanceof CellCoords)) {\n        return false;\n      }\n\n      if (expandedRange) {\n        if (expandedRange.includes(coords)) {\n          if (this.getOuterTopLeftCorner().isEqual(new CellCoords(expandedRange.from.row, expandedRange.from.col))) {\n            return this.getOuterBottomRightCorner();\n          }\n\n          if (this.getOuterTopRightCorner().isEqual(new CellCoords(expandedRange.from.row, expandedRange.to.col))) {\n            return this.getOuterBottomLeftCorner();\n          }\n\n          if (this.getOuterBottomLeftCorner().isEqual(new CellCoords(expandedRange.to.row, expandedRange.from.col))) {\n            return this.getOuterTopRightCorner();\n          }\n\n          if (this.getOuterBottomRightCorner().isEqual(new CellCoords(expandedRange.to.row, expandedRange.to.col))) {\n            return this.getOuterTopLeftCorner();\n          }\n        }\n      }\n\n      if (coords.isEqual(this.getOuterBottomRightCorner())) {\n        return this.getOuterTopLeftCorner();\n      } else if (coords.isEqual(this.getOuterTopLeftCorner())) {\n        return this.getOuterBottomRightCorner();\n      } else if (coords.isEqual(this.getOuterTopRightCorner())) {\n        return this.getOuterBottomLeftCorner();\n      } else if (coords.isEqual(this.getOuterBottomLeftCorner())) {\n        return this.getOuterTopRightCorner();\n      }\n    }\n    /**\n     * @param {CellRange} range The cells range to compare with.\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getBordersSharedWith\",\n    value: function getBordersSharedWith(range) {\n      if (!this.includesRange(range)) {\n        return [];\n      }\n\n      var thisBorders = {\n        top: Math.min(this.from.row, this.to.row),\n        bottom: Math.max(this.from.row, this.to.row),\n        left: Math.min(this.from.col, this.to.col),\n        right: Math.max(this.from.col, this.to.col)\n      };\n      var rangeBorders = {\n        top: Math.min(range.from.row, range.to.row),\n        bottom: Math.max(range.from.row, range.to.row),\n        left: Math.min(range.from.col, range.to.col),\n        right: Math.max(range.from.col, range.to.col)\n      };\n      var result = [];\n\n      if (thisBorders.top === rangeBorders.top) {\n        result.push('top');\n      }\n\n      if (thisBorders.right === rangeBorders.right) {\n        result.push('right');\n      }\n\n      if (thisBorders.bottom === rangeBorders.bottom) {\n        result.push('bottom');\n      }\n\n      if (thisBorders.left === rangeBorders.left) {\n        result.push('left');\n      }\n\n      return result;\n    }\n    /**\n     * Get inner selected cell coords defined by this range.\n     *\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getInner\",\n    value: function getInner() {\n      var topLeft = this.getOuterTopLeftCorner();\n      var bottomRight = this.getOuterBottomRightCorner();\n      var out = [];\n\n      for (var r = topLeft.row; r <= bottomRight.row; r++) {\n        for (var c = topLeft.col; c <= bottomRight.col; c++) {\n          if (!(this.from.row === r && this.from.col === c) && !(this.to.row === r && this.to.col === c)) {\n            out.push(new CellCoords(r, c));\n          }\n        }\n      }\n\n      return out;\n    }\n    /**\n     * Get all selected cell coords defined by this range.\n     *\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getAll\",\n    value: function getAll() {\n      var topLeft = this.getOuterTopLeftCorner();\n      var bottomRight = this.getOuterBottomRightCorner();\n      var out = [];\n\n      for (var r = topLeft.row; r <= bottomRight.row; r++) {\n        for (var c = topLeft.col; c <= bottomRight.col; c++) {\n          if (topLeft.row === r && topLeft.col === c) {\n            out.push(topLeft);\n          } else if (bottomRight.row === r && bottomRight.col === c) {\n            out.push(bottomRight);\n          } else {\n            out.push(new CellCoords(r, c));\n          }\n        }\n      }\n\n      return out;\n    }\n    /**\n     * Runs a callback function against all cells in the range. You can break the iteration by returning\n     * `false` in the callback function.\n     *\n     * @param {Function} callback The callback function.\n     */\n\n  }, {\n    key: \"forAll\",\n    value: function forAll(callback) {\n      var topLeft = this.getOuterTopLeftCorner();\n      var bottomRight = this.getOuterBottomRightCorner();\n\n      for (var r = topLeft.row; r <= bottomRight.row; r++) {\n        for (var c = topLeft.col; c <= bottomRight.col; c++) {\n          var breakIteration = callback(r, c);\n\n          if (breakIteration === false) {\n            return;\n          }\n        }\n      }\n    }\n    /**\n     * Clones the range coordinates.\n     *\n     * @returns {CellRange}\n     */\n\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new CellRange(this.highlight, this.from, this.to);\n    }\n    /**\n     * Convert CellRange to literal object.\n     *\n     * @returns {object} Returns a literal object with `from` and `to` properties which each of that object\n     *                  contains `row` and `col` keys.\n     */\n\n  }, {\n    key: \"toObject\",\n    value: function toObject() {\n      return {\n        from: this.from.toObject(),\n        to: this.to.toObject()\n      };\n    }\n  }]);\n\n  return CellRange;\n}();\n\nexport default CellRange;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}