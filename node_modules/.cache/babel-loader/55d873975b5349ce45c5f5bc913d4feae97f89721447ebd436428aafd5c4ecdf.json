{"ast":null,"code":"import moment from 'moment';\nimport { getEditorInstance } from \"../../editors/registry.mjs\";\nimport { EDITOR_TYPE as DATE_EDITOR_TYPE } from \"../../editors/dateEditor/index.mjs\";\nimport { getNormalizedDate } from \"../../helpers/date.mjs\";\nexport var VALIDATOR_TYPE = 'date';\n/**\n * The Date cell validator.\n *\n * @private\n * @param {*} value Value of edited cell.\n * @param {Function} callback Callback called with validation result.\n */\n\nexport function dateValidator(value, callback) {\n  var dateEditor = getEditorInstance(DATE_EDITOR_TYPE, this.instance);\n  var valueToValidate = value;\n  var valid = true;\n  if (valueToValidate === null || valueToValidate === void 0) {\n    valueToValidate = '';\n  }\n  var isValidFormat = moment(valueToValidate, this.dateFormat || dateEditor.defaultDateFormat, true).isValid();\n  var isValidDate = moment(new Date(valueToValidate)).isValid() || isValidFormat;\n  if (this.allowEmpty && valueToValidate === '') {\n    isValidDate = true;\n    isValidFormat = true;\n  }\n  if (!isValidDate) {\n    valid = false;\n  }\n  if (!isValidDate && isValidFormat) {\n    valid = true;\n  }\n  if (isValidDate && !isValidFormat) {\n    if (this.correctFormat === true) {\n      // if format correction is enabled\n      var correctedValue = correctFormat(valueToValidate, this.dateFormat);\n      var row = this.instance.toVisualRow(this.row);\n      var column = this.instance.toVisualColumn(this.col);\n      this.instance.setDataAtCell(row, column, correctedValue, 'dateValidator');\n      valid = true;\n    } else {\n      valid = false;\n    }\n  }\n  callback(valid);\n}\ndateValidator.VALIDATOR_TYPE = VALIDATOR_TYPE;\n/**\n * Format the given string using moment.js' format feature.\n *\n * @param {string} value The value to format.\n * @param {string} dateFormat The date pattern to format to.\n * @returns {string}\n */\n\nexport function correctFormat(value, dateFormat) {\n  var dateFromDate = moment(getNormalizedDate(value));\n  var dateFromMoment = moment(value, dateFormat);\n  var isAlphanumeric = value.search(/[A-z]/g) > -1;\n  var date;\n  if (dateFromDate.isValid() && dateFromDate.format('x') === dateFromMoment.format('x') || !dateFromMoment.isValid() || isAlphanumeric) {\n    date = dateFromDate;\n  } else {\n    date = dateFromMoment;\n  }\n  return date.format(dateFormat);\n}","map":{"version":3,"names":["moment","getEditorInstance","EDITOR_TYPE","DATE_EDITOR_TYPE","getNormalizedDate","VALIDATOR_TYPE","dateValidator","value","callback","dateEditor","instance","valueToValidate","valid","isValidFormat","dateFormat","defaultDateFormat","isValid","isValidDate","Date","allowEmpty","correctFormat","correctedValue","row","toVisualRow","column","toVisualColumn","col","setDataAtCell","dateFromDate","dateFromMoment","isAlphanumeric","search","date","format"],"sources":["/Users/priyadeliwala/Desktop/sales-dashboard/node_modules/handsontable/validators/dateValidator/dateValidator.mjs"],"sourcesContent":["import \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.search.js\";\nimport moment from 'moment';\nimport { getEditorInstance } from \"../../editors/registry.mjs\";\nimport { EDITOR_TYPE as DATE_EDITOR_TYPE } from \"../../editors/dateEditor/index.mjs\";\nimport { getNormalizedDate } from \"../../helpers/date.mjs\";\nexport var VALIDATOR_TYPE = 'date';\n/**\n * The Date cell validator.\n *\n * @private\n * @param {*} value Value of edited cell.\n * @param {Function} callback Callback called with validation result.\n */\n\nexport function dateValidator(value, callback) {\n  var dateEditor = getEditorInstance(DATE_EDITOR_TYPE, this.instance);\n  var valueToValidate = value;\n  var valid = true;\n\n  if (valueToValidate === null || valueToValidate === void 0) {\n    valueToValidate = '';\n  }\n\n  var isValidFormat = moment(valueToValidate, this.dateFormat || dateEditor.defaultDateFormat, true).isValid();\n  var isValidDate = moment(new Date(valueToValidate)).isValid() || isValidFormat;\n\n  if (this.allowEmpty && valueToValidate === '') {\n    isValidDate = true;\n    isValidFormat = true;\n  }\n\n  if (!isValidDate) {\n    valid = false;\n  }\n\n  if (!isValidDate && isValidFormat) {\n    valid = true;\n  }\n\n  if (isValidDate && !isValidFormat) {\n    if (this.correctFormat === true) {\n      // if format correction is enabled\n      var correctedValue = correctFormat(valueToValidate, this.dateFormat);\n      var row = this.instance.toVisualRow(this.row);\n      var column = this.instance.toVisualColumn(this.col);\n      this.instance.setDataAtCell(row, column, correctedValue, 'dateValidator');\n      valid = true;\n    } else {\n      valid = false;\n    }\n  }\n\n  callback(valid);\n}\ndateValidator.VALIDATOR_TYPE = VALIDATOR_TYPE;\n/**\n * Format the given string using moment.js' format feature.\n *\n * @param {string} value The value to format.\n * @param {string} dateFormat The date pattern to format to.\n * @returns {string}\n */\n\nexport function correctFormat(value, dateFormat) {\n  var dateFromDate = moment(getNormalizedDate(value));\n  var dateFromMoment = moment(value, dateFormat);\n  var isAlphanumeric = value.search(/[A-z]/g) > -1;\n  var date;\n\n  if (dateFromDate.isValid() && dateFromDate.format('x') === dateFromMoment.format('x') || !dateFromMoment.isValid() || isAlphanumeric) {\n    date = dateFromDate;\n  } else {\n    date = dateFromMoment;\n  }\n\n  return date.format(dateFormat);\n}"],"mappings":"AAEA,OAAOA,MAAM,MAAM,QAAQ;AAC3B,SAASC,iBAAiB,QAAQ,4BAA4B;AAC9D,SAASC,WAAW,IAAIC,gBAAgB,QAAQ,oCAAoC;AACpF,SAASC,iBAAiB,QAAQ,wBAAwB;AAC1D,OAAO,IAAIC,cAAc,GAAG,MAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASC,aAAaA,CAACC,KAAK,EAAEC,QAAQ,EAAE;EAC7C,IAAIC,UAAU,GAAGR,iBAAiB,CAACE,gBAAgB,EAAE,IAAI,CAACO,QAAQ,CAAC;EACnE,IAAIC,eAAe,GAAGJ,KAAK;EAC3B,IAAIK,KAAK,GAAG,IAAI;EAEhB,IAAID,eAAe,KAAK,IAAI,IAAIA,eAAe,KAAK,KAAK,CAAC,EAAE;IAC1DA,eAAe,GAAG,EAAE;EACtB;EAEA,IAAIE,aAAa,GAAGb,MAAM,CAACW,eAAe,EAAE,IAAI,CAACG,UAAU,IAAIL,UAAU,CAACM,iBAAiB,EAAE,IAAI,CAAC,CAACC,OAAO,CAAC,CAAC;EAC5G,IAAIC,WAAW,GAAGjB,MAAM,CAAC,IAAIkB,IAAI,CAACP,eAAe,CAAC,CAAC,CAACK,OAAO,CAAC,CAAC,IAAIH,aAAa;EAE9E,IAAI,IAAI,CAACM,UAAU,IAAIR,eAAe,KAAK,EAAE,EAAE;IAC7CM,WAAW,GAAG,IAAI;IAClBJ,aAAa,GAAG,IAAI;EACtB;EAEA,IAAI,CAACI,WAAW,EAAE;IAChBL,KAAK,GAAG,KAAK;EACf;EAEA,IAAI,CAACK,WAAW,IAAIJ,aAAa,EAAE;IACjCD,KAAK,GAAG,IAAI;EACd;EAEA,IAAIK,WAAW,IAAI,CAACJ,aAAa,EAAE;IACjC,IAAI,IAAI,CAACO,aAAa,KAAK,IAAI,EAAE;MAC/B;MACA,IAAIC,cAAc,GAAGD,aAAa,CAACT,eAAe,EAAE,IAAI,CAACG,UAAU,CAAC;MACpE,IAAIQ,GAAG,GAAG,IAAI,CAACZ,QAAQ,CAACa,WAAW,CAAC,IAAI,CAACD,GAAG,CAAC;MAC7C,IAAIE,MAAM,GAAG,IAAI,CAACd,QAAQ,CAACe,cAAc,CAAC,IAAI,CAACC,GAAG,CAAC;MACnD,IAAI,CAAChB,QAAQ,CAACiB,aAAa,CAACL,GAAG,EAAEE,MAAM,EAAEH,cAAc,EAAE,eAAe,CAAC;MACzET,KAAK,GAAG,IAAI;IACd,CAAC,MAAM;MACLA,KAAK,GAAG,KAAK;IACf;EACF;EAEAJ,QAAQ,CAACI,KAAK,CAAC;AACjB;AACAN,aAAa,CAACD,cAAc,GAAGA,cAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASe,aAAaA,CAACb,KAAK,EAAEO,UAAU,EAAE;EAC/C,IAAIc,YAAY,GAAG5B,MAAM,CAACI,iBAAiB,CAACG,KAAK,CAAC,CAAC;EACnD,IAAIsB,cAAc,GAAG7B,MAAM,CAACO,KAAK,EAAEO,UAAU,CAAC;EAC9C,IAAIgB,cAAc,GAAGvB,KAAK,CAACwB,MAAM,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;EAChD,IAAIC,IAAI;EAER,IAAIJ,YAAY,CAACZ,OAAO,CAAC,CAAC,IAAIY,YAAY,CAACK,MAAM,CAAC,GAAG,CAAC,KAAKJ,cAAc,CAACI,MAAM,CAAC,GAAG,CAAC,IAAI,CAACJ,cAAc,CAACb,OAAO,CAAC,CAAC,IAAIc,cAAc,EAAE;IACpIE,IAAI,GAAGJ,YAAY;EACrB,CAAC,MAAM;IACLI,IAAI,GAAGH,cAAc;EACvB;EAEA,OAAOG,IAAI,CAACC,MAAM,CAACnB,UAAU,CAAC;AAChC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}