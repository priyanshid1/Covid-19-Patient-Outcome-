{"ast":null,"code":"var _templateObject;\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction _taggedTemplateLiteral(strings, raw) {\n  if (!raw) {\n    raw = strings.slice(0);\n  }\n  return Object.freeze(Object.defineProperties(strings, {\n    raw: {\n      value: Object.freeze(raw)\n    }\n  }));\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nimport { isUndefined } from \"../../../helpers/mixed.mjs\";\nimport { warn } from \"../../../helpers/console.mjs\";\nimport { toSingleLine } from \"../../../helpers/templateLiteralTag.mjs\";\nimport { CellCoords } from \"../../../3rdparty/walkontable/src/index.mjs\";\n/**\n * Helper class for the row-move-related operations.\n *\n * @private\n * @class RowMoveController\n */\n\nvar RowMoveController = /*#__PURE__*/function () {\n  function RowMoveController(plugin) {\n    _classCallCheck(this, RowMoveController);\n\n    /**\n     * Reference to the Nested Rows plugin instance.\n     *\n     * @type {NestedRows}\n     */\n    this.plugin = plugin;\n    /**\n     * Reference to the Handsontable instance.\n     *\n     * @type {Handsontable.Core}\n     */\n\n    this.hot = plugin.hot;\n    /**\n     * Reference to the Data Manager class instance.\n     *\n     * @type {DataManager}\n     */\n\n    this.dataManager = plugin.dataManager;\n    /**\n     * Reference to the Collapsing UI class instance.\n     *\n     * @type {CollapsingUI}\n     */\n\n    this.collapsingUI = plugin.collapsingUI;\n  }\n  /**\n   * `beforeRowMove` hook callback.\n   *\n   * @param {Array} rows Array of visual row indexes to be moved.\n   * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements\n   *   will be placed after the moving action. To check the visualization of the final index, please take a look at\n   *   [documentation](@/guides/rows/row-moving.md).\n   * @param {undefined|number} dropIndex Visual row index, being a drop index for the moved rows. Points to where we\n   *   are going to drop the moved elements. To check visualization of drop index please take a look at\n   *   [documentation](@/guides/rows/row-moving.md).\n   * @param {boolean} movePossible Indicates if it's possible to move rows to the desired position.\n   * @fires Hooks#afterRowMove\n   * @returns {boolean}\n   */\n\n  _createClass(RowMoveController, [{\n    key: \"onBeforeRowMove\",\n    value: function onBeforeRowMove(rows, finalIndex, dropIndex, movePossible) {\n      var _this = this;\n      var improperUsage = this.displayAPICompatibilityWarning({\n        rows: rows,\n        finalIndex: finalIndex,\n        dropIndex: dropIndex,\n        movePossible: movePossible\n      });\n      if (improperUsage) {\n        return false;\n      }\n      this.movedToCollapsed = false;\n      var dropToLastRow = dropIndex === this.hot.countRows();\n      var physicalDropIndex = dropToLastRow ? this.hot.countSourceRows() : this.dataManager.translateTrimmedRow(dropIndex);\n      var allowMove = true;\n      var physicalStartIndexes = rows.map(function (rowIndex) {\n        // Don't do the logic for the rest of the rows, as it's bound to fail anyway.\n        if (!allowMove) {\n          return false;\n        }\n        var physicalRowIndex = _this.dataManager.translateTrimmedRow(rowIndex);\n        allowMove = _this.shouldAllowMoving(physicalRowIndex, physicalDropIndex);\n        return physicalRowIndex;\n      });\n      var willDataChange = physicalStartIndexes.indexOf(physicalDropIndex) === -1;\n      if (!allowMove || !willDataChange) {\n        return false;\n      }\n      var baseParent = this.getBaseParent(physicalStartIndexes);\n      var targetParent = this.getTargetParent(dropToLastRow, physicalDropIndex);\n      var sameParent = baseParent === targetParent;\n      this.movedToCollapsed = this.collapsingUI.areChildrenCollapsed(targetParent); // Stash the current state of collapsed rows\n\n      this.collapsingUI.collapsedRowsStash.stash();\n      this.shiftCollapsibleParentsLocations(physicalStartIndexes, physicalDropIndex, sameParent);\n      this.moveRows(physicalStartIndexes, physicalDropIndex, targetParent);\n      this.dataManager.rewriteCache();\n      this.moveCellsMeta(physicalStartIndexes, physicalDropIndex);\n      this.collapsingUI.collapsedRowsStash.applyStash(false); // TODO: Trying to mock real work of the `ManualRowMove` plugin. It was blocked by returning `false` below.\n\n      this.hot.runHooks('afterRowMove', rows, finalIndex, dropIndex, movePossible, movePossible && this.isRowOrderChanged(rows, finalIndex)); // Not necessary - added to keep compatibility with other plugins (namely: columnSummary).\n\n      this.hot.render();\n      this.selectCells(rows, dropIndex);\n      return false;\n    }\n    /**\n     * Display a `dragRows`/`moveRows` method compatibility warning if needed.\n     *\n     * @param {object} beforeMoveRowHookArgs A set of arguments from the `beforeMoveRow` hook.\n     * @returns {boolean} `true` if is a result of an improper usage of the moving API.\n     */\n  }, {\n    key: \"displayAPICompatibilityWarning\",\n    value: function displayAPICompatibilityWarning(beforeMoveRowHookArgs) {\n      var rows = beforeMoveRowHookArgs.rows,\n        finalIndex = beforeMoveRowHookArgs.finalIndex,\n        dropIndex = beforeMoveRowHookArgs.dropIndex,\n        movePossible = beforeMoveRowHookArgs.movePossible;\n      var shouldTerminate = false;\n      if (isUndefined(dropIndex)) {\n        warn(toSingleLine(_templateObject || (_templateObject = _taggedTemplateLiteral([\"Since version 8.0.0 of the Handsontable the 'moveRows' method isn't used for moving rows \\n      when the NestedRows plugin is enabled. Please use the 'dragRows' method instead.\"], [\"Since version 8.0.0 of the Handsontable the 'moveRows' method isn't used for moving rows\\\\x20\\n      when the NestedRows plugin is enabled. Please use the 'dragRows' method instead.\"])))); // TODO: Trying to mock real work of the `ManualRowMove` plugin. It was blocked by returning `false` below.\n\n        this.hot.runHooks('afterRowMove', rows, finalIndex, dropIndex, movePossible, false);\n        shouldTerminate = true;\n      }\n      return shouldTerminate;\n    }\n    /**\n     * Check if the moving action should be allowed.\n     *\n     * @param {number} physicalRowIndex Physical start row index.\n     * @param {number} physicalDropIndex Physical drop index.\n     * @returns {boolean} `true` if it should continue with the moving action.\n     */\n  }, {\n    key: \"shouldAllowMoving\",\n    value: function shouldAllowMoving(physicalRowIndex, physicalDropIndex) {\n      /*\n         We can't move rows when any of them is:\n         - a parent\n         - a top-level element\n         - is being moved to the top level\n         - is being moved to the position of any of the moved rows (not changing position)\n      */\n      return !(this.dataManager.isParent(physicalRowIndex) || this.dataManager.isRowHighestLevel(physicalRowIndex) || physicalRowIndex === physicalDropIndex || physicalDropIndex === 0);\n    }\n    /**\n     * Get the base row parent.\n     *\n     * @param {number} physicalStartIndexes Physical start row index.\n     * @returns {object|null} The base row parent.\n     */\n  }, {\n    key: \"getBaseParent\",\n    value: function getBaseParent(physicalStartIndexes) {\n      return this.dataManager.getRowParent(physicalStartIndexes[0]);\n    }\n    /**\n     * Get the target row parent.\n     *\n     * @param {boolean} dropToLastRow `true` if the row is moved to the last row of the table.\n     * @param {number} physicalDropIndex Physical drop row index.\n     * @returns {object|null} The target row parent.\n     */\n  }, {\n    key: \"getTargetParent\",\n    value: function getTargetParent(dropToLastRow, physicalDropIndex) {\n      var targetParent = this.dataManager.getRowParent(dropToLastRow ? physicalDropIndex - 1 : physicalDropIndex); // If we try to move an element to the place of a top-level parent, snap the element to the previous top-level\n      // parent's children instead\n\n      if (targetParent === null || targetParent === void 0) {\n        targetParent = this.dataManager.getRowParent(physicalDropIndex - 1);\n      }\n      return targetParent;\n    }\n    /**\n     * Shift the cached collapsible rows position according to the move action.\n     *\n     * @param {number[]} physicalStartIndexes Physical start row indexes.\n     * @param {number} physicalDropIndex Physical drop index.\n     * @param {boolean} sameParent `true` if the row's being moved between siblings of the same parent.\n     */\n  }, {\n    key: \"shiftCollapsibleParentsLocations\",\n    value: function shiftCollapsibleParentsLocations(physicalStartIndexes, physicalDropIndex, sameParent) {\n      if (!sameParent) {\n        if (Math.max.apply(Math, _toConsumableArray(physicalStartIndexes)) <= physicalDropIndex) {\n          this.collapsingUI.collapsedRowsStash.shiftStash(physicalStartIndexes[0], physicalDropIndex, -1 * physicalStartIndexes.length);\n        } else {\n          this.collapsingUI.collapsedRowsStash.shiftStash(physicalDropIndex, physicalStartIndexes[0], physicalStartIndexes.length);\n        }\n      }\n    }\n    /**\n     * Move the rows at the provided coordinates.\n     *\n     * @param {number[]} physicalStartIndexes Physical indexes of the rows about to be moved.\n     * @param {number} physicalDropIndex Physical drop index.\n     * @param {object} targetParent Parent of the destination row.\n     */\n  }, {\n    key: \"moveRows\",\n    value: function moveRows(physicalStartIndexes, physicalDropIndex, targetParent) {\n      var _this2 = this;\n      var moveToLastChild = physicalDropIndex === this.dataManager.getRowIndex(targetParent) + this.dataManager.countChildren(targetParent) + 1;\n      this.hot.batchRender(function () {\n        physicalStartIndexes.forEach(function (physicalStartIndex) {\n          _this2.dataManager.moveRow(physicalStartIndex, physicalDropIndex, _this2.movedToCollapsed, moveToLastChild);\n        });\n      });\n    }\n    /**\n     * Move the cell meta for multiple rows.\n     *\n     * @param {number[]} baseIndexes Array of indexes for the rows being moved.\n     * @param {number} targetIndex Index of the destination of the move.\n     */\n  }, {\n    key: \"moveCellsMeta\",\n    value: function moveCellsMeta(baseIndexes, targetIndex) {\n      var _this3 = this,\n        _this$hot;\n      var rowsOfMeta = [];\n      var movingDown = Math.max.apply(Math, _toConsumableArray(baseIndexes)) < targetIndex;\n      baseIndexes.forEach(function (baseIndex) {\n        rowsOfMeta.push(_this3.hot.getCellMetaAtRow(baseIndex));\n      });\n      this.hot.spliceCellsMeta(baseIndexes[0], baseIndexes.length);\n      (_this$hot = this.hot).spliceCellsMeta.apply(_this$hot, [targetIndex - (movingDown ? rowsOfMeta.length : 0), 0].concat(rowsOfMeta));\n    }\n    /**\n     * Select cells after the move.\n     *\n     * @param {Array} rows Array of visual row indexes to be moved.\n     * @param {undefined|number} dropIndex Visual row index, being a drop index for the moved rows. Points to where we\n     *   are going to drop the moved elements. To check visualization of drop index please take a look at\n     *   [documentation](@/guides/rows/row-moving.md).\n     */\n  }, {\n    key: \"selectCells\",\n    value: function selectCells(rows, dropIndex) {\n      var rowsLen = rows.length;\n      var startRow = 0;\n      var endRow = 0;\n      var selection = null;\n      var lastColIndex = null;\n      if (this.movedToCollapsed) {\n        var physicalDropIndex = null;\n        if (rows[rowsLen - 1] < dropIndex) {\n          physicalDropIndex = this.dataManager.translateTrimmedRow(dropIndex - rowsLen);\n        } else {\n          physicalDropIndex = this.dataManager.translateTrimmedRow(dropIndex);\n        }\n        var parentObject = this.dataManager.getRowParent(physicalDropIndex === null ? this.hot.countSourceRows() - 1 : physicalDropIndex - 1);\n        var parentIndex = this.dataManager.getRowIndex(parentObject);\n        startRow = this.dataManager.untranslateTrimmedRow(parentIndex);\n        endRow = startRow;\n      } else if (rows[rowsLen - 1] < dropIndex) {\n        endRow = dropIndex - 1;\n        startRow = endRow - rowsLen + 1;\n      } else {\n        startRow = dropIndex;\n        endRow = startRow + rowsLen - 1;\n      }\n      selection = this.hot.selection;\n      lastColIndex = this.hot.countCols() - 1;\n      selection.setRangeStart(new CellCoords(startRow, 0));\n      selection.setRangeEnd(new CellCoords(endRow, lastColIndex), true);\n    } // TODO: Reimplementation of function which is inside the `ManualRowMove` plugin.\n\n    /**\n     * Indicates if order of rows was changed.\n     *\n     * @param {Array} movedRows Array of visual row indexes to be moved.\n     * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements\n     *   will be placed after the moving action. To check the visualization of the final index, please take a look at\n     *   [documentation](@/guides/rows/row-moving.md).\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isRowOrderChanged\",\n    value: function isRowOrderChanged(movedRows, finalIndex) {\n      return movedRows.some(function (row, nrOfMovedElement) {\n        return row - nrOfMovedElement !== finalIndex;\n      });\n    }\n  }]);\n  return RowMoveController;\n}();\nexport { RowMoveController as default };","map":{"version":3,"names":["_templateObject","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","TypeError","o","minLen","_arrayLikeToArray","n","Object","prototype","toString","call","slice","constructor","name","Array","from","test","iter","Symbol","iterator","isArray","len","length","i","arr2","_taggedTemplateLiteral","strings","raw","freeze","defineProperties","value","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","isUndefined","warn","toSingleLine","CellCoords","RowMoveController","plugin","hot","dataManager","collapsingUI","onBeforeRowMove","rows","finalIndex","dropIndex","movePossible","_this","improperUsage","displayAPICompatibilityWarning","movedToCollapsed","dropToLastRow","countRows","physicalDropIndex","countSourceRows","translateTrimmedRow","allowMove","physicalStartIndexes","map","rowIndex","physicalRowIndex","shouldAllowMoving","willDataChange","indexOf","baseParent","getBaseParent","targetParent","getTargetParent","sameParent","areChildrenCollapsed","collapsedRowsStash","stash","shiftCollapsibleParentsLocations","moveRows","rewriteCache","moveCellsMeta","applyStash","runHooks","isRowOrderChanged","render","selectCells","beforeMoveRowHookArgs","shouldTerminate","isParent","isRowHighestLevel","getRowParent","Math","max","apply","shiftStash","_this2","moveToLastChild","getRowIndex","countChildren","batchRender","forEach","physicalStartIndex","moveRow","baseIndexes","targetIndex","_this3","_this$hot","rowsOfMeta","movingDown","baseIndex","push","getCellMetaAtRow","spliceCellsMeta","concat","rowsLen","startRow","endRow","selection","lastColIndex","parentObject","parentIndex","untranslateTrimmedRow","countCols","setRangeStart","setRangeEnd","movedRows","some","row","nrOfMovedElement","default"],"sources":["/Users/priyadeliwala/Desktop/sales-dashboard/node_modules/handsontable/plugins/nestedRows/utils/rowMoveController.mjs"],"sourcesContent":["import \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.object.freeze.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\n\nvar _templateObject;\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.concat.js\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nimport { isUndefined } from \"../../../helpers/mixed.mjs\";\nimport { warn } from \"../../../helpers/console.mjs\";\nimport { toSingleLine } from \"../../../helpers/templateLiteralTag.mjs\";\nimport { CellCoords } from \"../../../3rdparty/walkontable/src/index.mjs\";\n/**\n * Helper class for the row-move-related operations.\n *\n * @private\n * @class RowMoveController\n */\n\nvar RowMoveController = /*#__PURE__*/function () {\n  function RowMoveController(plugin) {\n    _classCallCheck(this, RowMoveController);\n\n    /**\n     * Reference to the Nested Rows plugin instance.\n     *\n     * @type {NestedRows}\n     */\n    this.plugin = plugin;\n    /**\n     * Reference to the Handsontable instance.\n     *\n     * @type {Handsontable.Core}\n     */\n\n    this.hot = plugin.hot;\n    /**\n     * Reference to the Data Manager class instance.\n     *\n     * @type {DataManager}\n     */\n\n    this.dataManager = plugin.dataManager;\n    /**\n     * Reference to the Collapsing UI class instance.\n     *\n     * @type {CollapsingUI}\n     */\n\n    this.collapsingUI = plugin.collapsingUI;\n  }\n  /**\n   * `beforeRowMove` hook callback.\n   *\n   * @param {Array} rows Array of visual row indexes to be moved.\n   * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements\n   *   will be placed after the moving action. To check the visualization of the final index, please take a look at\n   *   [documentation](@/guides/rows/row-moving.md).\n   * @param {undefined|number} dropIndex Visual row index, being a drop index for the moved rows. Points to where we\n   *   are going to drop the moved elements. To check visualization of drop index please take a look at\n   *   [documentation](@/guides/rows/row-moving.md).\n   * @param {boolean} movePossible Indicates if it's possible to move rows to the desired position.\n   * @fires Hooks#afterRowMove\n   * @returns {boolean}\n   */\n\n\n  _createClass(RowMoveController, [{\n    key: \"onBeforeRowMove\",\n    value: function onBeforeRowMove(rows, finalIndex, dropIndex, movePossible) {\n      var _this = this;\n\n      var improperUsage = this.displayAPICompatibilityWarning({\n        rows: rows,\n        finalIndex: finalIndex,\n        dropIndex: dropIndex,\n        movePossible: movePossible\n      });\n\n      if (improperUsage) {\n        return false;\n      }\n\n      this.movedToCollapsed = false;\n      var dropToLastRow = dropIndex === this.hot.countRows();\n      var physicalDropIndex = dropToLastRow ? this.hot.countSourceRows() : this.dataManager.translateTrimmedRow(dropIndex);\n      var allowMove = true;\n      var physicalStartIndexes = rows.map(function (rowIndex) {\n        // Don't do the logic for the rest of the rows, as it's bound to fail anyway.\n        if (!allowMove) {\n          return false;\n        }\n\n        var physicalRowIndex = _this.dataManager.translateTrimmedRow(rowIndex);\n\n        allowMove = _this.shouldAllowMoving(physicalRowIndex, physicalDropIndex);\n        return physicalRowIndex;\n      });\n      var willDataChange = physicalStartIndexes.indexOf(physicalDropIndex) === -1;\n\n      if (!allowMove || !willDataChange) {\n        return false;\n      }\n\n      var baseParent = this.getBaseParent(physicalStartIndexes);\n      var targetParent = this.getTargetParent(dropToLastRow, physicalDropIndex);\n      var sameParent = baseParent === targetParent;\n      this.movedToCollapsed = this.collapsingUI.areChildrenCollapsed(targetParent); // Stash the current state of collapsed rows\n\n      this.collapsingUI.collapsedRowsStash.stash();\n      this.shiftCollapsibleParentsLocations(physicalStartIndexes, physicalDropIndex, sameParent);\n      this.moveRows(physicalStartIndexes, physicalDropIndex, targetParent);\n      this.dataManager.rewriteCache();\n      this.moveCellsMeta(physicalStartIndexes, physicalDropIndex);\n      this.collapsingUI.collapsedRowsStash.applyStash(false); // TODO: Trying to mock real work of the `ManualRowMove` plugin. It was blocked by returning `false` below.\n\n      this.hot.runHooks('afterRowMove', rows, finalIndex, dropIndex, movePossible, movePossible && this.isRowOrderChanged(rows, finalIndex)); // Not necessary - added to keep compatibility with other plugins (namely: columnSummary).\n\n      this.hot.render();\n      this.selectCells(rows, dropIndex);\n      return false;\n    }\n    /**\n     * Display a `dragRows`/`moveRows` method compatibility warning if needed.\n     *\n     * @param {object} beforeMoveRowHookArgs A set of arguments from the `beforeMoveRow` hook.\n     * @returns {boolean} `true` if is a result of an improper usage of the moving API.\n     */\n\n  }, {\n    key: \"displayAPICompatibilityWarning\",\n    value: function displayAPICompatibilityWarning(beforeMoveRowHookArgs) {\n      var rows = beforeMoveRowHookArgs.rows,\n          finalIndex = beforeMoveRowHookArgs.finalIndex,\n          dropIndex = beforeMoveRowHookArgs.dropIndex,\n          movePossible = beforeMoveRowHookArgs.movePossible;\n      var shouldTerminate = false;\n\n      if (isUndefined(dropIndex)) {\n        warn(toSingleLine(_templateObject || (_templateObject = _taggedTemplateLiteral([\"Since version 8.0.0 of the Handsontable the 'moveRows' method isn't used for moving rows \\n      when the NestedRows plugin is enabled. Please use the 'dragRows' method instead.\"], [\"Since version 8.0.0 of the Handsontable the 'moveRows' method isn't used for moving rows\\\\x20\\n      when the NestedRows plugin is enabled. Please use the 'dragRows' method instead.\"])))); // TODO: Trying to mock real work of the `ManualRowMove` plugin. It was blocked by returning `false` below.\n\n        this.hot.runHooks('afterRowMove', rows, finalIndex, dropIndex, movePossible, false);\n        shouldTerminate = true;\n      }\n\n      return shouldTerminate;\n    }\n    /**\n     * Check if the moving action should be allowed.\n     *\n     * @param {number} physicalRowIndex Physical start row index.\n     * @param {number} physicalDropIndex Physical drop index.\n     * @returns {boolean} `true` if it should continue with the moving action.\n     */\n\n  }, {\n    key: \"shouldAllowMoving\",\n    value: function shouldAllowMoving(physicalRowIndex, physicalDropIndex) {\n      /*\n         We can't move rows when any of them is:\n         - a parent\n         - a top-level element\n         - is being moved to the top level\n         - is being moved to the position of any of the moved rows (not changing position)\n      */\n      return !(this.dataManager.isParent(physicalRowIndex) || this.dataManager.isRowHighestLevel(physicalRowIndex) || physicalRowIndex === physicalDropIndex || physicalDropIndex === 0);\n    }\n    /**\n     * Get the base row parent.\n     *\n     * @param {number} physicalStartIndexes Physical start row index.\n     * @returns {object|null} The base row parent.\n     */\n\n  }, {\n    key: \"getBaseParent\",\n    value: function getBaseParent(physicalStartIndexes) {\n      return this.dataManager.getRowParent(physicalStartIndexes[0]);\n    }\n    /**\n     * Get the target row parent.\n     *\n     * @param {boolean} dropToLastRow `true` if the row is moved to the last row of the table.\n     * @param {number} physicalDropIndex Physical drop row index.\n     * @returns {object|null} The target row parent.\n     */\n\n  }, {\n    key: \"getTargetParent\",\n    value: function getTargetParent(dropToLastRow, physicalDropIndex) {\n      var targetParent = this.dataManager.getRowParent(dropToLastRow ? physicalDropIndex - 1 : physicalDropIndex); // If we try to move an element to the place of a top-level parent, snap the element to the previous top-level\n      // parent's children instead\n\n      if (targetParent === null || targetParent === void 0) {\n        targetParent = this.dataManager.getRowParent(physicalDropIndex - 1);\n      }\n\n      return targetParent;\n    }\n    /**\n     * Shift the cached collapsible rows position according to the move action.\n     *\n     * @param {number[]} physicalStartIndexes Physical start row indexes.\n     * @param {number} physicalDropIndex Physical drop index.\n     * @param {boolean} sameParent `true` if the row's being moved between siblings of the same parent.\n     */\n\n  }, {\n    key: \"shiftCollapsibleParentsLocations\",\n    value: function shiftCollapsibleParentsLocations(physicalStartIndexes, physicalDropIndex, sameParent) {\n      if (!sameParent) {\n        if (Math.max.apply(Math, _toConsumableArray(physicalStartIndexes)) <= physicalDropIndex) {\n          this.collapsingUI.collapsedRowsStash.shiftStash(physicalStartIndexes[0], physicalDropIndex, -1 * physicalStartIndexes.length);\n        } else {\n          this.collapsingUI.collapsedRowsStash.shiftStash(physicalDropIndex, physicalStartIndexes[0], physicalStartIndexes.length);\n        }\n      }\n    }\n    /**\n     * Move the rows at the provided coordinates.\n     *\n     * @param {number[]} physicalStartIndexes Physical indexes of the rows about to be moved.\n     * @param {number} physicalDropIndex Physical drop index.\n     * @param {object} targetParent Parent of the destination row.\n     */\n\n  }, {\n    key: \"moveRows\",\n    value: function moveRows(physicalStartIndexes, physicalDropIndex, targetParent) {\n      var _this2 = this;\n\n      var moveToLastChild = physicalDropIndex === this.dataManager.getRowIndex(targetParent) + this.dataManager.countChildren(targetParent) + 1;\n      this.hot.batchRender(function () {\n        physicalStartIndexes.forEach(function (physicalStartIndex) {\n          _this2.dataManager.moveRow(physicalStartIndex, physicalDropIndex, _this2.movedToCollapsed, moveToLastChild);\n        });\n      });\n    }\n    /**\n     * Move the cell meta for multiple rows.\n     *\n     * @param {number[]} baseIndexes Array of indexes for the rows being moved.\n     * @param {number} targetIndex Index of the destination of the move.\n     */\n\n  }, {\n    key: \"moveCellsMeta\",\n    value: function moveCellsMeta(baseIndexes, targetIndex) {\n      var _this3 = this,\n          _this$hot;\n\n      var rowsOfMeta = [];\n      var movingDown = Math.max.apply(Math, _toConsumableArray(baseIndexes)) < targetIndex;\n      baseIndexes.forEach(function (baseIndex) {\n        rowsOfMeta.push(_this3.hot.getCellMetaAtRow(baseIndex));\n      });\n      this.hot.spliceCellsMeta(baseIndexes[0], baseIndexes.length);\n\n      (_this$hot = this.hot).spliceCellsMeta.apply(_this$hot, [targetIndex - (movingDown ? rowsOfMeta.length : 0), 0].concat(rowsOfMeta));\n    }\n    /**\n     * Select cells after the move.\n     *\n     * @param {Array} rows Array of visual row indexes to be moved.\n     * @param {undefined|number} dropIndex Visual row index, being a drop index for the moved rows. Points to where we\n     *   are going to drop the moved elements. To check visualization of drop index please take a look at\n     *   [documentation](@/guides/rows/row-moving.md).\n     */\n\n  }, {\n    key: \"selectCells\",\n    value: function selectCells(rows, dropIndex) {\n      var rowsLen = rows.length;\n      var startRow = 0;\n      var endRow = 0;\n      var selection = null;\n      var lastColIndex = null;\n\n      if (this.movedToCollapsed) {\n        var physicalDropIndex = null;\n\n        if (rows[rowsLen - 1] < dropIndex) {\n          physicalDropIndex = this.dataManager.translateTrimmedRow(dropIndex - rowsLen);\n        } else {\n          physicalDropIndex = this.dataManager.translateTrimmedRow(dropIndex);\n        }\n\n        var parentObject = this.dataManager.getRowParent(physicalDropIndex === null ? this.hot.countSourceRows() - 1 : physicalDropIndex - 1);\n        var parentIndex = this.dataManager.getRowIndex(parentObject);\n        startRow = this.dataManager.untranslateTrimmedRow(parentIndex);\n        endRow = startRow;\n      } else if (rows[rowsLen - 1] < dropIndex) {\n        endRow = dropIndex - 1;\n        startRow = endRow - rowsLen + 1;\n      } else {\n        startRow = dropIndex;\n        endRow = startRow + rowsLen - 1;\n      }\n\n      selection = this.hot.selection;\n      lastColIndex = this.hot.countCols() - 1;\n      selection.setRangeStart(new CellCoords(startRow, 0));\n      selection.setRangeEnd(new CellCoords(endRow, lastColIndex), true);\n    } // TODO: Reimplementation of function which is inside the `ManualRowMove` plugin.\n\n    /**\n     * Indicates if order of rows was changed.\n     *\n     * @param {Array} movedRows Array of visual row indexes to be moved.\n     * @param {number} finalIndex Visual row index, being a start index for the moved rows. Points to where the elements\n     *   will be placed after the moving action. To check the visualization of the final index, please take a look at\n     *   [documentation](@/guides/rows/row-moving.md).\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isRowOrderChanged\",\n    value: function isRowOrderChanged(movedRows, finalIndex) {\n      return movedRows.some(function (row, nrOfMovedElement) {\n        return row - nrOfMovedElement !== finalIndex;\n      });\n    }\n  }]);\n\n  return RowMoveController;\n}();\n\nexport { RowMoveController as default };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}