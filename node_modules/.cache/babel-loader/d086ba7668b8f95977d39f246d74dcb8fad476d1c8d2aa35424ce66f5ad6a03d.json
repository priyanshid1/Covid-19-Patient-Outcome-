{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _s, _e;\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n  return _arr;\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nimport \"core-js/modules/web.immediate.js\";\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nimport { addClass, empty, removeClass } from \"./helpers/dom/element.mjs\";\nimport { isFunction } from \"./helpers/function.mjs\";\nimport { isDefined, isUndefined, isRegExp, _injectProductInfo, isEmpty } from \"./helpers/mixed.mjs\";\nimport { isMobileBrowser, isIpadOS } from \"./helpers/browser.mjs\";\nimport EditorManager from \"./editorManager.mjs\";\nimport EventManager from \"./eventManager.mjs\";\nimport { deepClone, duckSchema, isObjectEqual, isObject, deepObjectSize, hasOwnProperty, createObjectPropListener, objectEach } from \"./helpers/object.mjs\";\nimport { arrayMap, arrayEach, arrayReduce, getDifferenceOfArrays, stringToArray, pivot } from \"./helpers/array.mjs\";\nimport { instanceToHTML } from \"./utils/parseTable.mjs\";\nimport { getPlugin, getPluginsNames } from \"./plugins/registry.mjs\";\nimport { getRenderer } from \"./renderers/registry.mjs\";\nimport { getValidator } from \"./validators/registry.mjs\";\nimport { randomString, toUpperCaseFirst } from \"./helpers/string.mjs\";\nimport { rangeEach, rangeEachReverse, isNumericLike } from \"./helpers/number.mjs\";\nimport TableView from \"./tableView.mjs\";\nimport DataSource from \"./dataSource.mjs\";\nimport { cellMethodLookupFactory, spreadsheetColumnLabel } from \"./helpers/data.mjs\";\nimport { IndexMapper } from \"./translations/index.mjs\";\nimport { registerAsRootInstance, hasValidParameter, isRootInstance } from \"./utils/rootInstance.mjs\";\nimport { CellCoords, ViewportColumnsCalculator } from \"./3rdparty/walkontable/src/index.mjs\";\nimport Hooks from \"./pluginHooks.mjs\";\nimport { hasLanguageDictionary, getValidLanguageCode, getTranslatedPhrase } from \"./i18n/registry.mjs\";\nimport { warnUserAboutLanguageRegistration, normalizeLanguageCode } from \"./i18n/utils.mjs\";\nimport { startObserving as keyStateStartObserving, stopObserving as keyStateStopObserving } from \"./utils/keyStateObserver.mjs\";\nimport { Selection } from \"./selection/index.mjs\";\nimport { MetaManager, DynamicCellMetaMod, replaceData } from \"./dataMap/index.mjs\";\nimport { createUniqueMap } from \"./utils/dataStructures/uniqueMap.mjs\";\nvar activeGuid = null;\n/* eslint-disable jsdoc/require-description-complete-sentence */\n\n/**\n * Handsontable constructor.\n *\n * @core\n * @class Core\n * @description\n *\n * The `Handsontable` class to which we refer as to `Core`, allows you to modify the grid's behavior by using one of the available public methods.\n *\n * ## How to call a method\n *\n * ```js\n * // First, let's contruct Handsontable\n * const hot = new Handsontable(document.getElementById('example'), options);\n *\n * // Then, let's use the setDataAtCell method\n * hot.setDataAtCell(0, 0, 'new value');\n * ```\n *\n * @param {HTMLElement} rootElement The element to which the Handsontable instance is injected.\n * @param {object} userSettings The user defined options.\n * @param {boolean} [rootInstanceSymbol=false] Indicates if the instance is root of all later instances created.\n */\n\nexport default function Core(rootElement, userSettings) {\n  var _this = this;\n  var rootInstanceSymbol = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var preventScrollingToCell = false;\n  var instance = this;\n  var eventManager = new EventManager(instance);\n  var datamap;\n  var dataSource;\n  var grid;\n  var editorManager;\n  var firstRun = true;\n  userSettings.language = getValidLanguageCode(userSettings.language);\n  var metaManager = new MetaManager(instance, userSettings, [DynamicCellMetaMod]);\n  var tableMeta = metaManager.getTableMeta();\n  var globalMeta = metaManager.getGlobalMeta();\n  var pluginsRegistry = createUniqueMap();\n  if (hasValidParameter(rootInstanceSymbol)) {\n    registerAsRootInstance(this);\n  } // TODO: check if references to DOM elements should be move to UI layer (Walkontable)\n\n  /**\n   * Reference to the container element.\n   *\n   * @private\n   * @type {HTMLElement}\n   */\n\n  this.rootElement = rootElement;\n  /**\n   * The nearest document over container.\n   *\n   * @private\n   * @type {Document}\n   */\n\n  this.rootDocument = rootElement.ownerDocument;\n  /**\n   * Window object over container's document.\n   *\n   * @private\n   * @type {Window}\n   */\n\n  this.rootWindow = this.rootDocument.defaultView;\n  /**\n   * A boolean to tell if the Handsontable has been fully destroyed. This is set to `true`\n   * after `afterDestroy` hook is called.\n   *\n   * @memberof Core#\n   * @member isDestroyed\n   * @type {boolean}\n   */\n\n  this.isDestroyed = false;\n  /**\n   * The counter determines how many times the render suspending was called. It allows\n   * tracking the nested suspending calls. For each render suspend resuming call the\n   * counter is decremented. The value equal to 0 means the render suspending feature\n   * is disabled.\n   *\n   * @private\n   * @type {number}\n   */\n\n  this.renderSuspendedCounter = 0;\n  /**\n   * The counter determines how many times the execution suspending was called. It allows\n   * tracking the nested suspending calls. For each execution suspend resuming call the\n   * counter is decremented. The value equal to 0 means the execution suspending feature\n   * is disabled.\n   *\n   * @private\n   * @type {number}\n   */\n\n  this.executionSuspendedCounter = 0;\n  keyStateStartObserving(this.rootDocument);\n  this.container = this.rootDocument.createElement('div');\n  this.renderCall = false;\n  rootElement.insertBefore(this.container, rootElement.firstChild);\n  if (isRootInstance(this)) {\n    _injectProductInfo(userSettings.licenseKey, rootElement);\n  }\n  this.guid = \"ht_\".concat(randomString()); // this is the namespace for global events\n\n  /**\n   * Instance of index mapper which is responsible for managing the column indexes.\n   *\n   * @memberof Core#\n   * @member columnIndexMapper\n   * @type {IndexMapper}\n   */\n\n  this.columnIndexMapper = new IndexMapper();\n  /**\n   * Instance of index mapper which is responsible for managing the row indexes.\n   *\n   * @memberof Core#\n   * @member rowIndexMapper\n   * @type {IndexMapper}\n   */\n\n  this.rowIndexMapper = new IndexMapper();\n  dataSource = new DataSource(instance);\n  if (!this.rootElement.id || this.rootElement.id.substring(0, 3) === 'ht_') {\n    this.rootElement.id = this.guid; // if root element does not have an id, assign a random id\n  }\n  var visualToRenderableCoords = function visualToRenderableCoords(coords) {\n    var visualRow = coords.row,\n      visualColumn = coords.col;\n    return new CellCoords(\n    // We just store indexes for rows and columns without headers.\n    visualRow >= 0 ? instance.rowIndexMapper.getRenderableFromVisualIndex(visualRow) : visualRow, visualColumn >= 0 ? instance.columnIndexMapper.getRenderableFromVisualIndex(visualColumn) : visualColumn);\n  };\n  var renderableToVisualCoords = function renderableToVisualCoords(coords) {\n    var renderableRow = coords.row,\n      renderableColumn = coords.col;\n    return new CellCoords(\n    // We just store indexes for rows and columns without headers.\n    renderableRow >= 0 ? instance.rowIndexMapper.getVisualFromRenderableIndex(renderableRow) : renderableRow, renderableColumn >= 0 ? instance.columnIndexMapper.getVisualFromRenderableIndex(renderableColumn) : renderableColumn // eslint-disable-line max-len\n    );\n  };\n  var selection = new Selection(tableMeta, {\n    countCols: function countCols() {\n      return instance.countCols();\n    },\n    countRows: function countRows() {\n      return instance.countRows();\n    },\n    propToCol: function propToCol(prop) {\n      return datamap.propToCol(prop);\n    },\n    isEditorOpened: function isEditorOpened() {\n      return instance.getActiveEditor() ? instance.getActiveEditor().isOpened() : false;\n    },\n    countColsTranslated: function countColsTranslated() {\n      return _this.view.countRenderableColumns();\n    },\n    countRowsTranslated: function countRowsTranslated() {\n      return _this.view.countRenderableRows();\n    },\n    visualToRenderableCoords: visualToRenderableCoords,\n    renderableToVisualCoords: renderableToVisualCoords,\n    isDisabledCellSelection: function isDisabledCellSelection(visualRow, visualColumn) {\n      return instance.getCellMeta(visualRow, visualColumn).disableVisualSelection;\n    }\n  });\n  this.selection = selection;\n  var onIndexMapperCacheUpdate = function onIndexMapperCacheUpdate(_ref) {\n    var hiddenIndexesChanged = _ref.hiddenIndexesChanged;\n    if (hiddenIndexesChanged) {\n      _this.selection.refresh();\n    }\n  };\n  this.columnIndexMapper.addLocalHook('cacheUpdated', onIndexMapperCacheUpdate);\n  this.rowIndexMapper.addLocalHook('cacheUpdated', onIndexMapperCacheUpdate);\n  this.selection.addLocalHook('beforeSetRangeStart', function (cellCoords) {\n    _this.runHooks('beforeSetRangeStart', cellCoords);\n  });\n  this.selection.addLocalHook('beforeSetRangeStartOnly', function (cellCoords) {\n    _this.runHooks('beforeSetRangeStartOnly', cellCoords);\n  });\n  this.selection.addLocalHook('beforeSetRangeEnd', function (cellCoords) {\n    _this.runHooks('beforeSetRangeEnd', cellCoords);\n    if (cellCoords.row < 0) {\n      cellCoords.row = _this.view.wt.wtTable.getFirstVisibleRow();\n    }\n    if (cellCoords.col < 0) {\n      cellCoords.col = _this.view.wt.wtTable.getFirstVisibleColumn();\n    }\n  });\n  this.selection.addLocalHook('afterSetRangeEnd', function (cellCoords) {\n    var preventScrolling = createObjectPropListener(false);\n    var selectionRange = _this.selection.getSelectedRange();\n    var _selectionRange$curre = selectionRange.current(),\n      from = _selectionRange$curre.from,\n      to = _selectionRange$curre.to;\n    var selectionLayerLevel = selectionRange.size() - 1;\n    _this.runHooks('afterSelection', from.row, from.col, to.row, to.col, preventScrolling, selectionLayerLevel);\n    _this.runHooks('afterSelectionByProp', from.row, instance.colToProp(from.col), to.row, instance.colToProp(to.col), preventScrolling, selectionLayerLevel); // eslint-disable-line max-len\n\n    var isSelectedByAnyHeader = _this.selection.isSelectedByAnyHeader();\n    var currentSelectedRange = _this.selection.selectedRange.current();\n    var scrollToCell = true;\n    if (preventScrollingToCell) {\n      scrollToCell = false;\n    }\n    if (preventScrolling.isTouched()) {\n      scrollToCell = !preventScrolling.value;\n    }\n    var isSelectedByRowHeader = _this.selection.isSelectedByRowHeader();\n    var isSelectedByColumnHeader = _this.selection.isSelectedByColumnHeader();\n    if (scrollToCell !== false) {\n      if (!isSelectedByAnyHeader) {\n        if (currentSelectedRange && !_this.selection.isMultiple()) {\n          _this.view.scrollViewport(visualToRenderableCoords(currentSelectedRange.from));\n        } else {\n          _this.view.scrollViewport(visualToRenderableCoords(cellCoords));\n        }\n      } else if (isSelectedByRowHeader) {\n        _this.view.scrollViewportVertically(instance.rowIndexMapper.getRenderableFromVisualIndex(cellCoords.row));\n      } else if (isSelectedByColumnHeader) {\n        _this.view.scrollViewportHorizontally(instance.columnIndexMapper.getRenderableFromVisualIndex(cellCoords.col));\n      }\n    } // @TODO: These CSS classes are no longer needed anymore. They are used only as a indicator of the selected\n    // rows/columns in the MergedCells plugin (via border.js#L520 in the walkontable module). After fixing\n    // the Border class this should be removed.\n\n    if (isSelectedByRowHeader && isSelectedByColumnHeader) {\n      addClass(_this.rootElement, ['ht__selection--rows', 'ht__selection--columns']);\n    } else if (isSelectedByRowHeader) {\n      removeClass(_this.rootElement, 'ht__selection--columns');\n      addClass(_this.rootElement, 'ht__selection--rows');\n    } else if (isSelectedByColumnHeader) {\n      removeClass(_this.rootElement, 'ht__selection--rows');\n      addClass(_this.rootElement, 'ht__selection--columns');\n    } else {\n      removeClass(_this.rootElement, ['ht__selection--rows', 'ht__selection--columns']);\n    }\n    _this._refreshBorders(null);\n  });\n  this.selection.addLocalHook('afterSelectionFinished', function (cellRanges) {\n    var selectionLayerLevel = cellRanges.length - 1;\n    var _cellRanges$selection = cellRanges[selectionLayerLevel],\n      from = _cellRanges$selection.from,\n      to = _cellRanges$selection.to;\n    _this.runHooks('afterSelectionEnd', from.row, from.col, to.row, to.col, selectionLayerLevel);\n    _this.runHooks('afterSelectionEndByProp', from.row, instance.colToProp(from.col), to.row, instance.colToProp(to.col), selectionLayerLevel);\n  });\n  this.selection.addLocalHook('afterIsMultipleSelection', function (isMultiple) {\n    var changedIsMultiple = _this.runHooks('afterIsMultipleSelection', isMultiple.value);\n    if (isMultiple.value) {\n      isMultiple.value = changedIsMultiple;\n    }\n  });\n  this.selection.addLocalHook('beforeModifyTransformStart', function (cellCoordsDelta) {\n    _this.runHooks('modifyTransformStart', cellCoordsDelta);\n  });\n  this.selection.addLocalHook('afterModifyTransformStart', function (coords, rowTransformDir, colTransformDir) {\n    _this.runHooks('afterModifyTransformStart', coords, rowTransformDir, colTransformDir);\n  });\n  this.selection.addLocalHook('beforeModifyTransformEnd', function (cellCoordsDelta) {\n    _this.runHooks('modifyTransformEnd', cellCoordsDelta);\n  });\n  this.selection.addLocalHook('afterModifyTransformEnd', function (coords, rowTransformDir, colTransformDir) {\n    _this.runHooks('afterModifyTransformEnd', coords, rowTransformDir, colTransformDir);\n  });\n  this.selection.addLocalHook('afterDeselect', function () {\n    editorManager.destroyEditor();\n    _this._refreshBorders();\n    removeClass(_this.rootElement, ['ht__selection--rows', 'ht__selection--columns']);\n    _this.runHooks('afterDeselect');\n  });\n  this.selection.addLocalHook('insertRowRequire', function (totalRows) {\n    _this.alter('insert_row', totalRows, 1, 'auto');\n  });\n  this.selection.addLocalHook('insertColRequire', function (totalCols) {\n    _this.alter('insert_col', totalCols, 1, 'auto');\n  });\n  grid = {\n    /**\n     * Inserts or removes rows and columns.\n     *\n     * @private\n     * @param {string} action Possible values: \"insert_row\", \"insert_col\", \"remove_row\", \"remove_col\".\n     * @param {number|Array} index Row or column visual index which from the alter action will be triggered.\n     *                             Alter actions such as \"remove_row\" and \"remove_col\" support array indexes in the\n     *                             format `[[index, amount], [index, amount]...]` this can be used to remove\n     *                             non-consecutive columns or rows in one call.\n     * @param {number} [amount=1] Ammount rows or columns to remove.\n     * @param {string} [source] Optional. Source of hook runner.\n     * @param {boolean} [keepEmptyRows] Optional. Flag for preventing deletion of empty rows.\n     */\n    alter: function alter(action, index) {\n      var amount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      var source = arguments.length > 3 ? arguments[3] : undefined;\n      var keepEmptyRows = arguments.length > 4 ? arguments[4] : undefined;\n      var delta;\n      var normalizeIndexesGroup = function normalizeIndexesGroup(indexes) {\n        if (indexes.length === 0) {\n          return [];\n        }\n        var sortedIndexes = _toConsumableArray(indexes); // Sort the indexes in ascending order.\n\n        sortedIndexes.sort(function (_ref2, _ref3) {\n          var _ref4 = _slicedToArray(_ref2, 1),\n            indexA = _ref4[0];\n          var _ref5 = _slicedToArray(_ref3, 1),\n            indexB = _ref5[0];\n          if (indexA === indexB) {\n            return 0;\n          }\n          return indexA > indexB ? 1 : -1;\n        }); // Normalize the {index, amount} groups into bigger groups.\n\n        var normalizedIndexes = arrayReduce(sortedIndexes, function (acc, _ref6) {\n          var _ref7 = _slicedToArray(_ref6, 2),\n            groupIndex = _ref7[0],\n            groupAmount = _ref7[1];\n          var previousItem = acc[acc.length - 1];\n          var _previousItem = _slicedToArray(previousItem, 2),\n            prevIndex = _previousItem[0],\n            prevAmount = _previousItem[1];\n          var prevLastIndex = prevIndex + prevAmount;\n          if (groupIndex <= prevLastIndex) {\n            var amountToAdd = Math.max(groupAmount - (prevLastIndex - groupIndex), 0);\n            previousItem[1] += amountToAdd;\n          } else {\n            acc.push([groupIndex, groupAmount]);\n          }\n          return acc;\n        }, [sortedIndexes[0]]);\n        return normalizedIndexes;\n      };\n      /* eslint-disable no-case-declarations */\n\n      switch (action) {\n        case 'insert_row':\n          var numberOfSourceRows = instance.countSourceRows();\n          if (tableMeta.maxRows === numberOfSourceRows) {\n            return;\n          } // eslint-disable-next-line no-param-reassign\n\n          index = isDefined(index) ? index : numberOfSourceRows;\n          delta = datamap.createRow(index, amount, source);\n          if (delta) {\n            metaManager.createRow(instance.toPhysicalRow(index), amount);\n            var currentSelectedRange = selection.selectedRange.current();\n            var currentFromRange = currentSelectedRange === null || currentSelectedRange === void 0 ? void 0 : currentSelectedRange.from;\n            var currentFromRow = currentFromRange === null || currentFromRange === void 0 ? void 0 : currentFromRange.row; // Moving down the selection (when it exist). It should be present on the \"old\" row.\n            // TODO: The logic here should be handled by selection module.\n\n            if (isDefined(currentFromRow) && currentFromRow >= index) {\n              var _currentSelectedRange = currentSelectedRange.to,\n                currentToRow = _currentSelectedRange.row,\n                currentToColumn = _currentSelectedRange.col;\n              var currentFromColumn = currentFromRange.col; // Workaround: headers are not stored inside selection.\n\n              if (selection.isSelectedByRowHeader()) {\n                currentFromColumn = -1;\n              } // Remove from the stack the last added selection as that selection below will be\n              // replaced by new transformed selection.\n\n              selection.getSelectedRange().pop(); // I can't use transforms as they don't work in negative indexes.\n\n              selection.setRangeStartOnly(new CellCoords(currentFromRow + delta, currentFromColumn), true);\n              selection.setRangeEnd(new CellCoords(currentToRow + delta, currentToColumn)); // will call render() internally\n            } else {\n              instance._refreshBorders(); // it will call render and prepare methods\n            }\n          }\n          break;\n        case 'insert_col':\n          delta = datamap.createCol(index, amount, source);\n          if (delta) {\n            metaManager.createColumn(instance.toPhysicalColumn(index), amount);\n            if (Array.isArray(tableMeta.colHeaders)) {\n              var spliceArray = [index, 0];\n              spliceArray.length += delta; // inserts empty (undefined) elements at the end of an array\n\n              Array.prototype.splice.apply(tableMeta.colHeaders, spliceArray); // inserts empty (undefined) elements into the colHeader array\n            }\n            var _currentSelectedRange2 = selection.selectedRange.current();\n            var _currentFromRange = _currentSelectedRange2 === null || _currentSelectedRange2 === void 0 ? void 0 : _currentSelectedRange2.from;\n            var _currentFromColumn = _currentFromRange === null || _currentFromRange === void 0 ? void 0 : _currentFromRange.col; // Moving right the selection (when it exist). It should be present on the \"old\" row.\n            // TODO: The logic here should be handled by selection module.\n\n            if (isDefined(_currentFromColumn) && _currentFromColumn >= index) {\n              var _currentSelectedRange3 = _currentSelectedRange2.to,\n                _currentToRow = _currentSelectedRange3.row,\n                _currentToColumn = _currentSelectedRange3.col;\n              var _currentFromRow = _currentFromRange.row; // Workaround: headers are not stored inside selection.\n\n              if (selection.isSelectedByColumnHeader()) {\n                _currentFromRow = -1;\n              } // Remove from the stack the last added selection as that selection below will be\n              // replaced by new transformed selection.\n\n              selection.getSelectedRange().pop(); // I can't use transforms as they don't work in negative indexes.\n\n              selection.setRangeStartOnly(new CellCoords(_currentFromRow, _currentFromColumn + delta), true);\n              selection.setRangeEnd(new CellCoords(_currentToRow, _currentToColumn + delta)); // will call render() internally\n            } else {\n              instance._refreshBorders(); // it will call render and prepare methods\n            }\n          }\n          break;\n        case 'remove_row':\n          var removeRow = function removeRow(indexes) {\n            var offset = 0; // Normalize the {index, amount} groups into bigger groups.\n\n            arrayEach(indexes, function (_ref8) {\n              var _ref9 = _slicedToArray(_ref8, 2),\n                groupIndex = _ref9[0],\n                groupAmount = _ref9[1];\n              var calcIndex = isEmpty(groupIndex) ? instance.countRows() - 1 : Math.max(groupIndex - offset, 0); // If the 'index' is an integer decrease it by 'offset' otherwise pass it through to make the value\n              // compatible with datamap.removeCol method.\n\n              if (Number.isInteger(groupIndex)) {\n                // eslint-disable-next-line no-param-reassign\n                groupIndex = Math.max(groupIndex - offset, 0);\n              } // TODO: for datamap.removeRow index should be passed as it is (with undefined and null values). If not, the logic\n              // inside the datamap.removeRow breaks the removing functionality.\n\n              var wasRemoved = datamap.removeRow(groupIndex, groupAmount, source);\n              if (!wasRemoved) {\n                return;\n              }\n              metaManager.removeRow(instance.toPhysicalRow(calcIndex), groupAmount);\n              var totalRows = instance.countRows();\n              var fixedRowsTop = tableMeta.fixedRowsTop;\n              if (fixedRowsTop >= calcIndex + 1) {\n                tableMeta.fixedRowsTop -= Math.min(groupAmount, fixedRowsTop - calcIndex);\n              }\n              var fixedRowsBottom = tableMeta.fixedRowsBottom;\n              if (fixedRowsBottom && calcIndex >= totalRows - fixedRowsBottom) {\n                tableMeta.fixedRowsBottom -= Math.min(groupAmount, fixedRowsBottom);\n              }\n              offset += groupAmount;\n            });\n          };\n          if (Array.isArray(index)) {\n            removeRow(normalizeIndexesGroup(index));\n          } else {\n            removeRow([[index, amount]]);\n          }\n          grid.adjustRowsAndCols();\n          instance._refreshBorders(); // it will call render and prepare methods\n\n          break;\n        case 'remove_col':\n          var removeCol = function removeCol(indexes) {\n            var offset = 0; // Normalize the {index, amount} groups into bigger groups.\n\n            arrayEach(indexes, function (_ref10) {\n              var _ref11 = _slicedToArray(_ref10, 2),\n                groupIndex = _ref11[0],\n                groupAmount = _ref11[1];\n              var calcIndex = isEmpty(groupIndex) ? instance.countCols() - 1 : Math.max(groupIndex - offset, 0);\n              var physicalColumnIndex = instance.toPhysicalColumn(calcIndex); // If the 'index' is an integer decrease it by 'offset' otherwise pass it through to make the value\n              // compatible with datamap.removeCol method.\n\n              if (Number.isInteger(groupIndex)) {\n                // eslint-disable-next-line no-param-reassign\n                groupIndex = Math.max(groupIndex - offset, 0);\n              } // TODO: for datamap.removeCol index should be passed as it is (with undefined and null values). If not, the logic\n              // inside the datamap.removeCol breaks the removing functionality.\n\n              var wasRemoved = datamap.removeCol(groupIndex, groupAmount, source);\n              if (!wasRemoved) {\n                return;\n              }\n              metaManager.removeColumn(physicalColumnIndex, groupAmount);\n              var fixedColumnsLeft = tableMeta.fixedColumnsLeft;\n              if (fixedColumnsLeft >= calcIndex + 1) {\n                tableMeta.fixedColumnsLeft -= Math.min(groupAmount, fixedColumnsLeft - calcIndex);\n              }\n              if (Array.isArray(tableMeta.colHeaders)) {\n                if (typeof physicalColumnIndex === 'undefined') {\n                  physicalColumnIndex = -1;\n                }\n                tableMeta.colHeaders.splice(physicalColumnIndex, groupAmount);\n              }\n              offset += groupAmount;\n            });\n          };\n          if (Array.isArray(index)) {\n            removeCol(normalizeIndexesGroup(index));\n          } else {\n            removeCol([[index, amount]]);\n          }\n          grid.adjustRowsAndCols();\n          instance._refreshBorders(); // it will call render and prepare methods\n\n          break;\n        default:\n          throw new Error(\"There is no such action \\\"\".concat(action, \"\\\"\"));\n      }\n      if (!keepEmptyRows) {\n        grid.adjustRowsAndCols(); // makes sure that we did not add rows that will be removed in next refresh\n      }\n    },\n    /**\n     * Makes sure there are empty rows at the bottom of the table.\n     *\n     * @private\n     */\n    adjustRowsAndCols: function adjustRowsAndCols() {\n      var minRows = tableMeta.minRows;\n      var minSpareRows = tableMeta.minSpareRows;\n      var minCols = tableMeta.minCols;\n      var minSpareCols = tableMeta.minSpareCols;\n      if (minRows) {\n        // should I add empty rows to data source to meet minRows?\n        var nrOfRows = instance.countRows();\n        if (nrOfRows < minRows) {\n          // The synchronization with cell meta is not desired here. For `minRows` option,\n          // we don't want to touch/shift cell meta objects.\n          datamap.createRow(nrOfRows, minRows - nrOfRows, 'auto');\n        }\n      }\n      if (minSpareRows) {\n        var emptyRows = instance.countEmptyRows(true); // should I add empty rows to meet minSpareRows?\n\n        if (emptyRows < minSpareRows) {\n          var emptyRowsMissing = minSpareRows - emptyRows;\n          var rowsToCreate = Math.min(emptyRowsMissing, tableMeta.maxRows - instance.countSourceRows()); // The synchronization with cell meta is not desired here. For `minSpareRows` option,\n          // we don't want to touch/shift cell meta objects.\n\n          datamap.createRow(instance.countRows(), rowsToCreate, 'auto');\n        }\n      }\n      {\n        var emptyCols; // count currently empty cols\n\n        if (minCols || minSpareCols) {\n          emptyCols = instance.countEmptyCols(true);\n        }\n        var nrOfColumns = instance.countCols(); // should I add empty cols to meet minCols?\n\n        if (minCols && !tableMeta.columns && nrOfColumns < minCols) {\n          // The synchronization with cell meta is not desired here. For `minSpareRows` option,\n          // we don't want to touch/shift cell meta objects.\n          var colsToCreate = minCols - nrOfColumns;\n          emptyCols += colsToCreate;\n          datamap.createCol(nrOfColumns, colsToCreate, 'auto');\n        } // should I add empty cols to meet minSpareCols?\n\n        if (minSpareCols && !tableMeta.columns && instance.dataType === 'array' && emptyCols < minSpareCols) {\n          nrOfColumns = instance.countCols();\n          var emptyColsMissing = minSpareCols - emptyCols;\n          var _colsToCreate = Math.min(emptyColsMissing, tableMeta.maxCols - nrOfColumns); // The synchronization with cell meta is not desired here. For `minSpareRows` option,\n          // we don't want to touch/shift cell meta objects.\n\n          datamap.createCol(nrOfColumns, _colsToCreate, 'auto');\n        }\n      }\n      var rowCount = instance.countRows();\n      var colCount = instance.countCols();\n      if (rowCount === 0 || colCount === 0) {\n        selection.deselect();\n      }\n      if (selection.isSelected()) {\n        arrayEach(selection.selectedRange, function (range) {\n          var selectionChanged = false;\n          var fromRow = range.from.row;\n          var fromCol = range.from.col;\n          var toRow = range.to.row;\n          var toCol = range.to.col; // if selection is outside, move selection to last row\n\n          if (fromRow > rowCount - 1) {\n            fromRow = rowCount - 1;\n            selectionChanged = true;\n            if (toRow > fromRow) {\n              toRow = fromRow;\n            }\n          } else if (toRow > rowCount - 1) {\n            toRow = rowCount - 1;\n            selectionChanged = true;\n            if (fromRow > toRow) {\n              fromRow = toRow;\n            }\n          } // if selection is outside, move selection to last row\n\n          if (fromCol > colCount - 1) {\n            fromCol = colCount - 1;\n            selectionChanged = true;\n            if (toCol > fromCol) {\n              toCol = fromCol;\n            }\n          } else if (toCol > colCount - 1) {\n            toCol = colCount - 1;\n            selectionChanged = true;\n            if (fromCol > toCol) {\n              fromCol = toCol;\n            }\n          }\n          if (selectionChanged) {\n            instance.selectCell(fromRow, fromCol, toRow, toCol);\n          }\n        });\n      }\n      if (instance.view) {\n        instance.view.adjustElementsSize();\n      }\n    },\n    /**\n     * Populate the data from the provided 2d array from the given cell coordinates.\n     *\n     * @private\n     * @param {object} start Start selection position. Visual indexes.\n     * @param {Array} input 2d data array.\n     * @param {object} [end] End selection position (only for drag-down mode). Visual indexes.\n     * @param {string} [source=\"populateFromArray\"] Source information string.\n     * @param {string} [method=\"overwrite\"] Populate method. Possible options: `shift_down`, `shift_right`, `overwrite`.\n     * @param {string} direction (left|right|up|down) String specifying the direction.\n     * @param {Array} deltas The deltas array. A difference between values of adjacent cells.\n     *                       Useful **only** when the type of handled cells is `numeric`.\n     * @returns {object|undefined} Ending td in pasted area (only if any cell was changed).\n     */\n    populateFromArray: function populateFromArray(start, input, end, source, method, direction, deltas) {\n      // TODO: either remove or implement the `direction` argument. Currently it's not working at all.\n      var r;\n      var rlen;\n      var c;\n      var clen;\n      var setData = [];\n      var current = {};\n      var newDataByColumns = [];\n      var startRow = start.row;\n      var startColumn = start.col;\n      rlen = input.length;\n      if (rlen === 0) {\n        return false;\n      }\n      var columnsPopulationEnd = 0;\n      var rowsPopulationEnd = 0;\n      if (isObject(end)) {\n        columnsPopulationEnd = end.col - startColumn + 1;\n        rowsPopulationEnd = end.row - startRow + 1;\n      } // insert data with specified pasteMode method\n\n      switch (method) {\n        case 'shift_down':\n          // translate data from a list of rows to a list of columns\n          var populatedDataByColumns = pivot(input);\n          var numberOfDataColumns = populatedDataByColumns.length; // method's argument can extend the range of data population (data would be repeated)\n\n          var numberOfColumnsToPopulate = Math.max(numberOfDataColumns, columnsPopulationEnd);\n          var pushedDownDataByRows = instance.getData().slice(startRow); // translate data from a list of rows to a list of columns\n\n          var pushedDownDataByColumns = pivot(pushedDownDataByRows).slice(startColumn, startColumn + numberOfColumnsToPopulate);\n          for (c = 0; c < numberOfColumnsToPopulate; c += 1) {\n            if (c < numberOfDataColumns) {\n              for (r = 0, rlen = populatedDataByColumns[c].length; r < rowsPopulationEnd - rlen; r += 1) {\n                // repeating data for rows\n                populatedDataByColumns[c].push(populatedDataByColumns[c][r % rlen]);\n              }\n              if (c < pushedDownDataByColumns.length) {\n                newDataByColumns.push(populatedDataByColumns[c].concat(pushedDownDataByColumns[c]));\n              } else {\n                // if before data population, there was no data in the column\n                // we fill the required rows' newly-created cells with `null` values\n                newDataByColumns.push(populatedDataByColumns[c].concat(new Array(pushedDownDataByRows.length).fill(null)));\n              }\n            } else {\n              // Repeating data for columns.\n              newDataByColumns.push(populatedDataByColumns[c % numberOfDataColumns].concat(pushedDownDataByColumns[c]));\n            }\n          }\n          instance.populateFromArray(startRow, startColumn, pivot(newDataByColumns));\n          break;\n        case 'shift_right':\n          var numberOfDataRows = input.length; // method's argument can extend the range of data population (data would be repeated)\n\n          var numberOfRowsToPopulate = Math.max(numberOfDataRows, rowsPopulationEnd);\n          var pushedRightDataByRows = instance.getData().slice(startRow).map(function (rowData) {\n            return rowData.slice(startColumn);\n          });\n          for (r = 0; r < numberOfRowsToPopulate; r += 1) {\n            if (r < numberOfDataRows) {\n              for (c = 0, clen = input[r].length; c < columnsPopulationEnd - clen; c += 1) {\n                // repeating data for rows\n                input[r].push(input[r][c % clen]);\n              }\n              if (r < pushedRightDataByRows.length) {\n                for (var i = 0; i < pushedRightDataByRows[r].length; i += 1) {\n                  input[r].push(pushedRightDataByRows[r][i]);\n                }\n              } else {\n                var _input$r;\n\n                // if before data population, there was no data in the row\n                // we fill the required columns' newly-created cells with `null` values\n                (_input$r = input[r]).push.apply(_input$r, _toConsumableArray(new Array(pushedRightDataByRows[0].length).fill(null)));\n              }\n            } else {\n              // Repeating data for columns.\n              input.push(input[r % rlen].slice(0, numberOfRowsToPopulate).concat(pushedRightDataByRows[r]));\n            }\n          }\n          instance.populateFromArray(startRow, startColumn, input);\n          break;\n        case 'overwrite':\n        default:\n          // overwrite and other not specified options\n          current.row = start.row;\n          current.col = start.col;\n          var selected = {\n            // selected range\n            row: end && start ? end.row - start.row + 1 : 1,\n            col: end && start ? end.col - start.col + 1 : 1\n          };\n          var skippedRow = 0;\n          var skippedColumn = 0;\n          var pushData = true;\n          var cellMeta;\n          var getInputValue = function getInputValue(row) {\n            var col = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n            var rowValue = input[row % input.length];\n            if (col !== null) {\n              return rowValue[col % rowValue.length];\n            }\n            return rowValue;\n          };\n          var rowInputLength = input.length;\n          var rowSelectionLength = end ? end.row - start.row + 1 : 0;\n          if (end) {\n            rlen = rowSelectionLength;\n          } else {\n            rlen = Math.max(rowInputLength, rowSelectionLength);\n          }\n          for (r = 0; r < rlen; r++) {\n            if (end && current.row > end.row && rowSelectionLength > rowInputLength || !tableMeta.allowInsertRow && current.row > instance.countRows() - 1 || current.row >= tableMeta.maxRows) {\n              break;\n            }\n            var visualRow = r - skippedRow;\n            var colInputLength = getInputValue(visualRow).length;\n            var colSelectionLength = end ? end.col - start.col + 1 : 0;\n            if (end) {\n              clen = colSelectionLength;\n            } else {\n              clen = Math.max(colInputLength, colSelectionLength);\n            }\n            current.col = start.col;\n            cellMeta = instance.getCellMeta(current.row, current.col);\n            if ((source === 'CopyPaste.paste' || source === 'Autofill.fill') && cellMeta.skipRowOnPaste) {\n              skippedRow += 1;\n              current.row += 1;\n              rlen += 1;\n              /* eslint-disable no-continue */\n\n              continue;\n            }\n            skippedColumn = 0;\n            for (c = 0; c < clen; c++) {\n              if (end && current.col > end.col && colSelectionLength > colInputLength || !tableMeta.allowInsertColumn && current.col > instance.countCols() - 1 || current.col >= tableMeta.maxCols) {\n                break;\n              }\n              cellMeta = instance.getCellMeta(current.row, current.col);\n              if ((source === 'CopyPaste.paste' || source === 'Autofill.fill') && cellMeta.skipColumnOnPaste) {\n                skippedColumn += 1;\n                current.col += 1;\n                clen += 1;\n                continue;\n              }\n              if (cellMeta.readOnly && source !== 'UndoRedo.undo') {\n                current.col += 1;\n                /* eslint-disable no-continue */\n\n                continue;\n              }\n              var visualColumn = c - skippedColumn;\n              var value = getInputValue(visualRow, visualColumn);\n              var orgValue = instance.getDataAtCell(current.row, current.col);\n              var index = {\n                row: visualRow,\n                col: visualColumn\n              };\n              if (source === 'Autofill.fill') {\n                var result = instance.runHooks('beforeAutofillInsidePopulate', index, direction, input, deltas, {}, selected);\n                if (result) {\n                  value = isUndefined(result.value) ? value : result.value;\n                }\n              }\n              if (value !== null && _typeof(value) === 'object') {\n                // when 'value' is array and 'orgValue' is null, set 'orgValue' to\n                // an empty array so that the null value can be compared to 'value'\n                // as an empty value for the array context\n                if (Array.isArray(value) && orgValue === null) orgValue = [];\n                if (orgValue === null || _typeof(orgValue) !== 'object') {\n                  pushData = false;\n                } else {\n                  var orgValueSchema = duckSchema(Array.isArray(orgValue) ? orgValue : orgValue[0] || orgValue);\n                  var valueSchema = duckSchema(Array.isArray(value) ? value : value[0] || value);\n                  /* eslint-disable max-depth */\n\n                  if (isObjectEqual(orgValueSchema, valueSchema)) {\n                    value = deepClone(value);\n                  } else {\n                    pushData = false;\n                  }\n                }\n              } else if (orgValue !== null && _typeof(orgValue) === 'object') {\n                pushData = false;\n              }\n              if (pushData) {\n                setData.push([current.row, current.col, value]);\n              }\n              pushData = true;\n              current.col += 1;\n            }\n            current.row += 1;\n          }\n          instance.setDataAtCell(setData, null, null, source || 'populateFromArray');\n          break;\n      }\n    }\n  };\n  /**\n   * Internal function to set `language` key of settings.\n   *\n   * @private\n   * @param {string} languageCode Language code for specific language i.e. 'en-US', 'pt-BR', 'de-DE'.\n   * @fires Hooks#afterLanguageChange\n   */\n\n  function setLanguage(languageCode) {\n    var normalizedLanguageCode = normalizeLanguageCode(languageCode);\n    if (hasLanguageDictionary(normalizedLanguageCode)) {\n      instance.runHooks('beforeLanguageChange', normalizedLanguageCode);\n      globalMeta.language = normalizedLanguageCode;\n      instance.runHooks('afterLanguageChange', normalizedLanguageCode);\n    } else {\n      warnUserAboutLanguageRegistration(languageCode);\n    }\n  }\n  /**\n   * Internal function to set `className` or `tableClassName`, depending on the key from the settings object.\n   *\n   * @private\n   * @param {string} className `className` or `tableClassName` from the key in the settings object.\n   * @param {string|string[]} classSettings String or array of strings. Contains class name(s) from settings object.\n   */\n\n  function setClassName(className, classSettings) {\n    var element = className === 'className' ? instance.rootElement : instance.table;\n    if (firstRun) {\n      addClass(element, classSettings);\n    } else {\n      var globalMetaSettingsArray = [];\n      var settingsArray = [];\n      if (globalMeta[className]) {\n        globalMetaSettingsArray = Array.isArray(globalMeta[className]) ? globalMeta[className] : stringToArray(globalMeta[className]);\n      }\n      if (classSettings) {\n        settingsArray = Array.isArray(classSettings) ? classSettings : stringToArray(classSettings);\n      }\n      var classNameToRemove = getDifferenceOfArrays(globalMetaSettingsArray, settingsArray);\n      var classNameToAdd = getDifferenceOfArrays(settingsArray, globalMetaSettingsArray);\n      if (classNameToRemove.length) {\n        removeClass(element, classNameToRemove);\n      }\n      if (classNameToAdd.length) {\n        addClass(element, classNameToAdd);\n      }\n    }\n    globalMeta[className] = classSettings;\n  }\n  this.init = function () {\n    dataSource.setData(tableMeta.data);\n    instance.runHooks('beforeInit');\n    if (isMobileBrowser() || isIpadOS()) {\n      addClass(instance.rootElement, 'mobile');\n    }\n    this.updateSettings(tableMeta, true);\n    this.view = new TableView(this);\n    editorManager = EditorManager.getInstance(instance, tableMeta, selection);\n    instance.runHooks('init');\n    this.forceFullRender = true; // used when data was changed\n\n    this.view.render();\n    if (_typeof(firstRun) === 'object') {\n      instance.runHooks('afterChange', firstRun[0], firstRun[1]);\n      firstRun = false;\n    }\n    instance.runHooks('afterInit');\n  };\n  /**\n   * @ignore\n   * @returns {object}\n   */\n\n  function ValidatorsQueue() {\n    // moved this one level up so it can be used in any function here. Probably this should be moved to a separate file\n    var resolved = false;\n    return {\n      validatorsInQueue: 0,\n      valid: true,\n      addValidatorToQueue: function addValidatorToQueue() {\n        this.validatorsInQueue += 1;\n        resolved = false;\n      },\n      removeValidatorFormQueue: function removeValidatorFormQueue() {\n        this.validatorsInQueue = this.validatorsInQueue - 1 < 0 ? 0 : this.validatorsInQueue - 1;\n        this.checkIfQueueIsEmpty();\n      },\n      onQueueEmpty: function onQueueEmpty() {},\n      checkIfQueueIsEmpty: function checkIfQueueIsEmpty() {\n        if (this.validatorsInQueue === 0 && resolved === false) {\n          resolved = true;\n          this.onQueueEmpty(this.valid);\n        }\n      }\n    };\n  }\n  /**\n   * Get parsed number from numeric string.\n   *\n   * @private\n   * @param {string} numericData Float (separated by a dot or a comma) or integer.\n   * @returns {number} Number if we get data in parsable format, not changed value otherwise.\n   */\n\n  function getParsedNumber(numericData) {\n    // Unifying \"float like\" string. Change from value with comma determiner to value with dot determiner,\n    // for example from `450,65` to `450.65`.\n    var unifiedNumericData = numericData.replace(',', '.');\n    if (isNaN(parseFloat(unifiedNumericData)) === false) {\n      return parseFloat(unifiedNumericData);\n    }\n    return numericData;\n  }\n  /**\n   * @ignore\n   * @param {Array} changes The 2D array containing information about each of the edited cells.\n   * @param {string} source The string that identifies source of validation.\n   * @param {Function} callback The callback function fot async validation.\n   */\n\n  function validateChanges(changes, source, callback) {\n    if (!changes.length) {\n      return;\n    }\n    var activeEditor = instance.getActiveEditor();\n    var beforeChangeResult = instance.runHooks('beforeChange', changes, source || 'edit');\n    var shouldBeCanceled = true;\n    if (beforeChangeResult === false) {\n      if (activeEditor) {\n        activeEditor.cancelChanges();\n      }\n      return;\n    }\n    var waitingForValidator = new ValidatorsQueue();\n    waitingForValidator.onQueueEmpty = function (isValid) {\n      if (activeEditor && shouldBeCanceled) {\n        activeEditor.cancelChanges();\n      }\n      callback(isValid); // called when async validators are resolved and beforeChange was not async\n    };\n    for (var i = changes.length - 1; i >= 0; i--) {\n      if (changes[i] === null) {\n        changes.splice(i, 1);\n      } else {\n        var _changes$i = _slicedToArray(changes[i], 4),\n          row = _changes$i[0],\n          prop = _changes$i[1],\n          newValue = _changes$i[3];\n        var col = datamap.propToCol(prop);\n        var cellProperties = instance.getCellMeta(row, col);\n        if (cellProperties.type === 'numeric' && typeof newValue === 'string' && isNumericLike(newValue)) {\n          changes[i][3] = getParsedNumber(newValue);\n        }\n        /* eslint-disable no-loop-func */\n\n        if (instance.getCellValidator(cellProperties)) {\n          waitingForValidator.addValidatorToQueue();\n          instance.validateCell(changes[i][3], cellProperties, function (index, cellPropertiesReference) {\n            return function (result) {\n              if (typeof result !== 'boolean') {\n                throw new Error('Validation error: result is not boolean');\n              }\n              if (result === false && cellPropertiesReference.allowInvalid === false) {\n                shouldBeCanceled = false;\n                changes.splice(index, 1); // cancel the change\n\n                cellPropertiesReference.valid = true; // we cancelled the change, so cell value is still valid\n\n                var cell = instance.getCell(cellPropertiesReference.visualRow, cellPropertiesReference.visualCol);\n                if (cell !== null) {\n                  removeClass(cell, tableMeta.invalidCellClassName);\n                } // index -= 1;\n              }\n              waitingForValidator.removeValidatorFormQueue();\n            };\n          }(i, cellProperties), source);\n        }\n      }\n    }\n    waitingForValidator.checkIfQueueIsEmpty();\n  }\n  /**\n   * Internal function to apply changes. Called after validateChanges.\n   *\n   * @private\n   * @param {Array} changes Array in form of [row, prop, oldValue, newValue].\n   * @param {string} source String that identifies how this change will be described in changes array (useful in onChange callback).\n   * @fires Hooks#beforeChangeRender\n   * @fires Hooks#afterChange\n   */\n\n  function applyChanges(changes, source) {\n    var i = changes.length - 1;\n    if (i < 0) {\n      return;\n    }\n    for (; i >= 0; i--) {\n      var skipThisChange = false;\n      if (changes[i] === null) {\n        changes.splice(i, 1);\n        /* eslint-disable no-continue */\n\n        continue;\n      }\n      if ((changes[i][2] === null || changes[i][2] === void 0) && (changes[i][3] === null || changes[i][3] === void 0)) {\n        /* eslint-disable no-continue */\n        continue;\n      }\n      if (tableMeta.allowInsertRow) {\n        while (changes[i][0] > instance.countRows() - 1) {\n          var numberOfCreatedRows = datamap.createRow(void 0, void 0, source);\n          if (numberOfCreatedRows >= 1) {\n            metaManager.createRow(null, numberOfCreatedRows);\n          } else {\n            skipThisChange = true;\n            break;\n          }\n        }\n      }\n      if (instance.dataType === 'array' && (!tableMeta.columns || tableMeta.columns.length === 0) && tableMeta.allowInsertColumn) {\n        while (datamap.propToCol(changes[i][1]) > instance.countCols() - 1) {\n          var numberOfCreatedColumns = datamap.createCol(void 0, void 0, source);\n          if (numberOfCreatedColumns >= 1) {\n            metaManager.createColumn(null, numberOfCreatedColumns);\n          } else {\n            skipThisChange = true;\n            break;\n          }\n        }\n      }\n      if (skipThisChange) {\n        /* eslint-disable no-continue */\n        continue;\n      }\n      datamap.set(changes[i][0], changes[i][1], changes[i][3]);\n    }\n    instance.forceFullRender = true; // used when data was changed\n\n    grid.adjustRowsAndCols();\n    instance.runHooks('beforeChangeRender', changes, source);\n    editorManager.lockEditor();\n    instance._refreshBorders(null);\n    editorManager.unlockEditor();\n    instance.view.adjustElementsSize();\n    instance.runHooks('afterChange', changes, source || 'edit');\n    var activeEditor = instance.getActiveEditor();\n    if (activeEditor && isDefined(activeEditor.refreshValue)) {\n      activeEditor.refreshValue();\n    }\n  }\n  /**\n   * Validate a single cell.\n   *\n   * @memberof Core#\n   * @function validateCell\n   * @param {string|number} value The value to validate.\n   * @param {object} cellProperties The cell meta which corresponds with the value.\n   * @param {Function} callback The callback function.\n   * @param {string} source The string that identifies source of the validation.\n   */\n\n  this.validateCell = function (value, cellProperties, callback, source) {\n    var validator = instance.getCellValidator(cellProperties); // the `canBeValidated = false` argument suggests, that the cell passes validation by default.\n\n    /**\n     * @private\n     * @function done\n     * @param {boolean} valid Indicates if the validation was successful.\n     * @param {boolean} [canBeValidated=true] Flag which controls the validation process.\n     */\n\n    function done(valid) {\n      var canBeValidated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      // Fixes GH#3903\n      if (!canBeValidated || cellProperties.hidden === true) {\n        callback(valid);\n        return;\n      }\n      var col = cellProperties.visualCol;\n      var row = cellProperties.visualRow;\n      var td = instance.getCell(row, col, true);\n      if (td && td.nodeName !== 'TH') {\n        var renderableRow = instance.rowIndexMapper.getRenderableFromVisualIndex(row);\n        var renderableColumn = instance.columnIndexMapper.getRenderableFromVisualIndex(col);\n        instance.view.wt.wtSettings.settings.cellRenderer(renderableRow, renderableColumn, td);\n      }\n      callback(valid);\n    }\n    if (isRegExp(validator)) {\n      validator = function (expression) {\n        return function (cellValue, validatorCallback) {\n          validatorCallback(expression.test(cellValue));\n        };\n      }(validator);\n    }\n    if (isFunction(validator)) {\n      // eslint-disable-next-line no-param-reassign\n      value = instance.runHooks('beforeValidate', value, cellProperties.visualRow, cellProperties.prop, source); // To provide consistent behaviour, validation should be always asynchronous\n\n      instance._registerImmediate(function () {\n        validator.call(cellProperties, value, function (valid) {\n          if (!instance) {\n            return;\n          } // eslint-disable-next-line no-param-reassign\n\n          valid = instance.runHooks('afterValidate', valid, value, cellProperties.visualRow, cellProperties.prop, source);\n          cellProperties.valid = valid;\n          done(valid);\n          instance.runHooks('postAfterValidate', valid, value, cellProperties.visualRow, cellProperties.prop, source);\n        });\n      });\n    } else {\n      // resolve callback even if validator function was not found\n      instance._registerImmediate(function () {\n        cellProperties.valid = true;\n        done(cellProperties.valid, false);\n      });\n    }\n  };\n  /**\n   * @ignore\n   * @param {number} row The visual row index.\n   * @param {string|number} propOrCol The visual prop or column index.\n   * @param {*} value The cell value.\n   * @returns {Array}\n   */\n\n  function setDataInputToArray(row, propOrCol, value) {\n    if (Array.isArray(row)) {\n      // it's an array of changes\n      return row;\n    }\n    return [[row, propOrCol, value]];\n  }\n  /**\n   * @description\n   * Set new value to a cell. To change many cells at once (recommended way), pass an array of `changes` in format\n   * `[[row, col, value],...]` as the first argument.\n   *\n   * @memberof Core#\n   * @function setDataAtCell\n   * @param {number|Array} row Visual row index or array of changes in format `[[row, col, value],...]`.\n   * @param {number} [column] Visual column index.\n   * @param {string} [value] New value.\n   * @param {string} [source] String that identifies how this change will be described in the changes array (useful in afterChange or beforeChange callback). Set to 'edit' if left empty.\n   */\n\n  this.setDataAtCell = function (row, column, value, source) {\n    var input = setDataInputToArray(row, column, value);\n    var changes = [];\n    var changeSource = source;\n    var i;\n    var ilen;\n    var prop;\n    for (i = 0, ilen = input.length; i < ilen; i++) {\n      if (_typeof(input[i]) !== 'object') {\n        throw new Error('Method `setDataAtCell` accepts row number or changes array of arrays as its first parameter');\n      }\n      if (typeof input[i][1] !== 'number') {\n        throw new Error('Method `setDataAtCell` accepts row and column number as its parameters. If you want to use object property name, use method `setDataAtRowProp`'); // eslint-disable-line max-len\n      }\n      if (input[i][1] >= this.countCols()) {\n        prop = input[i][1];\n      } else {\n        prop = datamap.colToProp(input[i][1]);\n      }\n      changes.push([input[i][0], prop, dataSource.getAtCell(this.toPhysicalRow(input[i][0]), input[i][1]), input[i][2]]);\n    }\n    if (!changeSource && _typeof(row) === 'object') {\n      changeSource = column;\n    }\n    instance.runHooks('afterSetDataAtCell', changes, changeSource);\n    validateChanges(changes, changeSource, function () {\n      applyChanges(changes, changeSource);\n    });\n  };\n  /**\n   * @description\n   * Set new value to a cell. To change many cells at once (recommended way), pass an array of `changes` in format\n   * `[[row, prop, value],...]` as the first argument.\n   *\n   * @memberof Core#\n   * @function setDataAtRowProp\n   * @param {number|Array} row Visual row index or array of changes in format `[[row, prop, value], ...]`.\n   * @param {string} prop Property name or the source string (e.g. `'first.name'` or `'0'`).\n   * @param {string} value Value to be set.\n   * @param {string} [source] String that identifies how this change will be described in changes array (useful in onChange callback).\n   */\n\n  this.setDataAtRowProp = function (row, prop, value, source) {\n    var input = setDataInputToArray(row, prop, value);\n    var changes = [];\n    var changeSource = source;\n    var i;\n    var ilen;\n    for (i = 0, ilen = input.length; i < ilen; i++) {\n      changes.push([input[i][0], input[i][1], dataSource.getAtCell(this.toPhysicalRow(input[i][0]), input[i][1]), input[i][2]]);\n    }\n    if (!changeSource && _typeof(row) === 'object') {\n      changeSource = prop;\n    }\n    instance.runHooks('afterSetDataAtRowProp', changes, changeSource);\n    validateChanges(changes, changeSource, function () {\n      applyChanges(changes, changeSource);\n    });\n  };\n  /**\n   * Listen to the keyboard input on document body. This allows Handsontable to capture keyboard events and respond\n   * in the right way.\n   *\n   * @memberof Core#\n   * @function listen\n   * @fires Hooks#afterListen\n   */\n\n  this.listen = function () {\n    if (instance && !instance.isListening()) {\n      activeGuid = instance.guid;\n      instance.runHooks('afterListen');\n    }\n  };\n  /**\n   * Stop listening to keyboard input on the document body. Calling this method makes the Handsontable inactive for\n   * any keyboard events.\n   *\n   * @memberof Core#\n   * @function unlisten\n   */\n\n  this.unlisten = function () {\n    if (this.isListening()) {\n      activeGuid = null;\n      instance.runHooks('afterUnlisten');\n    }\n  };\n  /**\n   * Returns `true` if the current Handsontable instance is listening to keyboard input on document body.\n   *\n   * @memberof Core#\n   * @function isListening\n   * @returns {boolean} `true` if the instance is listening, `false` otherwise.\n   */\n\n  this.isListening = function () {\n    return activeGuid === instance.guid;\n  };\n  /**\n   * Destroys the current editor, render the table and prepares the editor of the newly selected cell.\n   *\n   * @memberof Core#\n   * @function destroyEditor\n   * @param {boolean} [revertOriginal=false] If `true`, the previous value will be restored. Otherwise, the edited value will be saved.\n   * @param {boolean} [prepareEditorIfNeeded=true] If `true` the editor under the selected cell will be prepared to open.\n   */\n\n  this.destroyEditor = function () {\n    var revertOriginal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var prepareEditorIfNeeded = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    instance._refreshBorders(revertOriginal, prepareEditorIfNeeded);\n  };\n  /**\n   * Populate cells at position with 2D input array (e.g. `[[1, 2], [3, 4]]`). Use `endRow`, `endCol` when you\n   * want to cut input when a certain row is reached.\n   *\n   * Optional `method` argument has the same effect as pasteMode option (see {@link Options#pasteMode}).\n   *\n   * @memberof Core#\n   * @function populateFromArray\n   * @param {number} row Start visual row index.\n   * @param {number} column Start visual column index.\n   * @param {Array} input 2d array.\n   * @param {number} [endRow] End visual row index (use when you want to cut input when certain row is reached).\n   * @param {number} [endCol] End visual column index (use when you want to cut input when certain column is reached).\n   * @param {string} [source=populateFromArray] Used to identify this call in the resulting events (beforeChange, afterChange).\n   * @param {string} [method=overwrite] Populate method, possible values: `'shift_down'`, `'shift_right'`, `'overwrite'`.\n   * @param {string} direction Populate direction, possible values: `'left'`, `'right'`, `'up'`, `'down'`.\n   * @param {Array} deltas The deltas array. A difference between values of adjacent cells.\n   *                       Useful **only** when the type of handled cells is `numeric`.\n   * @returns {object|undefined} Ending td in pasted area (only if any cell was changed).\n   */\n\n  this.populateFromArray = function (row, column, input, endRow, endCol, source, method, direction, deltas) {\n    if (!(_typeof(input) === 'object' && _typeof(input[0]) === 'object')) {\n      throw new Error('populateFromArray parameter `input` must be an array of arrays'); // API changed in 0.9-beta2, let's check if you use it correctly\n    }\n    var c = typeof endRow === 'number' ? new CellCoords(endRow, endCol) : null;\n    return grid.populateFromArray(new CellCoords(row, column), input, c, source, method, direction, deltas);\n  };\n  /**\n   * Adds/removes data from the column. This method works the same as Array.splice for arrays.\n   *\n   * @memberof Core#\n   * @function spliceCol\n   * @param {number} column Index of the column in which do you want to do splice.\n   * @param {number} index Index at which to start changing the array. If negative, will begin that many elements from the end.\n   * @param {number} amount An integer indicating the number of old array elements to remove. If amount is 0, no elements are removed.\n   * @param {...number} [elements] The elements to add to the array. If you don't specify any elements, spliceCol simply removes elements from the array.\n   * @returns {Array} Returns removed portion of columns.\n   */\n\n  this.spliceCol = function (column, index, amount) {\n    var _datamap;\n    for (var _len = arguments.length, elements = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n      elements[_key - 3] = arguments[_key];\n    }\n    return (_datamap = datamap).spliceCol.apply(_datamap, [column, index, amount].concat(elements));\n  };\n  /**\n   * Adds/removes data from the row. This method works the same as Array.splice for arrays.\n   *\n   * @memberof Core#\n   * @function spliceRow\n   * @param {number} row Index of column in which do you want to do splice.\n   * @param {number} index Index at which to start changing the array. If negative, will begin that many elements from the end.\n   * @param {number} amount An integer indicating the number of old array elements to remove. If amount is 0, no elements are removed.\n   * @param {...number} [elements] The elements to add to the array. If you don't specify any elements, spliceCol simply removes elements from the array.\n   * @returns {Array} Returns removed portion of rows.\n   */\n\n  this.spliceRow = function (row, index, amount) {\n    var _datamap2;\n    for (var _len2 = arguments.length, elements = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n      elements[_key2 - 3] = arguments[_key2];\n    }\n    return (_datamap2 = datamap).spliceRow.apply(_datamap2, [row, index, amount].concat(elements));\n  };\n  /**\n   * Returns indexes of the currently selected cells as an array of arrays `[[startRow, startCol, endRow, endCol],...]`.\n   *\n   * Start row and start column are the coordinates of the active cell (where the selection was started).\n   *\n   * The version 0.36.0 adds a non-consecutive selection feature. Since this version, the method returns an array of arrays.\n   * Additionally to collect the coordinates of the currently selected area (as it was previously done by the method)\n   * you need to use `getSelectedLast` method.\n   *\n   * @memberof Core#\n   * @function getSelected\n   * @returns {Array[]|undefined} An array of arrays of the selection's coordinates.\n   */\n\n  this.getSelected = function () {\n    // https://github.com/handsontable/handsontable/issues/44  //cjl\n    if (selection.isSelected()) {\n      return arrayMap(selection.getSelectedRange(), function (_ref12) {\n        var from = _ref12.from,\n          to = _ref12.to;\n        return [from.row, from.col, to.row, to.col];\n      });\n    }\n  };\n  /**\n   * Returns the last coordinates applied to the table as a an array `[startRow, startCol, endRow, endCol]`.\n   *\n   * @since 0.36.0\n   * @memberof Core#\n   * @function getSelectedLast\n   * @returns {Array|undefined} An array of the selection's coordinates.\n   */\n\n  this.getSelectedLast = function () {\n    var selected = this.getSelected();\n    var result;\n    if (selected && selected.length > 0) {\n      result = selected[selected.length - 1];\n    }\n    return result;\n  };\n  /**\n   * Returns the current selection as an array of CellRange objects.\n   *\n   * The version 0.36.0 adds a non-consecutive selection feature. Since this version, the method returns an array of arrays.\n   * Additionally to collect the coordinates of the currently selected area (as it was previously done by the method)\n   * you need to use `getSelectedRangeLast` method.\n   *\n   * @memberof Core#\n   * @function getSelectedRange\n   * @returns {CellRange[]|undefined} Selected range object or undefined if there is no selection.\n   */\n\n  this.getSelectedRange = function () {\n    // https://github.com/handsontable/handsontable/issues/44  //cjl\n    if (selection.isSelected()) {\n      return Array.from(selection.getSelectedRange());\n    }\n  };\n  /**\n   * Returns the last coordinates applied to the table as a CellRange object.\n   *\n   * @memberof Core#\n   * @function getSelectedRangeLast\n   * @since 0.36.0\n   * @returns {CellRange|undefined} Selected range object or undefined` if there is no selection.\n   */\n\n  this.getSelectedRangeLast = function () {\n    var selectedRange = this.getSelectedRange();\n    var result;\n    if (selectedRange && selectedRange.length > 0) {\n      result = selectedRange[selectedRange.length - 1];\n    }\n    return result;\n  };\n  /**\n   * Erases content from cells that have been selected in the table.\n   *\n   * @memberof Core#\n   * @function emptySelectedCells\n   * @param {string} [source] String that identifies how this change will be described in the changes array (useful in afterChange or beforeChange callback). Set to 'edit' if left empty.\n   * @since 0.36.0\n   */\n\n  this.emptySelectedCells = function (source) {\n    var _this2 = this;\n    if (!selection.isSelected() || this.countRows() === 0 || this.countCols() === 0) {\n      return;\n    }\n    var changes = [];\n    arrayEach(selection.getSelectedRange(), function (cellRange) {\n      var topLeft = cellRange.getTopLeftCorner();\n      var bottomRight = cellRange.getBottomRightCorner();\n      rangeEach(topLeft.row, bottomRight.row, function (row) {\n        rangeEach(topLeft.col, bottomRight.col, function (column) {\n          if (!_this2.getCellMeta(row, column).readOnly) {\n            changes.push([row, column, null]);\n          }\n        });\n      });\n    });\n    if (changes.length > 0) {\n      this.setDataAtCell(changes, source);\n    }\n  };\n  /**\n   * Checks if the table rendering process was suspended. See explanation in {@link Core#suspendRender}.\n   *\n   * @memberof Core#\n   * @function isRenderSuspended\n   * @since 8.3.0\n   * @returns {boolean}\n   */\n\n  this.isRenderSuspended = function () {\n    return this.renderSuspendedCounter > 0;\n  };\n  /**\n   * Suspends the rendering process. It's helpful to wrap the table render\n   * cycles triggered by API calls or UI actions (or both) and call the \"render\"\n   * once in the end. As a result, it improves the performance of wrapped operations.\n   * When the table is in the suspend state, most operations will have no visual\n   * effect until the rendering state is resumed. Resuming the state automatically\n   * invokes the table rendering. To make sure that after executing all operations,\n   * the table will be rendered, it's highly recommended to use the {@link Core#batchRender}\n   * method or {@link Core#batch}, which additionally aggregates the logic execution\n   * that happens behind the table.\n   *\n   * The method is intended to be used by advanced users. Suspending the rendering\n   * process could cause visual glitches when wrongly implemented.\n   *\n   * @memberof Core#\n   * @function suspendRender\n   * @since 8.3.0\n   * @example\n   * ```js\n   * hot.suspendRender();\n   * hot.alter('insert_row', 5, 45);\n   * hot.alter('insert_col', 10, 40);\n   * hot.setDataAtCell(1, 1, 'John');\n   * hot.setDataAtCell(2, 2, 'Mark');\n   * hot.setDataAtCell(3, 3, 'Ann');\n   * hot.setDataAtCell(4, 4, 'Sophia');\n   * hot.setDataAtCell(5, 5, 'Mia');\n   * hot.selectCell(0, 0);\n   * hot.resumeRender(); // It re-renders the table internally\n   * ```\n   */\n\n  this.suspendRender = function () {\n    this.renderSuspendedCounter += 1;\n  };\n  /**\n   * Resumes the rendering process. In combination with the {@link Core#suspendRender}\n   * method it allows aggregating the table render cycles triggered by API calls or UI\n   * actions (or both) and calls the \"render\" once in the end. When the table is in\n   * the suspend state, most operations will have no visual effect until the rendering\n   * state is resumed. Resuming the state automatically invokes the table rendering.\n   *\n   * The method is intended to be used by advanced users. Suspending the rendering\n   * process could cause visual glitches when wrongly implemented.\n   *\n   * @memberof Core#\n   * @function resumeRender\n   * @since 8.3.0\n   * @example\n   * ```js\n   * hot.suspendRender();\n   * hot.alter('insert_row', 5, 45);\n   * hot.alter('insert_col', 10, 40);\n   * hot.setDataAtCell(1, 1, 'John');\n   * hot.setDataAtCell(2, 2, 'Mark');\n   * hot.setDataAtCell(3, 3, 'Ann');\n   * hot.setDataAtCell(4, 4, 'Sophia');\n   * hot.setDataAtCell(5, 5, 'Mia');\n   * hot.selectCell(0, 0);\n   * hot.resumeRender(); // It re-renders the table internally\n   * ```\n   */\n\n  this.resumeRender = function () {\n    var nextValue = this.renderSuspendedCounter - 1;\n    this.renderSuspendedCounter = Math.max(nextValue, 0);\n    if (!this.isRenderSuspended() && nextValue === this.renderSuspendedCounter) {\n      if (this.renderCall) {\n        this.render();\n      } else {\n        this._refreshBorders(null);\n      }\n    }\n  };\n  /**\n   * Rerender the table. Calling this method starts the process of recalculating, redrawing and applying the changes\n   * to the DOM. While rendering the table all cell renderers are recalled.\n   *\n   * Calling this method manually is not recommended. Handsontable tries to render itself by choosing the most\n   * optimal moments in its lifecycle.\n   *\n   * @memberof Core#\n   * @function render\n   */\n\n  this.render = function () {\n    if (this.view) {\n      this.renderCall = true;\n      this.forceFullRender = true; // used when data was changed\n\n      if (!this.isRenderSuspended()) {\n        editorManager.lockEditor();\n        this._refreshBorders(null);\n        editorManager.unlockEditor();\n      }\n    }\n  };\n  /**\n   * The method aggregates multi-line API calls into a callback and postpones the\n   * table rendering process. After the execution of the operations, the table is\n   * rendered once. As a result, it improves the performance of wrapped operations.\n   * Without batching, a similar case could trigger multiple table render calls.\n   *\n   * @memberof Core#\n   * @function batchRender\n   * @param {Function} wrappedOperations Batched operations wrapped in a function.\n   * @returns {*} Returns result from the wrappedOperations callback.\n   * @since 8.3.0\n   * @example\n   * ```js\n   * hot.batchRender(() => {\n   *   hot.alter('insert_row', 5, 45);\n   *   hot.alter('insert_col', 10, 40);\n   *   hot.setDataAtCell(1, 1, 'John');\n   *   hot.setDataAtCell(2, 2, 'Mark');\n   *   hot.setDataAtCell(3, 3, 'Ann');\n   *   hot.setDataAtCell(4, 4, 'Sophia');\n   *   hot.setDataAtCell(5, 5, 'Mia');\n   *   hot.selectCell(0, 0);\n   *   // The table will be rendered once after executing the callback\n   * });\n   * ```\n   */\n\n  this.batchRender = function (wrappedOperations) {\n    this.suspendRender();\n    var result = wrappedOperations();\n    this.resumeRender();\n    return result;\n  };\n  /**\n   * Checks if the table indexes recalculation process was suspended. See explanation\n   * in {@link Core#suspendExecution}.\n   *\n   * @memberof Core#\n   * @function isExecutionSuspended\n   * @since 8.3.0\n   * @returns {boolean}\n   */\n\n  this.isExecutionSuspended = function () {\n    return this.executionSuspendedCounter > 0;\n  };\n  /**\n   * Suspends the execution process. It's helpful to wrap the table logic changes\n   * such as index changes into one call after which the cache is updated. As a result,\n   * it improves the performance of wrapped operations.\n   *\n   * The method is intended to be used by advanced users. Suspending the execution\n   * process could cause visual glitches caused by not updated the internal table cache.\n   *\n   * @memberof Core#\n   * @function suspendExecution\n   * @since 8.3.0\n   * @example\n   * ```js\n   * hot.suspendExecution();\n   * const filters = hot.getPlugin('filters');\n   *\n   * filters.addCondition(2, 'contains', ['3']);\n   * filters.filter();\n   * hot.getPlugin('columnSorting').sort({ column: 1, sortOrder: 'desc' });\n   * hot.resumeExecution(); // It updates the cache internally\n   * ```\n   */\n\n  this.suspendExecution = function () {\n    this.executionSuspendedCounter += 1;\n    this.columnIndexMapper.suspendOperations();\n    this.rowIndexMapper.suspendOperations();\n  };\n  /**\n   * Resumes the execution process. In combination with the {@link Core#suspendExecution}\n   * method it allows aggregating the table logic changes after which the cache is\n   * updated. Resuming the state automatically invokes the table cache updating process.\n   *\n   * The method is intended to be used by advanced users. Suspending the execution\n   * process could cause visual glitches caused by not updated the internal table cache.\n   *\n   * @memberof Core#\n   * @function resumeExecution\n   * @param {boolean} [forceFlushChanges=false] If `true`, the table internal data cache\n   * is recalculated after the execution of the batched operations. For nested\n   * {@link Core#batchExecution} calls, it can be desire to recalculate the table\n   * after each batch.\n   * @since 8.3.0\n   * @example\n   * ```js\n   * hot.suspendExecution();\n   * const filters = hot.getPlugin('filters');\n   *\n   * filters.addCondition(2, 'contains', ['3']);\n   * filters.filter();\n   * hot.getPlugin('columnSorting').sort({ column: 1, sortOrder: 'desc' });\n   * hot.resumeExecution(); // It updates the cache internally\n   * ```\n   */\n\n  this.resumeExecution = function () {\n    var forceFlushChanges = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var nextValue = this.executionSuspendedCounter - 1;\n    this.executionSuspendedCounter = Math.max(nextValue, 0);\n    if (!this.isExecutionSuspended() && nextValue === this.executionSuspendedCounter || forceFlushChanges) {\n      this.columnIndexMapper.resumeOperations();\n      this.rowIndexMapper.resumeOperations();\n    }\n  };\n  /**\n   * The method aggregates multi-line API calls into a callback and postpones the\n   * table execution process. After the execution of the operations, the internal table\n   * cache is recalculated once. As a result, it improves the performance of wrapped\n   * operations. Without batching, a similar case could trigger multiple table cache rebuilds.\n   *\n   * @memberof Core#\n   * @function batchExecution\n   * @param {Function} wrappedOperations Batched operations wrapped in a function.\n   * @param {boolean} [forceFlushChanges=false] If `true`, the table internal data cache\n   * is recalculated after the execution of the batched operations. For nested calls,\n   * it can be a desire to recalculate the table after each batch.\n   * @returns {*} Returns result from the wrappedOperations callback.\n   * @since 8.3.0\n   * @example\n   * ```js\n   * hot.batchExecution(() => {\n   *   const filters = hot.getPlugin('filters');\n   *\n   *   filters.addCondition(2, 'contains', ['3']);\n   *   filters.filter();\n   *   hot.getPlugin('columnSorting').sort({ column: 1, sortOrder: 'desc' });\n   *   // The table cache will be recalculated once after executing the callback\n   * });\n   * ```\n   */\n\n  this.batchExecution = function (wrappedOperations) {\n    var forceFlushChanges = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    this.suspendExecution();\n    var result = wrappedOperations();\n    this.resumeExecution(forceFlushChanges);\n    return result;\n  };\n  /**\n   * It batches the rendering process and index recalculations. The method aggregates\n   * multi-line API calls into a callback and postpones the table rendering process\n   * as well aggregates the table logic changes such as index changes into one call\n   * after which the cache is updated. After the execution of the operations, the\n   * table is rendered, and the cache is updated once. As a result, it improves the\n   * performance of wrapped operations.\n   *\n   * @memberof Core#\n   * @function batch\n   * @param {Function} wrappedOperations Batched operations wrapped in a function.\n   * @returns {*} Returns result from the wrappedOperations callback.\n   * @since 8.3.0\n   * @example\n   * ```js\n   * hot.batch(() => {\n   *   hot.alter('insert_row', 5, 45);\n   *   hot.alter('insert_col', 10, 40);\n   *   hot.setDataAtCell(1, 1, 'x');\n   *   hot.setDataAtCell(2, 2, 'c');\n   *   hot.setDataAtCell(3, 3, 'v');\n   *   hot.setDataAtCell(4, 4, 'b');\n   *   hot.setDataAtCell(5, 5, 'n');\n   *   hot.selectCell(0, 0);\n   *\n   *   const filters = hot.getPlugin('filters');\n   *\n   *   filters.addCondition(2, 'contains', ['3']);\n   *   filters.filter();\n   *   hot.getPlugin('columnSorting').sort({ column: 1, sortOrder: 'desc' });\n   *   // The table will be re-rendered and cache will be recalculated once after executing the callback\n   * });\n   * ```\n   */\n\n  this.batch = function (wrappedOperations) {\n    this.suspendRender();\n    this.suspendExecution();\n    var result = wrappedOperations();\n    this.resumeExecution();\n    this.resumeRender();\n    return result;\n  };\n  /**\n   * Updates dimensions of the table. The method compares previous dimensions with the current ones and updates accordingly.\n   *\n   * @memberof Core#\n   * @function refreshDimensions\n   * @fires Hooks#beforeRefreshDimensions\n   * @fires Hooks#afterRefreshDimensions\n   */\n\n  this.refreshDimensions = function () {\n    if (!instance.view) {\n      return;\n    }\n    var _instance$view$getLas = instance.view.getLastSize(),\n      lastWidth = _instance$view$getLas.width,\n      lastHeight = _instance$view$getLas.height;\n    var _instance$rootElement = instance.rootElement.getBoundingClientRect(),\n      width = _instance$rootElement.width,\n      height = _instance$rootElement.height;\n    var isSizeChanged = width !== lastWidth || height !== lastHeight;\n    var isResizeBlocked = instance.runHooks('beforeRefreshDimensions', {\n      width: lastWidth,\n      height: lastHeight\n    }, {\n      width: width,\n      height: height\n    }, isSizeChanged) === false;\n    if (isResizeBlocked) {\n      return;\n    }\n    if (isSizeChanged || instance.view.wt.wtOverlays.scrollableElement === instance.rootWindow) {\n      instance.view.setLastSize(width, height);\n      instance.render();\n    }\n    instance.runHooks('afterRefreshDimensions', {\n      width: lastWidth,\n      height: lastHeight\n    }, {\n      width: width,\n      height: height\n    }, isSizeChanged);\n  };\n  /**\n   * The `updateData()` method replaces Handsontable's [`data`](@/api/options.md#data) with a new dataset.\n   *\n   * The `updateData()` method:\n   * - Keeps cells' states (e.g. cells' [formatting](@/guides/cell-features/formatting-cells.md) and cells' [`readOnly`](@/api/options.md#readonly) states)\n   * - Keeps rows' states (e.g. row order)\n   * - Keeps columns' states (e.g. column order)\n   *\n   * To replace Handsontable's [`data`](@/api/options.md#data) and reset states, use the [`loadData()`](#loaddata) method.\n   *\n   * Read more:\n   * - [Binding to data &#8594;](@/guides/getting-started/binding-to-data.md)\n   * - [Saving data &#8594;](@/guides/getting-started/saving-data.md)\n   *\n   * @memberof Core#\n   * @function updateData\n   * @since 11.1.0\n   * @param {Array} data An [array of arrays](@/guides/getting-started/binding-to-data.md#array-of-arrays), or an [array of objects](@/guides/getting-started/binding-to-data.md#array-of-objects), that contains Handsontable's data\n   * @param {string} [source] The source of the `updateData()` call\n   * @fires Hooks#beforeUpdateData\n   * @fires Hooks#afterUpdateData\n   * @fires Hooks#afterChange\n   */\n\n  this.updateData = function (data, source) {\n    var _this3 = this;\n    replaceData(data, function (newDataMap) {\n      datamap = newDataMap;\n    }, function (newDataMap) {\n      datamap = newDataMap;\n      instance.columnIndexMapper.fitToLength(_this3.getInitialColumnCount());\n      instance.rowIndexMapper.fitToLength(_this3.countSourceRows());\n      grid.adjustRowsAndCols();\n    }, {\n      hotInstance: instance,\n      dataMap: datamap,\n      dataSource: dataSource,\n      internalSource: 'updateData',\n      source: source,\n      firstRun: firstRun\n    });\n  };\n  /**\n   * The `loadData()` method replaces Handsontable's [`data`](@/api/options.md#data) with a new dataset.\n   *\n   * Additionally, the `loadData()` method:\n   * - Resets cells' states (e.g. cells' [formatting](@/guides/cell-features/formatting-cells.md) and cells' [`readOnly`](@/api/options.md#readonly) states)\n   * - Resets rows' states (e.g. row order)\n   * - Resets columns' states (e.g. column order)\n   *\n   * To replace Handsontable's [`data`](@/api/options.md#data) without resetting states, use the [`updateData()`](#updatedata) method.\n   *\n   * Read more:\n   * - [Binding to data &#8594;](@/guides/getting-started/binding-to-data.md)\n   * - [Saving data &#8594;](@/guides/getting-started/saving-data.md)\n   *\n   * @memberof Core#\n   * @function loadData\n   * @param {Array} data An [array of arrays](@/guides/getting-started/binding-to-data.md#array-of-arrays), or an [array of objects](@/guides/getting-started/binding-to-data.md#array-of-objects), that contains Handsontable's data\n   * @param {string} [source] The source of the `loadData()` call\n   * @fires Hooks#beforeLoadData\n   * @fires Hooks#afterLoadData\n   * @fires Hooks#afterChange\n   */\n\n  this.loadData = function (data, source) {\n    replaceData(data, function (newDataMap) {\n      datamap = newDataMap;\n    }, function () {\n      metaManager.clearCellsCache();\n      instance.initIndexMappers();\n      grid.adjustRowsAndCols();\n      if (firstRun) {\n        firstRun = [null, 'loadData'];\n      }\n    }, {\n      hotInstance: instance,\n      dataMap: datamap,\n      dataSource: dataSource,\n      internalSource: 'loadData',\n      source: source,\n      firstRun: firstRun\n    });\n  };\n  /**\n   * Gets the initial column count, calculated based on the `columns` setting.\n   *\n   * @private\n   * @returns {number} The calculated number of columns.\n   */\n\n  this.getInitialColumnCount = function () {\n    var columnsSettings = tableMeta.columns;\n    var finalNrOfColumns = 0; // We will check number of columns when the `columns` property was defined as an array. Columns option may\n    // narrow down or expand displayed dataset in that case.\n\n    if (Array.isArray(columnsSettings)) {\n      finalNrOfColumns = columnsSettings.length;\n    } else if (isFunction(columnsSettings)) {\n      if (instance.dataType === 'array') {\n        var nrOfSourceColumns = this.countSourceCols();\n        for (var columnIndex = 0; columnIndex < nrOfSourceColumns; columnIndex += 1) {\n          if (columnsSettings(columnIndex)) {\n            finalNrOfColumns += 1;\n          }\n        } // Extended dataset by the `columns` property? Moved code right from the refactored `countCols` method.\n      } else if (instance.dataType === 'object' || instance.dataType === 'function') {\n        finalNrOfColumns = datamap.colToPropCache.length;\n      } // In some cases we need to check columns length from the schema, i.e. `data` may be empty.\n    } else if (isDefined(tableMeta.dataSchema)) {\n      var schema = datamap.getSchema(); // Schema may be defined as an array of objects. Each object will define column.\n\n      finalNrOfColumns = Array.isArray(schema) ? schema.length : deepObjectSize(schema);\n    } else {\n      // We init index mappers by length of source data to provide indexes also for skipped indexes.\n      finalNrOfColumns = this.countSourceCols();\n    }\n    return finalNrOfColumns;\n  };\n  /**\n   * Init index mapper which manage indexes assigned to the data.\n   *\n   * @private\n   */\n\n  this.initIndexMappers = function () {\n    this.columnIndexMapper.initToLength(this.getInitialColumnCount());\n    this.rowIndexMapper.initToLength(this.countSourceRows());\n  };\n  /**\n   * Returns the current data object (the same one that was passed by `data` configuration option or `loadData` method,\n   * unless some modifications have been applied (i.e. Sequence of rows/columns was changed, some row/column was skipped).\n   * If that's the case - use the {@link Core#getSourceData} method.).\n   *\n   * Optionally you can provide cell range by defining `row`, `column`, `row2`, `column2` to get only a fragment of table data.\n   *\n   * @memberof Core#\n   * @function getData\n   * @param {number} [row] From visual row index.\n   * @param {number} [column] From visual column index.\n   * @param {number} [row2] To visual row index.\n   * @param {number} [column2] To visual column index.\n   * @returns {Array[]} Array with the data.\n   * @example\n   * ```js\n   * // Get all data (in order how it is rendered in the table).\n   * hot.getData();\n   * // Get data fragment (from top-left 0, 0 to bottom-right 3, 3).\n   * hot.getData(3, 3);\n   * // Get data fragment (from top-left 2, 1 to bottom-right 3, 3).\n   * hot.getData(2, 1, 3, 3);\n   * ```\n   */\n\n  this.getData = function (row, column, row2, column2) {\n    if (isUndefined(row)) {\n      return datamap.getAll();\n    }\n    return datamap.getRange(new CellCoords(row, column), new CellCoords(row2, column2), datamap.DESTINATION_RENDERER);\n  };\n  /**\n   * Returns a string value of the selected range. Each column is separated by tab, each row is separated by a new\n   * line character.\n   *\n   * @memberof Core#\n   * @function getCopyableText\n   * @param {number} startRow From visual row index.\n   * @param {number} startCol From visual column index.\n   * @param {number} endRow To visual row index.\n   * @param {number} endCol To visual column index.\n   * @returns {string}\n   */\n\n  this.getCopyableText = function (startRow, startCol, endRow, endCol) {\n    return datamap.getCopyableText(new CellCoords(startRow, startCol), new CellCoords(endRow, endCol));\n  };\n  /**\n   * Returns the data's copyable value at specified `row` and `column` index.\n   *\n   * @memberof Core#\n   * @function getCopyableData\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @returns {string}\n   */\n\n  this.getCopyableData = function (row, column) {\n    return datamap.getCopyable(row, datamap.colToProp(column));\n  };\n  /**\n   * Returns schema provided by constructor settings. If it doesn't exist then it returns the schema based on the data\n   * structure in the first row.\n   *\n   * @memberof Core#\n   * @function getSchema\n   * @returns {object} Schema object.\n   */\n\n  this.getSchema = function () {\n    return datamap.getSchema();\n  };\n  /**\n   * Use it if you need to change configuration after initialization. The `settings` argument is an object containing the new\n   * settings, declared the same way as in the initial settings object.\n   *\n   * __Note__, that although the `updateSettings` method doesn't overwrite the previously declared settings, it might reset\n   * the settings made post-initialization. (for example - ignore changes made using the columnResize feature).\n   *\n   * Since 8.0.0 passing `columns` or `data` inside `settings` objects will result in resetting states corresponding to rows and columns\n   * (for example, row/column sequence, column width, row height, frozen columns etc.).\n   *\n   * @memberof Core#\n   * @function updateSettings\n   * @param {object} settings New settings object (see {@link Options}).\n   * @param {boolean} [init=false] Internally used for in initialization mode.\n   * @example\n   * ```js\n   * hot.updateSettings({\n   *    contextMenu: true,\n   *    colHeaders: true,\n   *    fixedRowsTop: 2\n   * });\n   * ```\n   * @fires Hooks#afterCellMetaReset\n   * @fires Hooks#afterUpdateSettings\n   */\n\n  this.updateSettings = function (settings) {\n    var init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    // TODO: uncomment the next line with the next major version update\n    // Do not forget to re-enable the pending tests that cover the change:\n    //  * https://github.com/handsontable/handsontable/blob/9f62c282a1c951b27cd8406aa27105bd32b05bb6/handsontable/test/e2e/core/toPhysicalColumn.spec.js#L70\n    //  * https://github.com/handsontable/handsontable/blob/9f62c282a1c951b27cd8406aa27105bd32b05bb6/handsontable/test/e2e/core/toVisualColumn.spec.js#L70\n    // const dataUpdateFunction = (firstRun ? instance.loadData : instance.updateData).bind(this);\n    var dataUpdateFunction = instance.loadData.bind(this);\n    var columnsAsFunc = false;\n    var i;\n    var j;\n    if (isDefined(settings.rows)) {\n      throw new Error('The \"rows\" setting is no longer supported. Do you mean startRows, minRows or maxRows?');\n    }\n    if (isDefined(settings.cols)) {\n      throw new Error('The \"cols\" setting is no longer supported. Do you mean startCols, minCols or maxCols?');\n    }\n    if (isDefined(settings.ganttChart)) {\n      throw new Error('Since 8.0.0 the \"ganttChart\" setting is no longer supported.');\n    } // eslint-disable-next-line no-restricted-syntax\n\n    for (i in settings) {\n      if (i === 'data') {\n        /* eslint-disable-next-line no-continue */\n        continue; // loadData will be triggered later\n      } else if (i === 'language') {\n        setLanguage(settings.language);\n        /* eslint-disable-next-line no-continue */\n\n        continue;\n      } else if (i === 'className') {\n        setClassName('className', settings.className);\n      } else if (i === 'tableClassName' && instance.table) {\n        setClassName('tableClassName', settings.tableClassName);\n        instance.view.wt.wtOverlays.syncOverlayTableClassNames();\n      } else if (Hooks.getSingleton().isRegistered(i) || Hooks.getSingleton().isDeprecated(i)) {\n        if (isFunction(settings[i]) || Array.isArray(settings[i])) {\n          settings[i].initialHook = true;\n          instance.addHook(i, settings[i]);\n        }\n      } else if (!init && hasOwnProperty(settings, i)) {\n        // Update settings\n        globalMeta[i] = settings[i];\n      }\n    } // Load data or create data map\n\n    if (settings.data === void 0 && tableMeta.data === void 0) {\n      dataUpdateFunction(null, 'updateSettings'); // data source created just now\n    } else if (settings.data !== void 0) {\n      dataUpdateFunction(settings.data, 'updateSettings'); // data source given as option\n    } else if (settings.columns !== void 0) {\n      datamap.createMap(); // The `column` property has changed - dataset may be expanded or narrowed down. The `loadData` do the same.\n\n      instance.initIndexMappers();\n    }\n    var clen = instance.countCols();\n    var columnSetting = tableMeta.columns; // Init columns constructors configuration\n\n    if (columnSetting && isFunction(columnSetting)) {\n      columnsAsFunc = true;\n    } // Clear cell meta cache\n\n    if (settings.cell !== void 0 || settings.cells !== void 0 || settings.columns !== void 0) {\n      metaManager.clearCache();\n    }\n    if (clen > 0) {\n      for (i = 0, j = 0; i < clen; i++) {\n        // Use settings provided by user\n        if (columnSetting) {\n          var column = columnsAsFunc ? columnSetting(i) : columnSetting[j];\n          if (column) {\n            metaManager.updateColumnMeta(j, column);\n          }\n        }\n        j += 1;\n      }\n    }\n    if (isDefined(settings.cell)) {\n      objectEach(settings.cell, function (cell) {\n        instance.setCellMetaObject(cell.row, cell.col, cell);\n      });\n    }\n    instance.runHooks('afterCellMetaReset');\n    var currentHeight = instance.rootElement.style.height;\n    if (currentHeight !== '') {\n      currentHeight = parseInt(instance.rootElement.style.height, 10);\n    }\n    var height = settings.height;\n    if (isFunction(height)) {\n      height = height();\n    }\n    if (init) {\n      var initialStyle = instance.rootElement.getAttribute('style');\n      if (initialStyle) {\n        instance.rootElement.setAttribute('data-initialstyle', instance.rootElement.getAttribute('style'));\n      }\n    }\n    if (height === null) {\n      var _initialStyle = instance.rootElement.getAttribute('data-initialstyle');\n      if (_initialStyle && (_initialStyle.indexOf('height') > -1 || _initialStyle.indexOf('overflow') > -1)) {\n        instance.rootElement.setAttribute('style', _initialStyle);\n      } else {\n        instance.rootElement.style.height = '';\n        instance.rootElement.style.overflow = '';\n      }\n    } else if (height !== void 0) {\n      instance.rootElement.style.height = isNaN(height) ? \"\".concat(height) : \"\".concat(height, \"px\");\n      instance.rootElement.style.overflow = 'hidden';\n    }\n    if (typeof settings.width !== 'undefined') {\n      var width = settings.width;\n      if (isFunction(width)) {\n        width = width();\n      }\n      instance.rootElement.style.width = isNaN(width) ? \"\".concat(width) : \"\".concat(width, \"px\");\n    }\n    if (!init) {\n      if (instance.view) {\n        instance.view.wt.wtViewport.resetHasOversizedColumnHeadersMarked();\n        instance.view.wt.exportSettingsAsClassNames();\n      }\n      instance.runHooks('afterUpdateSettings', settings);\n    }\n    grid.adjustRowsAndCols();\n    if (instance.view && !firstRun) {\n      instance.forceFullRender = true; // used when data was changed\n\n      editorManager.lockEditor();\n      instance._refreshBorders(null);\n      instance.view.wt.wtOverlays.adjustElementsSize();\n      editorManager.unlockEditor();\n    }\n    if (!init && instance.view && (currentHeight === '' || height === '' || height === void 0) && currentHeight !== height) {\n      instance.view.wt.wtOverlays.updateMainScrollableElements();\n    }\n  };\n  /**\n   * Get value from the selected cell.\n   *\n   * @memberof Core#\n   * @function getValue\n   * @returns {*} Value of selected cell.\n   */\n\n  this.getValue = function () {\n    var sel = instance.getSelectedLast();\n    if (tableMeta.getValue) {\n      if (isFunction(tableMeta.getValue)) {\n        return tableMeta.getValue.call(instance);\n      } else if (sel) {\n        return instance.getData()[sel[0][0]][tableMeta.getValue];\n      }\n    } else if (sel) {\n      return instance.getDataAtCell(sel[0], sel[1]);\n    }\n  };\n  /**\n   * Returns the object settings.\n   *\n   * @memberof Core#\n   * @function getSettings\n   * @returns {object} Object containing the current table settings.\n   */\n\n  this.getSettings = function () {\n    return tableMeta;\n  };\n  /**\n   * Clears the data from the table (the table settings remain intact).\n   *\n   * @memberof Core#\n   * @function clear\n   */\n\n  this.clear = function () {\n    this.selectAll();\n    this.emptySelectedCells();\n  };\n  /**\n   * Allows altering the table structure by either inserting/removing rows or columns.\n   * This method works with an array data structure only.\n   *\n   * @memberof Core#\n   * @function alter\n   * @param {string} action Possible alter operations:\n   *  <ul>\n   *    <li> `'insert_row'` </li>\n   *    <li> `'insert_col'` </li>\n   *    <li> `'remove_row'` </li>\n   *    <li> `'remove_col'` </li>\n   * </ul>.\n   * @param {number|number[]} index Visual index of the row/column before which the new row/column will be\n   *                                inserted/removed or an array of arrays in format `[[index, amount],...]`.\n   * @param {number} [amount=1] Amount of rows/columns to be inserted or removed.\n   * @param {string} [source] Source indicator.\n   * @param {boolean} [keepEmptyRows] Flag for preventing deletion of empty rows.\n   * @example\n   * ```js\n   * // Insert new row above the row at given visual index.\n   * hot.alter('insert_row', 10);\n   * // Insert 3 new columns before 10th column.\n   * hot.alter('insert_col', 10, 3);\n   * // Remove 2 rows starting from 10th row.\n   * hot.alter('remove_row', 10, 2);\n   * // Remove 5 non-contiquous rows (it removes 3 rows from visual index 1 and 2 rows from visual index 5).\n   * hot.alter('remove_row', [[1, 3], [5, 2]]);\n   * ```\n   */\n\n  this.alter = function (action, index, amount, source, keepEmptyRows) {\n    grid.alter(action, index, amount, source, keepEmptyRows);\n  };\n  /**\n   * Returns a TD element for the given `row` and `column` arguments, if it is rendered on screen.\n   * Returns `null` if the TD is not rendered on screen (probably because that part of the table is not visible).\n   *\n   * @memberof Core#\n   * @function getCell\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @param {boolean} [topmost=false] If set to `true`, it returns the TD element from the topmost overlay. For example,\n   * if the wanted cell is in the range of fixed rows, it will return a TD element from the `top` overlay.\n   * @returns {HTMLTableCellElement|null} The cell's TD element.\n   */\n\n  this.getCell = function (row, column) {\n    var topmost = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var renderableColumnIndex = column; // Handling also column headers.\n\n    var renderableRowIndex = row; // Handling also row headers.\n\n    if (column >= 0) {\n      if (this.columnIndexMapper.isHidden(this.toPhysicalColumn(column))) {\n        return null;\n      }\n      renderableColumnIndex = this.columnIndexMapper.getRenderableFromVisualIndex(column);\n    }\n    if (row >= 0) {\n      if (this.rowIndexMapper.isHidden(this.toPhysicalRow(row))) {\n        return null;\n      }\n      renderableRowIndex = this.rowIndexMapper.getRenderableFromVisualIndex(row);\n    }\n    if (renderableRowIndex === null || renderableColumnIndex === null) {\n      return null;\n    }\n    return instance.view.getCellAtCoords(new CellCoords(renderableRowIndex, renderableColumnIndex), topmost);\n  };\n  /**\n   * Returns the coordinates of the cell, provided as a HTML table cell element.\n   *\n   * @memberof Core#\n   * @function getCoords\n   * @param {HTMLTableCellElement} element The HTML Element representing the cell.\n   * @returns {CellCoords|null} Visual coordinates object.\n   * @example\n   * ```js\n   * hot.getCoords(hot.getCell(1, 1));\n   * // it returns CellCoords object instance with props row: 1 and col: 1.\n   * ```\n   */\n\n  this.getCoords = function (element) {\n    var renderableCoords = this.view.wt.wtTable.getCoords(element);\n    if (renderableCoords === null) {\n      return null;\n    }\n    var renderableRow = renderableCoords.row,\n      renderableColumn = renderableCoords.col;\n    var visualRow = renderableRow;\n    var visualColumn = renderableColumn;\n    if (renderableRow >= 0) {\n      visualRow = this.rowIndexMapper.getVisualFromRenderableIndex(renderableRow);\n    }\n    if (renderableColumn >= 0) {\n      visualColumn = this.columnIndexMapper.getVisualFromRenderableIndex(renderableColumn);\n    }\n    return new CellCoords(visualRow, visualColumn);\n  };\n  /**\n   * Returns the property name that corresponds with the given column index.\n   * If the data source is an array of arrays, it returns the columns index.\n   *\n   * @memberof Core#\n   * @function colToProp\n   * @param {number} column Visual column index.\n   * @returns {string|number} Column property or physical column index.\n   */\n\n  this.colToProp = function (column) {\n    return datamap.colToProp(column);\n  };\n  /**\n   * Returns column index that corresponds with the given property.\n   *\n   * @memberof Core#\n   * @function propToCol\n   * @param {string|number} prop Property name or physical column index.\n   * @returns {number} Visual column index.\n   */\n\n  this.propToCol = function (prop) {\n    return datamap.propToCol(prop);\n  };\n  /**\n   * Translate physical row index into visual.\n   *\n   * This method is useful when you want to retrieve visual row index which can be reordered, moved or trimmed\n   * based on a physical index.\n   *\n   * @memberof Core#\n   * @function toVisualRow\n   * @param {number} row Physical row index.\n   * @returns {number} Returns visual row index.\n   */\n\n  this.toVisualRow = function (row) {\n    return _this.rowIndexMapper.getVisualFromPhysicalIndex(row);\n  };\n  /**\n   * Translate physical column index into visual.\n   *\n   * This method is useful when you want to retrieve visual column index which can be reordered, moved or trimmed\n   * based on a physical index.\n   *\n   * @memberof Core#\n   * @function toVisualColumn\n   * @param {number} column Physical column index.\n   * @returns {number} Returns visual column index.\n   */\n\n  this.toVisualColumn = function (column) {\n    return _this.columnIndexMapper.getVisualFromPhysicalIndex(column);\n  };\n  /**\n   * Translate visual row index into physical.\n   *\n   * This method is useful when you want to retrieve physical row index based on a visual index which can be\n   * reordered, moved or trimmed.\n   *\n   * @memberof Core#\n   * @function toPhysicalRow\n   * @param {number} row Visual row index.\n   * @returns {number} Returns physical row index.\n   */\n\n  this.toPhysicalRow = function (row) {\n    return _this.rowIndexMapper.getPhysicalFromVisualIndex(row);\n  };\n  /**\n   * Translate visual column index into physical.\n   *\n   * This method is useful when you want to retrieve physical column index based on a visual index which can be\n   * reordered, moved or trimmed.\n   *\n   * @memberof Core#\n   * @function toPhysicalColumn\n   * @param {number} column Visual column index.\n   * @returns {number} Returns physical column index.\n   */\n\n  this.toPhysicalColumn = function (column) {\n    return _this.columnIndexMapper.getPhysicalFromVisualIndex(column);\n  };\n  /**\n   * @description\n   * Returns the cell value at `row`, `column`.\n   *\n   * __Note__: If data is reordered, sorted or trimmed, the currently visible order will be used.\n   *\n   * @memberof Core#\n   * @function getDataAtCell\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @returns {*} Data at cell.\n   */\n\n  this.getDataAtCell = function (row, column) {\n    return datamap.get(row, datamap.colToProp(column));\n  };\n  /**\n   * Returns value at visual `row` and `prop` indexes.\n   *\n   * __Note__: If data is reordered, sorted or trimmed, the currently visible order will be used.\n   *\n   * @memberof Core#\n   * @function getDataAtRowProp\n   * @param {number} row Visual row index.\n   * @param {string} prop Property name.\n   * @returns {*} Cell value.\n   */\n\n  this.getDataAtRowProp = function (row, prop) {\n    return datamap.get(row, prop);\n  };\n  /**\n   * @description\n   * Returns array of column values from the data source.\n   *\n   * __Note__: If columns were reordered or sorted, the currently visible order will be used.\n   *\n   * @memberof Core#\n   * @function getDataAtCol\n   * @param {number} column Visual column index.\n   * @returns {Array} Array of cell values.\n   */\n\n  this.getDataAtCol = function (column) {\n    var _ref13;\n    return (_ref13 = []).concat.apply(_ref13, _toConsumableArray(datamap.getRange(new CellCoords(0, column), new CellCoords(tableMeta.data.length - 1, column), datamap.DESTINATION_RENDERER)));\n  };\n  /**\n   * Given the object property name (e.g. `'first.name'` or `'0'`), returns an array of column's values from the table data.\n   * You can also provide a column index as the first argument.\n   *\n   * @memberof Core#\n   * @function getDataAtProp\n   * @param {string|number} prop Property name or physical column index.\n   * @returns {Array} Array of cell values.\n   */\n  // TODO: Getting data from `datamap` should work on visual indexes.\n\n  this.getDataAtProp = function (prop) {\n    var _ref14;\n    var range = datamap.getRange(new CellCoords(0, datamap.propToCol(prop)), new CellCoords(tableMeta.data.length - 1, datamap.propToCol(prop)), datamap.DESTINATION_RENDERER);\n    return (_ref14 = []).concat.apply(_ref14, _toConsumableArray(range));\n  };\n  /**\n   * Returns a clone of the source data object.\n   * Optionally you can provide a cell range by using the `row`, `column`, `row2`, `column2` arguments, to get only a\n   * fragment of the table data.\n   *\n   * __Note__: This method does not participate in data transformation. If the visual data of the table is reordered,\n   * sorted or trimmed only physical indexes are correct.\n   *\n   * @memberof Core#\n   * @function getSourceData\n   * @param {number} [row] From physical row index.\n   * @param {number} [column] From physical column index (or visual index, if data type is an array of objects).\n   * @param {number} [row2] To physical row index.\n   * @param {number} [column2] To physical column index (or visual index, if data type is an array of objects).\n   * @returns {Array[]|object[]} The table data.\n   */\n\n  this.getSourceData = function (row, column, row2, column2) {\n    var data;\n    if (row === void 0) {\n      data = dataSource.getData();\n    } else {\n      data = dataSource.getByRange(new CellCoords(row, column), new CellCoords(row2, column2));\n    }\n    return data;\n  };\n  /**\n   * Returns the source data object as an arrays of arrays format even when source data was provided in another format.\n   * Optionally you can provide a cell range by using the `row`, `column`, `row2`, `column2` arguments, to get only a\n   * fragment of the table data.\n   *\n   * __Note__: This method does not participate in data transformation. If the visual data of the table is reordered,\n   * sorted or trimmed only physical indexes are correct.\n   *\n   * @memberof Core#\n   * @function getSourceDataArray\n   * @param {number} [row] From physical row index.\n   * @param {number} [column] From physical column index (or visual index, if data type is an array of objects).\n   * @param {number} [row2] To physical row index.\n   * @param {number} [column2] To physical column index (or visual index, if data type is an array of objects).\n   * @returns {Array} An array of arrays.\n   */\n\n  this.getSourceDataArray = function (row, column, row2, column2) {\n    var data;\n    if (row === void 0) {\n      data = dataSource.getData(true);\n    } else {\n      data = dataSource.getByRange(new CellCoords(row, column), new CellCoords(row2, column2), true);\n    }\n    return data;\n  };\n  /**\n   * Returns an array of column values from the data source.\n   *\n   * @memberof Core#\n   * @function getSourceDataAtCol\n   * @param {number} column Visual column index.\n   * @returns {Array} Array of the column's cell values.\n   */\n  // TODO: Getting data from `sourceData` should work always on physical indexes.\n\n  this.getSourceDataAtCol = function (column) {\n    return dataSource.getAtColumn(column);\n  };\n  /* eslint-disable jsdoc/require-param */\n\n  /**\n   * Set the provided value in the source data set at the provided coordinates.\n   *\n   * @memberof Core#\n   * @function setSourceDataAtCell\n   * @param {number|Array} row Physical row index or array of changes in format `[[row, prop, value], ...]`.\n   * @param {number|string} column Physical column index / prop name.\n   * @param {*} value The value to be set at the provided coordinates.\n   * @param {string} [source] Source of the change as a string.\n   */\n\n  /* eslint-enable jsdoc/require-param */\n\n  this.setSourceDataAtCell = function (row, column, value, source) {\n    var input = setDataInputToArray(row, column, value);\n    var isThereAnySetSourceListener = this.hasHook('afterSetSourceDataAtCell');\n    var changesForHook = [];\n    if (isThereAnySetSourceListener) {\n      arrayEach(input, function (_ref15) {\n        var _ref16 = _slicedToArray(_ref15, 3),\n          changeRow = _ref16[0],\n          changeProp = _ref16[1],\n          changeValue = _ref16[2];\n        changesForHook.push([changeRow, changeProp, dataSource.getAtCell(changeRow, changeProp),\n        // The previous value.\n        changeValue]);\n      });\n    }\n    arrayEach(input, function (_ref17) {\n      var _ref18 = _slicedToArray(_ref17, 3),\n        changeRow = _ref18[0],\n        changeProp = _ref18[1],\n        changeValue = _ref18[2];\n      dataSource.setAtCell(changeRow, changeProp, changeValue);\n    });\n    if (isThereAnySetSourceListener) {\n      this.runHooks('afterSetSourceDataAtCell', changesForHook, source);\n    }\n    this.render();\n    var activeEditor = instance.getActiveEditor();\n    if (activeEditor && isDefined(activeEditor.refreshValue)) {\n      activeEditor.refreshValue();\n    }\n  };\n  /**\n   * Returns a single row of the data (array or object, depending on what data format you use).\n   *\n   * __Note__: This method does not participate in data transformation. If the visual data of the table is reordered,\n   * sorted or trimmed only physical indexes are correct.\n   *\n   * @memberof Core#\n   * @function getSourceDataAtRow\n   * @param {number} row Physical row index.\n   * @returns {Array|object} Single row of data.\n   */\n\n  this.getSourceDataAtRow = function (row) {\n    return dataSource.getAtRow(row);\n  };\n  /**\n   * Returns a single value from the data source.\n   *\n   * @memberof Core#\n   * @function getSourceDataAtCell\n   * @param {number} row Physical row index.\n   * @param {number} column Visual column index.\n   * @returns {*} Cell data.\n   */\n  // TODO: Getting data from `sourceData` should work always on physical indexes.\n\n  this.getSourceDataAtCell = function (row, column) {\n    return dataSource.getAtCell(row, column);\n  };\n  /**\n   * @description\n   * Returns a single row of the data.\n   *\n   * __Note__: If rows were reordered, sorted or trimmed, the currently visible order will be used.\n   *\n   * @memberof Core#\n   * @function getDataAtRow\n   * @param {number} row Visual row index.\n   * @returns {Array} Array of row's cell data.\n   */\n\n  this.getDataAtRow = function (row) {\n    var data = datamap.getRange(new CellCoords(row, 0), new CellCoords(row, this.countCols() - 1), datamap.DESTINATION_RENDERER);\n    return data[0] || [];\n  };\n  /**\n   * @description\n   * Returns a data type defined in the Handsontable settings under the `type` key ({@link Options#type}).\n   * If there are cells with different types in the selected range, it returns `'mixed'`.\n   *\n   * __Note__: If data is reordered, sorted or trimmed, the currently visible order will be used.\n   *\n   * @memberof Core#\n   * @function getDataType\n   * @param {number} rowFrom From visual row index.\n   * @param {number} columnFrom From visual column index.\n   * @param {number} rowTo To visual row index.\n   * @param {number} columnTo To visual column index.\n   * @returns {string} Cell type (e.q: `'mixed'`, `'text'`, `'numeric'`, `'autocomplete'`).\n   */\n\n  this.getDataType = function (rowFrom, columnFrom, rowTo, columnTo) {\n    var _this4 = this;\n    var coords = rowFrom === void 0 ? [0, 0, this.countRows(), this.countCols()] : [rowFrom, columnFrom, rowTo, columnTo];\n    var rowStart = coords[0],\n      columnStart = coords[1];\n    var rowEnd = coords[2],\n      columnEnd = coords[3];\n    var previousType = null;\n    var currentType = null;\n    if (rowEnd === void 0) {\n      rowEnd = rowStart;\n    }\n    if (columnEnd === void 0) {\n      columnEnd = columnStart;\n    }\n    var type = 'mixed';\n    rangeEach(Math.max(Math.min(rowStart, rowEnd), 0), Math.max(rowStart, rowEnd), function (row) {\n      var isTypeEqual = true;\n      rangeEach(Math.max(Math.min(columnStart, columnEnd), 0), Math.max(columnStart, columnEnd), function (column) {\n        var cellType = _this4.getCellMeta(row, column);\n        currentType = cellType.type;\n        if (previousType) {\n          isTypeEqual = previousType === currentType;\n        } else {\n          previousType = currentType;\n        }\n        return isTypeEqual;\n      });\n      type = isTypeEqual ? currentType : 'mixed';\n      return isTypeEqual;\n    });\n    return type;\n  };\n  /**\n   * Remove a property defined by the `key` argument from the cell meta object for the provided `row` and `column` coordinates.\n   *\n   * @memberof Core#\n   * @function removeCellMeta\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @param {string} key Property name.\n   * @fires Hooks#beforeRemoveCellMeta\n   * @fires Hooks#afterRemoveCellMeta\n   */\n\n  this.removeCellMeta = function (row, column, key) {\n    var _ref19 = [this.toPhysicalRow(row), this.toPhysicalColumn(column)],\n      physicalRow = _ref19[0],\n      physicalColumn = _ref19[1];\n    var cachedValue = metaManager.getCellMetaKeyValue(physicalRow, physicalColumn, key);\n    var hookResult = instance.runHooks('beforeRemoveCellMeta', row, column, key, cachedValue);\n    if (hookResult !== false) {\n      metaManager.removeCellMeta(physicalRow, physicalColumn, key);\n      instance.runHooks('afterRemoveCellMeta', row, column, key, cachedValue);\n    }\n    cachedValue = null;\n  };\n  /**\n   * Removes or adds one or more rows of the cell meta objects to the cell meta collections.\n   *\n   * @since 0.30.0\n   * @memberof Core#\n   * @function spliceCellsMeta\n   * @param {number} visualIndex A visual index that specifies at what position to add/remove items.\n   * @param {number} [deleteAmount=0] The number of items to be removed. If set to 0, no cell meta objects will be removed.\n   * @param {...object} [cellMetaRows] The new cell meta row objects to be added to the cell meta collection.\n   */\n\n  this.spliceCellsMeta = function (visualIndex) {\n    var _this5 = this;\n    var deleteAmount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    for (var _len3 = arguments.length, cellMetaRows = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n      cellMetaRows[_key3 - 2] = arguments[_key3];\n    }\n    if (cellMetaRows.length > 0 && !Array.isArray(cellMetaRows[0])) {\n      throw new Error('The 3rd argument (cellMetaRows) has to be passed as an array of cell meta objects array.');\n    }\n    if (deleteAmount > 0) {\n      metaManager.removeRow(this.toPhysicalRow(visualIndex), deleteAmount);\n    }\n    if (cellMetaRows.length > 0) {\n      arrayEach(cellMetaRows.reverse(), function (cellMetaRow) {\n        metaManager.createRow(_this5.toPhysicalRow(visualIndex));\n        arrayEach(cellMetaRow, function (cellMeta, columnIndex) {\n          return _this5.setCellMetaObject(visualIndex, columnIndex, cellMeta);\n        });\n      });\n    }\n    instance.render();\n  };\n  /**\n   * Set cell meta data object defined by `prop` to the corresponding params `row` and `column`.\n   *\n   * @memberof Core#\n   * @function setCellMetaObject\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @param {object} prop Meta object.\n   */\n\n  this.setCellMetaObject = function (row, column, prop) {\n    var _this6 = this;\n    if (_typeof(prop) === 'object') {\n      objectEach(prop, function (value, key) {\n        _this6.setCellMeta(row, column, key, value);\n      });\n    }\n  };\n  /**\n   * Sets a property defined by the `key` property to the meta object of a cell corresponding to params `row` and `column`.\n   *\n   * @memberof Core#\n   * @function setCellMeta\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @param {string} key Property name.\n   * @param {string} value Property value.\n   * @fires Hooks#beforeSetCellMeta\n   * @fires Hooks#afterSetCellMeta\n   */\n\n  this.setCellMeta = function (row, column, key, value) {\n    var allowSetCellMeta = instance.runHooks('beforeSetCellMeta', row, column, key, value);\n    if (allowSetCellMeta === false) {\n      return;\n    }\n    var physicalRow = row;\n    var physicalColumn = column;\n    if (row < this.countRows()) {\n      physicalRow = this.toPhysicalRow(row);\n    }\n    if (column < this.countCols()) {\n      physicalColumn = this.toPhysicalColumn(column);\n    }\n    metaManager.setCellMeta(physicalRow, physicalColumn, key, value);\n    instance.runHooks('afterSetCellMeta', row, column, key, value);\n  };\n  /**\n   * Get all the cells meta settings at least once generated in the table (in order of cell initialization).\n   *\n   * @memberof Core#\n   * @function getCellsMeta\n   * @returns {Array} Returns an array of ColumnSettings object instances.\n   */\n\n  this.getCellsMeta = function () {\n    return metaManager.getCellsMeta();\n  };\n  /**\n   * Returns the cell properties object for the given `row` and `column` coordinates.\n   *\n   * @memberof Core#\n   * @function getCellMeta\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @returns {object} The cell properties object.\n   * @fires Hooks#beforeGetCellMeta\n   * @fires Hooks#afterGetCellMeta\n   */\n\n  this.getCellMeta = function (row, column) {\n    var physicalRow = this.toPhysicalRow(row);\n    var physicalColumn = this.toPhysicalColumn(column);\n    if (physicalRow === null) {\n      physicalRow = row;\n    }\n    if (physicalColumn === null) {\n      physicalColumn = column;\n    }\n    return metaManager.getCellMeta(physicalRow, physicalColumn, {\n      visualRow: row,\n      visualColumn: column\n    });\n  };\n  /**\n   * Returns an array of cell meta objects for specified physical row index.\n   *\n   * @memberof Core#\n   * @function getCellMetaAtRow\n   * @param {number} row Physical row index.\n   * @returns {Array}\n   */\n\n  this.getCellMetaAtRow = function (row) {\n    return metaManager.getCellsMetaAtRow(row);\n  };\n  /**\n   * Checks if the data format and config allows user to modify the column structure.\n   *\n   * @memberof Core#\n   * @function isColumnModificationAllowed\n   * @returns {boolean}\n   */\n\n  this.isColumnModificationAllowed = function () {\n    return !(instance.dataType === 'object' || tableMeta.columns);\n  };\n  var rendererLookup = cellMethodLookupFactory('renderer');\n  /**\n   * Returns the cell renderer function by given `row` and `column` arguments.\n   *\n   * @memberof Core#\n   * @function getCellRenderer\n   * @param {number|object} row Visual row index or cell meta object (see {@link Core#getCellMeta}).\n   * @param {number} column Visual column index.\n   * @returns {Function} The renderer function.\n   * @example\n   * ```js\n   * // Get cell renderer using `row` and `column` coordinates.\n   * hot.getCellRenderer(1, 1);\n   * // Get cell renderer using cell meta object.\n   * hot.getCellRenderer(hot.getCellMeta(1, 1));\n   * ```\n   */\n\n  this.getCellRenderer = function (row, column) {\n    return getRenderer(rendererLookup.call(this, row, column));\n  };\n  /**\n   * Returns the cell editor class by the provided `row` and `column` arguments.\n   *\n   * @memberof Core#\n   * @function getCellEditor\n   * @param {number} row Visual row index or cell meta object (see {@link Core#getCellMeta}).\n   * @param {number} column Visual column index.\n   * @returns {Function} The editor class.\n   * @example\n   * ```js\n   * // Get cell editor class using `row` and `column` coordinates.\n   * hot.getCellEditor(1, 1);\n   * // Get cell editor class using cell meta object.\n   * hot.getCellEditor(hot.getCellMeta(1, 1));\n   * ```\n   */\n\n  this.getCellEditor = cellMethodLookupFactory('editor');\n  var validatorLookup = cellMethodLookupFactory('validator');\n  /**\n   * Returns the cell validator by `row` and `column`.\n   *\n   * @memberof Core#\n   * @function getCellValidator\n   * @param {number|object} row Visual row index or cell meta object (see {@link Core#getCellMeta}).\n   * @param {number} column Visual column index.\n   * @returns {Function|RegExp|undefined} The validator function.\n   * @example\n   * ```js\n   * // Get cell valiator using `row` and `column` coordinates.\n   * hot.getCellValidator(1, 1);\n   * // Get cell valiator using cell meta object.\n   * hot.getCellValidator(hot.getCellMeta(1, 1));\n   * ```\n   */\n\n  this.getCellValidator = function (row, column) {\n    var validator = validatorLookup.call(this, row, column);\n    if (typeof validator === 'string') {\n      validator = getValidator(validator);\n    }\n    return validator;\n  };\n  /**\n   * Validates all cells using their validator functions and calls callback when finished.\n   *\n   * If one of the cells is invalid, the callback will be fired with `'valid'` arguments as `false` - otherwise it\n   * would equal `true`.\n   *\n   * @memberof Core#\n   * @function validateCells\n   * @param {Function} [callback] The callback function.\n   * @example\n   * ```js\n   * hot.validateCells((valid) => {\n   *   if (valid) {\n   *     // ... code for validated cells\n   *   }\n   * })\n   * ```\n   */\n\n  this.validateCells = function (callback) {\n    this._validateCells(callback);\n  };\n  /**\n   * Validates rows using their validator functions and calls callback when finished.\n   *\n   * If one of the cells is invalid, the callback will be fired with `'valid'` arguments as `false` - otherwise it\n   *  would equal `true`.\n   *\n   * @memberof Core#\n   * @function validateRows\n   * @param {Array} [rows] Array of validation target visual row indexes.\n   * @param {Function} [callback] The callback function.\n   * @example\n   * ```js\n   * hot.validateRows([3, 4, 5], (valid) => {\n   *   if (valid) {\n   *     // ... code for validated rows\n   *   }\n   * })\n   * ```\n   */\n\n  this.validateRows = function (rows, callback) {\n    if (!Array.isArray(rows)) {\n      throw new Error('validateRows parameter `rows` must be an array');\n    }\n    this._validateCells(callback, rows);\n  };\n  /**\n   * Validates columns using their validator functions and calls callback when finished.\n   *\n   * If one of the cells is invalid, the callback will be fired with `'valid'` arguments as `false` - otherwise it\n   *  would equal `true`.\n   *\n   * @memberof Core#\n   * @function validateColumns\n   * @param {Array} [columns] Array of validation target visual columns indexes.\n   * @param {Function} [callback] The callback function.\n   * @example\n   * ```js\n   * hot.validateColumns([3, 4, 5], (valid) => {\n   *   if (valid) {\n   *     // ... code for validated columns\n   *   }\n   * })\n   * ```\n   */\n\n  this.validateColumns = function (columns, callback) {\n    if (!Array.isArray(columns)) {\n      throw new Error('validateColumns parameter `columns` must be an array');\n    }\n    this._validateCells(callback, undefined, columns);\n  };\n  /**\n   * Validates all cells using their validator functions and calls callback when finished.\n   *\n   * If one of the cells is invalid, the callback will be fired with `'valid'` arguments as `false` - otherwise it would equal `true`.\n   *\n   * Private use intended.\n   *\n   * @private\n   * @memberof Core#\n   * @function _validateCells\n   * @param {Function} [callback] The callback function.\n   * @param {Array} [rows] An array of validation target visual row indexes.\n   * @param {Array} [columns] An array of validation target visual column indexes.\n   */\n\n  this._validateCells = function (callback, rows, columns) {\n    var waitingForValidator = new ValidatorsQueue();\n    if (callback) {\n      waitingForValidator.onQueueEmpty = callback;\n    }\n    var i = instance.countRows() - 1;\n    while (i >= 0) {\n      if (rows !== undefined && rows.indexOf(i) === -1) {\n        i -= 1;\n        continue;\n      }\n      var j = instance.countCols() - 1;\n      while (j >= 0) {\n        if (columns !== undefined && columns.indexOf(j) === -1) {\n          j -= 1;\n          continue;\n        }\n        waitingForValidator.addValidatorToQueue();\n        instance.validateCell(instance.getDataAtCell(i, j), instance.getCellMeta(i, j), function (result) {\n          if (typeof result !== 'boolean') {\n            throw new Error('Validation error: result is not boolean');\n          }\n          if (result === false) {\n            waitingForValidator.valid = false;\n          }\n          waitingForValidator.removeValidatorFormQueue();\n        }, 'validateCells');\n        j -= 1;\n      }\n      i -= 1;\n    }\n    waitingForValidator.checkIfQueueIsEmpty();\n  };\n  /**\n   * Returns an array of row headers' values (if they are enabled). If param `row` was given, it returns the header of the given row as a string.\n   *\n   * @memberof Core#\n   * @function getRowHeader\n   * @param {number} [row] Visual row index.\n   * @fires Hooks#modifyRowHeader\n   * @returns {Array|string|number} Array of header values / single header value.\n   */\n\n  this.getRowHeader = function (row) {\n    var rowHeader = tableMeta.rowHeaders;\n    var physicalRow = row;\n    if (physicalRow !== void 0) {\n      physicalRow = instance.runHooks('modifyRowHeader', physicalRow);\n    }\n    if (physicalRow === void 0) {\n      rowHeader = [];\n      rangeEach(instance.countRows() - 1, function (i) {\n        rowHeader.push(instance.getRowHeader(i));\n      });\n    } else if (Array.isArray(rowHeader) && rowHeader[physicalRow] !== void 0) {\n      rowHeader = rowHeader[physicalRow];\n    } else if (isFunction(rowHeader)) {\n      rowHeader = rowHeader(physicalRow);\n    } else if (rowHeader && typeof rowHeader !== 'string' && typeof rowHeader !== 'number') {\n      rowHeader = physicalRow + 1;\n    }\n    return rowHeader;\n  };\n  /**\n   * Returns information about if this table is configured to display row headers.\n   *\n   * @memberof Core#\n   * @function hasRowHeaders\n   * @returns {boolean} `true` if the instance has the row headers enabled, `false` otherwise.\n   */\n\n  this.hasRowHeaders = function () {\n    return !!tableMeta.rowHeaders;\n  };\n  /**\n   * Returns information about if this table is configured to display column headers.\n   *\n   * @memberof Core#\n   * @function hasColHeaders\n   * @returns {boolean} `true` if the instance has the column headers enabled, `false` otherwise.\n   */\n\n  this.hasColHeaders = function () {\n    if (tableMeta.colHeaders !== void 0 && tableMeta.colHeaders !== null) {\n      // Polymer has empty value = null\n      return !!tableMeta.colHeaders;\n    }\n    for (var i = 0, ilen = instance.countCols(); i < ilen; i++) {\n      if (instance.getColHeader(i)) {\n        return true;\n      }\n    }\n    return false;\n  };\n  /**\n   * Returns an array of column headers (in string format, if they are enabled). If param `column` is given, it\n   * returns the header at the given column.\n   *\n   * @memberof Core#\n   * @function getColHeader\n   * @param {number} [column] Visual column index.\n   * @fires Hooks#modifyColHeader\n   * @returns {Array|string|number} The column header(s).\n   */\n\n  this.getColHeader = function (column) {\n    var columnIndex = instance.runHooks('modifyColHeader', column);\n    var result = tableMeta.colHeaders;\n    if (columnIndex === void 0) {\n      var out = [];\n      var ilen = instance.countCols();\n      for (var i = 0; i < ilen; i++) {\n        out.push(instance.getColHeader(i));\n      }\n      result = out;\n    } else {\n      var translateVisualIndexToColumns = function translateVisualIndexToColumns(visualColumnIndex) {\n        var arr = [];\n        var columnsLen = instance.countCols();\n        var index = 0;\n        for (; index < columnsLen; index++) {\n          if (isFunction(tableMeta.columns) && tableMeta.columns(index)) {\n            arr.push(index);\n          }\n        }\n        return arr[visualColumnIndex];\n      };\n      var physicalColumn = instance.toPhysicalColumn(columnIndex);\n      var prop = translateVisualIndexToColumns(physicalColumn);\n      if (tableMeta.colHeaders === false) {\n        result = null;\n      } else if (tableMeta.columns && isFunction(tableMeta.columns) && tableMeta.columns(prop) && tableMeta.columns(prop).title) {\n        result = tableMeta.columns(prop).title;\n      } else if (tableMeta.columns && tableMeta.columns[physicalColumn] && tableMeta.columns[physicalColumn].title) {\n        result = tableMeta.columns[physicalColumn].title;\n      } else if (Array.isArray(tableMeta.colHeaders) && tableMeta.colHeaders[physicalColumn] !== void 0) {\n        result = tableMeta.colHeaders[physicalColumn];\n      } else if (isFunction(tableMeta.colHeaders)) {\n        result = tableMeta.colHeaders(physicalColumn);\n      } else if (tableMeta.colHeaders && typeof tableMeta.colHeaders !== 'string' && typeof tableMeta.colHeaders !== 'number') {\n        result = spreadsheetColumnLabel(columnIndex); // see #1458\n      }\n    }\n    return result;\n  };\n  /**\n   * Return column width from settings (no guessing). Private use intended.\n   *\n   * @private\n   * @memberof Core#\n   * @function _getColWidthFromSettings\n   * @param {number} col Visual col index.\n   * @returns {number}\n   */\n\n  this._getColWidthFromSettings = function (col) {\n    var width; // We currently don't support cell meta objects for headers (negative values)\n\n    if (col >= 0) {\n      var cellProperties = instance.getCellMeta(0, col);\n      width = cellProperties.width;\n    }\n    if (width === void 0 || width === tableMeta.width) {\n      width = tableMeta.colWidths;\n    }\n    if (width !== void 0 && width !== null) {\n      switch (_typeof(width)) {\n        case 'object':\n          // array\n          width = width[col];\n          break;\n        case 'function':\n          width = width(col);\n          break;\n        default:\n          break;\n      }\n      if (typeof width === 'string') {\n        width = parseInt(width, 10);\n      }\n    }\n    return width;\n  };\n  /**\n   * Returns the width of the requested column.\n   *\n   * @memberof Core#\n   * @function getColWidth\n   * @param {number} column Visual column index.\n   * @returns {number} Column width.\n   * @fires Hooks#modifyColWidth\n   */\n\n  this.getColWidth = function (column) {\n    var width = instance._getColWidthFromSettings(column);\n    width = instance.runHooks('modifyColWidth', width, column);\n    if (width === void 0) {\n      width = ViewportColumnsCalculator.DEFAULT_WIDTH;\n    }\n    return width;\n  };\n  /**\n   * Return row height from settings (no guessing). Private use intended.\n   *\n   * @private\n   * @memberof Core#\n   * @function _getRowHeightFromSettings\n   * @param {number} row Visual row index.\n   * @returns {number}\n   */\n\n  this._getRowHeightFromSettings = function (row) {\n    // let cellProperties = instance.getCellMeta(row, 0);\n    // let height = cellProperties.height;\n    //\n    // if (height === void 0 || height === tableMeta.height) {\n    //  height = cellProperties.rowHeights;\n    // }\n    var height = tableMeta.rowHeights;\n    if (height !== void 0 && height !== null) {\n      switch (_typeof(height)) {\n        case 'object':\n          // array\n          height = height[row];\n          break;\n        case 'function':\n          height = height(row);\n          break;\n        default:\n          break;\n      }\n      if (typeof height === 'string') {\n        height = parseInt(height, 10);\n      }\n    }\n    return height;\n  };\n  /**\n   * Returns the row height.\n   *\n   * Mind that this method is different from the [AutoRowSize](@/api/autoRowSize.md) plugin's [`getRowHeight()`](@/api/autoRowSize.md#getrowheight) method.\n   *\n   * @memberof Core#\n   * @function getRowHeight\n   * @param {number} row Visual row index.\n   * @returns {number} The given row's height.\n   * @fires Hooks#modifyRowHeight\n   */\n\n  this.getRowHeight = function (row) {\n    var height = instance._getRowHeightFromSettings(row);\n    height = instance.runHooks('modifyRowHeight', height, row);\n    return height;\n  };\n  /**\n   * Returns the total number of rows in the data source.\n   *\n   * @memberof Core#\n   * @function countSourceRows\n   * @returns {number} Total number of rows.\n   */\n\n  this.countSourceRows = function () {\n    return dataSource.countRows();\n  };\n  /**\n   * Returns the total number of columns in the data source.\n   *\n   * @memberof Core#\n   * @function countSourceCols\n   * @returns {number} Total number of columns.\n   */\n\n  this.countSourceCols = function () {\n    return dataSource.countFirstRowKeys();\n  };\n  /**\n   * Returns the total number of visual rows in the table.\n   *\n   * @memberof Core#\n   * @function countRows\n   * @returns {number} Total number of rows.\n   */\n\n  this.countRows = function () {\n    return datamap.getLength();\n  };\n  /**\n   * Returns the total number of visible columns in the table.\n   *\n   * @memberof Core#\n   * @function countCols\n   * @returns {number} Total number of columns.\n   */\n\n  this.countCols = function () {\n    var maxCols = tableMeta.maxCols;\n    var dataLen = this.columnIndexMapper.getNotTrimmedIndexesLength();\n    return Math.min(maxCols, dataLen);\n  };\n  /**\n   * Returns the number of rendered rows (including rows partially or fully rendered outside viewport).\n   *\n   * @memberof Core#\n   * @function countRenderedRows\n   * @returns {number} Returns -1 if table is not visible.\n   */\n\n  this.countRenderedRows = function () {\n    return instance.view.wt.drawn ? instance.view.wt.wtTable.getRenderedRowsCount() : -1;\n  };\n  /**\n   * Returns the number of visible rows (rendered rows that fully fit inside viewport).\n   *\n   * @memberof Core#\n   * @function countVisibleRows\n   * @returns {number} Number of visible rows or -1.\n   */\n\n  this.countVisibleRows = function () {\n    return instance.view.wt.drawn ? instance.view.wt.wtTable.getVisibleRowsCount() : -1;\n  };\n  /**\n   * Returns the number of rendered columns (including columns partially or fully rendered outside viewport).\n   *\n   * @memberof Core#\n   * @function countRenderedCols\n   * @returns {number} Returns -1 if table is not visible.\n   */\n\n  this.countRenderedCols = function () {\n    return instance.view.wt.drawn ? instance.view.wt.wtTable.getRenderedColumnsCount() : -1;\n  };\n  /**\n   * Returns the number of visible columns. Returns -1 if table is not visible.\n   *\n   * @memberof Core#\n   * @function countVisibleCols\n   * @returns {number} Number of visible columns or -1.\n   */\n\n  this.countVisibleCols = function () {\n    return instance.view.wt.drawn ? instance.view.wt.wtTable.getVisibleColumnsCount() : -1;\n  };\n  /**\n   * Returns the number of empty rows. If the optional ending parameter is `true`, returns the\n   * number of empty rows at the bottom of the table.\n   *\n   * @memberof Core#\n   * @function countEmptyRows\n   * @param {boolean} [ending=false] If `true`, will only count empty rows at the end of the data source.\n   * @returns {number} Count empty rows.\n   */\n\n  this.countEmptyRows = function () {\n    var ending = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var emptyRows = 0;\n    rangeEachReverse(instance.countRows() - 1, function (visualIndex) {\n      if (instance.isEmptyRow(visualIndex)) {\n        emptyRows += 1;\n      } else if (ending === true) {\n        return false;\n      }\n    });\n    return emptyRows;\n  };\n  /**\n   * Returns the number of empty columns. If the optional ending parameter is `true`, returns the number of empty\n   * columns at right hand edge of the table.\n   *\n   * @memberof Core#\n   * @function countEmptyCols\n   * @param {boolean} [ending=false] If `true`, will only count empty columns at the end of the data source row.\n   * @returns {number} Count empty cols.\n   */\n\n  this.countEmptyCols = function () {\n    var ending = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (instance.countRows() < 1) {\n      return 0;\n    }\n    var emptyColumns = 0;\n    rangeEachReverse(instance.countCols() - 1, function (visualIndex) {\n      if (instance.isEmptyCol(visualIndex)) {\n        emptyColumns += 1;\n      } else if (ending === true) {\n        return false;\n      }\n    });\n    return emptyColumns;\n  };\n  /**\n   * Check if all cells in the row declared by the `row` argument are empty.\n   *\n   * @memberof Core#\n   * @function isEmptyRow\n   * @param {number} row Visual row index.\n   * @returns {boolean} `true` if the row at the given `row` is empty, `false` otherwise.\n   */\n\n  this.isEmptyRow = function (row) {\n    return tableMeta.isEmptyRow.call(instance, row);\n  };\n  /**\n   * Check if all cells in the the column declared by the `column` argument are empty.\n   *\n   * @memberof Core#\n   * @function isEmptyCol\n   * @param {number} column Column index.\n   * @returns {boolean} `true` if the column at the given `col` is empty, `false` otherwise.\n   */\n\n  this.isEmptyCol = function (column) {\n    return tableMeta.isEmptyCol.call(instance, column);\n  };\n  /**\n   * Select cell specified by `row` and `column` values or a range of cells finishing at `endRow`, `endCol`. If the table\n   * was configured to support data column properties that properties can be used to making a selection.\n   *\n   * By default, viewport will be scrolled to the selection. After the `selectCell` method had finished, the instance\n   * will be listening to keyboard input on the document.\n   *\n   * @example\n   * ```js\n   * // select a single cell\n   * hot.selectCell(2, 4);\n   * // select a single cell using column property\n   * hot.selectCell(2, 'address');\n   * // select a range of cells\n   * hot.selectCell(2, 4, 3, 5);\n   * // select a range of cells using column properties\n   * hot.selectCell(2, 'address', 3, 'phone_number');\n   * // select a range of cells without scrolling to them\n   * hot.selectCell(2, 'address', 3, 'phone_number', false);\n   * ```\n   *\n   * @memberof Core#\n   * @function selectCell\n   * @param {number} row Visual row index.\n   * @param {number|string} column Visual column index or column property.\n   * @param {number} [endRow] Visual end row index (if selecting a range).\n   * @param {number|string} [endColumn] Visual end column index or column property (if selecting a range).\n   * @param {boolean} [scrollToCell=true] If `true`, the viewport will be scrolled to the selection.\n   * @param {boolean} [changeListener=true] If `false`, Handsontable will not change keyboard events listener to himself.\n   * @returns {boolean} `true` if selection was successful, `false` otherwise.\n   */\n\n  this.selectCell = function (row, column, endRow, endColumn) {\n    var scrollToCell = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    var changeListener = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n    if (isUndefined(row) || isUndefined(column)) {\n      return false;\n    }\n    return this.selectCells([[row, column, endRow, endColumn]], scrollToCell, changeListener);\n  };\n  /**\n   * Make multiple, non-contiguous selection specified by `row` and `column` values or a range of cells\n   * finishing at `endRow`, `endColumn`. The method supports two input formats which are the same as that\n   * produces by `getSelected` and `getSelectedRange` methods.\n   *\n   * By default, viewport will be scrolled to selection. After the `selectCells` method had finished, the instance\n   * will be listening to keyboard input on the document.\n   *\n   * @example\n   * ```js\n   * // Using an array of arrays.\n   * hot.selectCells([[1, 1, 2, 2], [3, 3], [6, 2, 0, 2]]);\n   * // Using an array of arrays with defined columns as props.\n   * hot.selectCells([[1, 'id', 2, 'first_name'], [3, 'full_name'], [6, 'last_name', 0, 'first_name']]);\n   * // Using an array of CellRange objects (produced by `.getSelectedRange()` method).\n   * const selected = hot.getSelectedRange();\n   *\n   * selected[0].from.row = 0;\n   * selected[0].from.col = 0;\n   *\n   * hot.selectCells(selected);\n   * ```\n   *\n   * @memberof Core#\n   * @since 0.38.0\n   * @function selectCells\n   * @param {Array[]|CellRange[]} coords Visual coords passed as an array of array (`[[rowStart, columnStart, rowEnd, columnEnd], ...]`)\n   *                                     the same format as `getSelected` method returns or as an CellRange objects\n   *                                     which is the same format what `getSelectedRange` method returns.\n   * @param {boolean} [scrollToCell=true] If `true`, the viewport will be scrolled to the selection.\n   * @param {boolean} [changeListener=true] If `false`, Handsontable will not change keyboard events listener to himself.\n   * @returns {boolean} `true` if selection was successful, `false` otherwise.\n   */\n\n  this.selectCells = function () {\n    var coords = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [[]];\n    var scrollToCell = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var changeListener = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    if (scrollToCell === false) {\n      preventScrollingToCell = true;\n    }\n    var wasSelected = selection.selectCells(coords);\n    if (wasSelected && changeListener) {\n      instance.listen();\n    }\n    preventScrollingToCell = false;\n    return wasSelected;\n  };\n  /**\n   * Select column specified by `startColumn` visual index, column property or a range of columns finishing at `endColumn`.\n   *\n   * @example\n   * ```js\n   * // Select column using visual index.\n   * hot.selectColumns(1);\n   * // Select column using column property.\n   * hot.selectColumns('id');\n   * // Select range of columns using visual indexes.\n   * hot.selectColumns(1, 4);\n   * // Select range of columns using column properties.\n   * hot.selectColumns('id', 'last_name');\n   * ```\n   *\n   * @memberof Core#\n   * @since 0.38.0\n   * @function selectColumns\n   * @param {number} startColumn The visual column index from which the selection starts.\n   * @param {number} [endColumn=startColumn] The visual column index to which the selection finishes. If `endColumn`\n   *                                         is not defined the column defined by `startColumn` will be selected.\n   * @returns {boolean} `true` if selection was successful, `false` otherwise.\n   */\n\n  this.selectColumns = function (startColumn) {\n    var endColumn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startColumn;\n    return selection.selectColumns(startColumn, endColumn);\n  };\n  /**\n   * Select row specified by `startRow` visual index or a range of rows finishing at `endRow`.\n   *\n   * @example\n   * ```js\n   * // Select row using visual index.\n   * hot.selectRows(1);\n   * // Select range of rows using visual indexes.\n   * hot.selectRows(1, 4);\n   * ```\n   *\n   * @memberof Core#\n   * @since 0.38.0\n   * @function selectRows\n   * @param {number} startRow The visual row index from which the selection starts.\n   * @param {number} [endRow=startRow] The visual row index to which the selection finishes. If `endRow`\n   *                                   is not defined the row defined by `startRow` will be selected.\n   * @returns {boolean} `true` if selection was successful, `false` otherwise.\n   */\n\n  this.selectRows = function (startRow) {\n    var endRow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startRow;\n    return selection.selectRows(startRow, endRow);\n  };\n  /**\n   * Deselects the current cell selection on the table.\n   *\n   * @memberof Core#\n   * @function deselectCell\n   */\n\n  this.deselectCell = function () {\n    selection.deselect();\n  };\n  /**\n   * Select the whole table. The previous selection will be overwritten.\n   *\n   * @since 0.38.2\n   * @memberof Core#\n   * @function selectAll\n   * @param {boolean} [includeHeaders=true] `true` If the selection should include the row, column and corner headers,\n   * `false` otherwise.\n   */\n\n  this.selectAll = function () {\n    var includeHeaders = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    var includeRowHeaders = includeHeaders && this.hasRowHeaders();\n    var includeColumnHeaders = includeHeaders && this.hasColHeaders();\n    preventScrollingToCell = true;\n    selection.selectAll(includeRowHeaders, includeColumnHeaders);\n    preventScrollingToCell = false;\n  };\n  var getIndexToScroll = function getIndexToScroll(indexMapper, visualIndex) {\n    // Looking for a visual index on the right and then (when not found) on the left.\n    return indexMapper.getFirstNotHiddenIndex(visualIndex, 1, true);\n  };\n  /**\n   * Scroll viewport to coordinates specified by the `row` and `column` arguments.\n   *\n   * @memberof Core#\n   * @function scrollViewportTo\n   * @param {number} [row] Row index. If the last argument isn't defined we treat the index as a visual row index. Otherwise,\n   * we are using the index for numbering only this rows which may be rendered (we don't consider hidden rows).\n   * @param {number} [column] Column index. If the last argument isn't defined we treat the index as a visual column index.\n   * Otherwise, we are using the index for numbering only this columns which may be rendered (we don't consider hidden columns).\n   * @param {boolean} [snapToBottom=false] If `true`, viewport is scrolled to show the cell on the bottom of the table.\n   * @param {boolean} [snapToRight=false] If `true`, viewport is scrolled to show the cell on the right side of the table.\n   * @param {boolean} [considerHiddenIndexes=true] If `true`, we handle visual indexes, otherwise we handle only indexes which\n   * may be rendered when they are in the viewport (we don't consider hidden indexes as they aren't rendered).\n   * @returns {boolean} `true` if scroll was successful, `false` otherwise.\n   */\n\n  this.scrollViewportTo = function (row, column) {\n    var snapToBottom = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var snapToRight = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    var considerHiddenIndexes = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    var snapToTop = !snapToBottom;\n    var snapToLeft = !snapToRight;\n    var renderableRow = row;\n    var renderableColumn = column;\n    if (considerHiddenIndexes) {\n      var _isRowInteger = Number.isInteger(row);\n      var _isColumnInteger = Number.isInteger(column);\n      var visualRowToScroll = _isRowInteger ? getIndexToScroll(this.rowIndexMapper, row) : void 0;\n      var visualColumnToScroll = _isColumnInteger ? getIndexToScroll(this.columnIndexMapper, column) : void 0;\n      if (visualRowToScroll === null || visualColumnToScroll === null) {\n        return false;\n      }\n      renderableRow = _isRowInteger ? instance.rowIndexMapper.getRenderableFromVisualIndex(visualRowToScroll) : void 0;\n      renderableColumn = _isColumnInteger ? instance.columnIndexMapper.getRenderableFromVisualIndex(visualColumnToScroll) : void 0;\n    }\n    var isRowInteger = Number.isInteger(renderableRow);\n    var isColumnInteger = Number.isInteger(renderableColumn);\n    if (isRowInteger && isColumnInteger) {\n      return instance.view.scrollViewport(new CellCoords(renderableRow, renderableColumn), snapToTop, snapToRight, snapToBottom, snapToLeft);\n    }\n    if (isRowInteger && isColumnInteger === false) {\n      return instance.view.scrollViewportVertically(renderableRow, snapToTop, snapToBottom);\n    }\n    if (isColumnInteger && isRowInteger === false) {\n      return instance.view.scrollViewportHorizontally(renderableColumn, snapToRight, snapToLeft);\n    }\n    return false;\n  };\n  /**\n   * Removes the table from the DOM and destroys the instance of the Handsontable.\n   *\n   * @memberof Core#\n   * @function destroy\n   * @fires Hooks#afterDestroy\n   */\n\n  this.destroy = function () {\n    instance._clearTimeouts();\n    instance._clearImmediates();\n    if (instance.view) {\n      // in case HT is destroyed before initialization has finished\n      instance.view.destroy();\n    }\n    if (dataSource) {\n      dataSource.destroy();\n    }\n    dataSource = null;\n    metaManager.clearCache();\n    keyStateStopObserving();\n    if (isRootInstance(instance)) {\n      var licenseInfo = this.rootDocument.querySelector('#hot-display-license-info');\n      if (licenseInfo) {\n        licenseInfo.parentNode.removeChild(licenseInfo);\n      }\n    }\n    empty(instance.rootElement);\n    eventManager.destroy();\n    if (editorManager) {\n      editorManager.destroy();\n    } // The plugin's `destroy` method is called as a consequence and it should handle\n    // unregistration of plugin's maps. Some unregistered maps reset the cache.\n\n    instance.batchExecution(function () {\n      instance.rowIndexMapper.unregisterAll();\n      instance.columnIndexMapper.unregisterAll();\n      pluginsRegistry.getItems().forEach(function (_ref20) {\n        var _ref21 = _slicedToArray(_ref20, 2),\n          plugin = _ref21[1];\n        plugin.destroy();\n      });\n      pluginsRegistry.clear();\n      instance.runHooks('afterDestroy');\n    }, true);\n    Hooks.getSingleton().destroy(instance);\n    objectEach(instance, function (property, key, obj) {\n      // replace instance methods with post mortem\n      if (isFunction(property)) {\n        obj[key] = postMortem(key);\n      } else if (key !== 'guid') {\n        // replace instance properties with null (restores memory)\n        // it should not be necessary but this prevents a memory leak side effects that show itself in Jasmine tests\n        obj[key] = null;\n      }\n    });\n    instance.isDestroyed = true; // replace private properties with null (restores memory)\n    // it should not be necessary but this prevents a memory leak side effects that show itself in Jasmine tests\n\n    if (datamap) {\n      datamap.destroy();\n    }\n    instance.rowIndexMapper = null;\n    instance.columnIndexMapper = null;\n    datamap = null;\n    grid = null;\n    selection = null;\n    editorManager = null;\n    instance = null;\n  };\n  /**\n   * Replacement for all methods after the Handsontable was destroyed.\n   *\n   * @private\n   * @param {string} method The method name.\n   * @returns {Function}\n   */\n\n  function postMortem(method) {\n    return function () {\n      throw new Error(\"The \\\"\".concat(method, \"\\\" method cannot be called because this Handsontable instance has been destroyed\"));\n    };\n  }\n  /**\n   * Returns the active editor class instance.\n   *\n   * @memberof Core#\n   * @function getActiveEditor\n   * @returns {BaseEditor} The active editor instance.\n   */\n\n  this.getActiveEditor = function () {\n    return editorManager.getActiveEditor();\n  };\n  /**\n   * Returns plugin instance by provided its name.\n   *\n   * @memberof Core#\n   * @function getPlugin\n   * @param {string} pluginName The plugin name.\n   * @returns {BasePlugin|undefined} The plugin instance or undefined if there is no plugin.\n   */\n\n  this.getPlugin = function (pluginName) {\n    var unifiedPluginName = toUpperCaseFirst(pluginName); // Workaround for the UndoRedo plugin which, currently doesn't follow the plugin architecture.\n\n    if (unifiedPluginName === 'UndoRedo') {\n      return this.undoRedo;\n    }\n    return pluginsRegistry.getItem(unifiedPluginName);\n  };\n  /**\n   * Returns name of the passed plugin.\n   *\n   * @private\n   * @memberof Core#\n   * @param {BasePlugin} plugin The plugin instance.\n   * @returns {string}\n   */\n\n  this.getPluginName = function (plugin) {\n    // Workaround for the UndoRedo plugin which, currently doesn't follow the plugin architecture.\n    if (plugin === this.undoRedo) {\n      return this.undoRedo.constructor.PLUGIN_KEY;\n    }\n    return pluginsRegistry.getId(plugin);\n  };\n  /**\n   * Returns the Handsontable instance.\n   *\n   * @memberof Core#\n   * @function getInstance\n   * @returns {Handsontable} The Handsontable instance.\n   */\n\n  this.getInstance = function () {\n    return instance;\n  };\n  /**\n   * Adds listener to the specified hook name (only for this Handsontable instance).\n   *\n   * @memberof Core#\n   * @function addHook\n   * @see Hooks#add\n   * @param {string} key Hook name (see {@link Hooks}).\n   * @param {Function|Array} callback Function or array of functions.\n   * @example\n   * ```js\n   * hot.addHook('beforeInit', myCallback);\n   * ```\n   */\n\n  this.addHook = function (key, callback) {\n    Hooks.getSingleton().add(key, callback, instance);\n  };\n  /**\n   * Check if for a specified hook name there are added listeners (only for this Handsontable instance). All available\n   * hooks you will find {@link Hooks}.\n   *\n   * @memberof Core#\n   * @function hasHook\n   * @see Hooks#has\n   * @param {string} key Hook name.\n   * @returns {boolean}\n   *\n   * @example\n   * ```js\n   * const hasBeforeInitListeners = hot.hasHook('beforeInit');\n   * ```\n   */\n\n  this.hasHook = function (key) {\n    return Hooks.getSingleton().has(key, instance);\n  };\n  /**\n   * Adds listener to specified hook name (only for this Handsontable instance). After the listener is triggered,\n   * it will be automatically removed.\n   *\n   * @memberof Core#\n   * @function addHookOnce\n   * @see Hooks#once\n   * @param {string} key Hook name (see {@link Hooks}).\n   * @param {Function|Array} callback Function or array of functions.\n   * @example\n   * ```js\n   * hot.addHookOnce('beforeInit', myCallback);\n   * ```\n   */\n\n  this.addHookOnce = function (key, callback) {\n    Hooks.getSingleton().once(key, callback, instance);\n  };\n  /**\n   * Removes the hook listener previously registered with {@link Core#addHook}.\n   *\n   * @memberof Core#\n   * @function removeHook\n   * @see Hooks#remove\n   * @param {string} key Hook name.\n   * @param {Function} callback Reference to the function which has been registered using {@link Core#addHook}.\n   *\n   * @example\n   * ```js\n   * hot.removeHook('beforeInit', myCallback);\n   * ```\n   */\n\n  this.removeHook = function (key, callback) {\n    Hooks.getSingleton().remove(key, callback, instance);\n  };\n  /**\n   * Run the callbacks for the hook provided in the `key` argument using the parameters given in the other arguments.\n   *\n   * @memberof Core#\n   * @function runHooks\n   * @see Hooks#run\n   * @param {string} key Hook name.\n   * @param {*} [p1] Argument passed to the callback.\n   * @param {*} [p2] Argument passed to the callback.\n   * @param {*} [p3] Argument passed to the callback.\n   * @param {*} [p4] Argument passed to the callback.\n   * @param {*} [p5] Argument passed to the callback.\n   * @param {*} [p6] Argument passed to the callback.\n   * @returns {*}\n   *\n   * @example\n   * ```js\n   * // Run built-in hook\n   * hot.runHooks('beforeInit');\n   * // Run custom hook\n   * hot.runHooks('customAction', 10, 'foo');\n   * ```\n   */\n\n  this.runHooks = function (key, p1, p2, p3, p4, p5, p6) {\n    return Hooks.getSingleton().run(instance, key, p1, p2, p3, p4, p5, p6);\n  };\n  /**\n   * Get language phrase for specified dictionary key.\n   *\n   * @memberof Core#\n   * @function getTranslatedPhrase\n   * @since 0.35.0\n   * @param {string} dictionaryKey Constant which is dictionary key.\n   * @param {*} extraArguments Arguments which will be handled by formatters.\n   * @returns {string}\n   */\n\n  this.getTranslatedPhrase = function (dictionaryKey, extraArguments) {\n    return getTranslatedPhrase(tableMeta.language, dictionaryKey, extraArguments);\n  };\n  /**\n   * Converts instance into outerHTML of HTMLTableElement.\n   *\n   * @memberof Core#\n   * @function toHTML\n   * @since 7.1.0\n   * @returns {string}\n   */\n\n  this.toHTML = function () {\n    return instanceToHTML(_this);\n  };\n  /**\n   * Converts instance into HTMLTableElement.\n   *\n   * @memberof Core#\n   * @function toTableElement\n   * @since 7.1.0\n   * @returns {HTMLTableElement}\n   */\n\n  this.toTableElement = function () {\n    var tempElement = _this.rootDocument.createElement('div');\n    tempElement.insertAdjacentHTML('afterbegin', instanceToHTML(_this));\n    return tempElement.firstElementChild;\n  };\n  this.timeouts = [];\n  /**\n   * Sets timeout. Purpose of this method is to clear all known timeouts when `destroy` method is called.\n   *\n   * @param {number|Function} handle Handler returned from setTimeout or function to execute (it will be automatically wraped\n   *                                 by setTimeout function).\n   * @param {number} [delay=0] If first argument is passed as a function this argument set delay of the execution of that function.\n   * @private\n   */\n\n  this._registerTimeout = function (handle) {\n    var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var handleFunc = handle;\n    if (typeof handleFunc === 'function') {\n      handleFunc = setTimeout(handleFunc, delay);\n    }\n    this.timeouts.push(handleFunc);\n  };\n  /**\n   * Clears all known timeouts.\n   *\n   * @private\n   */\n\n  this._clearTimeouts = function () {\n    arrayEach(this.timeouts, function (handler) {\n      clearTimeout(handler);\n    });\n  };\n  this.immediates = [];\n  /**\n   * Execute function execution to the next event loop cycle. Purpose of this method is to clear all known timeouts when `destroy` method is called.\n   *\n   * @param {Function} callback Function to be delayed in execution.\n   * @private\n   */\n\n  this._registerImmediate = function (callback) {\n    this.immediates.push(setImmediate(callback));\n  };\n  /**\n   * Clears all known timeouts.\n   *\n   * @private\n   */\n\n  this._clearImmediates = function () {\n    arrayEach(this.immediates, function (handler) {\n      clearImmediate(handler);\n    });\n  };\n  /**\n   * Refresh selection borders. This is temporary method relic after selection rewrite.\n   *\n   * @private\n   * @param {boolean} [revertOriginal=false] If `true`, the previous value will be restored. Otherwise, the edited value will be saved.\n   * @param {boolean} [prepareEditorIfNeeded=true] If `true` the editor under the selected cell will be prepared to open.\n   */\n\n  this._refreshBorders = function () {\n    var revertOriginal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var prepareEditorIfNeeded = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    editorManager.destroyEditor(revertOriginal);\n    instance.view.render();\n    if (prepareEditorIfNeeded && selection.isSelected()) {\n      editorManager.prepareEditor();\n    }\n  };\n  /**\n   * Check if currently it is RTL direction.\n   *\n   * @private\n   * @memberof Core#\n   * @function isRtl\n   * @returns {boolean} True if RTL.\n   */\n\n  this.isRtl = function () {\n    return instance.rootWindow.getComputedStyle(instance.rootElement).direction === 'rtl';\n  };\n  /**\n   * Check if currently it is LTR direction.\n   *\n   * @private\n   * @memberof Core#\n   * @function isLtr\n   * @returns {boolean} True if LTR.\n   */\n\n  this.isLtr = function () {\n    return !instance.isRtl();\n  };\n  /**\n   * Returns 1 for LTR; -1 for RTL. Useful for calculations.\n   *\n   * @private\n   * @memberof Core#\n   * @function getDirectionFactor\n   * @returns {number} Returns 1 for LTR; -1 for RTL.\n   */\n\n  this.getDirectionFactor = function () {\n    return instance.isLtr() ? 1 : -1;\n  };\n  getPluginsNames().forEach(function (pluginName) {\n    var PluginClass = getPlugin(pluginName);\n    pluginsRegistry.addItem(pluginName, new PluginClass(_this));\n  });\n  Hooks.getSingleton().run(instance, 'construct');\n}","map":{"version":3,"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","TypeError","_i","_arr","_n","_d","_s","_e","call","next","done","push","value","length","err","Array","isArray","_toConsumableArray","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","o","minLen","_arrayLikeToArray","n","Object","toString","slice","name","from","test","iter","len","arr2","addClass","empty","removeClass","isFunction","isDefined","isUndefined","isRegExp","_injectProductInfo","isEmpty","isMobileBrowser","isIpadOS","EditorManager","EventManager","deepClone","duckSchema","isObjectEqual","isObject","deepObjectSize","hasOwnProperty","createObjectPropListener","objectEach","arrayMap","arrayEach","arrayReduce","getDifferenceOfArrays","stringToArray","pivot","instanceToHTML","getPlugin","getPluginsNames","getRenderer","getValidator","randomString","toUpperCaseFirst","rangeEach","rangeEachReverse","isNumericLike","TableView","DataSource","cellMethodLookupFactory","spreadsheetColumnLabel","IndexMapper","registerAsRootInstance","hasValidParameter","isRootInstance","CellCoords","ViewportColumnsCalculator","Hooks","hasLanguageDictionary","getValidLanguageCode","getTranslatedPhrase","warnUserAboutLanguageRegistration","normalizeLanguageCode","startObserving","keyStateStartObserving","stopObserving","keyStateStopObserving","Selection","MetaManager","DynamicCellMetaMod","replaceData","createUniqueMap","activeGuid","Core","rootElement","userSettings","_this","rootInstanceSymbol","arguments","undefined","preventScrollingToCell","instance","eventManager","datamap","dataSource","grid","editorManager","firstRun","language","metaManager","tableMeta","getTableMeta","globalMeta","getGlobalMeta","pluginsRegistry","rootDocument","ownerDocument","rootWindow","defaultView","isDestroyed","renderSuspendedCounter","executionSuspendedCounter","container","createElement","renderCall","insertBefore","firstChild","licenseKey","guid","concat","columnIndexMapper","rowIndexMapper","id","substring","visualToRenderableCoords","coords","visualRow","row","visualColumn","col","getRenderableFromVisualIndex","renderableToVisualCoords","renderableRow","renderableColumn","getVisualFromRenderableIndex","selection","countCols","countRows","propToCol","prop","isEditorOpened","getActiveEditor","isOpened","countColsTranslated","view","countRenderableColumns","countRowsTranslated","countRenderableRows","isDisabledCellSelection","getCellMeta","disableVisualSelection","onIndexMapperCacheUpdate","_ref","hiddenIndexesChanged","refresh","addLocalHook","cellCoords","runHooks","wt","wtTable","getFirstVisibleRow","getFirstVisibleColumn","preventScrolling","selectionRange","getSelectedRange","_selectionRange$curre","current","to","selectionLayerLevel","size","colToProp","isSelectedByAnyHeader","currentSelectedRange","selectedRange","scrollToCell","isTouched","isSelectedByRowHeader","isSelectedByColumnHeader","isMultiple","scrollViewport","scrollViewportVertically","scrollViewportHorizontally","_refreshBorders","cellRanges","_cellRanges$selection","changedIsMultiple","cellCoordsDelta","rowTransformDir","colTransformDir","destroyEditor","totalRows","alter","totalCols","action","index","amount","source","keepEmptyRows","delta","normalizeIndexesGroup","indexes","sortedIndexes","sort","_ref2","_ref3","_ref4","indexA","_ref5","indexB","normalizedIndexes","acc","_ref6","_ref7","groupIndex","groupAmount","previousItem","_previousItem","prevIndex","prevAmount","prevLastIndex","amountToAdd","Math","max","numberOfSourceRows","countSourceRows","maxRows","createRow","toPhysicalRow","currentFromRange","currentFromRow","_currentSelectedRange","currentToRow","currentToColumn","currentFromColumn","pop","setRangeStartOnly","setRangeEnd","createCol","createColumn","toPhysicalColumn","colHeaders","spliceArray","splice","apply","_currentSelectedRange2","_currentFromRange","_currentFromColumn","_currentSelectedRange3","_currentToRow","_currentToColumn","_currentFromRow","removeRow","offset","_ref8","_ref9","calcIndex","Number","isInteger","wasRemoved","fixedRowsTop","min","fixedRowsBottom","adjustRowsAndCols","removeCol","_ref10","_ref11","physicalColumnIndex","removeColumn","fixedColumnsLeft","Error","minRows","minSpareRows","minCols","minSpareCols","nrOfRows","emptyRows","countEmptyRows","emptyRowsMissing","rowsToCreate","emptyCols","countEmptyCols","nrOfColumns","columns","colsToCreate","dataType","emptyColsMissing","_colsToCreate","maxCols","rowCount","colCount","deselect","isSelected","range","selectionChanged","fromRow","fromCol","toRow","toCol","selectCell","adjustElementsSize","populateFromArray","start","input","end","method","direction","deltas","r","rlen","c","clen","setData","newDataByColumns","startRow","startColumn","columnsPopulationEnd","rowsPopulationEnd","populatedDataByColumns","numberOfDataColumns","numberOfColumnsToPopulate","pushedDownDataByRows","getData","pushedDownDataByColumns","fill","numberOfDataRows","numberOfRowsToPopulate","pushedRightDataByRows","map","rowData","_input$r","selected","skippedRow","skippedColumn","pushData","cellMeta","getInputValue","rowValue","rowInputLength","rowSelectionLength","allowInsertRow","colInputLength","colSelectionLength","skipRowOnPaste","allowInsertColumn","skipColumnOnPaste","readOnly","orgValue","getDataAtCell","result","orgValueSchema","valueSchema","setDataAtCell","setLanguage","languageCode","normalizedLanguageCode","setClassName","className","classSettings","element","table","globalMetaSettingsArray","settingsArray","classNameToRemove","classNameToAdd","init","data","updateSettings","getInstance","forceFullRender","render","ValidatorsQueue","resolved","validatorsInQueue","valid","addValidatorToQueue","removeValidatorFormQueue","checkIfQueueIsEmpty","onQueueEmpty","getParsedNumber","numericData","unifiedNumericData","replace","isNaN","parseFloat","validateChanges","changes","callback","activeEditor","beforeChangeResult","shouldBeCanceled","cancelChanges","waitingForValidator","isValid","_changes$i","newValue","cellProperties","type","getCellValidator","validateCell","cellPropertiesReference","allowInvalid","cell","getCell","visualCol","invalidCellClassName","applyChanges","skipThisChange","numberOfCreatedRows","numberOfCreatedColumns","set","lockEditor","unlockEditor","refreshValue","validator","canBeValidated","hidden","td","nodeName","wtSettings","settings","cellRenderer","expression","cellValue","validatorCallback","_registerImmediate","setDataInputToArray","propOrCol","column","changeSource","ilen","getAtCell","setDataAtRowProp","listen","isListening","unlisten","revertOriginal","prepareEditorIfNeeded","endRow","endCol","spliceCol","_datamap","_len","elements","_key","spliceRow","_datamap2","_len2","_key2","getSelected","_ref12","getSelectedLast","getSelectedRangeLast","emptySelectedCells","_this2","cellRange","topLeft","getTopLeftCorner","bottomRight","getBottomRightCorner","isRenderSuspended","suspendRender","resumeRender","nextValue","batchRender","wrappedOperations","isExecutionSuspended","suspendExecution","suspendOperations","resumeExecution","forceFlushChanges","resumeOperations","batchExecution","batch","refreshDimensions","_instance$view$getLas","getLastSize","lastWidth","width","lastHeight","height","_instance$rootElement","getBoundingClientRect","isSizeChanged","isResizeBlocked","wtOverlays","scrollableElement","setLastSize","updateData","_this3","newDataMap","fitToLength","getInitialColumnCount","hotInstance","dataMap","internalSource","loadData","clearCellsCache","initIndexMappers","columnsSettings","finalNrOfColumns","nrOfSourceColumns","countSourceCols","columnIndex","colToPropCache","dataSchema","schema","getSchema","initToLength","row2","column2","getAll","getRange","DESTINATION_RENDERER","getCopyableText","startCol","getCopyableData","getCopyable","dataUpdateFunction","bind","columnsAsFunc","j","rows","cols","ganttChart","tableClassName","syncOverlayTableClassNames","getSingleton","isRegistered","isDeprecated","initialHook","addHook","createMap","columnSetting","cells","clearCache","updateColumnMeta","setCellMetaObject","currentHeight","style","parseInt","initialStyle","getAttribute","setAttribute","_initialStyle","indexOf","overflow","wtViewport","resetHasOversizedColumnHeadersMarked","exportSettingsAsClassNames","updateMainScrollableElements","getValue","sel","getSettings","clear","selectAll","topmost","renderableColumnIndex","renderableRowIndex","isHidden","getCellAtCoords","getCoords","renderableCoords","toVisualRow","getVisualFromPhysicalIndex","toVisualColumn","getPhysicalFromVisualIndex","get","getDataAtRowProp","getDataAtCol","_ref13","getDataAtProp","_ref14","getSourceData","getByRange","getSourceDataArray","getSourceDataAtCol","getAtColumn","setSourceDataAtCell","isThereAnySetSourceListener","hasHook","changesForHook","_ref15","_ref16","changeRow","changeProp","changeValue","_ref17","_ref18","setAtCell","getSourceDataAtRow","getAtRow","getSourceDataAtCell","getDataAtRow","getDataType","rowFrom","columnFrom","rowTo","columnTo","_this4","rowStart","columnStart","rowEnd","columnEnd","previousType","currentType","isTypeEqual","cellType","removeCellMeta","key","_ref19","physicalRow","physicalColumn","cachedValue","getCellMetaKeyValue","hookResult","spliceCellsMeta","visualIndex","_this5","deleteAmount","_len3","cellMetaRows","_key3","reverse","cellMetaRow","_this6","setCellMeta","allowSetCellMeta","getCellsMeta","getCellMetaAtRow","getCellsMetaAtRow","isColumnModificationAllowed","rendererLookup","getCellRenderer","getCellEditor","validatorLookup","validateCells","_validateCells","validateRows","validateColumns","getRowHeader","rowHeader","rowHeaders","hasRowHeaders","hasColHeaders","getColHeader","out","translateVisualIndexToColumns","visualColumnIndex","columnsLen","title","_getColWidthFromSettings","colWidths","getColWidth","DEFAULT_WIDTH","_getRowHeightFromSettings","rowHeights","getRowHeight","countFirstRowKeys","getLength","dataLen","getNotTrimmedIndexesLength","countRenderedRows","drawn","getRenderedRowsCount","countVisibleRows","getVisibleRowsCount","countRenderedCols","getRenderedColumnsCount","countVisibleCols","getVisibleColumnsCount","ending","isEmptyRow","emptyColumns","isEmptyCol","endColumn","changeListener","selectCells","wasSelected","selectColumns","selectRows","deselectCell","includeHeaders","includeRowHeaders","includeColumnHeaders","getIndexToScroll","indexMapper","getFirstNotHiddenIndex","scrollViewportTo","snapToBottom","snapToRight","considerHiddenIndexes","snapToTop","snapToLeft","_isRowInteger","_isColumnInteger","visualRowToScroll","visualColumnToScroll","isRowInteger","isColumnInteger","destroy","_clearTimeouts","_clearImmediates","licenseInfo","querySelector","parentNode","removeChild","unregisterAll","getItems","forEach","_ref20","_ref21","plugin","property","postMortem","pluginName","unifiedPluginName","undoRedo","getItem","getPluginName","PLUGIN_KEY","getId","add","has","addHookOnce","once","removeHook","remove","p1","p2","p3","p4","p5","p6","run","dictionaryKey","extraArguments","toHTML","toTableElement","tempElement","insertAdjacentHTML","firstElementChild","timeouts","_registerTimeout","handle","delay","handleFunc","setTimeout","handler","clearTimeout","immediates","setImmediate","clearImmediate","prepareEditor","isRtl","getComputedStyle","isLtr","getDirectionFactor","PluginClass","addItem"],"sources":["/Users/priyadeliwala/Desktop/sales-dashboard/node_modules/handsontable/core.mjs"],"sourcesContent":["function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.number.is-integer.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.fill.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.reverse.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/web.timers.js\";\nimport \"core-js/modules/web.immediate.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.function.name.js\";\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport { addClass, empty, removeClass } from \"./helpers/dom/element.mjs\";\nimport { isFunction } from \"./helpers/function.mjs\";\nimport { isDefined, isUndefined, isRegExp, _injectProductInfo, isEmpty } from \"./helpers/mixed.mjs\";\nimport { isMobileBrowser, isIpadOS } from \"./helpers/browser.mjs\";\nimport EditorManager from \"./editorManager.mjs\";\nimport EventManager from \"./eventManager.mjs\";\nimport { deepClone, duckSchema, isObjectEqual, isObject, deepObjectSize, hasOwnProperty, createObjectPropListener, objectEach } from \"./helpers/object.mjs\";\nimport { arrayMap, arrayEach, arrayReduce, getDifferenceOfArrays, stringToArray, pivot } from \"./helpers/array.mjs\";\nimport { instanceToHTML } from \"./utils/parseTable.mjs\";\nimport { getPlugin, getPluginsNames } from \"./plugins/registry.mjs\";\nimport { getRenderer } from \"./renderers/registry.mjs\";\nimport { getValidator } from \"./validators/registry.mjs\";\nimport { randomString, toUpperCaseFirst } from \"./helpers/string.mjs\";\nimport { rangeEach, rangeEachReverse, isNumericLike } from \"./helpers/number.mjs\";\nimport TableView from \"./tableView.mjs\";\nimport DataSource from \"./dataSource.mjs\";\nimport { cellMethodLookupFactory, spreadsheetColumnLabel } from \"./helpers/data.mjs\";\nimport { IndexMapper } from \"./translations/index.mjs\";\nimport { registerAsRootInstance, hasValidParameter, isRootInstance } from \"./utils/rootInstance.mjs\";\nimport { CellCoords, ViewportColumnsCalculator } from \"./3rdparty/walkontable/src/index.mjs\";\nimport Hooks from \"./pluginHooks.mjs\";\nimport { hasLanguageDictionary, getValidLanguageCode, getTranslatedPhrase } from \"./i18n/registry.mjs\";\nimport { warnUserAboutLanguageRegistration, normalizeLanguageCode } from \"./i18n/utils.mjs\";\nimport { startObserving as keyStateStartObserving, stopObserving as keyStateStopObserving } from \"./utils/keyStateObserver.mjs\";\nimport { Selection } from \"./selection/index.mjs\";\nimport { MetaManager, DynamicCellMetaMod, replaceData } from \"./dataMap/index.mjs\";\nimport { createUniqueMap } from \"./utils/dataStructures/uniqueMap.mjs\";\nvar activeGuid = null;\n/* eslint-disable jsdoc/require-description-complete-sentence */\n\n/**\n * Handsontable constructor.\n *\n * @core\n * @class Core\n * @description\n *\n * The `Handsontable` class to which we refer as to `Core`, allows you to modify the grid's behavior by using one of the available public methods.\n *\n * ## How to call a method\n *\n * ```js\n * // First, let's contruct Handsontable\n * const hot = new Handsontable(document.getElementById('example'), options);\n *\n * // Then, let's use the setDataAtCell method\n * hot.setDataAtCell(0, 0, 'new value');\n * ```\n *\n * @param {HTMLElement} rootElement The element to which the Handsontable instance is injected.\n * @param {object} userSettings The user defined options.\n * @param {boolean} [rootInstanceSymbol=false] Indicates if the instance is root of all later instances created.\n */\n\nexport default function Core(rootElement, userSettings) {\n  var _this = this;\n\n  var rootInstanceSymbol = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var preventScrollingToCell = false;\n  var instance = this;\n  var eventManager = new EventManager(instance);\n  var datamap;\n  var dataSource;\n  var grid;\n  var editorManager;\n  var firstRun = true;\n  userSettings.language = getValidLanguageCode(userSettings.language);\n  var metaManager = new MetaManager(instance, userSettings, [DynamicCellMetaMod]);\n  var tableMeta = metaManager.getTableMeta();\n  var globalMeta = metaManager.getGlobalMeta();\n  var pluginsRegistry = createUniqueMap();\n\n  if (hasValidParameter(rootInstanceSymbol)) {\n    registerAsRootInstance(this);\n  } // TODO: check if references to DOM elements should be move to UI layer (Walkontable)\n\n  /**\n   * Reference to the container element.\n   *\n   * @private\n   * @type {HTMLElement}\n   */\n\n\n  this.rootElement = rootElement;\n  /**\n   * The nearest document over container.\n   *\n   * @private\n   * @type {Document}\n   */\n\n  this.rootDocument = rootElement.ownerDocument;\n  /**\n   * Window object over container's document.\n   *\n   * @private\n   * @type {Window}\n   */\n\n  this.rootWindow = this.rootDocument.defaultView;\n  /**\n   * A boolean to tell if the Handsontable has been fully destroyed. This is set to `true`\n   * after `afterDestroy` hook is called.\n   *\n   * @memberof Core#\n   * @member isDestroyed\n   * @type {boolean}\n   */\n\n  this.isDestroyed = false;\n  /**\n   * The counter determines how many times the render suspending was called. It allows\n   * tracking the nested suspending calls. For each render suspend resuming call the\n   * counter is decremented. The value equal to 0 means the render suspending feature\n   * is disabled.\n   *\n   * @private\n   * @type {number}\n   */\n\n  this.renderSuspendedCounter = 0;\n  /**\n   * The counter determines how many times the execution suspending was called. It allows\n   * tracking the nested suspending calls. For each execution suspend resuming call the\n   * counter is decremented. The value equal to 0 means the execution suspending feature\n   * is disabled.\n   *\n   * @private\n   * @type {number}\n   */\n\n  this.executionSuspendedCounter = 0;\n  keyStateStartObserving(this.rootDocument);\n  this.container = this.rootDocument.createElement('div');\n  this.renderCall = false;\n  rootElement.insertBefore(this.container, rootElement.firstChild);\n\n  if (isRootInstance(this)) {\n    _injectProductInfo(userSettings.licenseKey, rootElement);\n  }\n\n  this.guid = \"ht_\".concat(randomString()); // this is the namespace for global events\n\n  /**\n   * Instance of index mapper which is responsible for managing the column indexes.\n   *\n   * @memberof Core#\n   * @member columnIndexMapper\n   * @type {IndexMapper}\n   */\n\n  this.columnIndexMapper = new IndexMapper();\n  /**\n   * Instance of index mapper which is responsible for managing the row indexes.\n   *\n   * @memberof Core#\n   * @member rowIndexMapper\n   * @type {IndexMapper}\n   */\n\n  this.rowIndexMapper = new IndexMapper();\n  dataSource = new DataSource(instance);\n\n  if (!this.rootElement.id || this.rootElement.id.substring(0, 3) === 'ht_') {\n    this.rootElement.id = this.guid; // if root element does not have an id, assign a random id\n  }\n\n  var visualToRenderableCoords = function visualToRenderableCoords(coords) {\n    var visualRow = coords.row,\n        visualColumn = coords.col;\n    return new CellCoords( // We just store indexes for rows and columns without headers.\n    visualRow >= 0 ? instance.rowIndexMapper.getRenderableFromVisualIndex(visualRow) : visualRow, visualColumn >= 0 ? instance.columnIndexMapper.getRenderableFromVisualIndex(visualColumn) : visualColumn);\n  };\n\n  var renderableToVisualCoords = function renderableToVisualCoords(coords) {\n    var renderableRow = coords.row,\n        renderableColumn = coords.col;\n    return new CellCoords( // We just store indexes for rows and columns without headers.\n    renderableRow >= 0 ? instance.rowIndexMapper.getVisualFromRenderableIndex(renderableRow) : renderableRow, renderableColumn >= 0 ? instance.columnIndexMapper.getVisualFromRenderableIndex(renderableColumn) : renderableColumn // eslint-disable-line max-len\n    );\n  };\n\n  var selection = new Selection(tableMeta, {\n    countCols: function countCols() {\n      return instance.countCols();\n    },\n    countRows: function countRows() {\n      return instance.countRows();\n    },\n    propToCol: function propToCol(prop) {\n      return datamap.propToCol(prop);\n    },\n    isEditorOpened: function isEditorOpened() {\n      return instance.getActiveEditor() ? instance.getActiveEditor().isOpened() : false;\n    },\n    countColsTranslated: function countColsTranslated() {\n      return _this.view.countRenderableColumns();\n    },\n    countRowsTranslated: function countRowsTranslated() {\n      return _this.view.countRenderableRows();\n    },\n    visualToRenderableCoords: visualToRenderableCoords,\n    renderableToVisualCoords: renderableToVisualCoords,\n    isDisabledCellSelection: function isDisabledCellSelection(visualRow, visualColumn) {\n      return instance.getCellMeta(visualRow, visualColumn).disableVisualSelection;\n    }\n  });\n  this.selection = selection;\n\n  var onIndexMapperCacheUpdate = function onIndexMapperCacheUpdate(_ref) {\n    var hiddenIndexesChanged = _ref.hiddenIndexesChanged;\n\n    if (hiddenIndexesChanged) {\n      _this.selection.refresh();\n    }\n  };\n\n  this.columnIndexMapper.addLocalHook('cacheUpdated', onIndexMapperCacheUpdate);\n  this.rowIndexMapper.addLocalHook('cacheUpdated', onIndexMapperCacheUpdate);\n  this.selection.addLocalHook('beforeSetRangeStart', function (cellCoords) {\n    _this.runHooks('beforeSetRangeStart', cellCoords);\n  });\n  this.selection.addLocalHook('beforeSetRangeStartOnly', function (cellCoords) {\n    _this.runHooks('beforeSetRangeStartOnly', cellCoords);\n  });\n  this.selection.addLocalHook('beforeSetRangeEnd', function (cellCoords) {\n    _this.runHooks('beforeSetRangeEnd', cellCoords);\n\n    if (cellCoords.row < 0) {\n      cellCoords.row = _this.view.wt.wtTable.getFirstVisibleRow();\n    }\n\n    if (cellCoords.col < 0) {\n      cellCoords.col = _this.view.wt.wtTable.getFirstVisibleColumn();\n    }\n  });\n  this.selection.addLocalHook('afterSetRangeEnd', function (cellCoords) {\n    var preventScrolling = createObjectPropListener(false);\n\n    var selectionRange = _this.selection.getSelectedRange();\n\n    var _selectionRange$curre = selectionRange.current(),\n        from = _selectionRange$curre.from,\n        to = _selectionRange$curre.to;\n\n    var selectionLayerLevel = selectionRange.size() - 1;\n\n    _this.runHooks('afterSelection', from.row, from.col, to.row, to.col, preventScrolling, selectionLayerLevel);\n\n    _this.runHooks('afterSelectionByProp', from.row, instance.colToProp(from.col), to.row, instance.colToProp(to.col), preventScrolling, selectionLayerLevel); // eslint-disable-line max-len\n\n\n    var isSelectedByAnyHeader = _this.selection.isSelectedByAnyHeader();\n\n    var currentSelectedRange = _this.selection.selectedRange.current();\n\n    var scrollToCell = true;\n\n    if (preventScrollingToCell) {\n      scrollToCell = false;\n    }\n\n    if (preventScrolling.isTouched()) {\n      scrollToCell = !preventScrolling.value;\n    }\n\n    var isSelectedByRowHeader = _this.selection.isSelectedByRowHeader();\n\n    var isSelectedByColumnHeader = _this.selection.isSelectedByColumnHeader();\n\n    if (scrollToCell !== false) {\n      if (!isSelectedByAnyHeader) {\n        if (currentSelectedRange && !_this.selection.isMultiple()) {\n          _this.view.scrollViewport(visualToRenderableCoords(currentSelectedRange.from));\n        } else {\n          _this.view.scrollViewport(visualToRenderableCoords(cellCoords));\n        }\n      } else if (isSelectedByRowHeader) {\n        _this.view.scrollViewportVertically(instance.rowIndexMapper.getRenderableFromVisualIndex(cellCoords.row));\n      } else if (isSelectedByColumnHeader) {\n        _this.view.scrollViewportHorizontally(instance.columnIndexMapper.getRenderableFromVisualIndex(cellCoords.col));\n      }\n    } // @TODO: These CSS classes are no longer needed anymore. They are used only as a indicator of the selected\n    // rows/columns in the MergedCells plugin (via border.js#L520 in the walkontable module). After fixing\n    // the Border class this should be removed.\n\n\n    if (isSelectedByRowHeader && isSelectedByColumnHeader) {\n      addClass(_this.rootElement, ['ht__selection--rows', 'ht__selection--columns']);\n    } else if (isSelectedByRowHeader) {\n      removeClass(_this.rootElement, 'ht__selection--columns');\n      addClass(_this.rootElement, 'ht__selection--rows');\n    } else if (isSelectedByColumnHeader) {\n      removeClass(_this.rootElement, 'ht__selection--rows');\n      addClass(_this.rootElement, 'ht__selection--columns');\n    } else {\n      removeClass(_this.rootElement, ['ht__selection--rows', 'ht__selection--columns']);\n    }\n\n    _this._refreshBorders(null);\n  });\n  this.selection.addLocalHook('afterSelectionFinished', function (cellRanges) {\n    var selectionLayerLevel = cellRanges.length - 1;\n    var _cellRanges$selection = cellRanges[selectionLayerLevel],\n        from = _cellRanges$selection.from,\n        to = _cellRanges$selection.to;\n\n    _this.runHooks('afterSelectionEnd', from.row, from.col, to.row, to.col, selectionLayerLevel);\n\n    _this.runHooks('afterSelectionEndByProp', from.row, instance.colToProp(from.col), to.row, instance.colToProp(to.col), selectionLayerLevel);\n  });\n  this.selection.addLocalHook('afterIsMultipleSelection', function (isMultiple) {\n    var changedIsMultiple = _this.runHooks('afterIsMultipleSelection', isMultiple.value);\n\n    if (isMultiple.value) {\n      isMultiple.value = changedIsMultiple;\n    }\n  });\n  this.selection.addLocalHook('beforeModifyTransformStart', function (cellCoordsDelta) {\n    _this.runHooks('modifyTransformStart', cellCoordsDelta);\n  });\n  this.selection.addLocalHook('afterModifyTransformStart', function (coords, rowTransformDir, colTransformDir) {\n    _this.runHooks('afterModifyTransformStart', coords, rowTransformDir, colTransformDir);\n  });\n  this.selection.addLocalHook('beforeModifyTransformEnd', function (cellCoordsDelta) {\n    _this.runHooks('modifyTransformEnd', cellCoordsDelta);\n  });\n  this.selection.addLocalHook('afterModifyTransformEnd', function (coords, rowTransformDir, colTransformDir) {\n    _this.runHooks('afterModifyTransformEnd', coords, rowTransformDir, colTransformDir);\n  });\n  this.selection.addLocalHook('afterDeselect', function () {\n    editorManager.destroyEditor();\n\n    _this._refreshBorders();\n\n    removeClass(_this.rootElement, ['ht__selection--rows', 'ht__selection--columns']);\n\n    _this.runHooks('afterDeselect');\n  });\n  this.selection.addLocalHook('insertRowRequire', function (totalRows) {\n    _this.alter('insert_row', totalRows, 1, 'auto');\n  });\n  this.selection.addLocalHook('insertColRequire', function (totalCols) {\n    _this.alter('insert_col', totalCols, 1, 'auto');\n  });\n  grid = {\n    /**\n     * Inserts or removes rows and columns.\n     *\n     * @private\n     * @param {string} action Possible values: \"insert_row\", \"insert_col\", \"remove_row\", \"remove_col\".\n     * @param {number|Array} index Row or column visual index which from the alter action will be triggered.\n     *                             Alter actions such as \"remove_row\" and \"remove_col\" support array indexes in the\n     *                             format `[[index, amount], [index, amount]...]` this can be used to remove\n     *                             non-consecutive columns or rows in one call.\n     * @param {number} [amount=1] Ammount rows or columns to remove.\n     * @param {string} [source] Optional. Source of hook runner.\n     * @param {boolean} [keepEmptyRows] Optional. Flag for preventing deletion of empty rows.\n     */\n    alter: function alter(action, index) {\n      var amount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      var source = arguments.length > 3 ? arguments[3] : undefined;\n      var keepEmptyRows = arguments.length > 4 ? arguments[4] : undefined;\n      var delta;\n\n      var normalizeIndexesGroup = function normalizeIndexesGroup(indexes) {\n        if (indexes.length === 0) {\n          return [];\n        }\n\n        var sortedIndexes = _toConsumableArray(indexes); // Sort the indexes in ascending order.\n\n\n        sortedIndexes.sort(function (_ref2, _ref3) {\n          var _ref4 = _slicedToArray(_ref2, 1),\n              indexA = _ref4[0];\n\n          var _ref5 = _slicedToArray(_ref3, 1),\n              indexB = _ref5[0];\n\n          if (indexA === indexB) {\n            return 0;\n          }\n\n          return indexA > indexB ? 1 : -1;\n        }); // Normalize the {index, amount} groups into bigger groups.\n\n        var normalizedIndexes = arrayReduce(sortedIndexes, function (acc, _ref6) {\n          var _ref7 = _slicedToArray(_ref6, 2),\n              groupIndex = _ref7[0],\n              groupAmount = _ref7[1];\n\n          var previousItem = acc[acc.length - 1];\n\n          var _previousItem = _slicedToArray(previousItem, 2),\n              prevIndex = _previousItem[0],\n              prevAmount = _previousItem[1];\n\n          var prevLastIndex = prevIndex + prevAmount;\n\n          if (groupIndex <= prevLastIndex) {\n            var amountToAdd = Math.max(groupAmount - (prevLastIndex - groupIndex), 0);\n            previousItem[1] += amountToAdd;\n          } else {\n            acc.push([groupIndex, groupAmount]);\n          }\n\n          return acc;\n        }, [sortedIndexes[0]]);\n        return normalizedIndexes;\n      };\n      /* eslint-disable no-case-declarations */\n\n\n      switch (action) {\n        case 'insert_row':\n          var numberOfSourceRows = instance.countSourceRows();\n\n          if (tableMeta.maxRows === numberOfSourceRows) {\n            return;\n          } // eslint-disable-next-line no-param-reassign\n\n\n          index = isDefined(index) ? index : numberOfSourceRows;\n          delta = datamap.createRow(index, amount, source);\n\n          if (delta) {\n            metaManager.createRow(instance.toPhysicalRow(index), amount);\n            var currentSelectedRange = selection.selectedRange.current();\n            var currentFromRange = currentSelectedRange === null || currentSelectedRange === void 0 ? void 0 : currentSelectedRange.from;\n            var currentFromRow = currentFromRange === null || currentFromRange === void 0 ? void 0 : currentFromRange.row; // Moving down the selection (when it exist). It should be present on the \"old\" row.\n            // TODO: The logic here should be handled by selection module.\n\n            if (isDefined(currentFromRow) && currentFromRow >= index) {\n              var _currentSelectedRange = currentSelectedRange.to,\n                  currentToRow = _currentSelectedRange.row,\n                  currentToColumn = _currentSelectedRange.col;\n              var currentFromColumn = currentFromRange.col; // Workaround: headers are not stored inside selection.\n\n              if (selection.isSelectedByRowHeader()) {\n                currentFromColumn = -1;\n              } // Remove from the stack the last added selection as that selection below will be\n              // replaced by new transformed selection.\n\n\n              selection.getSelectedRange().pop(); // I can't use transforms as they don't work in negative indexes.\n\n              selection.setRangeStartOnly(new CellCoords(currentFromRow + delta, currentFromColumn), true);\n              selection.setRangeEnd(new CellCoords(currentToRow + delta, currentToColumn)); // will call render() internally\n            } else {\n              instance._refreshBorders(); // it will call render and prepare methods\n\n            }\n          }\n\n          break;\n\n        case 'insert_col':\n          delta = datamap.createCol(index, amount, source);\n\n          if (delta) {\n            metaManager.createColumn(instance.toPhysicalColumn(index), amount);\n\n            if (Array.isArray(tableMeta.colHeaders)) {\n              var spliceArray = [index, 0];\n              spliceArray.length += delta; // inserts empty (undefined) elements at the end of an array\n\n              Array.prototype.splice.apply(tableMeta.colHeaders, spliceArray); // inserts empty (undefined) elements into the colHeader array\n            }\n\n            var _currentSelectedRange2 = selection.selectedRange.current();\n\n            var _currentFromRange = _currentSelectedRange2 === null || _currentSelectedRange2 === void 0 ? void 0 : _currentSelectedRange2.from;\n\n            var _currentFromColumn = _currentFromRange === null || _currentFromRange === void 0 ? void 0 : _currentFromRange.col; // Moving right the selection (when it exist). It should be present on the \"old\" row.\n            // TODO: The logic here should be handled by selection module.\n\n\n            if (isDefined(_currentFromColumn) && _currentFromColumn >= index) {\n              var _currentSelectedRange3 = _currentSelectedRange2.to,\n                  _currentToRow = _currentSelectedRange3.row,\n                  _currentToColumn = _currentSelectedRange3.col;\n              var _currentFromRow = _currentFromRange.row; // Workaround: headers are not stored inside selection.\n\n              if (selection.isSelectedByColumnHeader()) {\n                _currentFromRow = -1;\n              } // Remove from the stack the last added selection as that selection below will be\n              // replaced by new transformed selection.\n\n\n              selection.getSelectedRange().pop(); // I can't use transforms as they don't work in negative indexes.\n\n              selection.setRangeStartOnly(new CellCoords(_currentFromRow, _currentFromColumn + delta), true);\n              selection.setRangeEnd(new CellCoords(_currentToRow, _currentToColumn + delta)); // will call render() internally\n            } else {\n              instance._refreshBorders(); // it will call render and prepare methods\n\n            }\n          }\n\n          break;\n\n        case 'remove_row':\n          var removeRow = function removeRow(indexes) {\n            var offset = 0; // Normalize the {index, amount} groups into bigger groups.\n\n            arrayEach(indexes, function (_ref8) {\n              var _ref9 = _slicedToArray(_ref8, 2),\n                  groupIndex = _ref9[0],\n                  groupAmount = _ref9[1];\n\n              var calcIndex = isEmpty(groupIndex) ? instance.countRows() - 1 : Math.max(groupIndex - offset, 0); // If the 'index' is an integer decrease it by 'offset' otherwise pass it through to make the value\n              // compatible with datamap.removeCol method.\n\n              if (Number.isInteger(groupIndex)) {\n                // eslint-disable-next-line no-param-reassign\n                groupIndex = Math.max(groupIndex - offset, 0);\n              } // TODO: for datamap.removeRow index should be passed as it is (with undefined and null values). If not, the logic\n              // inside the datamap.removeRow breaks the removing functionality.\n\n\n              var wasRemoved = datamap.removeRow(groupIndex, groupAmount, source);\n\n              if (!wasRemoved) {\n                return;\n              }\n\n              metaManager.removeRow(instance.toPhysicalRow(calcIndex), groupAmount);\n              var totalRows = instance.countRows();\n              var fixedRowsTop = tableMeta.fixedRowsTop;\n\n              if (fixedRowsTop >= calcIndex + 1) {\n                tableMeta.fixedRowsTop -= Math.min(groupAmount, fixedRowsTop - calcIndex);\n              }\n\n              var fixedRowsBottom = tableMeta.fixedRowsBottom;\n\n              if (fixedRowsBottom && calcIndex >= totalRows - fixedRowsBottom) {\n                tableMeta.fixedRowsBottom -= Math.min(groupAmount, fixedRowsBottom);\n              }\n\n              offset += groupAmount;\n            });\n          };\n\n          if (Array.isArray(index)) {\n            removeRow(normalizeIndexesGroup(index));\n          } else {\n            removeRow([[index, amount]]);\n          }\n\n          grid.adjustRowsAndCols();\n\n          instance._refreshBorders(); // it will call render and prepare methods\n\n\n          break;\n\n        case 'remove_col':\n          var removeCol = function removeCol(indexes) {\n            var offset = 0; // Normalize the {index, amount} groups into bigger groups.\n\n            arrayEach(indexes, function (_ref10) {\n              var _ref11 = _slicedToArray(_ref10, 2),\n                  groupIndex = _ref11[0],\n                  groupAmount = _ref11[1];\n\n              var calcIndex = isEmpty(groupIndex) ? instance.countCols() - 1 : Math.max(groupIndex - offset, 0);\n              var physicalColumnIndex = instance.toPhysicalColumn(calcIndex); // If the 'index' is an integer decrease it by 'offset' otherwise pass it through to make the value\n              // compatible with datamap.removeCol method.\n\n              if (Number.isInteger(groupIndex)) {\n                // eslint-disable-next-line no-param-reassign\n                groupIndex = Math.max(groupIndex - offset, 0);\n              } // TODO: for datamap.removeCol index should be passed as it is (with undefined and null values). If not, the logic\n              // inside the datamap.removeCol breaks the removing functionality.\n\n\n              var wasRemoved = datamap.removeCol(groupIndex, groupAmount, source);\n\n              if (!wasRemoved) {\n                return;\n              }\n\n              metaManager.removeColumn(physicalColumnIndex, groupAmount);\n              var fixedColumnsLeft = tableMeta.fixedColumnsLeft;\n\n              if (fixedColumnsLeft >= calcIndex + 1) {\n                tableMeta.fixedColumnsLeft -= Math.min(groupAmount, fixedColumnsLeft - calcIndex);\n              }\n\n              if (Array.isArray(tableMeta.colHeaders)) {\n                if (typeof physicalColumnIndex === 'undefined') {\n                  physicalColumnIndex = -1;\n                }\n\n                tableMeta.colHeaders.splice(physicalColumnIndex, groupAmount);\n              }\n\n              offset += groupAmount;\n            });\n          };\n\n          if (Array.isArray(index)) {\n            removeCol(normalizeIndexesGroup(index));\n          } else {\n            removeCol([[index, amount]]);\n          }\n\n          grid.adjustRowsAndCols();\n\n          instance._refreshBorders(); // it will call render and prepare methods\n\n\n          break;\n\n        default:\n          throw new Error(\"There is no such action \\\"\".concat(action, \"\\\"\"));\n      }\n\n      if (!keepEmptyRows) {\n        grid.adjustRowsAndCols(); // makes sure that we did not add rows that will be removed in next refresh\n      }\n    },\n\n    /**\n     * Makes sure there are empty rows at the bottom of the table.\n     *\n     * @private\n     */\n    adjustRowsAndCols: function adjustRowsAndCols() {\n      var minRows = tableMeta.minRows;\n      var minSpareRows = tableMeta.minSpareRows;\n      var minCols = tableMeta.minCols;\n      var minSpareCols = tableMeta.minSpareCols;\n\n      if (minRows) {\n        // should I add empty rows to data source to meet minRows?\n        var nrOfRows = instance.countRows();\n\n        if (nrOfRows < minRows) {\n          // The synchronization with cell meta is not desired here. For `minRows` option,\n          // we don't want to touch/shift cell meta objects.\n          datamap.createRow(nrOfRows, minRows - nrOfRows, 'auto');\n        }\n      }\n\n      if (minSpareRows) {\n        var emptyRows = instance.countEmptyRows(true); // should I add empty rows to meet minSpareRows?\n\n        if (emptyRows < minSpareRows) {\n          var emptyRowsMissing = minSpareRows - emptyRows;\n          var rowsToCreate = Math.min(emptyRowsMissing, tableMeta.maxRows - instance.countSourceRows()); // The synchronization with cell meta is not desired here. For `minSpareRows` option,\n          // we don't want to touch/shift cell meta objects.\n\n          datamap.createRow(instance.countRows(), rowsToCreate, 'auto');\n        }\n      }\n\n      {\n        var emptyCols; // count currently empty cols\n\n        if (minCols || minSpareCols) {\n          emptyCols = instance.countEmptyCols(true);\n        }\n\n        var nrOfColumns = instance.countCols(); // should I add empty cols to meet minCols?\n\n        if (minCols && !tableMeta.columns && nrOfColumns < minCols) {\n          // The synchronization with cell meta is not desired here. For `minSpareRows` option,\n          // we don't want to touch/shift cell meta objects.\n          var colsToCreate = minCols - nrOfColumns;\n          emptyCols += colsToCreate;\n          datamap.createCol(nrOfColumns, colsToCreate, 'auto');\n        } // should I add empty cols to meet minSpareCols?\n\n\n        if (minSpareCols && !tableMeta.columns && instance.dataType === 'array' && emptyCols < minSpareCols) {\n          nrOfColumns = instance.countCols();\n          var emptyColsMissing = minSpareCols - emptyCols;\n\n          var _colsToCreate = Math.min(emptyColsMissing, tableMeta.maxCols - nrOfColumns); // The synchronization with cell meta is not desired here. For `minSpareRows` option,\n          // we don't want to touch/shift cell meta objects.\n\n\n          datamap.createCol(nrOfColumns, _colsToCreate, 'auto');\n        }\n      }\n      var rowCount = instance.countRows();\n      var colCount = instance.countCols();\n\n      if (rowCount === 0 || colCount === 0) {\n        selection.deselect();\n      }\n\n      if (selection.isSelected()) {\n        arrayEach(selection.selectedRange, function (range) {\n          var selectionChanged = false;\n          var fromRow = range.from.row;\n          var fromCol = range.from.col;\n          var toRow = range.to.row;\n          var toCol = range.to.col; // if selection is outside, move selection to last row\n\n          if (fromRow > rowCount - 1) {\n            fromRow = rowCount - 1;\n            selectionChanged = true;\n\n            if (toRow > fromRow) {\n              toRow = fromRow;\n            }\n          } else if (toRow > rowCount - 1) {\n            toRow = rowCount - 1;\n            selectionChanged = true;\n\n            if (fromRow > toRow) {\n              fromRow = toRow;\n            }\n          } // if selection is outside, move selection to last row\n\n\n          if (fromCol > colCount - 1) {\n            fromCol = colCount - 1;\n            selectionChanged = true;\n\n            if (toCol > fromCol) {\n              toCol = fromCol;\n            }\n          } else if (toCol > colCount - 1) {\n            toCol = colCount - 1;\n            selectionChanged = true;\n\n            if (fromCol > toCol) {\n              fromCol = toCol;\n            }\n          }\n\n          if (selectionChanged) {\n            instance.selectCell(fromRow, fromCol, toRow, toCol);\n          }\n        });\n      }\n\n      if (instance.view) {\n        instance.view.adjustElementsSize();\n      }\n    },\n\n    /**\n     * Populate the data from the provided 2d array from the given cell coordinates.\n     *\n     * @private\n     * @param {object} start Start selection position. Visual indexes.\n     * @param {Array} input 2d data array.\n     * @param {object} [end] End selection position (only for drag-down mode). Visual indexes.\n     * @param {string} [source=\"populateFromArray\"] Source information string.\n     * @param {string} [method=\"overwrite\"] Populate method. Possible options: `shift_down`, `shift_right`, `overwrite`.\n     * @param {string} direction (left|right|up|down) String specifying the direction.\n     * @param {Array} deltas The deltas array. A difference between values of adjacent cells.\n     *                       Useful **only** when the type of handled cells is `numeric`.\n     * @returns {object|undefined} Ending td in pasted area (only if any cell was changed).\n     */\n    populateFromArray: function populateFromArray(start, input, end, source, method, direction, deltas) {\n      // TODO: either remove or implement the `direction` argument. Currently it's not working at all.\n      var r;\n      var rlen;\n      var c;\n      var clen;\n      var setData = [];\n      var current = {};\n      var newDataByColumns = [];\n      var startRow = start.row;\n      var startColumn = start.col;\n      rlen = input.length;\n\n      if (rlen === 0) {\n        return false;\n      }\n\n      var columnsPopulationEnd = 0;\n      var rowsPopulationEnd = 0;\n\n      if (isObject(end)) {\n        columnsPopulationEnd = end.col - startColumn + 1;\n        rowsPopulationEnd = end.row - startRow + 1;\n      } // insert data with specified pasteMode method\n\n\n      switch (method) {\n        case 'shift_down':\n          // translate data from a list of rows to a list of columns\n          var populatedDataByColumns = pivot(input);\n          var numberOfDataColumns = populatedDataByColumns.length; // method's argument can extend the range of data population (data would be repeated)\n\n          var numberOfColumnsToPopulate = Math.max(numberOfDataColumns, columnsPopulationEnd);\n          var pushedDownDataByRows = instance.getData().slice(startRow); // translate data from a list of rows to a list of columns\n\n          var pushedDownDataByColumns = pivot(pushedDownDataByRows).slice(startColumn, startColumn + numberOfColumnsToPopulate);\n\n          for (c = 0; c < numberOfColumnsToPopulate; c += 1) {\n            if (c < numberOfDataColumns) {\n              for (r = 0, rlen = populatedDataByColumns[c].length; r < rowsPopulationEnd - rlen; r += 1) {\n                // repeating data for rows\n                populatedDataByColumns[c].push(populatedDataByColumns[c][r % rlen]);\n              }\n\n              if (c < pushedDownDataByColumns.length) {\n                newDataByColumns.push(populatedDataByColumns[c].concat(pushedDownDataByColumns[c]));\n              } else {\n                // if before data population, there was no data in the column\n                // we fill the required rows' newly-created cells with `null` values\n                newDataByColumns.push(populatedDataByColumns[c].concat(new Array(pushedDownDataByRows.length).fill(null)));\n              }\n            } else {\n              // Repeating data for columns.\n              newDataByColumns.push(populatedDataByColumns[c % numberOfDataColumns].concat(pushedDownDataByColumns[c]));\n            }\n          }\n\n          instance.populateFromArray(startRow, startColumn, pivot(newDataByColumns));\n          break;\n\n        case 'shift_right':\n          var numberOfDataRows = input.length; // method's argument can extend the range of data population (data would be repeated)\n\n          var numberOfRowsToPopulate = Math.max(numberOfDataRows, rowsPopulationEnd);\n          var pushedRightDataByRows = instance.getData().slice(startRow).map(function (rowData) {\n            return rowData.slice(startColumn);\n          });\n\n          for (r = 0; r < numberOfRowsToPopulate; r += 1) {\n            if (r < numberOfDataRows) {\n              for (c = 0, clen = input[r].length; c < columnsPopulationEnd - clen; c += 1) {\n                // repeating data for rows\n                input[r].push(input[r][c % clen]);\n              }\n\n              if (r < pushedRightDataByRows.length) {\n                for (var i = 0; i < pushedRightDataByRows[r].length; i += 1) {\n                  input[r].push(pushedRightDataByRows[r][i]);\n                }\n              } else {\n                var _input$r;\n\n                // if before data population, there was no data in the row\n                // we fill the required columns' newly-created cells with `null` values\n                (_input$r = input[r]).push.apply(_input$r, _toConsumableArray(new Array(pushedRightDataByRows[0].length).fill(null)));\n              }\n            } else {\n              // Repeating data for columns.\n              input.push(input[r % rlen].slice(0, numberOfRowsToPopulate).concat(pushedRightDataByRows[r]));\n            }\n          }\n\n          instance.populateFromArray(startRow, startColumn, input);\n          break;\n\n        case 'overwrite':\n        default:\n          // overwrite and other not specified options\n          current.row = start.row;\n          current.col = start.col;\n          var selected = {\n            // selected range\n            row: end && start ? end.row - start.row + 1 : 1,\n            col: end && start ? end.col - start.col + 1 : 1\n          };\n          var skippedRow = 0;\n          var skippedColumn = 0;\n          var pushData = true;\n          var cellMeta;\n\n          var getInputValue = function getInputValue(row) {\n            var col = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n            var rowValue = input[row % input.length];\n\n            if (col !== null) {\n              return rowValue[col % rowValue.length];\n            }\n\n            return rowValue;\n          };\n\n          var rowInputLength = input.length;\n          var rowSelectionLength = end ? end.row - start.row + 1 : 0;\n\n          if (end) {\n            rlen = rowSelectionLength;\n          } else {\n            rlen = Math.max(rowInputLength, rowSelectionLength);\n          }\n\n          for (r = 0; r < rlen; r++) {\n            if (end && current.row > end.row && rowSelectionLength > rowInputLength || !tableMeta.allowInsertRow && current.row > instance.countRows() - 1 || current.row >= tableMeta.maxRows) {\n              break;\n            }\n\n            var visualRow = r - skippedRow;\n            var colInputLength = getInputValue(visualRow).length;\n            var colSelectionLength = end ? end.col - start.col + 1 : 0;\n\n            if (end) {\n              clen = colSelectionLength;\n            } else {\n              clen = Math.max(colInputLength, colSelectionLength);\n            }\n\n            current.col = start.col;\n            cellMeta = instance.getCellMeta(current.row, current.col);\n\n            if ((source === 'CopyPaste.paste' || source === 'Autofill.fill') && cellMeta.skipRowOnPaste) {\n              skippedRow += 1;\n              current.row += 1;\n              rlen += 1;\n              /* eslint-disable no-continue */\n\n              continue;\n            }\n\n            skippedColumn = 0;\n\n            for (c = 0; c < clen; c++) {\n              if (end && current.col > end.col && colSelectionLength > colInputLength || !tableMeta.allowInsertColumn && current.col > instance.countCols() - 1 || current.col >= tableMeta.maxCols) {\n                break;\n              }\n\n              cellMeta = instance.getCellMeta(current.row, current.col);\n\n              if ((source === 'CopyPaste.paste' || source === 'Autofill.fill') && cellMeta.skipColumnOnPaste) {\n                skippedColumn += 1;\n                current.col += 1;\n                clen += 1;\n                continue;\n              }\n\n              if (cellMeta.readOnly && source !== 'UndoRedo.undo') {\n                current.col += 1;\n                /* eslint-disable no-continue */\n\n                continue;\n              }\n\n              var visualColumn = c - skippedColumn;\n              var value = getInputValue(visualRow, visualColumn);\n              var orgValue = instance.getDataAtCell(current.row, current.col);\n              var index = {\n                row: visualRow,\n                col: visualColumn\n              };\n\n              if (source === 'Autofill.fill') {\n                var result = instance.runHooks('beforeAutofillInsidePopulate', index, direction, input, deltas, {}, selected);\n\n                if (result) {\n                  value = isUndefined(result.value) ? value : result.value;\n                }\n              }\n\n              if (value !== null && _typeof(value) === 'object') {\n                // when 'value' is array and 'orgValue' is null, set 'orgValue' to\n                // an empty array so that the null value can be compared to 'value'\n                // as an empty value for the array context\n                if (Array.isArray(value) && orgValue === null) orgValue = [];\n\n                if (orgValue === null || _typeof(orgValue) !== 'object') {\n                  pushData = false;\n                } else {\n                  var orgValueSchema = duckSchema(Array.isArray(orgValue) ? orgValue : orgValue[0] || orgValue);\n                  var valueSchema = duckSchema(Array.isArray(value) ? value : value[0] || value);\n                  /* eslint-disable max-depth */\n\n                  if (isObjectEqual(orgValueSchema, valueSchema)) {\n                    value = deepClone(value);\n                  } else {\n                    pushData = false;\n                  }\n                }\n              } else if (orgValue !== null && _typeof(orgValue) === 'object') {\n                pushData = false;\n              }\n\n              if (pushData) {\n                setData.push([current.row, current.col, value]);\n              }\n\n              pushData = true;\n              current.col += 1;\n            }\n\n            current.row += 1;\n          }\n\n          instance.setDataAtCell(setData, null, null, source || 'populateFromArray');\n          break;\n      }\n    }\n  };\n  /**\n   * Internal function to set `language` key of settings.\n   *\n   * @private\n   * @param {string} languageCode Language code for specific language i.e. 'en-US', 'pt-BR', 'de-DE'.\n   * @fires Hooks#afterLanguageChange\n   */\n\n  function setLanguage(languageCode) {\n    var normalizedLanguageCode = normalizeLanguageCode(languageCode);\n\n    if (hasLanguageDictionary(normalizedLanguageCode)) {\n      instance.runHooks('beforeLanguageChange', normalizedLanguageCode);\n      globalMeta.language = normalizedLanguageCode;\n      instance.runHooks('afterLanguageChange', normalizedLanguageCode);\n    } else {\n      warnUserAboutLanguageRegistration(languageCode);\n    }\n  }\n  /**\n   * Internal function to set `className` or `tableClassName`, depending on the key from the settings object.\n   *\n   * @private\n   * @param {string} className `className` or `tableClassName` from the key in the settings object.\n   * @param {string|string[]} classSettings String or array of strings. Contains class name(s) from settings object.\n   */\n\n\n  function setClassName(className, classSettings) {\n    var element = className === 'className' ? instance.rootElement : instance.table;\n\n    if (firstRun) {\n      addClass(element, classSettings);\n    } else {\n      var globalMetaSettingsArray = [];\n      var settingsArray = [];\n\n      if (globalMeta[className]) {\n        globalMetaSettingsArray = Array.isArray(globalMeta[className]) ? globalMeta[className] : stringToArray(globalMeta[className]);\n      }\n\n      if (classSettings) {\n        settingsArray = Array.isArray(classSettings) ? classSettings : stringToArray(classSettings);\n      }\n\n      var classNameToRemove = getDifferenceOfArrays(globalMetaSettingsArray, settingsArray);\n      var classNameToAdd = getDifferenceOfArrays(settingsArray, globalMetaSettingsArray);\n\n      if (classNameToRemove.length) {\n        removeClass(element, classNameToRemove);\n      }\n\n      if (classNameToAdd.length) {\n        addClass(element, classNameToAdd);\n      }\n    }\n\n    globalMeta[className] = classSettings;\n  }\n\n  this.init = function () {\n    dataSource.setData(tableMeta.data);\n    instance.runHooks('beforeInit');\n\n    if (isMobileBrowser() || isIpadOS()) {\n      addClass(instance.rootElement, 'mobile');\n    }\n\n    this.updateSettings(tableMeta, true);\n    this.view = new TableView(this);\n    editorManager = EditorManager.getInstance(instance, tableMeta, selection);\n    instance.runHooks('init');\n    this.forceFullRender = true; // used when data was changed\n\n    this.view.render();\n\n    if (_typeof(firstRun) === 'object') {\n      instance.runHooks('afterChange', firstRun[0], firstRun[1]);\n      firstRun = false;\n    }\n\n    instance.runHooks('afterInit');\n  };\n  /**\n   * @ignore\n   * @returns {object}\n   */\n\n\n  function ValidatorsQueue() {\n    // moved this one level up so it can be used in any function here. Probably this should be moved to a separate file\n    var resolved = false;\n    return {\n      validatorsInQueue: 0,\n      valid: true,\n      addValidatorToQueue: function addValidatorToQueue() {\n        this.validatorsInQueue += 1;\n        resolved = false;\n      },\n      removeValidatorFormQueue: function removeValidatorFormQueue() {\n        this.validatorsInQueue = this.validatorsInQueue - 1 < 0 ? 0 : this.validatorsInQueue - 1;\n        this.checkIfQueueIsEmpty();\n      },\n      onQueueEmpty: function onQueueEmpty() {},\n      checkIfQueueIsEmpty: function checkIfQueueIsEmpty() {\n        if (this.validatorsInQueue === 0 && resolved === false) {\n          resolved = true;\n          this.onQueueEmpty(this.valid);\n        }\n      }\n    };\n  }\n  /**\n   * Get parsed number from numeric string.\n   *\n   * @private\n   * @param {string} numericData Float (separated by a dot or a comma) or integer.\n   * @returns {number} Number if we get data in parsable format, not changed value otherwise.\n   */\n\n\n  function getParsedNumber(numericData) {\n    // Unifying \"float like\" string. Change from value with comma determiner to value with dot determiner,\n    // for example from `450,65` to `450.65`.\n    var unifiedNumericData = numericData.replace(',', '.');\n\n    if (isNaN(parseFloat(unifiedNumericData)) === false) {\n      return parseFloat(unifiedNumericData);\n    }\n\n    return numericData;\n  }\n  /**\n   * @ignore\n   * @param {Array} changes The 2D array containing information about each of the edited cells.\n   * @param {string} source The string that identifies source of validation.\n   * @param {Function} callback The callback function fot async validation.\n   */\n\n\n  function validateChanges(changes, source, callback) {\n    if (!changes.length) {\n      return;\n    }\n\n    var activeEditor = instance.getActiveEditor();\n    var beforeChangeResult = instance.runHooks('beforeChange', changes, source || 'edit');\n    var shouldBeCanceled = true;\n\n    if (beforeChangeResult === false) {\n      if (activeEditor) {\n        activeEditor.cancelChanges();\n      }\n\n      return;\n    }\n\n    var waitingForValidator = new ValidatorsQueue();\n\n    waitingForValidator.onQueueEmpty = function (isValid) {\n      if (activeEditor && shouldBeCanceled) {\n        activeEditor.cancelChanges();\n      }\n\n      callback(isValid); // called when async validators are resolved and beforeChange was not async\n    };\n\n    for (var i = changes.length - 1; i >= 0; i--) {\n      if (changes[i] === null) {\n        changes.splice(i, 1);\n      } else {\n        var _changes$i = _slicedToArray(changes[i], 4),\n            row = _changes$i[0],\n            prop = _changes$i[1],\n            newValue = _changes$i[3];\n\n        var col = datamap.propToCol(prop);\n        var cellProperties = instance.getCellMeta(row, col);\n\n        if (cellProperties.type === 'numeric' && typeof newValue === 'string' && isNumericLike(newValue)) {\n          changes[i][3] = getParsedNumber(newValue);\n        }\n        /* eslint-disable no-loop-func */\n\n\n        if (instance.getCellValidator(cellProperties)) {\n          waitingForValidator.addValidatorToQueue();\n          instance.validateCell(changes[i][3], cellProperties, function (index, cellPropertiesReference) {\n            return function (result) {\n              if (typeof result !== 'boolean') {\n                throw new Error('Validation error: result is not boolean');\n              }\n\n              if (result === false && cellPropertiesReference.allowInvalid === false) {\n                shouldBeCanceled = false;\n                changes.splice(index, 1); // cancel the change\n\n                cellPropertiesReference.valid = true; // we cancelled the change, so cell value is still valid\n\n                var cell = instance.getCell(cellPropertiesReference.visualRow, cellPropertiesReference.visualCol);\n\n                if (cell !== null) {\n                  removeClass(cell, tableMeta.invalidCellClassName);\n                } // index -= 1;\n\n              }\n\n              waitingForValidator.removeValidatorFormQueue();\n            };\n          }(i, cellProperties), source);\n        }\n      }\n    }\n\n    waitingForValidator.checkIfQueueIsEmpty();\n  }\n  /**\n   * Internal function to apply changes. Called after validateChanges.\n   *\n   * @private\n   * @param {Array} changes Array in form of [row, prop, oldValue, newValue].\n   * @param {string} source String that identifies how this change will be described in changes array (useful in onChange callback).\n   * @fires Hooks#beforeChangeRender\n   * @fires Hooks#afterChange\n   */\n\n\n  function applyChanges(changes, source) {\n    var i = changes.length - 1;\n\n    if (i < 0) {\n      return;\n    }\n\n    for (; i >= 0; i--) {\n      var skipThisChange = false;\n\n      if (changes[i] === null) {\n        changes.splice(i, 1);\n        /* eslint-disable no-continue */\n\n        continue;\n      }\n\n      if ((changes[i][2] === null || changes[i][2] === void 0) && (changes[i][3] === null || changes[i][3] === void 0)) {\n        /* eslint-disable no-continue */\n        continue;\n      }\n\n      if (tableMeta.allowInsertRow) {\n        while (changes[i][0] > instance.countRows() - 1) {\n          var numberOfCreatedRows = datamap.createRow(void 0, void 0, source);\n\n          if (numberOfCreatedRows >= 1) {\n            metaManager.createRow(null, numberOfCreatedRows);\n          } else {\n            skipThisChange = true;\n            break;\n          }\n        }\n      }\n\n      if (instance.dataType === 'array' && (!tableMeta.columns || tableMeta.columns.length === 0) && tableMeta.allowInsertColumn) {\n        while (datamap.propToCol(changes[i][1]) > instance.countCols() - 1) {\n          var numberOfCreatedColumns = datamap.createCol(void 0, void 0, source);\n\n          if (numberOfCreatedColumns >= 1) {\n            metaManager.createColumn(null, numberOfCreatedColumns);\n          } else {\n            skipThisChange = true;\n            break;\n          }\n        }\n      }\n\n      if (skipThisChange) {\n        /* eslint-disable no-continue */\n        continue;\n      }\n\n      datamap.set(changes[i][0], changes[i][1], changes[i][3]);\n    }\n\n    instance.forceFullRender = true; // used when data was changed\n\n    grid.adjustRowsAndCols();\n    instance.runHooks('beforeChangeRender', changes, source);\n    editorManager.lockEditor();\n\n    instance._refreshBorders(null);\n\n    editorManager.unlockEditor();\n    instance.view.adjustElementsSize();\n    instance.runHooks('afterChange', changes, source || 'edit');\n    var activeEditor = instance.getActiveEditor();\n\n    if (activeEditor && isDefined(activeEditor.refreshValue)) {\n      activeEditor.refreshValue();\n    }\n  }\n  /**\n   * Validate a single cell.\n   *\n   * @memberof Core#\n   * @function validateCell\n   * @param {string|number} value The value to validate.\n   * @param {object} cellProperties The cell meta which corresponds with the value.\n   * @param {Function} callback The callback function.\n   * @param {string} source The string that identifies source of the validation.\n   */\n\n\n  this.validateCell = function (value, cellProperties, callback, source) {\n    var validator = instance.getCellValidator(cellProperties); // the `canBeValidated = false` argument suggests, that the cell passes validation by default.\n\n    /**\n     * @private\n     * @function done\n     * @param {boolean} valid Indicates if the validation was successful.\n     * @param {boolean} [canBeValidated=true] Flag which controls the validation process.\n     */\n\n    function done(valid) {\n      var canBeValidated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      // Fixes GH#3903\n      if (!canBeValidated || cellProperties.hidden === true) {\n        callback(valid);\n        return;\n      }\n\n      var col = cellProperties.visualCol;\n      var row = cellProperties.visualRow;\n      var td = instance.getCell(row, col, true);\n\n      if (td && td.nodeName !== 'TH') {\n        var renderableRow = instance.rowIndexMapper.getRenderableFromVisualIndex(row);\n        var renderableColumn = instance.columnIndexMapper.getRenderableFromVisualIndex(col);\n        instance.view.wt.wtSettings.settings.cellRenderer(renderableRow, renderableColumn, td);\n      }\n\n      callback(valid);\n    }\n\n    if (isRegExp(validator)) {\n      validator = function (expression) {\n        return function (cellValue, validatorCallback) {\n          validatorCallback(expression.test(cellValue));\n        };\n      }(validator);\n    }\n\n    if (isFunction(validator)) {\n      // eslint-disable-next-line no-param-reassign\n      value = instance.runHooks('beforeValidate', value, cellProperties.visualRow, cellProperties.prop, source); // To provide consistent behaviour, validation should be always asynchronous\n\n      instance._registerImmediate(function () {\n        validator.call(cellProperties, value, function (valid) {\n          if (!instance) {\n            return;\n          } // eslint-disable-next-line no-param-reassign\n\n\n          valid = instance.runHooks('afterValidate', valid, value, cellProperties.visualRow, cellProperties.prop, source);\n          cellProperties.valid = valid;\n          done(valid);\n          instance.runHooks('postAfterValidate', valid, value, cellProperties.visualRow, cellProperties.prop, source);\n        });\n      });\n    } else {\n      // resolve callback even if validator function was not found\n      instance._registerImmediate(function () {\n        cellProperties.valid = true;\n        done(cellProperties.valid, false);\n      });\n    }\n  };\n  /**\n   * @ignore\n   * @param {number} row The visual row index.\n   * @param {string|number} propOrCol The visual prop or column index.\n   * @param {*} value The cell value.\n   * @returns {Array}\n   */\n\n\n  function setDataInputToArray(row, propOrCol, value) {\n    if (Array.isArray(row)) {\n      // it's an array of changes\n      return row;\n    }\n\n    return [[row, propOrCol, value]];\n  }\n  /**\n   * @description\n   * Set new value to a cell. To change many cells at once (recommended way), pass an array of `changes` in format\n   * `[[row, col, value],...]` as the first argument.\n   *\n   * @memberof Core#\n   * @function setDataAtCell\n   * @param {number|Array} row Visual row index or array of changes in format `[[row, col, value],...]`.\n   * @param {number} [column] Visual column index.\n   * @param {string} [value] New value.\n   * @param {string} [source] String that identifies how this change will be described in the changes array (useful in afterChange or beforeChange callback). Set to 'edit' if left empty.\n   */\n\n\n  this.setDataAtCell = function (row, column, value, source) {\n    var input = setDataInputToArray(row, column, value);\n    var changes = [];\n    var changeSource = source;\n    var i;\n    var ilen;\n    var prop;\n\n    for (i = 0, ilen = input.length; i < ilen; i++) {\n      if (_typeof(input[i]) !== 'object') {\n        throw new Error('Method `setDataAtCell` accepts row number or changes array of arrays as its first parameter');\n      }\n\n      if (typeof input[i][1] !== 'number') {\n        throw new Error('Method `setDataAtCell` accepts row and column number as its parameters. If you want to use object property name, use method `setDataAtRowProp`'); // eslint-disable-line max-len\n      }\n\n      if (input[i][1] >= this.countCols()) {\n        prop = input[i][1];\n      } else {\n        prop = datamap.colToProp(input[i][1]);\n      }\n\n      changes.push([input[i][0], prop, dataSource.getAtCell(this.toPhysicalRow(input[i][0]), input[i][1]), input[i][2]]);\n    }\n\n    if (!changeSource && _typeof(row) === 'object') {\n      changeSource = column;\n    }\n\n    instance.runHooks('afterSetDataAtCell', changes, changeSource);\n    validateChanges(changes, changeSource, function () {\n      applyChanges(changes, changeSource);\n    });\n  };\n  /**\n   * @description\n   * Set new value to a cell. To change many cells at once (recommended way), pass an array of `changes` in format\n   * `[[row, prop, value],...]` as the first argument.\n   *\n   * @memberof Core#\n   * @function setDataAtRowProp\n   * @param {number|Array} row Visual row index or array of changes in format `[[row, prop, value], ...]`.\n   * @param {string} prop Property name or the source string (e.g. `'first.name'` or `'0'`).\n   * @param {string} value Value to be set.\n   * @param {string} [source] String that identifies how this change will be described in changes array (useful in onChange callback).\n   */\n\n\n  this.setDataAtRowProp = function (row, prop, value, source) {\n    var input = setDataInputToArray(row, prop, value);\n    var changes = [];\n    var changeSource = source;\n    var i;\n    var ilen;\n\n    for (i = 0, ilen = input.length; i < ilen; i++) {\n      changes.push([input[i][0], input[i][1], dataSource.getAtCell(this.toPhysicalRow(input[i][0]), input[i][1]), input[i][2]]);\n    }\n\n    if (!changeSource && _typeof(row) === 'object') {\n      changeSource = prop;\n    }\n\n    instance.runHooks('afterSetDataAtRowProp', changes, changeSource);\n    validateChanges(changes, changeSource, function () {\n      applyChanges(changes, changeSource);\n    });\n  };\n  /**\n   * Listen to the keyboard input on document body. This allows Handsontable to capture keyboard events and respond\n   * in the right way.\n   *\n   * @memberof Core#\n   * @function listen\n   * @fires Hooks#afterListen\n   */\n\n\n  this.listen = function () {\n    if (instance && !instance.isListening()) {\n      activeGuid = instance.guid;\n      instance.runHooks('afterListen');\n    }\n  };\n  /**\n   * Stop listening to keyboard input on the document body. Calling this method makes the Handsontable inactive for\n   * any keyboard events.\n   *\n   * @memberof Core#\n   * @function unlisten\n   */\n\n\n  this.unlisten = function () {\n    if (this.isListening()) {\n      activeGuid = null;\n      instance.runHooks('afterUnlisten');\n    }\n  };\n  /**\n   * Returns `true` if the current Handsontable instance is listening to keyboard input on document body.\n   *\n   * @memberof Core#\n   * @function isListening\n   * @returns {boolean} `true` if the instance is listening, `false` otherwise.\n   */\n\n\n  this.isListening = function () {\n    return activeGuid === instance.guid;\n  };\n  /**\n   * Destroys the current editor, render the table and prepares the editor of the newly selected cell.\n   *\n   * @memberof Core#\n   * @function destroyEditor\n   * @param {boolean} [revertOriginal=false] If `true`, the previous value will be restored. Otherwise, the edited value will be saved.\n   * @param {boolean} [prepareEditorIfNeeded=true] If `true` the editor under the selected cell will be prepared to open.\n   */\n\n\n  this.destroyEditor = function () {\n    var revertOriginal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var prepareEditorIfNeeded = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    instance._refreshBorders(revertOriginal, prepareEditorIfNeeded);\n  };\n  /**\n   * Populate cells at position with 2D input array (e.g. `[[1, 2], [3, 4]]`). Use `endRow`, `endCol` when you\n   * want to cut input when a certain row is reached.\n   *\n   * Optional `method` argument has the same effect as pasteMode option (see {@link Options#pasteMode}).\n   *\n   * @memberof Core#\n   * @function populateFromArray\n   * @param {number} row Start visual row index.\n   * @param {number} column Start visual column index.\n   * @param {Array} input 2d array.\n   * @param {number} [endRow] End visual row index (use when you want to cut input when certain row is reached).\n   * @param {number} [endCol] End visual column index (use when you want to cut input when certain column is reached).\n   * @param {string} [source=populateFromArray] Used to identify this call in the resulting events (beforeChange, afterChange).\n   * @param {string} [method=overwrite] Populate method, possible values: `'shift_down'`, `'shift_right'`, `'overwrite'`.\n   * @param {string} direction Populate direction, possible values: `'left'`, `'right'`, `'up'`, `'down'`.\n   * @param {Array} deltas The deltas array. A difference between values of adjacent cells.\n   *                       Useful **only** when the type of handled cells is `numeric`.\n   * @returns {object|undefined} Ending td in pasted area (only if any cell was changed).\n   */\n\n\n  this.populateFromArray = function (row, column, input, endRow, endCol, source, method, direction, deltas) {\n    if (!(_typeof(input) === 'object' && _typeof(input[0]) === 'object')) {\n      throw new Error('populateFromArray parameter `input` must be an array of arrays'); // API changed in 0.9-beta2, let's check if you use it correctly\n    }\n\n    var c = typeof endRow === 'number' ? new CellCoords(endRow, endCol) : null;\n    return grid.populateFromArray(new CellCoords(row, column), input, c, source, method, direction, deltas);\n  };\n  /**\n   * Adds/removes data from the column. This method works the same as Array.splice for arrays.\n   *\n   * @memberof Core#\n   * @function spliceCol\n   * @param {number} column Index of the column in which do you want to do splice.\n   * @param {number} index Index at which to start changing the array. If negative, will begin that many elements from the end.\n   * @param {number} amount An integer indicating the number of old array elements to remove. If amount is 0, no elements are removed.\n   * @param {...number} [elements] The elements to add to the array. If you don't specify any elements, spliceCol simply removes elements from the array.\n   * @returns {Array} Returns removed portion of columns.\n   */\n\n\n  this.spliceCol = function (column, index, amount) {\n    var _datamap;\n\n    for (var _len = arguments.length, elements = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n      elements[_key - 3] = arguments[_key];\n    }\n\n    return (_datamap = datamap).spliceCol.apply(_datamap, [column, index, amount].concat(elements));\n  };\n  /**\n   * Adds/removes data from the row. This method works the same as Array.splice for arrays.\n   *\n   * @memberof Core#\n   * @function spliceRow\n   * @param {number} row Index of column in which do you want to do splice.\n   * @param {number} index Index at which to start changing the array. If negative, will begin that many elements from the end.\n   * @param {number} amount An integer indicating the number of old array elements to remove. If amount is 0, no elements are removed.\n   * @param {...number} [elements] The elements to add to the array. If you don't specify any elements, spliceCol simply removes elements from the array.\n   * @returns {Array} Returns removed portion of rows.\n   */\n\n\n  this.spliceRow = function (row, index, amount) {\n    var _datamap2;\n\n    for (var _len2 = arguments.length, elements = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n      elements[_key2 - 3] = arguments[_key2];\n    }\n\n    return (_datamap2 = datamap).spliceRow.apply(_datamap2, [row, index, amount].concat(elements));\n  };\n  /**\n   * Returns indexes of the currently selected cells as an array of arrays `[[startRow, startCol, endRow, endCol],...]`.\n   *\n   * Start row and start column are the coordinates of the active cell (where the selection was started).\n   *\n   * The version 0.36.0 adds a non-consecutive selection feature. Since this version, the method returns an array of arrays.\n   * Additionally to collect the coordinates of the currently selected area (as it was previously done by the method)\n   * you need to use `getSelectedLast` method.\n   *\n   * @memberof Core#\n   * @function getSelected\n   * @returns {Array[]|undefined} An array of arrays of the selection's coordinates.\n   */\n\n\n  this.getSelected = function () {\n    // https://github.com/handsontable/handsontable/issues/44  //cjl\n    if (selection.isSelected()) {\n      return arrayMap(selection.getSelectedRange(), function (_ref12) {\n        var from = _ref12.from,\n            to = _ref12.to;\n        return [from.row, from.col, to.row, to.col];\n      });\n    }\n  };\n  /**\n   * Returns the last coordinates applied to the table as a an array `[startRow, startCol, endRow, endCol]`.\n   *\n   * @since 0.36.0\n   * @memberof Core#\n   * @function getSelectedLast\n   * @returns {Array|undefined} An array of the selection's coordinates.\n   */\n\n\n  this.getSelectedLast = function () {\n    var selected = this.getSelected();\n    var result;\n\n    if (selected && selected.length > 0) {\n      result = selected[selected.length - 1];\n    }\n\n    return result;\n  };\n  /**\n   * Returns the current selection as an array of CellRange objects.\n   *\n   * The version 0.36.0 adds a non-consecutive selection feature. Since this version, the method returns an array of arrays.\n   * Additionally to collect the coordinates of the currently selected area (as it was previously done by the method)\n   * you need to use `getSelectedRangeLast` method.\n   *\n   * @memberof Core#\n   * @function getSelectedRange\n   * @returns {CellRange[]|undefined} Selected range object or undefined if there is no selection.\n   */\n\n\n  this.getSelectedRange = function () {\n    // https://github.com/handsontable/handsontable/issues/44  //cjl\n    if (selection.isSelected()) {\n      return Array.from(selection.getSelectedRange());\n    }\n  };\n  /**\n   * Returns the last coordinates applied to the table as a CellRange object.\n   *\n   * @memberof Core#\n   * @function getSelectedRangeLast\n   * @since 0.36.0\n   * @returns {CellRange|undefined} Selected range object or undefined` if there is no selection.\n   */\n\n\n  this.getSelectedRangeLast = function () {\n    var selectedRange = this.getSelectedRange();\n    var result;\n\n    if (selectedRange && selectedRange.length > 0) {\n      result = selectedRange[selectedRange.length - 1];\n    }\n\n    return result;\n  };\n  /**\n   * Erases content from cells that have been selected in the table.\n   *\n   * @memberof Core#\n   * @function emptySelectedCells\n   * @param {string} [source] String that identifies how this change will be described in the changes array (useful in afterChange or beforeChange callback). Set to 'edit' if left empty.\n   * @since 0.36.0\n   */\n\n\n  this.emptySelectedCells = function (source) {\n    var _this2 = this;\n\n    if (!selection.isSelected() || this.countRows() === 0 || this.countCols() === 0) {\n      return;\n    }\n\n    var changes = [];\n    arrayEach(selection.getSelectedRange(), function (cellRange) {\n      var topLeft = cellRange.getTopLeftCorner();\n      var bottomRight = cellRange.getBottomRightCorner();\n      rangeEach(topLeft.row, bottomRight.row, function (row) {\n        rangeEach(topLeft.col, bottomRight.col, function (column) {\n          if (!_this2.getCellMeta(row, column).readOnly) {\n            changes.push([row, column, null]);\n          }\n        });\n      });\n    });\n\n    if (changes.length > 0) {\n      this.setDataAtCell(changes, source);\n    }\n  };\n  /**\n   * Checks if the table rendering process was suspended. See explanation in {@link Core#suspendRender}.\n   *\n   * @memberof Core#\n   * @function isRenderSuspended\n   * @since 8.3.0\n   * @returns {boolean}\n   */\n\n\n  this.isRenderSuspended = function () {\n    return this.renderSuspendedCounter > 0;\n  };\n  /**\n   * Suspends the rendering process. It's helpful to wrap the table render\n   * cycles triggered by API calls or UI actions (or both) and call the \"render\"\n   * once in the end. As a result, it improves the performance of wrapped operations.\n   * When the table is in the suspend state, most operations will have no visual\n   * effect until the rendering state is resumed. Resuming the state automatically\n   * invokes the table rendering. To make sure that after executing all operations,\n   * the table will be rendered, it's highly recommended to use the {@link Core#batchRender}\n   * method or {@link Core#batch}, which additionally aggregates the logic execution\n   * that happens behind the table.\n   *\n   * The method is intended to be used by advanced users. Suspending the rendering\n   * process could cause visual glitches when wrongly implemented.\n   *\n   * @memberof Core#\n   * @function suspendRender\n   * @since 8.3.0\n   * @example\n   * ```js\n   * hot.suspendRender();\n   * hot.alter('insert_row', 5, 45);\n   * hot.alter('insert_col', 10, 40);\n   * hot.setDataAtCell(1, 1, 'John');\n   * hot.setDataAtCell(2, 2, 'Mark');\n   * hot.setDataAtCell(3, 3, 'Ann');\n   * hot.setDataAtCell(4, 4, 'Sophia');\n   * hot.setDataAtCell(5, 5, 'Mia');\n   * hot.selectCell(0, 0);\n   * hot.resumeRender(); // It re-renders the table internally\n   * ```\n   */\n\n\n  this.suspendRender = function () {\n    this.renderSuspendedCounter += 1;\n  };\n  /**\n   * Resumes the rendering process. In combination with the {@link Core#suspendRender}\n   * method it allows aggregating the table render cycles triggered by API calls or UI\n   * actions (or both) and calls the \"render\" once in the end. When the table is in\n   * the suspend state, most operations will have no visual effect until the rendering\n   * state is resumed. Resuming the state automatically invokes the table rendering.\n   *\n   * The method is intended to be used by advanced users. Suspending the rendering\n   * process could cause visual glitches when wrongly implemented.\n   *\n   * @memberof Core#\n   * @function resumeRender\n   * @since 8.3.0\n   * @example\n   * ```js\n   * hot.suspendRender();\n   * hot.alter('insert_row', 5, 45);\n   * hot.alter('insert_col', 10, 40);\n   * hot.setDataAtCell(1, 1, 'John');\n   * hot.setDataAtCell(2, 2, 'Mark');\n   * hot.setDataAtCell(3, 3, 'Ann');\n   * hot.setDataAtCell(4, 4, 'Sophia');\n   * hot.setDataAtCell(5, 5, 'Mia');\n   * hot.selectCell(0, 0);\n   * hot.resumeRender(); // It re-renders the table internally\n   * ```\n   */\n\n\n  this.resumeRender = function () {\n    var nextValue = this.renderSuspendedCounter - 1;\n    this.renderSuspendedCounter = Math.max(nextValue, 0);\n\n    if (!this.isRenderSuspended() && nextValue === this.renderSuspendedCounter) {\n      if (this.renderCall) {\n        this.render();\n      } else {\n        this._refreshBorders(null);\n      }\n    }\n  };\n  /**\n   * Rerender the table. Calling this method starts the process of recalculating, redrawing and applying the changes\n   * to the DOM. While rendering the table all cell renderers are recalled.\n   *\n   * Calling this method manually is not recommended. Handsontable tries to render itself by choosing the most\n   * optimal moments in its lifecycle.\n   *\n   * @memberof Core#\n   * @function render\n   */\n\n\n  this.render = function () {\n    if (this.view) {\n      this.renderCall = true;\n      this.forceFullRender = true; // used when data was changed\n\n      if (!this.isRenderSuspended()) {\n        editorManager.lockEditor();\n\n        this._refreshBorders(null);\n\n        editorManager.unlockEditor();\n      }\n    }\n  };\n  /**\n   * The method aggregates multi-line API calls into a callback and postpones the\n   * table rendering process. After the execution of the operations, the table is\n   * rendered once. As a result, it improves the performance of wrapped operations.\n   * Without batching, a similar case could trigger multiple table render calls.\n   *\n   * @memberof Core#\n   * @function batchRender\n   * @param {Function} wrappedOperations Batched operations wrapped in a function.\n   * @returns {*} Returns result from the wrappedOperations callback.\n   * @since 8.3.0\n   * @example\n   * ```js\n   * hot.batchRender(() => {\n   *   hot.alter('insert_row', 5, 45);\n   *   hot.alter('insert_col', 10, 40);\n   *   hot.setDataAtCell(1, 1, 'John');\n   *   hot.setDataAtCell(2, 2, 'Mark');\n   *   hot.setDataAtCell(3, 3, 'Ann');\n   *   hot.setDataAtCell(4, 4, 'Sophia');\n   *   hot.setDataAtCell(5, 5, 'Mia');\n   *   hot.selectCell(0, 0);\n   *   // The table will be rendered once after executing the callback\n   * });\n   * ```\n   */\n\n\n  this.batchRender = function (wrappedOperations) {\n    this.suspendRender();\n    var result = wrappedOperations();\n    this.resumeRender();\n    return result;\n  };\n  /**\n   * Checks if the table indexes recalculation process was suspended. See explanation\n   * in {@link Core#suspendExecution}.\n   *\n   * @memberof Core#\n   * @function isExecutionSuspended\n   * @since 8.3.0\n   * @returns {boolean}\n   */\n\n\n  this.isExecutionSuspended = function () {\n    return this.executionSuspendedCounter > 0;\n  };\n  /**\n   * Suspends the execution process. It's helpful to wrap the table logic changes\n   * such as index changes into one call after which the cache is updated. As a result,\n   * it improves the performance of wrapped operations.\n   *\n   * The method is intended to be used by advanced users. Suspending the execution\n   * process could cause visual glitches caused by not updated the internal table cache.\n   *\n   * @memberof Core#\n   * @function suspendExecution\n   * @since 8.3.0\n   * @example\n   * ```js\n   * hot.suspendExecution();\n   * const filters = hot.getPlugin('filters');\n   *\n   * filters.addCondition(2, 'contains', ['3']);\n   * filters.filter();\n   * hot.getPlugin('columnSorting').sort({ column: 1, sortOrder: 'desc' });\n   * hot.resumeExecution(); // It updates the cache internally\n   * ```\n   */\n\n\n  this.suspendExecution = function () {\n    this.executionSuspendedCounter += 1;\n    this.columnIndexMapper.suspendOperations();\n    this.rowIndexMapper.suspendOperations();\n  };\n  /**\n   * Resumes the execution process. In combination with the {@link Core#suspendExecution}\n   * method it allows aggregating the table logic changes after which the cache is\n   * updated. Resuming the state automatically invokes the table cache updating process.\n   *\n   * The method is intended to be used by advanced users. Suspending the execution\n   * process could cause visual glitches caused by not updated the internal table cache.\n   *\n   * @memberof Core#\n   * @function resumeExecution\n   * @param {boolean} [forceFlushChanges=false] If `true`, the table internal data cache\n   * is recalculated after the execution of the batched operations. For nested\n   * {@link Core#batchExecution} calls, it can be desire to recalculate the table\n   * after each batch.\n   * @since 8.3.0\n   * @example\n   * ```js\n   * hot.suspendExecution();\n   * const filters = hot.getPlugin('filters');\n   *\n   * filters.addCondition(2, 'contains', ['3']);\n   * filters.filter();\n   * hot.getPlugin('columnSorting').sort({ column: 1, sortOrder: 'desc' });\n   * hot.resumeExecution(); // It updates the cache internally\n   * ```\n   */\n\n\n  this.resumeExecution = function () {\n    var forceFlushChanges = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var nextValue = this.executionSuspendedCounter - 1;\n    this.executionSuspendedCounter = Math.max(nextValue, 0);\n\n    if (!this.isExecutionSuspended() && nextValue === this.executionSuspendedCounter || forceFlushChanges) {\n      this.columnIndexMapper.resumeOperations();\n      this.rowIndexMapper.resumeOperations();\n    }\n  };\n  /**\n   * The method aggregates multi-line API calls into a callback and postpones the\n   * table execution process. After the execution of the operations, the internal table\n   * cache is recalculated once. As a result, it improves the performance of wrapped\n   * operations. Without batching, a similar case could trigger multiple table cache rebuilds.\n   *\n   * @memberof Core#\n   * @function batchExecution\n   * @param {Function} wrappedOperations Batched operations wrapped in a function.\n   * @param {boolean} [forceFlushChanges=false] If `true`, the table internal data cache\n   * is recalculated after the execution of the batched operations. For nested calls,\n   * it can be a desire to recalculate the table after each batch.\n   * @returns {*} Returns result from the wrappedOperations callback.\n   * @since 8.3.0\n   * @example\n   * ```js\n   * hot.batchExecution(() => {\n   *   const filters = hot.getPlugin('filters');\n   *\n   *   filters.addCondition(2, 'contains', ['3']);\n   *   filters.filter();\n   *   hot.getPlugin('columnSorting').sort({ column: 1, sortOrder: 'desc' });\n   *   // The table cache will be recalculated once after executing the callback\n   * });\n   * ```\n   */\n\n\n  this.batchExecution = function (wrappedOperations) {\n    var forceFlushChanges = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    this.suspendExecution();\n    var result = wrappedOperations();\n    this.resumeExecution(forceFlushChanges);\n    return result;\n  };\n  /**\n   * It batches the rendering process and index recalculations. The method aggregates\n   * multi-line API calls into a callback and postpones the table rendering process\n   * as well aggregates the table logic changes such as index changes into one call\n   * after which the cache is updated. After the execution of the operations, the\n   * table is rendered, and the cache is updated once. As a result, it improves the\n   * performance of wrapped operations.\n   *\n   * @memberof Core#\n   * @function batch\n   * @param {Function} wrappedOperations Batched operations wrapped in a function.\n   * @returns {*} Returns result from the wrappedOperations callback.\n   * @since 8.3.0\n   * @example\n   * ```js\n   * hot.batch(() => {\n   *   hot.alter('insert_row', 5, 45);\n   *   hot.alter('insert_col', 10, 40);\n   *   hot.setDataAtCell(1, 1, 'x');\n   *   hot.setDataAtCell(2, 2, 'c');\n   *   hot.setDataAtCell(3, 3, 'v');\n   *   hot.setDataAtCell(4, 4, 'b');\n   *   hot.setDataAtCell(5, 5, 'n');\n   *   hot.selectCell(0, 0);\n   *\n   *   const filters = hot.getPlugin('filters');\n   *\n   *   filters.addCondition(2, 'contains', ['3']);\n   *   filters.filter();\n   *   hot.getPlugin('columnSorting').sort({ column: 1, sortOrder: 'desc' });\n   *   // The table will be re-rendered and cache will be recalculated once after executing the callback\n   * });\n   * ```\n   */\n\n\n  this.batch = function (wrappedOperations) {\n    this.suspendRender();\n    this.suspendExecution();\n    var result = wrappedOperations();\n    this.resumeExecution();\n    this.resumeRender();\n    return result;\n  };\n  /**\n   * Updates dimensions of the table. The method compares previous dimensions with the current ones and updates accordingly.\n   *\n   * @memberof Core#\n   * @function refreshDimensions\n   * @fires Hooks#beforeRefreshDimensions\n   * @fires Hooks#afterRefreshDimensions\n   */\n\n\n  this.refreshDimensions = function () {\n    if (!instance.view) {\n      return;\n    }\n\n    var _instance$view$getLas = instance.view.getLastSize(),\n        lastWidth = _instance$view$getLas.width,\n        lastHeight = _instance$view$getLas.height;\n\n    var _instance$rootElement = instance.rootElement.getBoundingClientRect(),\n        width = _instance$rootElement.width,\n        height = _instance$rootElement.height;\n\n    var isSizeChanged = width !== lastWidth || height !== lastHeight;\n    var isResizeBlocked = instance.runHooks('beforeRefreshDimensions', {\n      width: lastWidth,\n      height: lastHeight\n    }, {\n      width: width,\n      height: height\n    }, isSizeChanged) === false;\n\n    if (isResizeBlocked) {\n      return;\n    }\n\n    if (isSizeChanged || instance.view.wt.wtOverlays.scrollableElement === instance.rootWindow) {\n      instance.view.setLastSize(width, height);\n      instance.render();\n    }\n\n    instance.runHooks('afterRefreshDimensions', {\n      width: lastWidth,\n      height: lastHeight\n    }, {\n      width: width,\n      height: height\n    }, isSizeChanged);\n  };\n  /**\n   * The `updateData()` method replaces Handsontable's [`data`](@/api/options.md#data) with a new dataset.\n   *\n   * The `updateData()` method:\n   * - Keeps cells' states (e.g. cells' [formatting](@/guides/cell-features/formatting-cells.md) and cells' [`readOnly`](@/api/options.md#readonly) states)\n   * - Keeps rows' states (e.g. row order)\n   * - Keeps columns' states (e.g. column order)\n   *\n   * To replace Handsontable's [`data`](@/api/options.md#data) and reset states, use the [`loadData()`](#loaddata) method.\n   *\n   * Read more:\n   * - [Binding to data &#8594;](@/guides/getting-started/binding-to-data.md)\n   * - [Saving data &#8594;](@/guides/getting-started/saving-data.md)\n   *\n   * @memberof Core#\n   * @function updateData\n   * @since 11.1.0\n   * @param {Array} data An [array of arrays](@/guides/getting-started/binding-to-data.md#array-of-arrays), or an [array of objects](@/guides/getting-started/binding-to-data.md#array-of-objects), that contains Handsontable's data\n   * @param {string} [source] The source of the `updateData()` call\n   * @fires Hooks#beforeUpdateData\n   * @fires Hooks#afterUpdateData\n   * @fires Hooks#afterChange\n   */\n\n\n  this.updateData = function (data, source) {\n    var _this3 = this;\n\n    replaceData(data, function (newDataMap) {\n      datamap = newDataMap;\n    }, function (newDataMap) {\n      datamap = newDataMap;\n      instance.columnIndexMapper.fitToLength(_this3.getInitialColumnCount());\n      instance.rowIndexMapper.fitToLength(_this3.countSourceRows());\n      grid.adjustRowsAndCols();\n    }, {\n      hotInstance: instance,\n      dataMap: datamap,\n      dataSource: dataSource,\n      internalSource: 'updateData',\n      source: source,\n      firstRun: firstRun\n    });\n  };\n  /**\n   * The `loadData()` method replaces Handsontable's [`data`](@/api/options.md#data) with a new dataset.\n   *\n   * Additionally, the `loadData()` method:\n   * - Resets cells' states (e.g. cells' [formatting](@/guides/cell-features/formatting-cells.md) and cells' [`readOnly`](@/api/options.md#readonly) states)\n   * - Resets rows' states (e.g. row order)\n   * - Resets columns' states (e.g. column order)\n   *\n   * To replace Handsontable's [`data`](@/api/options.md#data) without resetting states, use the [`updateData()`](#updatedata) method.\n   *\n   * Read more:\n   * - [Binding to data &#8594;](@/guides/getting-started/binding-to-data.md)\n   * - [Saving data &#8594;](@/guides/getting-started/saving-data.md)\n   *\n   * @memberof Core#\n   * @function loadData\n   * @param {Array} data An [array of arrays](@/guides/getting-started/binding-to-data.md#array-of-arrays), or an [array of objects](@/guides/getting-started/binding-to-data.md#array-of-objects), that contains Handsontable's data\n   * @param {string} [source] The source of the `loadData()` call\n   * @fires Hooks#beforeLoadData\n   * @fires Hooks#afterLoadData\n   * @fires Hooks#afterChange\n   */\n\n\n  this.loadData = function (data, source) {\n    replaceData(data, function (newDataMap) {\n      datamap = newDataMap;\n    }, function () {\n      metaManager.clearCellsCache();\n      instance.initIndexMappers();\n      grid.adjustRowsAndCols();\n\n      if (firstRun) {\n        firstRun = [null, 'loadData'];\n      }\n    }, {\n      hotInstance: instance,\n      dataMap: datamap,\n      dataSource: dataSource,\n      internalSource: 'loadData',\n      source: source,\n      firstRun: firstRun\n    });\n  };\n  /**\n   * Gets the initial column count, calculated based on the `columns` setting.\n   *\n   * @private\n   * @returns {number} The calculated number of columns.\n   */\n\n\n  this.getInitialColumnCount = function () {\n    var columnsSettings = tableMeta.columns;\n    var finalNrOfColumns = 0; // We will check number of columns when the `columns` property was defined as an array. Columns option may\n    // narrow down or expand displayed dataset in that case.\n\n    if (Array.isArray(columnsSettings)) {\n      finalNrOfColumns = columnsSettings.length;\n    } else if (isFunction(columnsSettings)) {\n      if (instance.dataType === 'array') {\n        var nrOfSourceColumns = this.countSourceCols();\n\n        for (var columnIndex = 0; columnIndex < nrOfSourceColumns; columnIndex += 1) {\n          if (columnsSettings(columnIndex)) {\n            finalNrOfColumns += 1;\n          }\n        } // Extended dataset by the `columns` property? Moved code right from the refactored `countCols` method.\n\n      } else if (instance.dataType === 'object' || instance.dataType === 'function') {\n        finalNrOfColumns = datamap.colToPropCache.length;\n      } // In some cases we need to check columns length from the schema, i.e. `data` may be empty.\n\n    } else if (isDefined(tableMeta.dataSchema)) {\n      var schema = datamap.getSchema(); // Schema may be defined as an array of objects. Each object will define column.\n\n      finalNrOfColumns = Array.isArray(schema) ? schema.length : deepObjectSize(schema);\n    } else {\n      // We init index mappers by length of source data to provide indexes also for skipped indexes.\n      finalNrOfColumns = this.countSourceCols();\n    }\n\n    return finalNrOfColumns;\n  };\n  /**\n   * Init index mapper which manage indexes assigned to the data.\n   *\n   * @private\n   */\n\n\n  this.initIndexMappers = function () {\n    this.columnIndexMapper.initToLength(this.getInitialColumnCount());\n    this.rowIndexMapper.initToLength(this.countSourceRows());\n  };\n  /**\n   * Returns the current data object (the same one that was passed by `data` configuration option or `loadData` method,\n   * unless some modifications have been applied (i.e. Sequence of rows/columns was changed, some row/column was skipped).\n   * If that's the case - use the {@link Core#getSourceData} method.).\n   *\n   * Optionally you can provide cell range by defining `row`, `column`, `row2`, `column2` to get only a fragment of table data.\n   *\n   * @memberof Core#\n   * @function getData\n   * @param {number} [row] From visual row index.\n   * @param {number} [column] From visual column index.\n   * @param {number} [row2] To visual row index.\n   * @param {number} [column2] To visual column index.\n   * @returns {Array[]} Array with the data.\n   * @example\n   * ```js\n   * // Get all data (in order how it is rendered in the table).\n   * hot.getData();\n   * // Get data fragment (from top-left 0, 0 to bottom-right 3, 3).\n   * hot.getData(3, 3);\n   * // Get data fragment (from top-left 2, 1 to bottom-right 3, 3).\n   * hot.getData(2, 1, 3, 3);\n   * ```\n   */\n\n\n  this.getData = function (row, column, row2, column2) {\n    if (isUndefined(row)) {\n      return datamap.getAll();\n    }\n\n    return datamap.getRange(new CellCoords(row, column), new CellCoords(row2, column2), datamap.DESTINATION_RENDERER);\n  };\n  /**\n   * Returns a string value of the selected range. Each column is separated by tab, each row is separated by a new\n   * line character.\n   *\n   * @memberof Core#\n   * @function getCopyableText\n   * @param {number} startRow From visual row index.\n   * @param {number} startCol From visual column index.\n   * @param {number} endRow To visual row index.\n   * @param {number} endCol To visual column index.\n   * @returns {string}\n   */\n\n\n  this.getCopyableText = function (startRow, startCol, endRow, endCol) {\n    return datamap.getCopyableText(new CellCoords(startRow, startCol), new CellCoords(endRow, endCol));\n  };\n  /**\n   * Returns the data's copyable value at specified `row` and `column` index.\n   *\n   * @memberof Core#\n   * @function getCopyableData\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @returns {string}\n   */\n\n\n  this.getCopyableData = function (row, column) {\n    return datamap.getCopyable(row, datamap.colToProp(column));\n  };\n  /**\n   * Returns schema provided by constructor settings. If it doesn't exist then it returns the schema based on the data\n   * structure in the first row.\n   *\n   * @memberof Core#\n   * @function getSchema\n   * @returns {object} Schema object.\n   */\n\n\n  this.getSchema = function () {\n    return datamap.getSchema();\n  };\n  /**\n   * Use it if you need to change configuration after initialization. The `settings` argument is an object containing the new\n   * settings, declared the same way as in the initial settings object.\n   *\n   * __Note__, that although the `updateSettings` method doesn't overwrite the previously declared settings, it might reset\n   * the settings made post-initialization. (for example - ignore changes made using the columnResize feature).\n   *\n   * Since 8.0.0 passing `columns` or `data` inside `settings` objects will result in resetting states corresponding to rows and columns\n   * (for example, row/column sequence, column width, row height, frozen columns etc.).\n   *\n   * @memberof Core#\n   * @function updateSettings\n   * @param {object} settings New settings object (see {@link Options}).\n   * @param {boolean} [init=false] Internally used for in initialization mode.\n   * @example\n   * ```js\n   * hot.updateSettings({\n   *    contextMenu: true,\n   *    colHeaders: true,\n   *    fixedRowsTop: 2\n   * });\n   * ```\n   * @fires Hooks#afterCellMetaReset\n   * @fires Hooks#afterUpdateSettings\n   */\n\n\n  this.updateSettings = function (settings) {\n    var init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    // TODO: uncomment the next line with the next major version update\n    // Do not forget to re-enable the pending tests that cover the change:\n    //  * https://github.com/handsontable/handsontable/blob/9f62c282a1c951b27cd8406aa27105bd32b05bb6/handsontable/test/e2e/core/toPhysicalColumn.spec.js#L70\n    //  * https://github.com/handsontable/handsontable/blob/9f62c282a1c951b27cd8406aa27105bd32b05bb6/handsontable/test/e2e/core/toVisualColumn.spec.js#L70\n    // const dataUpdateFunction = (firstRun ? instance.loadData : instance.updateData).bind(this);\n    var dataUpdateFunction = instance.loadData.bind(this);\n    var columnsAsFunc = false;\n    var i;\n    var j;\n\n    if (isDefined(settings.rows)) {\n      throw new Error('The \"rows\" setting is no longer supported. Do you mean startRows, minRows or maxRows?');\n    }\n\n    if (isDefined(settings.cols)) {\n      throw new Error('The \"cols\" setting is no longer supported. Do you mean startCols, minCols or maxCols?');\n    }\n\n    if (isDefined(settings.ganttChart)) {\n      throw new Error('Since 8.0.0 the \"ganttChart\" setting is no longer supported.');\n    } // eslint-disable-next-line no-restricted-syntax\n\n\n    for (i in settings) {\n      if (i === 'data') {\n        /* eslint-disable-next-line no-continue */\n        continue; // loadData will be triggered later\n      } else if (i === 'language') {\n        setLanguage(settings.language);\n        /* eslint-disable-next-line no-continue */\n\n        continue;\n      } else if (i === 'className') {\n        setClassName('className', settings.className);\n      } else if (i === 'tableClassName' && instance.table) {\n        setClassName('tableClassName', settings.tableClassName);\n        instance.view.wt.wtOverlays.syncOverlayTableClassNames();\n      } else if (Hooks.getSingleton().isRegistered(i) || Hooks.getSingleton().isDeprecated(i)) {\n        if (isFunction(settings[i]) || Array.isArray(settings[i])) {\n          settings[i].initialHook = true;\n          instance.addHook(i, settings[i]);\n        }\n      } else if (!init && hasOwnProperty(settings, i)) {\n        // Update settings\n        globalMeta[i] = settings[i];\n      }\n    } // Load data or create data map\n\n\n    if (settings.data === void 0 && tableMeta.data === void 0) {\n      dataUpdateFunction(null, 'updateSettings'); // data source created just now\n    } else if (settings.data !== void 0) {\n      dataUpdateFunction(settings.data, 'updateSettings'); // data source given as option\n    } else if (settings.columns !== void 0) {\n      datamap.createMap(); // The `column` property has changed - dataset may be expanded or narrowed down. The `loadData` do the same.\n\n      instance.initIndexMappers();\n    }\n\n    var clen = instance.countCols();\n    var columnSetting = tableMeta.columns; // Init columns constructors configuration\n\n    if (columnSetting && isFunction(columnSetting)) {\n      columnsAsFunc = true;\n    } // Clear cell meta cache\n\n\n    if (settings.cell !== void 0 || settings.cells !== void 0 || settings.columns !== void 0) {\n      metaManager.clearCache();\n    }\n\n    if (clen > 0) {\n      for (i = 0, j = 0; i < clen; i++) {\n        // Use settings provided by user\n        if (columnSetting) {\n          var column = columnsAsFunc ? columnSetting(i) : columnSetting[j];\n\n          if (column) {\n            metaManager.updateColumnMeta(j, column);\n          }\n        }\n\n        j += 1;\n      }\n    }\n\n    if (isDefined(settings.cell)) {\n      objectEach(settings.cell, function (cell) {\n        instance.setCellMetaObject(cell.row, cell.col, cell);\n      });\n    }\n\n    instance.runHooks('afterCellMetaReset');\n    var currentHeight = instance.rootElement.style.height;\n\n    if (currentHeight !== '') {\n      currentHeight = parseInt(instance.rootElement.style.height, 10);\n    }\n\n    var height = settings.height;\n\n    if (isFunction(height)) {\n      height = height();\n    }\n\n    if (init) {\n      var initialStyle = instance.rootElement.getAttribute('style');\n\n      if (initialStyle) {\n        instance.rootElement.setAttribute('data-initialstyle', instance.rootElement.getAttribute('style'));\n      }\n    }\n\n    if (height === null) {\n      var _initialStyle = instance.rootElement.getAttribute('data-initialstyle');\n\n      if (_initialStyle && (_initialStyle.indexOf('height') > -1 || _initialStyle.indexOf('overflow') > -1)) {\n        instance.rootElement.setAttribute('style', _initialStyle);\n      } else {\n        instance.rootElement.style.height = '';\n        instance.rootElement.style.overflow = '';\n      }\n    } else if (height !== void 0) {\n      instance.rootElement.style.height = isNaN(height) ? \"\".concat(height) : \"\".concat(height, \"px\");\n      instance.rootElement.style.overflow = 'hidden';\n    }\n\n    if (typeof settings.width !== 'undefined') {\n      var width = settings.width;\n\n      if (isFunction(width)) {\n        width = width();\n      }\n\n      instance.rootElement.style.width = isNaN(width) ? \"\".concat(width) : \"\".concat(width, \"px\");\n    }\n\n    if (!init) {\n      if (instance.view) {\n        instance.view.wt.wtViewport.resetHasOversizedColumnHeadersMarked();\n        instance.view.wt.exportSettingsAsClassNames();\n      }\n\n      instance.runHooks('afterUpdateSettings', settings);\n    }\n\n    grid.adjustRowsAndCols();\n\n    if (instance.view && !firstRun) {\n      instance.forceFullRender = true; // used when data was changed\n\n      editorManager.lockEditor();\n\n      instance._refreshBorders(null);\n\n      instance.view.wt.wtOverlays.adjustElementsSize();\n      editorManager.unlockEditor();\n    }\n\n    if (!init && instance.view && (currentHeight === '' || height === '' || height === void 0) && currentHeight !== height) {\n      instance.view.wt.wtOverlays.updateMainScrollableElements();\n    }\n  };\n  /**\n   * Get value from the selected cell.\n   *\n   * @memberof Core#\n   * @function getValue\n   * @returns {*} Value of selected cell.\n   */\n\n\n  this.getValue = function () {\n    var sel = instance.getSelectedLast();\n\n    if (tableMeta.getValue) {\n      if (isFunction(tableMeta.getValue)) {\n        return tableMeta.getValue.call(instance);\n      } else if (sel) {\n        return instance.getData()[sel[0][0]][tableMeta.getValue];\n      }\n    } else if (sel) {\n      return instance.getDataAtCell(sel[0], sel[1]);\n    }\n  };\n  /**\n   * Returns the object settings.\n   *\n   * @memberof Core#\n   * @function getSettings\n   * @returns {object} Object containing the current table settings.\n   */\n\n\n  this.getSettings = function () {\n    return tableMeta;\n  };\n  /**\n   * Clears the data from the table (the table settings remain intact).\n   *\n   * @memberof Core#\n   * @function clear\n   */\n\n\n  this.clear = function () {\n    this.selectAll();\n    this.emptySelectedCells();\n  };\n  /**\n   * Allows altering the table structure by either inserting/removing rows or columns.\n   * This method works with an array data structure only.\n   *\n   * @memberof Core#\n   * @function alter\n   * @param {string} action Possible alter operations:\n   *  <ul>\n   *    <li> `'insert_row'` </li>\n   *    <li> `'insert_col'` </li>\n   *    <li> `'remove_row'` </li>\n   *    <li> `'remove_col'` </li>\n   * </ul>.\n   * @param {number|number[]} index Visual index of the row/column before which the new row/column will be\n   *                                inserted/removed or an array of arrays in format `[[index, amount],...]`.\n   * @param {number} [amount=1] Amount of rows/columns to be inserted or removed.\n   * @param {string} [source] Source indicator.\n   * @param {boolean} [keepEmptyRows] Flag for preventing deletion of empty rows.\n   * @example\n   * ```js\n   * // Insert new row above the row at given visual index.\n   * hot.alter('insert_row', 10);\n   * // Insert 3 new columns before 10th column.\n   * hot.alter('insert_col', 10, 3);\n   * // Remove 2 rows starting from 10th row.\n   * hot.alter('remove_row', 10, 2);\n   * // Remove 5 non-contiquous rows (it removes 3 rows from visual index 1 and 2 rows from visual index 5).\n   * hot.alter('remove_row', [[1, 3], [5, 2]]);\n   * ```\n   */\n\n\n  this.alter = function (action, index, amount, source, keepEmptyRows) {\n    grid.alter(action, index, amount, source, keepEmptyRows);\n  };\n  /**\n   * Returns a TD element for the given `row` and `column` arguments, if it is rendered on screen.\n   * Returns `null` if the TD is not rendered on screen (probably because that part of the table is not visible).\n   *\n   * @memberof Core#\n   * @function getCell\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @param {boolean} [topmost=false] If set to `true`, it returns the TD element from the topmost overlay. For example,\n   * if the wanted cell is in the range of fixed rows, it will return a TD element from the `top` overlay.\n   * @returns {HTMLTableCellElement|null} The cell's TD element.\n   */\n\n\n  this.getCell = function (row, column) {\n    var topmost = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var renderableColumnIndex = column; // Handling also column headers.\n\n    var renderableRowIndex = row; // Handling also row headers.\n\n    if (column >= 0) {\n      if (this.columnIndexMapper.isHidden(this.toPhysicalColumn(column))) {\n        return null;\n      }\n\n      renderableColumnIndex = this.columnIndexMapper.getRenderableFromVisualIndex(column);\n    }\n\n    if (row >= 0) {\n      if (this.rowIndexMapper.isHidden(this.toPhysicalRow(row))) {\n        return null;\n      }\n\n      renderableRowIndex = this.rowIndexMapper.getRenderableFromVisualIndex(row);\n    }\n\n    if (renderableRowIndex === null || renderableColumnIndex === null) {\n      return null;\n    }\n\n    return instance.view.getCellAtCoords(new CellCoords(renderableRowIndex, renderableColumnIndex), topmost);\n  };\n  /**\n   * Returns the coordinates of the cell, provided as a HTML table cell element.\n   *\n   * @memberof Core#\n   * @function getCoords\n   * @param {HTMLTableCellElement} element The HTML Element representing the cell.\n   * @returns {CellCoords|null} Visual coordinates object.\n   * @example\n   * ```js\n   * hot.getCoords(hot.getCell(1, 1));\n   * // it returns CellCoords object instance with props row: 1 and col: 1.\n   * ```\n   */\n\n\n  this.getCoords = function (element) {\n    var renderableCoords = this.view.wt.wtTable.getCoords(element);\n\n    if (renderableCoords === null) {\n      return null;\n    }\n\n    var renderableRow = renderableCoords.row,\n        renderableColumn = renderableCoords.col;\n    var visualRow = renderableRow;\n    var visualColumn = renderableColumn;\n\n    if (renderableRow >= 0) {\n      visualRow = this.rowIndexMapper.getVisualFromRenderableIndex(renderableRow);\n    }\n\n    if (renderableColumn >= 0) {\n      visualColumn = this.columnIndexMapper.getVisualFromRenderableIndex(renderableColumn);\n    }\n\n    return new CellCoords(visualRow, visualColumn);\n  };\n  /**\n   * Returns the property name that corresponds with the given column index.\n   * If the data source is an array of arrays, it returns the columns index.\n   *\n   * @memberof Core#\n   * @function colToProp\n   * @param {number} column Visual column index.\n   * @returns {string|number} Column property or physical column index.\n   */\n\n\n  this.colToProp = function (column) {\n    return datamap.colToProp(column);\n  };\n  /**\n   * Returns column index that corresponds with the given property.\n   *\n   * @memberof Core#\n   * @function propToCol\n   * @param {string|number} prop Property name or physical column index.\n   * @returns {number} Visual column index.\n   */\n\n\n  this.propToCol = function (prop) {\n    return datamap.propToCol(prop);\n  };\n  /**\n   * Translate physical row index into visual.\n   *\n   * This method is useful when you want to retrieve visual row index which can be reordered, moved or trimmed\n   * based on a physical index.\n   *\n   * @memberof Core#\n   * @function toVisualRow\n   * @param {number} row Physical row index.\n   * @returns {number} Returns visual row index.\n   */\n\n\n  this.toVisualRow = function (row) {\n    return _this.rowIndexMapper.getVisualFromPhysicalIndex(row);\n  };\n  /**\n   * Translate physical column index into visual.\n   *\n   * This method is useful when you want to retrieve visual column index which can be reordered, moved or trimmed\n   * based on a physical index.\n   *\n   * @memberof Core#\n   * @function toVisualColumn\n   * @param {number} column Physical column index.\n   * @returns {number} Returns visual column index.\n   */\n\n\n  this.toVisualColumn = function (column) {\n    return _this.columnIndexMapper.getVisualFromPhysicalIndex(column);\n  };\n  /**\n   * Translate visual row index into physical.\n   *\n   * This method is useful when you want to retrieve physical row index based on a visual index which can be\n   * reordered, moved or trimmed.\n   *\n   * @memberof Core#\n   * @function toPhysicalRow\n   * @param {number} row Visual row index.\n   * @returns {number} Returns physical row index.\n   */\n\n\n  this.toPhysicalRow = function (row) {\n    return _this.rowIndexMapper.getPhysicalFromVisualIndex(row);\n  };\n  /**\n   * Translate visual column index into physical.\n   *\n   * This method is useful when you want to retrieve physical column index based on a visual index which can be\n   * reordered, moved or trimmed.\n   *\n   * @memberof Core#\n   * @function toPhysicalColumn\n   * @param {number} column Visual column index.\n   * @returns {number} Returns physical column index.\n   */\n\n\n  this.toPhysicalColumn = function (column) {\n    return _this.columnIndexMapper.getPhysicalFromVisualIndex(column);\n  };\n  /**\n   * @description\n   * Returns the cell value at `row`, `column`.\n   *\n   * __Note__: If data is reordered, sorted or trimmed, the currently visible order will be used.\n   *\n   * @memberof Core#\n   * @function getDataAtCell\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @returns {*} Data at cell.\n   */\n\n\n  this.getDataAtCell = function (row, column) {\n    return datamap.get(row, datamap.colToProp(column));\n  };\n  /**\n   * Returns value at visual `row` and `prop` indexes.\n   *\n   * __Note__: If data is reordered, sorted or trimmed, the currently visible order will be used.\n   *\n   * @memberof Core#\n   * @function getDataAtRowProp\n   * @param {number} row Visual row index.\n   * @param {string} prop Property name.\n   * @returns {*} Cell value.\n   */\n\n\n  this.getDataAtRowProp = function (row, prop) {\n    return datamap.get(row, prop);\n  };\n  /**\n   * @description\n   * Returns array of column values from the data source.\n   *\n   * __Note__: If columns were reordered or sorted, the currently visible order will be used.\n   *\n   * @memberof Core#\n   * @function getDataAtCol\n   * @param {number} column Visual column index.\n   * @returns {Array} Array of cell values.\n   */\n\n\n  this.getDataAtCol = function (column) {\n    var _ref13;\n\n    return (_ref13 = []).concat.apply(_ref13, _toConsumableArray(datamap.getRange(new CellCoords(0, column), new CellCoords(tableMeta.data.length - 1, column), datamap.DESTINATION_RENDERER)));\n  };\n  /**\n   * Given the object property name (e.g. `'first.name'` or `'0'`), returns an array of column's values from the table data.\n   * You can also provide a column index as the first argument.\n   *\n   * @memberof Core#\n   * @function getDataAtProp\n   * @param {string|number} prop Property name or physical column index.\n   * @returns {Array} Array of cell values.\n   */\n  // TODO: Getting data from `datamap` should work on visual indexes.\n\n\n  this.getDataAtProp = function (prop) {\n    var _ref14;\n\n    var range = datamap.getRange(new CellCoords(0, datamap.propToCol(prop)), new CellCoords(tableMeta.data.length - 1, datamap.propToCol(prop)), datamap.DESTINATION_RENDERER);\n    return (_ref14 = []).concat.apply(_ref14, _toConsumableArray(range));\n  };\n  /**\n   * Returns a clone of the source data object.\n   * Optionally you can provide a cell range by using the `row`, `column`, `row2`, `column2` arguments, to get only a\n   * fragment of the table data.\n   *\n   * __Note__: This method does not participate in data transformation. If the visual data of the table is reordered,\n   * sorted or trimmed only physical indexes are correct.\n   *\n   * @memberof Core#\n   * @function getSourceData\n   * @param {number} [row] From physical row index.\n   * @param {number} [column] From physical column index (or visual index, if data type is an array of objects).\n   * @param {number} [row2] To physical row index.\n   * @param {number} [column2] To physical column index (or visual index, if data type is an array of objects).\n   * @returns {Array[]|object[]} The table data.\n   */\n\n\n  this.getSourceData = function (row, column, row2, column2) {\n    var data;\n\n    if (row === void 0) {\n      data = dataSource.getData();\n    } else {\n      data = dataSource.getByRange(new CellCoords(row, column), new CellCoords(row2, column2));\n    }\n\n    return data;\n  };\n  /**\n   * Returns the source data object as an arrays of arrays format even when source data was provided in another format.\n   * Optionally you can provide a cell range by using the `row`, `column`, `row2`, `column2` arguments, to get only a\n   * fragment of the table data.\n   *\n   * __Note__: This method does not participate in data transformation. If the visual data of the table is reordered,\n   * sorted or trimmed only physical indexes are correct.\n   *\n   * @memberof Core#\n   * @function getSourceDataArray\n   * @param {number} [row] From physical row index.\n   * @param {number} [column] From physical column index (or visual index, if data type is an array of objects).\n   * @param {number} [row2] To physical row index.\n   * @param {number} [column2] To physical column index (or visual index, if data type is an array of objects).\n   * @returns {Array} An array of arrays.\n   */\n\n\n  this.getSourceDataArray = function (row, column, row2, column2) {\n    var data;\n\n    if (row === void 0) {\n      data = dataSource.getData(true);\n    } else {\n      data = dataSource.getByRange(new CellCoords(row, column), new CellCoords(row2, column2), true);\n    }\n\n    return data;\n  };\n  /**\n   * Returns an array of column values from the data source.\n   *\n   * @memberof Core#\n   * @function getSourceDataAtCol\n   * @param {number} column Visual column index.\n   * @returns {Array} Array of the column's cell values.\n   */\n  // TODO: Getting data from `sourceData` should work always on physical indexes.\n\n\n  this.getSourceDataAtCol = function (column) {\n    return dataSource.getAtColumn(column);\n  };\n  /* eslint-disable jsdoc/require-param */\n\n  /**\n   * Set the provided value in the source data set at the provided coordinates.\n   *\n   * @memberof Core#\n   * @function setSourceDataAtCell\n   * @param {number|Array} row Physical row index or array of changes in format `[[row, prop, value], ...]`.\n   * @param {number|string} column Physical column index / prop name.\n   * @param {*} value The value to be set at the provided coordinates.\n   * @param {string} [source] Source of the change as a string.\n   */\n\n  /* eslint-enable jsdoc/require-param */\n\n\n  this.setSourceDataAtCell = function (row, column, value, source) {\n    var input = setDataInputToArray(row, column, value);\n    var isThereAnySetSourceListener = this.hasHook('afterSetSourceDataAtCell');\n    var changesForHook = [];\n\n    if (isThereAnySetSourceListener) {\n      arrayEach(input, function (_ref15) {\n        var _ref16 = _slicedToArray(_ref15, 3),\n            changeRow = _ref16[0],\n            changeProp = _ref16[1],\n            changeValue = _ref16[2];\n\n        changesForHook.push([changeRow, changeProp, dataSource.getAtCell(changeRow, changeProp), // The previous value.\n        changeValue]);\n      });\n    }\n\n    arrayEach(input, function (_ref17) {\n      var _ref18 = _slicedToArray(_ref17, 3),\n          changeRow = _ref18[0],\n          changeProp = _ref18[1],\n          changeValue = _ref18[2];\n\n      dataSource.setAtCell(changeRow, changeProp, changeValue);\n    });\n\n    if (isThereAnySetSourceListener) {\n      this.runHooks('afterSetSourceDataAtCell', changesForHook, source);\n    }\n\n    this.render();\n    var activeEditor = instance.getActiveEditor();\n\n    if (activeEditor && isDefined(activeEditor.refreshValue)) {\n      activeEditor.refreshValue();\n    }\n  };\n  /**\n   * Returns a single row of the data (array or object, depending on what data format you use).\n   *\n   * __Note__: This method does not participate in data transformation. If the visual data of the table is reordered,\n   * sorted or trimmed only physical indexes are correct.\n   *\n   * @memberof Core#\n   * @function getSourceDataAtRow\n   * @param {number} row Physical row index.\n   * @returns {Array|object} Single row of data.\n   */\n\n\n  this.getSourceDataAtRow = function (row) {\n    return dataSource.getAtRow(row);\n  };\n  /**\n   * Returns a single value from the data source.\n   *\n   * @memberof Core#\n   * @function getSourceDataAtCell\n   * @param {number} row Physical row index.\n   * @param {number} column Visual column index.\n   * @returns {*} Cell data.\n   */\n  // TODO: Getting data from `sourceData` should work always on physical indexes.\n\n\n  this.getSourceDataAtCell = function (row, column) {\n    return dataSource.getAtCell(row, column);\n  };\n  /**\n   * @description\n   * Returns a single row of the data.\n   *\n   * __Note__: If rows were reordered, sorted or trimmed, the currently visible order will be used.\n   *\n   * @memberof Core#\n   * @function getDataAtRow\n   * @param {number} row Visual row index.\n   * @returns {Array} Array of row's cell data.\n   */\n\n\n  this.getDataAtRow = function (row) {\n    var data = datamap.getRange(new CellCoords(row, 0), new CellCoords(row, this.countCols() - 1), datamap.DESTINATION_RENDERER);\n    return data[0] || [];\n  };\n  /**\n   * @description\n   * Returns a data type defined in the Handsontable settings under the `type` key ({@link Options#type}).\n   * If there are cells with different types in the selected range, it returns `'mixed'`.\n   *\n   * __Note__: If data is reordered, sorted or trimmed, the currently visible order will be used.\n   *\n   * @memberof Core#\n   * @function getDataType\n   * @param {number} rowFrom From visual row index.\n   * @param {number} columnFrom From visual column index.\n   * @param {number} rowTo To visual row index.\n   * @param {number} columnTo To visual column index.\n   * @returns {string} Cell type (e.q: `'mixed'`, `'text'`, `'numeric'`, `'autocomplete'`).\n   */\n\n\n  this.getDataType = function (rowFrom, columnFrom, rowTo, columnTo) {\n    var _this4 = this;\n\n    var coords = rowFrom === void 0 ? [0, 0, this.countRows(), this.countCols()] : [rowFrom, columnFrom, rowTo, columnTo];\n    var rowStart = coords[0],\n        columnStart = coords[1];\n    var rowEnd = coords[2],\n        columnEnd = coords[3];\n    var previousType = null;\n    var currentType = null;\n\n    if (rowEnd === void 0) {\n      rowEnd = rowStart;\n    }\n\n    if (columnEnd === void 0) {\n      columnEnd = columnStart;\n    }\n\n    var type = 'mixed';\n    rangeEach(Math.max(Math.min(rowStart, rowEnd), 0), Math.max(rowStart, rowEnd), function (row) {\n      var isTypeEqual = true;\n      rangeEach(Math.max(Math.min(columnStart, columnEnd), 0), Math.max(columnStart, columnEnd), function (column) {\n        var cellType = _this4.getCellMeta(row, column);\n\n        currentType = cellType.type;\n\n        if (previousType) {\n          isTypeEqual = previousType === currentType;\n        } else {\n          previousType = currentType;\n        }\n\n        return isTypeEqual;\n      });\n      type = isTypeEqual ? currentType : 'mixed';\n      return isTypeEqual;\n    });\n    return type;\n  };\n  /**\n   * Remove a property defined by the `key` argument from the cell meta object for the provided `row` and `column` coordinates.\n   *\n   * @memberof Core#\n   * @function removeCellMeta\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @param {string} key Property name.\n   * @fires Hooks#beforeRemoveCellMeta\n   * @fires Hooks#afterRemoveCellMeta\n   */\n\n\n  this.removeCellMeta = function (row, column, key) {\n    var _ref19 = [this.toPhysicalRow(row), this.toPhysicalColumn(column)],\n        physicalRow = _ref19[0],\n        physicalColumn = _ref19[1];\n    var cachedValue = metaManager.getCellMetaKeyValue(physicalRow, physicalColumn, key);\n    var hookResult = instance.runHooks('beforeRemoveCellMeta', row, column, key, cachedValue);\n\n    if (hookResult !== false) {\n      metaManager.removeCellMeta(physicalRow, physicalColumn, key);\n      instance.runHooks('afterRemoveCellMeta', row, column, key, cachedValue);\n    }\n\n    cachedValue = null;\n  };\n  /**\n   * Removes or adds one or more rows of the cell meta objects to the cell meta collections.\n   *\n   * @since 0.30.0\n   * @memberof Core#\n   * @function spliceCellsMeta\n   * @param {number} visualIndex A visual index that specifies at what position to add/remove items.\n   * @param {number} [deleteAmount=0] The number of items to be removed. If set to 0, no cell meta objects will be removed.\n   * @param {...object} [cellMetaRows] The new cell meta row objects to be added to the cell meta collection.\n   */\n\n\n  this.spliceCellsMeta = function (visualIndex) {\n    var _this5 = this;\n\n    var deleteAmount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    for (var _len3 = arguments.length, cellMetaRows = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n      cellMetaRows[_key3 - 2] = arguments[_key3];\n    }\n\n    if (cellMetaRows.length > 0 && !Array.isArray(cellMetaRows[0])) {\n      throw new Error('The 3rd argument (cellMetaRows) has to be passed as an array of cell meta objects array.');\n    }\n\n    if (deleteAmount > 0) {\n      metaManager.removeRow(this.toPhysicalRow(visualIndex), deleteAmount);\n    }\n\n    if (cellMetaRows.length > 0) {\n      arrayEach(cellMetaRows.reverse(), function (cellMetaRow) {\n        metaManager.createRow(_this5.toPhysicalRow(visualIndex));\n        arrayEach(cellMetaRow, function (cellMeta, columnIndex) {\n          return _this5.setCellMetaObject(visualIndex, columnIndex, cellMeta);\n        });\n      });\n    }\n\n    instance.render();\n  };\n  /**\n   * Set cell meta data object defined by `prop` to the corresponding params `row` and `column`.\n   *\n   * @memberof Core#\n   * @function setCellMetaObject\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @param {object} prop Meta object.\n   */\n\n\n  this.setCellMetaObject = function (row, column, prop) {\n    var _this6 = this;\n\n    if (_typeof(prop) === 'object') {\n      objectEach(prop, function (value, key) {\n        _this6.setCellMeta(row, column, key, value);\n      });\n    }\n  };\n  /**\n   * Sets a property defined by the `key` property to the meta object of a cell corresponding to params `row` and `column`.\n   *\n   * @memberof Core#\n   * @function setCellMeta\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @param {string} key Property name.\n   * @param {string} value Property value.\n   * @fires Hooks#beforeSetCellMeta\n   * @fires Hooks#afterSetCellMeta\n   */\n\n\n  this.setCellMeta = function (row, column, key, value) {\n    var allowSetCellMeta = instance.runHooks('beforeSetCellMeta', row, column, key, value);\n\n    if (allowSetCellMeta === false) {\n      return;\n    }\n\n    var physicalRow = row;\n    var physicalColumn = column;\n\n    if (row < this.countRows()) {\n      physicalRow = this.toPhysicalRow(row);\n    }\n\n    if (column < this.countCols()) {\n      physicalColumn = this.toPhysicalColumn(column);\n    }\n\n    metaManager.setCellMeta(physicalRow, physicalColumn, key, value);\n    instance.runHooks('afterSetCellMeta', row, column, key, value);\n  };\n  /**\n   * Get all the cells meta settings at least once generated in the table (in order of cell initialization).\n   *\n   * @memberof Core#\n   * @function getCellsMeta\n   * @returns {Array} Returns an array of ColumnSettings object instances.\n   */\n\n\n  this.getCellsMeta = function () {\n    return metaManager.getCellsMeta();\n  };\n  /**\n   * Returns the cell properties object for the given `row` and `column` coordinates.\n   *\n   * @memberof Core#\n   * @function getCellMeta\n   * @param {number} row Visual row index.\n   * @param {number} column Visual column index.\n   * @returns {object} The cell properties object.\n   * @fires Hooks#beforeGetCellMeta\n   * @fires Hooks#afterGetCellMeta\n   */\n\n\n  this.getCellMeta = function (row, column) {\n    var physicalRow = this.toPhysicalRow(row);\n    var physicalColumn = this.toPhysicalColumn(column);\n\n    if (physicalRow === null) {\n      physicalRow = row;\n    }\n\n    if (physicalColumn === null) {\n      physicalColumn = column;\n    }\n\n    return metaManager.getCellMeta(physicalRow, physicalColumn, {\n      visualRow: row,\n      visualColumn: column\n    });\n  };\n  /**\n   * Returns an array of cell meta objects for specified physical row index.\n   *\n   * @memberof Core#\n   * @function getCellMetaAtRow\n   * @param {number} row Physical row index.\n   * @returns {Array}\n   */\n\n\n  this.getCellMetaAtRow = function (row) {\n    return metaManager.getCellsMetaAtRow(row);\n  };\n  /**\n   * Checks if the data format and config allows user to modify the column structure.\n   *\n   * @memberof Core#\n   * @function isColumnModificationAllowed\n   * @returns {boolean}\n   */\n\n\n  this.isColumnModificationAllowed = function () {\n    return !(instance.dataType === 'object' || tableMeta.columns);\n  };\n\n  var rendererLookup = cellMethodLookupFactory('renderer');\n  /**\n   * Returns the cell renderer function by given `row` and `column` arguments.\n   *\n   * @memberof Core#\n   * @function getCellRenderer\n   * @param {number|object} row Visual row index or cell meta object (see {@link Core#getCellMeta}).\n   * @param {number} column Visual column index.\n   * @returns {Function} The renderer function.\n   * @example\n   * ```js\n   * // Get cell renderer using `row` and `column` coordinates.\n   * hot.getCellRenderer(1, 1);\n   * // Get cell renderer using cell meta object.\n   * hot.getCellRenderer(hot.getCellMeta(1, 1));\n   * ```\n   */\n\n  this.getCellRenderer = function (row, column) {\n    return getRenderer(rendererLookup.call(this, row, column));\n  };\n  /**\n   * Returns the cell editor class by the provided `row` and `column` arguments.\n   *\n   * @memberof Core#\n   * @function getCellEditor\n   * @param {number} row Visual row index or cell meta object (see {@link Core#getCellMeta}).\n   * @param {number} column Visual column index.\n   * @returns {Function} The editor class.\n   * @example\n   * ```js\n   * // Get cell editor class using `row` and `column` coordinates.\n   * hot.getCellEditor(1, 1);\n   * // Get cell editor class using cell meta object.\n   * hot.getCellEditor(hot.getCellMeta(1, 1));\n   * ```\n   */\n\n\n  this.getCellEditor = cellMethodLookupFactory('editor');\n  var validatorLookup = cellMethodLookupFactory('validator');\n  /**\n   * Returns the cell validator by `row` and `column`.\n   *\n   * @memberof Core#\n   * @function getCellValidator\n   * @param {number|object} row Visual row index or cell meta object (see {@link Core#getCellMeta}).\n   * @param {number} column Visual column index.\n   * @returns {Function|RegExp|undefined} The validator function.\n   * @example\n   * ```js\n   * // Get cell valiator using `row` and `column` coordinates.\n   * hot.getCellValidator(1, 1);\n   * // Get cell valiator using cell meta object.\n   * hot.getCellValidator(hot.getCellMeta(1, 1));\n   * ```\n   */\n\n  this.getCellValidator = function (row, column) {\n    var validator = validatorLookup.call(this, row, column);\n\n    if (typeof validator === 'string') {\n      validator = getValidator(validator);\n    }\n\n    return validator;\n  };\n  /**\n   * Validates all cells using their validator functions and calls callback when finished.\n   *\n   * If one of the cells is invalid, the callback will be fired with `'valid'` arguments as `false` - otherwise it\n   * would equal `true`.\n   *\n   * @memberof Core#\n   * @function validateCells\n   * @param {Function} [callback] The callback function.\n   * @example\n   * ```js\n   * hot.validateCells((valid) => {\n   *   if (valid) {\n   *     // ... code for validated cells\n   *   }\n   * })\n   * ```\n   */\n\n\n  this.validateCells = function (callback) {\n    this._validateCells(callback);\n  };\n  /**\n   * Validates rows using their validator functions and calls callback when finished.\n   *\n   * If one of the cells is invalid, the callback will be fired with `'valid'` arguments as `false` - otherwise it\n   *  would equal `true`.\n   *\n   * @memberof Core#\n   * @function validateRows\n   * @param {Array} [rows] Array of validation target visual row indexes.\n   * @param {Function} [callback] The callback function.\n   * @example\n   * ```js\n   * hot.validateRows([3, 4, 5], (valid) => {\n   *   if (valid) {\n   *     // ... code for validated rows\n   *   }\n   * })\n   * ```\n   */\n\n\n  this.validateRows = function (rows, callback) {\n    if (!Array.isArray(rows)) {\n      throw new Error('validateRows parameter `rows` must be an array');\n    }\n\n    this._validateCells(callback, rows);\n  };\n  /**\n   * Validates columns using their validator functions and calls callback when finished.\n   *\n   * If one of the cells is invalid, the callback will be fired with `'valid'` arguments as `false` - otherwise it\n   *  would equal `true`.\n   *\n   * @memberof Core#\n   * @function validateColumns\n   * @param {Array} [columns] Array of validation target visual columns indexes.\n   * @param {Function} [callback] The callback function.\n   * @example\n   * ```js\n   * hot.validateColumns([3, 4, 5], (valid) => {\n   *   if (valid) {\n   *     // ... code for validated columns\n   *   }\n   * })\n   * ```\n   */\n\n\n  this.validateColumns = function (columns, callback) {\n    if (!Array.isArray(columns)) {\n      throw new Error('validateColumns parameter `columns` must be an array');\n    }\n\n    this._validateCells(callback, undefined, columns);\n  };\n  /**\n   * Validates all cells using their validator functions and calls callback when finished.\n   *\n   * If one of the cells is invalid, the callback will be fired with `'valid'` arguments as `false` - otherwise it would equal `true`.\n   *\n   * Private use intended.\n   *\n   * @private\n   * @memberof Core#\n   * @function _validateCells\n   * @param {Function} [callback] The callback function.\n   * @param {Array} [rows] An array of validation target visual row indexes.\n   * @param {Array} [columns] An array of validation target visual column indexes.\n   */\n\n\n  this._validateCells = function (callback, rows, columns) {\n    var waitingForValidator = new ValidatorsQueue();\n\n    if (callback) {\n      waitingForValidator.onQueueEmpty = callback;\n    }\n\n    var i = instance.countRows() - 1;\n\n    while (i >= 0) {\n      if (rows !== undefined && rows.indexOf(i) === -1) {\n        i -= 1;\n        continue;\n      }\n\n      var j = instance.countCols() - 1;\n\n      while (j >= 0) {\n        if (columns !== undefined && columns.indexOf(j) === -1) {\n          j -= 1;\n          continue;\n        }\n\n        waitingForValidator.addValidatorToQueue();\n        instance.validateCell(instance.getDataAtCell(i, j), instance.getCellMeta(i, j), function (result) {\n          if (typeof result !== 'boolean') {\n            throw new Error('Validation error: result is not boolean');\n          }\n\n          if (result === false) {\n            waitingForValidator.valid = false;\n          }\n\n          waitingForValidator.removeValidatorFormQueue();\n        }, 'validateCells');\n        j -= 1;\n      }\n\n      i -= 1;\n    }\n\n    waitingForValidator.checkIfQueueIsEmpty();\n  };\n  /**\n   * Returns an array of row headers' values (if they are enabled). If param `row` was given, it returns the header of the given row as a string.\n   *\n   * @memberof Core#\n   * @function getRowHeader\n   * @param {number} [row] Visual row index.\n   * @fires Hooks#modifyRowHeader\n   * @returns {Array|string|number} Array of header values / single header value.\n   */\n\n\n  this.getRowHeader = function (row) {\n    var rowHeader = tableMeta.rowHeaders;\n    var physicalRow = row;\n\n    if (physicalRow !== void 0) {\n      physicalRow = instance.runHooks('modifyRowHeader', physicalRow);\n    }\n\n    if (physicalRow === void 0) {\n      rowHeader = [];\n      rangeEach(instance.countRows() - 1, function (i) {\n        rowHeader.push(instance.getRowHeader(i));\n      });\n    } else if (Array.isArray(rowHeader) && rowHeader[physicalRow] !== void 0) {\n      rowHeader = rowHeader[physicalRow];\n    } else if (isFunction(rowHeader)) {\n      rowHeader = rowHeader(physicalRow);\n    } else if (rowHeader && typeof rowHeader !== 'string' && typeof rowHeader !== 'number') {\n      rowHeader = physicalRow + 1;\n    }\n\n    return rowHeader;\n  };\n  /**\n   * Returns information about if this table is configured to display row headers.\n   *\n   * @memberof Core#\n   * @function hasRowHeaders\n   * @returns {boolean} `true` if the instance has the row headers enabled, `false` otherwise.\n   */\n\n\n  this.hasRowHeaders = function () {\n    return !!tableMeta.rowHeaders;\n  };\n  /**\n   * Returns information about if this table is configured to display column headers.\n   *\n   * @memberof Core#\n   * @function hasColHeaders\n   * @returns {boolean} `true` if the instance has the column headers enabled, `false` otherwise.\n   */\n\n\n  this.hasColHeaders = function () {\n    if (tableMeta.colHeaders !== void 0 && tableMeta.colHeaders !== null) {\n      // Polymer has empty value = null\n      return !!tableMeta.colHeaders;\n    }\n\n    for (var i = 0, ilen = instance.countCols(); i < ilen; i++) {\n      if (instance.getColHeader(i)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\n   * Returns an array of column headers (in string format, if they are enabled). If param `column` is given, it\n   * returns the header at the given column.\n   *\n   * @memberof Core#\n   * @function getColHeader\n   * @param {number} [column] Visual column index.\n   * @fires Hooks#modifyColHeader\n   * @returns {Array|string|number} The column header(s).\n   */\n\n\n  this.getColHeader = function (column) {\n    var columnIndex = instance.runHooks('modifyColHeader', column);\n    var result = tableMeta.colHeaders;\n\n    if (columnIndex === void 0) {\n      var out = [];\n      var ilen = instance.countCols();\n\n      for (var i = 0; i < ilen; i++) {\n        out.push(instance.getColHeader(i));\n      }\n\n      result = out;\n    } else {\n      var translateVisualIndexToColumns = function translateVisualIndexToColumns(visualColumnIndex) {\n        var arr = [];\n        var columnsLen = instance.countCols();\n        var index = 0;\n\n        for (; index < columnsLen; index++) {\n          if (isFunction(tableMeta.columns) && tableMeta.columns(index)) {\n            arr.push(index);\n          }\n        }\n\n        return arr[visualColumnIndex];\n      };\n\n      var physicalColumn = instance.toPhysicalColumn(columnIndex);\n      var prop = translateVisualIndexToColumns(physicalColumn);\n\n      if (tableMeta.colHeaders === false) {\n        result = null;\n      } else if (tableMeta.columns && isFunction(tableMeta.columns) && tableMeta.columns(prop) && tableMeta.columns(prop).title) {\n        result = tableMeta.columns(prop).title;\n      } else if (tableMeta.columns && tableMeta.columns[physicalColumn] && tableMeta.columns[physicalColumn].title) {\n        result = tableMeta.columns[physicalColumn].title;\n      } else if (Array.isArray(tableMeta.colHeaders) && tableMeta.colHeaders[physicalColumn] !== void 0) {\n        result = tableMeta.colHeaders[physicalColumn];\n      } else if (isFunction(tableMeta.colHeaders)) {\n        result = tableMeta.colHeaders(physicalColumn);\n      } else if (tableMeta.colHeaders && typeof tableMeta.colHeaders !== 'string' && typeof tableMeta.colHeaders !== 'number') {\n        result = spreadsheetColumnLabel(columnIndex); // see #1458\n      }\n    }\n\n    return result;\n  };\n  /**\n   * Return column width from settings (no guessing). Private use intended.\n   *\n   * @private\n   * @memberof Core#\n   * @function _getColWidthFromSettings\n   * @param {number} col Visual col index.\n   * @returns {number}\n   */\n\n\n  this._getColWidthFromSettings = function (col) {\n    var width; // We currently don't support cell meta objects for headers (negative values)\n\n    if (col >= 0) {\n      var cellProperties = instance.getCellMeta(0, col);\n      width = cellProperties.width;\n    }\n\n    if (width === void 0 || width === tableMeta.width) {\n      width = tableMeta.colWidths;\n    }\n\n    if (width !== void 0 && width !== null) {\n      switch (_typeof(width)) {\n        case 'object':\n          // array\n          width = width[col];\n          break;\n\n        case 'function':\n          width = width(col);\n          break;\n\n        default:\n          break;\n      }\n\n      if (typeof width === 'string') {\n        width = parseInt(width, 10);\n      }\n    }\n\n    return width;\n  };\n  /**\n   * Returns the width of the requested column.\n   *\n   * @memberof Core#\n   * @function getColWidth\n   * @param {number} column Visual column index.\n   * @returns {number} Column width.\n   * @fires Hooks#modifyColWidth\n   */\n\n\n  this.getColWidth = function (column) {\n    var width = instance._getColWidthFromSettings(column);\n\n    width = instance.runHooks('modifyColWidth', width, column);\n\n    if (width === void 0) {\n      width = ViewportColumnsCalculator.DEFAULT_WIDTH;\n    }\n\n    return width;\n  };\n  /**\n   * Return row height from settings (no guessing). Private use intended.\n   *\n   * @private\n   * @memberof Core#\n   * @function _getRowHeightFromSettings\n   * @param {number} row Visual row index.\n   * @returns {number}\n   */\n\n\n  this._getRowHeightFromSettings = function (row) {\n    // let cellProperties = instance.getCellMeta(row, 0);\n    // let height = cellProperties.height;\n    //\n    // if (height === void 0 || height === tableMeta.height) {\n    //  height = cellProperties.rowHeights;\n    // }\n    var height = tableMeta.rowHeights;\n\n    if (height !== void 0 && height !== null) {\n      switch (_typeof(height)) {\n        case 'object':\n          // array\n          height = height[row];\n          break;\n\n        case 'function':\n          height = height(row);\n          break;\n\n        default:\n          break;\n      }\n\n      if (typeof height === 'string') {\n        height = parseInt(height, 10);\n      }\n    }\n\n    return height;\n  };\n  /**\n   * Returns the row height.\n   *\n   * Mind that this method is different from the [AutoRowSize](@/api/autoRowSize.md) plugin's [`getRowHeight()`](@/api/autoRowSize.md#getrowheight) method.\n   *\n   * @memberof Core#\n   * @function getRowHeight\n   * @param {number} row Visual row index.\n   * @returns {number} The given row's height.\n   * @fires Hooks#modifyRowHeight\n   */\n\n\n  this.getRowHeight = function (row) {\n    var height = instance._getRowHeightFromSettings(row);\n\n    height = instance.runHooks('modifyRowHeight', height, row);\n    return height;\n  };\n  /**\n   * Returns the total number of rows in the data source.\n   *\n   * @memberof Core#\n   * @function countSourceRows\n   * @returns {number} Total number of rows.\n   */\n\n\n  this.countSourceRows = function () {\n    return dataSource.countRows();\n  };\n  /**\n   * Returns the total number of columns in the data source.\n   *\n   * @memberof Core#\n   * @function countSourceCols\n   * @returns {number} Total number of columns.\n   */\n\n\n  this.countSourceCols = function () {\n    return dataSource.countFirstRowKeys();\n  };\n  /**\n   * Returns the total number of visual rows in the table.\n   *\n   * @memberof Core#\n   * @function countRows\n   * @returns {number} Total number of rows.\n   */\n\n\n  this.countRows = function () {\n    return datamap.getLength();\n  };\n  /**\n   * Returns the total number of visible columns in the table.\n   *\n   * @memberof Core#\n   * @function countCols\n   * @returns {number} Total number of columns.\n   */\n\n\n  this.countCols = function () {\n    var maxCols = tableMeta.maxCols;\n    var dataLen = this.columnIndexMapper.getNotTrimmedIndexesLength();\n    return Math.min(maxCols, dataLen);\n  };\n  /**\n   * Returns the number of rendered rows (including rows partially or fully rendered outside viewport).\n   *\n   * @memberof Core#\n   * @function countRenderedRows\n   * @returns {number} Returns -1 if table is not visible.\n   */\n\n\n  this.countRenderedRows = function () {\n    return instance.view.wt.drawn ? instance.view.wt.wtTable.getRenderedRowsCount() : -1;\n  };\n  /**\n   * Returns the number of visible rows (rendered rows that fully fit inside viewport).\n   *\n   * @memberof Core#\n   * @function countVisibleRows\n   * @returns {number} Number of visible rows or -1.\n   */\n\n\n  this.countVisibleRows = function () {\n    return instance.view.wt.drawn ? instance.view.wt.wtTable.getVisibleRowsCount() : -1;\n  };\n  /**\n   * Returns the number of rendered columns (including columns partially or fully rendered outside viewport).\n   *\n   * @memberof Core#\n   * @function countRenderedCols\n   * @returns {number} Returns -1 if table is not visible.\n   */\n\n\n  this.countRenderedCols = function () {\n    return instance.view.wt.drawn ? instance.view.wt.wtTable.getRenderedColumnsCount() : -1;\n  };\n  /**\n   * Returns the number of visible columns. Returns -1 if table is not visible.\n   *\n   * @memberof Core#\n   * @function countVisibleCols\n   * @returns {number} Number of visible columns or -1.\n   */\n\n\n  this.countVisibleCols = function () {\n    return instance.view.wt.drawn ? instance.view.wt.wtTable.getVisibleColumnsCount() : -1;\n  };\n  /**\n   * Returns the number of empty rows. If the optional ending parameter is `true`, returns the\n   * number of empty rows at the bottom of the table.\n   *\n   * @memberof Core#\n   * @function countEmptyRows\n   * @param {boolean} [ending=false] If `true`, will only count empty rows at the end of the data source.\n   * @returns {number} Count empty rows.\n   */\n\n\n  this.countEmptyRows = function () {\n    var ending = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var emptyRows = 0;\n    rangeEachReverse(instance.countRows() - 1, function (visualIndex) {\n      if (instance.isEmptyRow(visualIndex)) {\n        emptyRows += 1;\n      } else if (ending === true) {\n        return false;\n      }\n    });\n    return emptyRows;\n  };\n  /**\n   * Returns the number of empty columns. If the optional ending parameter is `true`, returns the number of empty\n   * columns at right hand edge of the table.\n   *\n   * @memberof Core#\n   * @function countEmptyCols\n   * @param {boolean} [ending=false] If `true`, will only count empty columns at the end of the data source row.\n   * @returns {number} Count empty cols.\n   */\n\n\n  this.countEmptyCols = function () {\n    var ending = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    if (instance.countRows() < 1) {\n      return 0;\n    }\n\n    var emptyColumns = 0;\n    rangeEachReverse(instance.countCols() - 1, function (visualIndex) {\n      if (instance.isEmptyCol(visualIndex)) {\n        emptyColumns += 1;\n      } else if (ending === true) {\n        return false;\n      }\n    });\n    return emptyColumns;\n  };\n  /**\n   * Check if all cells in the row declared by the `row` argument are empty.\n   *\n   * @memberof Core#\n   * @function isEmptyRow\n   * @param {number} row Visual row index.\n   * @returns {boolean} `true` if the row at the given `row` is empty, `false` otherwise.\n   */\n\n\n  this.isEmptyRow = function (row) {\n    return tableMeta.isEmptyRow.call(instance, row);\n  };\n  /**\n   * Check if all cells in the the column declared by the `column` argument are empty.\n   *\n   * @memberof Core#\n   * @function isEmptyCol\n   * @param {number} column Column index.\n   * @returns {boolean} `true` if the column at the given `col` is empty, `false` otherwise.\n   */\n\n\n  this.isEmptyCol = function (column) {\n    return tableMeta.isEmptyCol.call(instance, column);\n  };\n  /**\n   * Select cell specified by `row` and `column` values or a range of cells finishing at `endRow`, `endCol`. If the table\n   * was configured to support data column properties that properties can be used to making a selection.\n   *\n   * By default, viewport will be scrolled to the selection. After the `selectCell` method had finished, the instance\n   * will be listening to keyboard input on the document.\n   *\n   * @example\n   * ```js\n   * // select a single cell\n   * hot.selectCell(2, 4);\n   * // select a single cell using column property\n   * hot.selectCell(2, 'address');\n   * // select a range of cells\n   * hot.selectCell(2, 4, 3, 5);\n   * // select a range of cells using column properties\n   * hot.selectCell(2, 'address', 3, 'phone_number');\n   * // select a range of cells without scrolling to them\n   * hot.selectCell(2, 'address', 3, 'phone_number', false);\n   * ```\n   *\n   * @memberof Core#\n   * @function selectCell\n   * @param {number} row Visual row index.\n   * @param {number|string} column Visual column index or column property.\n   * @param {number} [endRow] Visual end row index (if selecting a range).\n   * @param {number|string} [endColumn] Visual end column index or column property (if selecting a range).\n   * @param {boolean} [scrollToCell=true] If `true`, the viewport will be scrolled to the selection.\n   * @param {boolean} [changeListener=true] If `false`, Handsontable will not change keyboard events listener to himself.\n   * @returns {boolean} `true` if selection was successful, `false` otherwise.\n   */\n\n\n  this.selectCell = function (row, column, endRow, endColumn) {\n    var scrollToCell = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    var changeListener = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n\n    if (isUndefined(row) || isUndefined(column)) {\n      return false;\n    }\n\n    return this.selectCells([[row, column, endRow, endColumn]], scrollToCell, changeListener);\n  };\n  /**\n   * Make multiple, non-contiguous selection specified by `row` and `column` values or a range of cells\n   * finishing at `endRow`, `endColumn`. The method supports two input formats which are the same as that\n   * produces by `getSelected` and `getSelectedRange` methods.\n   *\n   * By default, viewport will be scrolled to selection. After the `selectCells` method had finished, the instance\n   * will be listening to keyboard input on the document.\n   *\n   * @example\n   * ```js\n   * // Using an array of arrays.\n   * hot.selectCells([[1, 1, 2, 2], [3, 3], [6, 2, 0, 2]]);\n   * // Using an array of arrays with defined columns as props.\n   * hot.selectCells([[1, 'id', 2, 'first_name'], [3, 'full_name'], [6, 'last_name', 0, 'first_name']]);\n   * // Using an array of CellRange objects (produced by `.getSelectedRange()` method).\n   * const selected = hot.getSelectedRange();\n   *\n   * selected[0].from.row = 0;\n   * selected[0].from.col = 0;\n   *\n   * hot.selectCells(selected);\n   * ```\n   *\n   * @memberof Core#\n   * @since 0.38.0\n   * @function selectCells\n   * @param {Array[]|CellRange[]} coords Visual coords passed as an array of array (`[[rowStart, columnStart, rowEnd, columnEnd], ...]`)\n   *                                     the same format as `getSelected` method returns or as an CellRange objects\n   *                                     which is the same format what `getSelectedRange` method returns.\n   * @param {boolean} [scrollToCell=true] If `true`, the viewport will be scrolled to the selection.\n   * @param {boolean} [changeListener=true] If `false`, Handsontable will not change keyboard events listener to himself.\n   * @returns {boolean} `true` if selection was successful, `false` otherwise.\n   */\n\n\n  this.selectCells = function () {\n    var coords = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [[]];\n    var scrollToCell = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var changeListener = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n    if (scrollToCell === false) {\n      preventScrollingToCell = true;\n    }\n\n    var wasSelected = selection.selectCells(coords);\n\n    if (wasSelected && changeListener) {\n      instance.listen();\n    }\n\n    preventScrollingToCell = false;\n    return wasSelected;\n  };\n  /**\n   * Select column specified by `startColumn` visual index, column property or a range of columns finishing at `endColumn`.\n   *\n   * @example\n   * ```js\n   * // Select column using visual index.\n   * hot.selectColumns(1);\n   * // Select column using column property.\n   * hot.selectColumns('id');\n   * // Select range of columns using visual indexes.\n   * hot.selectColumns(1, 4);\n   * // Select range of columns using column properties.\n   * hot.selectColumns('id', 'last_name');\n   * ```\n   *\n   * @memberof Core#\n   * @since 0.38.0\n   * @function selectColumns\n   * @param {number} startColumn The visual column index from which the selection starts.\n   * @param {number} [endColumn=startColumn] The visual column index to which the selection finishes. If `endColumn`\n   *                                         is not defined the column defined by `startColumn` will be selected.\n   * @returns {boolean} `true` if selection was successful, `false` otherwise.\n   */\n\n\n  this.selectColumns = function (startColumn) {\n    var endColumn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startColumn;\n    return selection.selectColumns(startColumn, endColumn);\n  };\n  /**\n   * Select row specified by `startRow` visual index or a range of rows finishing at `endRow`.\n   *\n   * @example\n   * ```js\n   * // Select row using visual index.\n   * hot.selectRows(1);\n   * // Select range of rows using visual indexes.\n   * hot.selectRows(1, 4);\n   * ```\n   *\n   * @memberof Core#\n   * @since 0.38.0\n   * @function selectRows\n   * @param {number} startRow The visual row index from which the selection starts.\n   * @param {number} [endRow=startRow] The visual row index to which the selection finishes. If `endRow`\n   *                                   is not defined the row defined by `startRow` will be selected.\n   * @returns {boolean} `true` if selection was successful, `false` otherwise.\n   */\n\n\n  this.selectRows = function (startRow) {\n    var endRow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startRow;\n    return selection.selectRows(startRow, endRow);\n  };\n  /**\n   * Deselects the current cell selection on the table.\n   *\n   * @memberof Core#\n   * @function deselectCell\n   */\n\n\n  this.deselectCell = function () {\n    selection.deselect();\n  };\n  /**\n   * Select the whole table. The previous selection will be overwritten.\n   *\n   * @since 0.38.2\n   * @memberof Core#\n   * @function selectAll\n   * @param {boolean} [includeHeaders=true] `true` If the selection should include the row, column and corner headers,\n   * `false` otherwise.\n   */\n\n\n  this.selectAll = function () {\n    var includeHeaders = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    var includeRowHeaders = includeHeaders && this.hasRowHeaders();\n    var includeColumnHeaders = includeHeaders && this.hasColHeaders();\n    preventScrollingToCell = true;\n    selection.selectAll(includeRowHeaders, includeColumnHeaders);\n    preventScrollingToCell = false;\n  };\n\n  var getIndexToScroll = function getIndexToScroll(indexMapper, visualIndex) {\n    // Looking for a visual index on the right and then (when not found) on the left.\n    return indexMapper.getFirstNotHiddenIndex(visualIndex, 1, true);\n  };\n  /**\n   * Scroll viewport to coordinates specified by the `row` and `column` arguments.\n   *\n   * @memberof Core#\n   * @function scrollViewportTo\n   * @param {number} [row] Row index. If the last argument isn't defined we treat the index as a visual row index. Otherwise,\n   * we are using the index for numbering only this rows which may be rendered (we don't consider hidden rows).\n   * @param {number} [column] Column index. If the last argument isn't defined we treat the index as a visual column index.\n   * Otherwise, we are using the index for numbering only this columns which may be rendered (we don't consider hidden columns).\n   * @param {boolean} [snapToBottom=false] If `true`, viewport is scrolled to show the cell on the bottom of the table.\n   * @param {boolean} [snapToRight=false] If `true`, viewport is scrolled to show the cell on the right side of the table.\n   * @param {boolean} [considerHiddenIndexes=true] If `true`, we handle visual indexes, otherwise we handle only indexes which\n   * may be rendered when they are in the viewport (we don't consider hidden indexes as they aren't rendered).\n   * @returns {boolean} `true` if scroll was successful, `false` otherwise.\n   */\n\n\n  this.scrollViewportTo = function (row, column) {\n    var snapToBottom = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var snapToRight = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    var considerHiddenIndexes = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    var snapToTop = !snapToBottom;\n    var snapToLeft = !snapToRight;\n    var renderableRow = row;\n    var renderableColumn = column;\n\n    if (considerHiddenIndexes) {\n      var _isRowInteger = Number.isInteger(row);\n\n      var _isColumnInteger = Number.isInteger(column);\n\n      var visualRowToScroll = _isRowInteger ? getIndexToScroll(this.rowIndexMapper, row) : void 0;\n      var visualColumnToScroll = _isColumnInteger ? getIndexToScroll(this.columnIndexMapper, column) : void 0;\n\n      if (visualRowToScroll === null || visualColumnToScroll === null) {\n        return false;\n      }\n\n      renderableRow = _isRowInteger ? instance.rowIndexMapper.getRenderableFromVisualIndex(visualRowToScroll) : void 0;\n      renderableColumn = _isColumnInteger ? instance.columnIndexMapper.getRenderableFromVisualIndex(visualColumnToScroll) : void 0;\n    }\n\n    var isRowInteger = Number.isInteger(renderableRow);\n    var isColumnInteger = Number.isInteger(renderableColumn);\n\n    if (isRowInteger && isColumnInteger) {\n      return instance.view.scrollViewport(new CellCoords(renderableRow, renderableColumn), snapToTop, snapToRight, snapToBottom, snapToLeft);\n    }\n\n    if (isRowInteger && isColumnInteger === false) {\n      return instance.view.scrollViewportVertically(renderableRow, snapToTop, snapToBottom);\n    }\n\n    if (isColumnInteger && isRowInteger === false) {\n      return instance.view.scrollViewportHorizontally(renderableColumn, snapToRight, snapToLeft);\n    }\n\n    return false;\n  };\n  /**\n   * Removes the table from the DOM and destroys the instance of the Handsontable.\n   *\n   * @memberof Core#\n   * @function destroy\n   * @fires Hooks#afterDestroy\n   */\n\n\n  this.destroy = function () {\n    instance._clearTimeouts();\n\n    instance._clearImmediates();\n\n    if (instance.view) {\n      // in case HT is destroyed before initialization has finished\n      instance.view.destroy();\n    }\n\n    if (dataSource) {\n      dataSource.destroy();\n    }\n\n    dataSource = null;\n    metaManager.clearCache();\n    keyStateStopObserving();\n\n    if (isRootInstance(instance)) {\n      var licenseInfo = this.rootDocument.querySelector('#hot-display-license-info');\n\n      if (licenseInfo) {\n        licenseInfo.parentNode.removeChild(licenseInfo);\n      }\n    }\n\n    empty(instance.rootElement);\n    eventManager.destroy();\n\n    if (editorManager) {\n      editorManager.destroy();\n    } // The plugin's `destroy` method is called as a consequence and it should handle\n    // unregistration of plugin's maps. Some unregistered maps reset the cache.\n\n\n    instance.batchExecution(function () {\n      instance.rowIndexMapper.unregisterAll();\n      instance.columnIndexMapper.unregisterAll();\n      pluginsRegistry.getItems().forEach(function (_ref20) {\n        var _ref21 = _slicedToArray(_ref20, 2),\n            plugin = _ref21[1];\n\n        plugin.destroy();\n      });\n      pluginsRegistry.clear();\n      instance.runHooks('afterDestroy');\n    }, true);\n    Hooks.getSingleton().destroy(instance);\n    objectEach(instance, function (property, key, obj) {\n      // replace instance methods with post mortem\n      if (isFunction(property)) {\n        obj[key] = postMortem(key);\n      } else if (key !== 'guid') {\n        // replace instance properties with null (restores memory)\n        // it should not be necessary but this prevents a memory leak side effects that show itself in Jasmine tests\n        obj[key] = null;\n      }\n    });\n    instance.isDestroyed = true; // replace private properties with null (restores memory)\n    // it should not be necessary but this prevents a memory leak side effects that show itself in Jasmine tests\n\n    if (datamap) {\n      datamap.destroy();\n    }\n\n    instance.rowIndexMapper = null;\n    instance.columnIndexMapper = null;\n    datamap = null;\n    grid = null;\n    selection = null;\n    editorManager = null;\n    instance = null;\n  };\n  /**\n   * Replacement for all methods after the Handsontable was destroyed.\n   *\n   * @private\n   * @param {string} method The method name.\n   * @returns {Function}\n   */\n\n\n  function postMortem(method) {\n    return function () {\n      throw new Error(\"The \\\"\".concat(method, \"\\\" method cannot be called because this Handsontable instance has been destroyed\"));\n    };\n  }\n  /**\n   * Returns the active editor class instance.\n   *\n   * @memberof Core#\n   * @function getActiveEditor\n   * @returns {BaseEditor} The active editor instance.\n   */\n\n\n  this.getActiveEditor = function () {\n    return editorManager.getActiveEditor();\n  };\n  /**\n   * Returns plugin instance by provided its name.\n   *\n   * @memberof Core#\n   * @function getPlugin\n   * @param {string} pluginName The plugin name.\n   * @returns {BasePlugin|undefined} The plugin instance or undefined if there is no plugin.\n   */\n\n\n  this.getPlugin = function (pluginName) {\n    var unifiedPluginName = toUpperCaseFirst(pluginName); // Workaround for the UndoRedo plugin which, currently doesn't follow the plugin architecture.\n\n    if (unifiedPluginName === 'UndoRedo') {\n      return this.undoRedo;\n    }\n\n    return pluginsRegistry.getItem(unifiedPluginName);\n  };\n  /**\n   * Returns name of the passed plugin.\n   *\n   * @private\n   * @memberof Core#\n   * @param {BasePlugin} plugin The plugin instance.\n   * @returns {string}\n   */\n\n\n  this.getPluginName = function (plugin) {\n    // Workaround for the UndoRedo plugin which, currently doesn't follow the plugin architecture.\n    if (plugin === this.undoRedo) {\n      return this.undoRedo.constructor.PLUGIN_KEY;\n    }\n\n    return pluginsRegistry.getId(plugin);\n  };\n  /**\n   * Returns the Handsontable instance.\n   *\n   * @memberof Core#\n   * @function getInstance\n   * @returns {Handsontable} The Handsontable instance.\n   */\n\n\n  this.getInstance = function () {\n    return instance;\n  };\n  /**\n   * Adds listener to the specified hook name (only for this Handsontable instance).\n   *\n   * @memberof Core#\n   * @function addHook\n   * @see Hooks#add\n   * @param {string} key Hook name (see {@link Hooks}).\n   * @param {Function|Array} callback Function or array of functions.\n   * @example\n   * ```js\n   * hot.addHook('beforeInit', myCallback);\n   * ```\n   */\n\n\n  this.addHook = function (key, callback) {\n    Hooks.getSingleton().add(key, callback, instance);\n  };\n  /**\n   * Check if for a specified hook name there are added listeners (only for this Handsontable instance). All available\n   * hooks you will find {@link Hooks}.\n   *\n   * @memberof Core#\n   * @function hasHook\n   * @see Hooks#has\n   * @param {string} key Hook name.\n   * @returns {boolean}\n   *\n   * @example\n   * ```js\n   * const hasBeforeInitListeners = hot.hasHook('beforeInit');\n   * ```\n   */\n\n\n  this.hasHook = function (key) {\n    return Hooks.getSingleton().has(key, instance);\n  };\n  /**\n   * Adds listener to specified hook name (only for this Handsontable instance). After the listener is triggered,\n   * it will be automatically removed.\n   *\n   * @memberof Core#\n   * @function addHookOnce\n   * @see Hooks#once\n   * @param {string} key Hook name (see {@link Hooks}).\n   * @param {Function|Array} callback Function or array of functions.\n   * @example\n   * ```js\n   * hot.addHookOnce('beforeInit', myCallback);\n   * ```\n   */\n\n\n  this.addHookOnce = function (key, callback) {\n    Hooks.getSingleton().once(key, callback, instance);\n  };\n  /**\n   * Removes the hook listener previously registered with {@link Core#addHook}.\n   *\n   * @memberof Core#\n   * @function removeHook\n   * @see Hooks#remove\n   * @param {string} key Hook name.\n   * @param {Function} callback Reference to the function which has been registered using {@link Core#addHook}.\n   *\n   * @example\n   * ```js\n   * hot.removeHook('beforeInit', myCallback);\n   * ```\n   */\n\n\n  this.removeHook = function (key, callback) {\n    Hooks.getSingleton().remove(key, callback, instance);\n  };\n  /**\n   * Run the callbacks for the hook provided in the `key` argument using the parameters given in the other arguments.\n   *\n   * @memberof Core#\n   * @function runHooks\n   * @see Hooks#run\n   * @param {string} key Hook name.\n   * @param {*} [p1] Argument passed to the callback.\n   * @param {*} [p2] Argument passed to the callback.\n   * @param {*} [p3] Argument passed to the callback.\n   * @param {*} [p4] Argument passed to the callback.\n   * @param {*} [p5] Argument passed to the callback.\n   * @param {*} [p6] Argument passed to the callback.\n   * @returns {*}\n   *\n   * @example\n   * ```js\n   * // Run built-in hook\n   * hot.runHooks('beforeInit');\n   * // Run custom hook\n   * hot.runHooks('customAction', 10, 'foo');\n   * ```\n   */\n\n\n  this.runHooks = function (key, p1, p2, p3, p4, p5, p6) {\n    return Hooks.getSingleton().run(instance, key, p1, p2, p3, p4, p5, p6);\n  };\n  /**\n   * Get language phrase for specified dictionary key.\n   *\n   * @memberof Core#\n   * @function getTranslatedPhrase\n   * @since 0.35.0\n   * @param {string} dictionaryKey Constant which is dictionary key.\n   * @param {*} extraArguments Arguments which will be handled by formatters.\n   * @returns {string}\n   */\n\n\n  this.getTranslatedPhrase = function (dictionaryKey, extraArguments) {\n    return getTranslatedPhrase(tableMeta.language, dictionaryKey, extraArguments);\n  };\n  /**\n   * Converts instance into outerHTML of HTMLTableElement.\n   *\n   * @memberof Core#\n   * @function toHTML\n   * @since 7.1.0\n   * @returns {string}\n   */\n\n\n  this.toHTML = function () {\n    return instanceToHTML(_this);\n  };\n  /**\n   * Converts instance into HTMLTableElement.\n   *\n   * @memberof Core#\n   * @function toTableElement\n   * @since 7.1.0\n   * @returns {HTMLTableElement}\n   */\n\n\n  this.toTableElement = function () {\n    var tempElement = _this.rootDocument.createElement('div');\n\n    tempElement.insertAdjacentHTML('afterbegin', instanceToHTML(_this));\n    return tempElement.firstElementChild;\n  };\n\n  this.timeouts = [];\n  /**\n   * Sets timeout. Purpose of this method is to clear all known timeouts when `destroy` method is called.\n   *\n   * @param {number|Function} handle Handler returned from setTimeout or function to execute (it will be automatically wraped\n   *                                 by setTimeout function).\n   * @param {number} [delay=0] If first argument is passed as a function this argument set delay of the execution of that function.\n   * @private\n   */\n\n  this._registerTimeout = function (handle) {\n    var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var handleFunc = handle;\n\n    if (typeof handleFunc === 'function') {\n      handleFunc = setTimeout(handleFunc, delay);\n    }\n\n    this.timeouts.push(handleFunc);\n  };\n  /**\n   * Clears all known timeouts.\n   *\n   * @private\n   */\n\n\n  this._clearTimeouts = function () {\n    arrayEach(this.timeouts, function (handler) {\n      clearTimeout(handler);\n    });\n  };\n\n  this.immediates = [];\n  /**\n   * Execute function execution to the next event loop cycle. Purpose of this method is to clear all known timeouts when `destroy` method is called.\n   *\n   * @param {Function} callback Function to be delayed in execution.\n   * @private\n   */\n\n  this._registerImmediate = function (callback) {\n    this.immediates.push(setImmediate(callback));\n  };\n  /**\n   * Clears all known timeouts.\n   *\n   * @private\n   */\n\n\n  this._clearImmediates = function () {\n    arrayEach(this.immediates, function (handler) {\n      clearImmediate(handler);\n    });\n  };\n  /**\n   * Refresh selection borders. This is temporary method relic after selection rewrite.\n   *\n   * @private\n   * @param {boolean} [revertOriginal=false] If `true`, the previous value will be restored. Otherwise, the edited value will be saved.\n   * @param {boolean} [prepareEditorIfNeeded=true] If `true` the editor under the selected cell will be prepared to open.\n   */\n\n\n  this._refreshBorders = function () {\n    var revertOriginal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var prepareEditorIfNeeded = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    editorManager.destroyEditor(revertOriginal);\n    instance.view.render();\n\n    if (prepareEditorIfNeeded && selection.isSelected()) {\n      editorManager.prepareEditor();\n    }\n  };\n  /**\n   * Check if currently it is RTL direction.\n   *\n   * @private\n   * @memberof Core#\n   * @function isRtl\n   * @returns {boolean} True if RTL.\n   */\n\n\n  this.isRtl = function () {\n    return instance.rootWindow.getComputedStyle(instance.rootElement).direction === 'rtl';\n  };\n  /**\n   * Check if currently it is LTR direction.\n   *\n   * @private\n   * @memberof Core#\n   * @function isLtr\n   * @returns {boolean} True if LTR.\n   */\n\n\n  this.isLtr = function () {\n    return !instance.isRtl();\n  };\n  /**\n   * Returns 1 for LTR; -1 for RTL. Useful for calculations.\n   *\n   * @private\n   * @memberof Core#\n   * @function getDirectionFactor\n   * @returns {number} Returns 1 for LTR; -1 for RTL.\n   */\n\n\n  this.getDirectionFactor = function () {\n    return instance.isLtr() ? 1 : -1;\n  };\n\n  getPluginsNames().forEach(function (pluginName) {\n    var PluginClass = getPlugin(pluginName);\n    pluginsRegistry.addItem(pluginName, new PluginClass(_this));\n  });\n  Hooks.getSingleton().run(instance, 'construct');\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}