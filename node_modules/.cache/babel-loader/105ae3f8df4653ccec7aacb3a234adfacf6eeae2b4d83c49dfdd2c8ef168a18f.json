{"ast":null,"code":"import moment from 'moment'; // Formats which are correctly parsed to time (supported by momentjs)\n\nvar STRICT_FORMATS = ['YYYY-MM-DDTHH:mm:ss.SSSZ', 'X',\n// Unix timestamp\n'x' // Unix ms timestamp\n];\nexport var VALIDATOR_TYPE = 'time';\n/**\n * The Time cell validator.\n *\n * @private\n * @param {*} value Value of edited cell.\n * @param {Function} callback Callback called with validation result.\n */\n\nexport function timeValidator(value, callback) {\n  var timeFormat = this.timeFormat || 'h:mm:ss a';\n  var valid = true;\n  var valueToValidate = value;\n  if (valueToValidate === null) {\n    valueToValidate = '';\n  }\n  valueToValidate = /^\\d{3,}$/.test(valueToValidate) ? parseInt(valueToValidate, 10) : valueToValidate;\n  var twoDigitValue = /^\\d{1,2}$/.test(valueToValidate);\n  if (twoDigitValue) {\n    valueToValidate += ':00';\n  }\n  var date = moment(valueToValidate, STRICT_FORMATS, true).isValid() ? moment(valueToValidate) : moment(valueToValidate, timeFormat);\n  var isValidTime = date.isValid(); // is it in the specified format\n\n  var isValidFormat = moment(valueToValidate, timeFormat, true).isValid() && !twoDigitValue;\n  if (this.allowEmpty && valueToValidate === '') {\n    isValidTime = true;\n    isValidFormat = true;\n  }\n  if (!isValidTime) {\n    valid = false;\n  }\n  if (!isValidTime && isValidFormat) {\n    valid = true;\n  }\n  if (isValidTime && !isValidFormat) {\n    if (this.correctFormat === true) {\n      // if format correction is enabled\n      var correctedValue = date.format(timeFormat);\n      var row = this.instance.toVisualRow(this.row);\n      var column = this.instance.toVisualColumn(this.col);\n      this.instance.setDataAtCell(row, column, correctedValue, 'timeValidator');\n      valid = true;\n    } else {\n      valid = false;\n    }\n  }\n  callback(valid);\n}\ntimeValidator.VALIDATOR_TYPE = VALIDATOR_TYPE;","map":{"version":3,"names":["moment","STRICT_FORMATS","VALIDATOR_TYPE","timeValidator","value","callback","timeFormat","valid","valueToValidate","test","parseInt","twoDigitValue","date","isValid","isValidTime","isValidFormat","allowEmpty","correctFormat","correctedValue","format","row","instance","toVisualRow","column","toVisualColumn","col","setDataAtCell"],"sources":["/Users/priyadeliwala/Desktop/sales-dashboard/node_modules/handsontable/validators/timeValidator/timeValidator.mjs"],"sourcesContent":["import \"core-js/modules/es.regexp.exec.js\";\nimport moment from 'moment'; // Formats which are correctly parsed to time (supported by momentjs)\n\nvar STRICT_FORMATS = ['YYYY-MM-DDTHH:mm:ss.SSSZ', 'X', // Unix timestamp\n'x' // Unix ms timestamp\n];\nexport var VALIDATOR_TYPE = 'time';\n/**\n * The Time cell validator.\n *\n * @private\n * @param {*} value Value of edited cell.\n * @param {Function} callback Callback called with validation result.\n */\n\nexport function timeValidator(value, callback) {\n  var timeFormat = this.timeFormat || 'h:mm:ss a';\n  var valid = true;\n  var valueToValidate = value;\n\n  if (valueToValidate === null) {\n    valueToValidate = '';\n  }\n\n  valueToValidate = /^\\d{3,}$/.test(valueToValidate) ? parseInt(valueToValidate, 10) : valueToValidate;\n  var twoDigitValue = /^\\d{1,2}$/.test(valueToValidate);\n\n  if (twoDigitValue) {\n    valueToValidate += ':00';\n  }\n\n  var date = moment(valueToValidate, STRICT_FORMATS, true).isValid() ? moment(valueToValidate) : moment(valueToValidate, timeFormat);\n  var isValidTime = date.isValid(); // is it in the specified format\n\n  var isValidFormat = moment(valueToValidate, timeFormat, true).isValid() && !twoDigitValue;\n\n  if (this.allowEmpty && valueToValidate === '') {\n    isValidTime = true;\n    isValidFormat = true;\n  }\n\n  if (!isValidTime) {\n    valid = false;\n  }\n\n  if (!isValidTime && isValidFormat) {\n    valid = true;\n  }\n\n  if (isValidTime && !isValidFormat) {\n    if (this.correctFormat === true) {\n      // if format correction is enabled\n      var correctedValue = date.format(timeFormat);\n      var row = this.instance.toVisualRow(this.row);\n      var column = this.instance.toVisualColumn(this.col);\n      this.instance.setDataAtCell(row, column, correctedValue, 'timeValidator');\n      valid = true;\n    } else {\n      valid = false;\n    }\n  }\n\n  callback(valid);\n}\ntimeValidator.VALIDATOR_TYPE = VALIDATOR_TYPE;"],"mappings":"AACA,OAAOA,MAAM,MAAM,QAAQ,CAAC,CAAC;;AAE7B,IAAIC,cAAc,GAAG,CAAC,0BAA0B,EAAE,GAAG;AAAE;AACvD,GAAG,CAAC;AAAA,CACH;AACD,OAAO,IAAIC,cAAc,GAAG,MAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASC,aAAaA,CAACC,KAAK,EAAEC,QAAQ,EAAE;EAC7C,IAAIC,UAAU,GAAG,IAAI,CAACA,UAAU,IAAI,WAAW;EAC/C,IAAIC,KAAK,GAAG,IAAI;EAChB,IAAIC,eAAe,GAAGJ,KAAK;EAE3B,IAAII,eAAe,KAAK,IAAI,EAAE;IAC5BA,eAAe,GAAG,EAAE;EACtB;EAEAA,eAAe,GAAG,UAAU,CAACC,IAAI,CAACD,eAAe,CAAC,GAAGE,QAAQ,CAACF,eAAe,EAAE,EAAE,CAAC,GAAGA,eAAe;EACpG,IAAIG,aAAa,GAAG,WAAW,CAACF,IAAI,CAACD,eAAe,CAAC;EAErD,IAAIG,aAAa,EAAE;IACjBH,eAAe,IAAI,KAAK;EAC1B;EAEA,IAAII,IAAI,GAAGZ,MAAM,CAACQ,eAAe,EAAEP,cAAc,EAAE,IAAI,CAAC,CAACY,OAAO,CAAC,CAAC,GAAGb,MAAM,CAACQ,eAAe,CAAC,GAAGR,MAAM,CAACQ,eAAe,EAAEF,UAAU,CAAC;EAClI,IAAIQ,WAAW,GAAGF,IAAI,CAACC,OAAO,CAAC,CAAC,CAAC,CAAC;;EAElC,IAAIE,aAAa,GAAGf,MAAM,CAACQ,eAAe,EAAEF,UAAU,EAAE,IAAI,CAAC,CAACO,OAAO,CAAC,CAAC,IAAI,CAACF,aAAa;EAEzF,IAAI,IAAI,CAACK,UAAU,IAAIR,eAAe,KAAK,EAAE,EAAE;IAC7CM,WAAW,GAAG,IAAI;IAClBC,aAAa,GAAG,IAAI;EACtB;EAEA,IAAI,CAACD,WAAW,EAAE;IAChBP,KAAK,GAAG,KAAK;EACf;EAEA,IAAI,CAACO,WAAW,IAAIC,aAAa,EAAE;IACjCR,KAAK,GAAG,IAAI;EACd;EAEA,IAAIO,WAAW,IAAI,CAACC,aAAa,EAAE;IACjC,IAAI,IAAI,CAACE,aAAa,KAAK,IAAI,EAAE;MAC/B;MACA,IAAIC,cAAc,GAAGN,IAAI,CAACO,MAAM,CAACb,UAAU,CAAC;MAC5C,IAAIc,GAAG,GAAG,IAAI,CAACC,QAAQ,CAACC,WAAW,CAAC,IAAI,CAACF,GAAG,CAAC;MAC7C,IAAIG,MAAM,GAAG,IAAI,CAACF,QAAQ,CAACG,cAAc,CAAC,IAAI,CAACC,GAAG,CAAC;MACnD,IAAI,CAACJ,QAAQ,CAACK,aAAa,CAACN,GAAG,EAAEG,MAAM,EAAEL,cAAc,EAAE,eAAe,CAAC;MACzEX,KAAK,GAAG,IAAI;IACd,CAAC,MAAM;MACLA,KAAK,GAAG,KAAK;IACf;EACF;EAEAF,QAAQ,CAACE,KAAK,CAAC;AACjB;AACAJ,aAAa,CAACD,cAAc,GAAGA,cAAc","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}