{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nimport { arrayFilter } from \"../../helpers/array.mjs\";\nimport { assert, isUnsignedNumber, isNullish } from \"./utils.mjs\";\n/* eslint-disable jsdoc/require-description-complete-sentence */\n\n/**\n * @class LazyFactoryMap\n *\n * The LazyFactoryMap object holds key-value pairs in the structure similar to the\n * regular Map. Once created, items can be moved around a grid depending on the operations\n * performed on that grid - adding or removing rows. The collection requires \"key\"\n * to be a zero-based index.\n *\n * It's essential to notice that the \"key\" index under which the item was created\n * is volatile. After altering the grid, the \"key\" index can change.\n *\n * Having created N items with corresponding example data where the data has 10\n * holes (`undefined` values) within (that's why internal storage index counts from 10).\n * +------+------+------+------+------+.\n * | 0/10 | 1/11 | 2/12 | 3/13 | 4/14 |  Keys (volatile zero-based index / internal storage index)\n * +------+------+------+------+------+.\n *    │      │      │      │      │\n * +------+------+------+------+------+.\n * | AAA  | BBB  | CCC  | DDD  | EEE  |  Data\n * +------+------+------+------+------+.\n *\n * Map.obtain(0) // returns \"AAA\"\n * map.obtain(2) // returns \"CCC\".\n *\n * After inserting 2 new rows, keys that hold the data positioned after the place\n * where the new rows are added are upshifted by 2.\n *               │\n *               │ Insert 2 rows\n *              \\│/\n * +------+------+------+------+------+.\n * | 0/10 | 1/11 | 2/12 | 3/13 | 4/14 |  Keys before\n * +------+------+------+------+------+.\n *\n *                / 2 new rows \\\n * +------+------+------+------+------+------+------+.\n * | 0/10 | 1/11 | 2/15 | 3/16 | 4/12 | 5/13 | 6/14 |  Keys after\n * +------+------+------+------+------+------+------+.\n *    │       │      │      │      │      │     │\n *    │       │      └──────┼──────┼──────┼┐    │\n *    │       │             └──────┼──────┼┼────┼┐\n *    │       │      ┌─────────────┘      ││    ││\n *    │       │      │      ┌─────────────┘│    ││\n *    │       │      │      │      ┌───────┼────┘│\n *    │       │      │      │      │       │     │\n * +------+------+------+------+------+------+------+.\n * | AAA  | BBB  | CCC  | DDD  | EEE  | FFF  | GGG  |  Data\n * +------+------+------+------+------+------+------+\n *\n * Now at index 2 and 3 we have access to new items.\n *\n * map.obtain(2) // returns new value \"FFF\" for newly created row.\n * map.obtain(4) // index shifted by 2 has access to the old \"CCC\" value, as before inserting.\n *\n * after removing 4 rows, keys that hold the data positioned after the place where the\n * rows are removed are downshifted by 4.\n *        │\n *        │ Remove 4 rows\n *        ├───────────────────────────┐\n *       \\│/                          │\n * +------+------+------+------+------+------+------+\n * | 0/10 | 1/11 | 2/15 | 3/16 | 4/12 | 5/13 | 6/14 |  Keys after\n * +------+------+------+------+------+------+------+\n *    │       │      │      │      │      │     │\n *    │       │      └──────┼──────┼──────┼┐    │\n *    │       │             └──────┼──────┼┼────┼┐\n *    │       │      ┌─────────────┘      ││    ││\n *    │       │      │      ┌─────────────┘│    ││\n *    │       │      │      │      ┌───────┼────┘│\n *    │       │      │      │      │       │     │\n * +------+------+------+------+------+------+------+\n * | AAA  | BBB  | CCC  | DDD  | EEE  | FFF  | GGG  |  Data\n * +------+------+------+------+------+------+------+\n *\n * +------+------+------+\n * | 0/10 | 1/13 | 2/14 |  Keys after\n * +------+------+------+\n *    │       │      │\n *    │       │      └─────────────┐\n *    │       └────────────┐       │\n *    │                    │       │\n *    │                    │       │\n *    │                    │       │\n *    │                    │       │\n * +------+------+------+------+------+------+------+\n * | AAA  | BBB  | CCC  | DDD  | EEE  | FFF  | GGG  |  Data\n * +------+------+------+------+------+------+------+\n *           /│\\   /│\\                   /│\\   /│\\\n *            └──┬──┘                     └──┬──┘\n *           This data is marked as \"hole\" which\n *           means that can be replaced by new item\n *           when that will be created.\n *\n * map.obtain(2) // returns the value (\"EEE\") as it should. Access to the value is\n *               // changed (the key was downshifted). However, the internal index has not changed,\n *               // which means that the data does not need to be changed (spliced) too.\n *\n * After previous remove operation which creates some \"holes\" obtaining new\n * items replaces that \"holes\" as follows:\n *\n * // Obtains new item\n * map.obtain(90) // Returns \"NEW\" value\n *\n * +------+------+------+...+------+\n * | 0/10 | 1/13 | 2/14 |   | 90/0 |  Keys after\n * +------+------+------+...+------+\n *    │       │      │          │\n *    │       │      └──────────┼────────────┐\n *    │       └─────────────────┼─────┐      │\n *    └──────────┐              │     │      │\n *               │              │     │      │\n *    ┌──────────┼──────────────┘     │      │\n *    │          │                    │      │\n * +------+...+------+------+------+------+------+-----+\n * | NEW  |   | AAA  | BBB  | CCC  | DDD  | EEE  | FFF |  Data\n * +------+...+------+------+------+------+------+-----+\n *   /│\\\n *    │\n * The first \"hole\" (at index 0) item is permanently removed and replaced by a new item.\n * The hole index is taken from the hole collection which act as FIFO (First In First Out).\n */\n\n/* eslint-enable jsdoc/require-description-complete-sentence */\n\nvar LazyFactoryMap = /*#__PURE__*/function (_Symbol$iterator) {\n  function LazyFactoryMap(valueFactory) {\n    _classCallCheck(this, LazyFactoryMap);\n    this.valueFactory = valueFactory;\n    /**\n     * An array which contains data.\n     *\n     * @type {Array}\n     */\n\n    this.data = [];\n    /**\n     * An array of indexes where the key of the array is mapped to the value which points to the\n     * specific position of the data array.\n     *\n     * @type {number[]}\n     */\n\n    this.index = [];\n    /**\n     * The collection of indexes that points to the data items which can be replaced by obtaining new\n     * ones. The \"holes\" are an intended effect of deleting entries.\n     *\n     * The idea of \"holes\" generally allows us to not modify the \"data\" structure while removing\n     * items from the collection.\n     *\n     * @type {Set<number>}\n     */\n\n    this.holes = new Set();\n  }\n  /**\n   * Gets or if data not exist creates and returns new data.\n   *\n   * @param {number} key The item key as zero-based index.\n   * @returns {*}\n   */\n\n  _createClass(LazyFactoryMap, [{\n    key: \"obtain\",\n    value: function obtain(key) {\n      assert(function () {\n        return isUnsignedNumber(key);\n      }, 'Expecting an unsigned number.');\n      var dataIndex = this._getStorageIndexByKey(key);\n      var result;\n      if (dataIndex >= 0) {\n        result = this.data[dataIndex];\n        if (result === void 0) {\n          result = this.valueFactory(key);\n          this.data[dataIndex] = result;\n        }\n      } else {\n        result = this.valueFactory(key);\n        if (this.holes.size > 0) {\n          var reuseIndex = this.holes.values().next().value; // Gets first item from the collection\n\n          this.holes.delete(reuseIndex);\n          this.data[reuseIndex] = result;\n          this.index[key] = reuseIndex;\n        } else {\n          this.data.push(result);\n          this.index[key] = this.data.length - 1;\n        }\n      }\n      return result;\n    }\n    /**\n     * Inserts an empty data to the map. This method creates an empty space for obtaining\n     * new data.\n     *\n     * @param {number} key The key as volatile zero-based index at which to begin inserting space for new data.\n     * @param {number} [amount=1] Ammount of data to insert.\n     */\n  }, {\n    key: \"insert\",\n    value: function insert(key) {\n      var _this$index;\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      assert(function () {\n        return isUnsignedNumber(key) || isNullish(key);\n      }, 'Expecting an unsigned number or null/undefined argument.');\n      var newIndexes = [];\n      var dataLength = this.data.length;\n      for (var i = 0; i < amount; i++) {\n        newIndexes.push(dataLength + i);\n        this.data.push(void 0);\n      }\n      (_this$index = this.index).splice.apply(_this$index, [isNullish(key) ? this.index.length : key, 0].concat(newIndexes));\n    }\n    /**\n     * Removes (soft remove) data from \"index\" and according to the amount of data.\n     *\n     * @param {number} key The key as volatile zero-based index at which to begin removing the data.\n     * @param {number} [amount=1] Ammount data to remove.\n     */\n  }, {\n    key: \"remove\",\n    value: function remove(key) {\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      assert(function () {\n        return isUnsignedNumber(key) || isNullish(key);\n      }, 'Expecting an unsigned number or null/undefined argument.');\n      var removed = this.index.splice(isNullish(key) ? this.index.length - amount : key, amount);\n      for (var i = 0; i < removed.length; i++) {\n        var removedIndex = removed[i];\n        if (typeof removedIndex === 'number') {\n          this.holes.add(removedIndex);\n        }\n      }\n    }\n    /**\n     * Returns the size of the data which this map holds.\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"size\",\n    value: function size() {\n      return this.data.length - this.holes.size;\n    }\n    /**\n     * Returns a new Iterator object that contains the values for each item in the LazyMap object.\n     *\n     * @returns {Iterator}\n     */\n  }, {\n    key: \"values\",\n    value: function values() {\n      var _this = this;\n      return arrayFilter(this.data, function (_, index) {\n        return !_this.holes.has(index);\n      })[Symbol.iterator]();\n    }\n    /**\n     * Returns a new Iterator object that contains an array of `[index, value]` for each item in the LazyMap object.\n     *\n     * @returns {Iterator}\n     */\n  }, {\n    key: \"entries\",\n    value: function entries() {\n      var validEntries = [];\n      for (var i = 0; i < this.data.length; i++) {\n        var keyIndex = this._getKeyByStorageIndex(i);\n        if (keyIndex !== -1) {\n          validEntries.push([keyIndex, this.data[i]]);\n        }\n      }\n      var dataIndex = 0;\n      return {\n        next: function next() {\n          if (dataIndex < validEntries.length) {\n            var value = validEntries[dataIndex];\n            dataIndex += 1;\n            return {\n              value: value,\n              done: false\n            };\n          }\n          return {\n            done: true\n          };\n        }\n      };\n    }\n    /**\n     * Clears the map.\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.data = [];\n      this.index = [];\n      this.holes.clear();\n    }\n    /**\n     * Gets storage index calculated from the key associated with the specified value.\n     *\n     * @param {number} key Volatile zero-based index.\n     * @returns {number} Returns index 0-N or -1 if no storage index found.\n     */\n  }, {\n    key: \"_getStorageIndexByKey\",\n    value: function _getStorageIndexByKey(key) {\n      return this.index.length > key ? this.index[key] : -1;\n    }\n    /**\n     * Gets the key associated with the specified value calculated from storage index.\n     *\n     * @param {number} dataIndex Zero-based storage index.\n     * @returns {number} Returns index 0-N or -1 if no key found.\n     */\n  }, {\n    key: \"_getKeyByStorageIndex\",\n    value: function _getKeyByStorageIndex(dataIndex) {\n      return this.index.indexOf(dataIndex);\n    }\n    /**\n     * Makes this object iterable.\n     *\n     * @returns {Iterator}\n     */\n  }, {\n    key: _Symbol$iterator,\n    value: function value() {\n      return this.entries();\n    }\n  }]);\n  return LazyFactoryMap;\n}(Symbol.iterator);\nexport { LazyFactoryMap as default };","map":{"version":3,"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","arrayFilter","assert","isUnsignedNumber","isNullish","LazyFactoryMap","_Symbol$iterator","valueFactory","data","index","holes","Set","value","obtain","dataIndex","_getStorageIndexByKey","result","size","reuseIndex","values","next","delete","push","insert","_this$index","amount","arguments","undefined","newIndexes","dataLength","splice","apply","concat","remove","removed","removedIndex","add","_this","_","has","Symbol","iterator","entries","validEntries","keyIndex","_getKeyByStorageIndex","done","clear","indexOf","default"],"sources":["/Users/priyadeliwala/Desktop/sales-dashboard/node_modules/handsontable/dataMap/metaManager/lazyFactoryMap.mjs"],"sourcesContent":["import \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.array.index-of.js\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nimport { arrayFilter } from \"../../helpers/array.mjs\";\nimport { assert, isUnsignedNumber, isNullish } from \"./utils.mjs\";\n/* eslint-disable jsdoc/require-description-complete-sentence */\n\n/**\n * @class LazyFactoryMap\n *\n * The LazyFactoryMap object holds key-value pairs in the structure similar to the\n * regular Map. Once created, items can be moved around a grid depending on the operations\n * performed on that grid - adding or removing rows. The collection requires \"key\"\n * to be a zero-based index.\n *\n * It's essential to notice that the \"key\" index under which the item was created\n * is volatile. After altering the grid, the \"key\" index can change.\n *\n * Having created N items with corresponding example data where the data has 10\n * holes (`undefined` values) within (that's why internal storage index counts from 10).\n * +------+------+------+------+------+.\n * | 0/10 | 1/11 | 2/12 | 3/13 | 4/14 |  Keys (volatile zero-based index / internal storage index)\n * +------+------+------+------+------+.\n *    │      │      │      │      │\n * +------+------+------+------+------+.\n * | AAA  | BBB  | CCC  | DDD  | EEE  |  Data\n * +------+------+------+------+------+.\n *\n * Map.obtain(0) // returns \"AAA\"\n * map.obtain(2) // returns \"CCC\".\n *\n * After inserting 2 new rows, keys that hold the data positioned after the place\n * where the new rows are added are upshifted by 2.\n *               │\n *               │ Insert 2 rows\n *              \\│/\n * +------+------+------+------+------+.\n * | 0/10 | 1/11 | 2/12 | 3/13 | 4/14 |  Keys before\n * +------+------+------+------+------+.\n *\n *                / 2 new rows \\\n * +------+------+------+------+------+------+------+.\n * | 0/10 | 1/11 | 2/15 | 3/16 | 4/12 | 5/13 | 6/14 |  Keys after\n * +------+------+------+------+------+------+------+.\n *    │       │      │      │      │      │     │\n *    │       │      └──────┼──────┼──────┼┐    │\n *    │       │             └──────┼──────┼┼────┼┐\n *    │       │      ┌─────────────┘      ││    ││\n *    │       │      │      ┌─────────────┘│    ││\n *    │       │      │      │      ┌───────┼────┘│\n *    │       │      │      │      │       │     │\n * +------+------+------+------+------+------+------+.\n * | AAA  | BBB  | CCC  | DDD  | EEE  | FFF  | GGG  |  Data\n * +------+------+------+------+------+------+------+\n *\n * Now at index 2 and 3 we have access to new items.\n *\n * map.obtain(2) // returns new value \"FFF\" for newly created row.\n * map.obtain(4) // index shifted by 2 has access to the old \"CCC\" value, as before inserting.\n *\n * after removing 4 rows, keys that hold the data positioned after the place where the\n * rows are removed are downshifted by 4.\n *        │\n *        │ Remove 4 rows\n *        ├───────────────────────────┐\n *       \\│/                          │\n * +------+------+------+------+------+------+------+\n * | 0/10 | 1/11 | 2/15 | 3/16 | 4/12 | 5/13 | 6/14 |  Keys after\n * +------+------+------+------+------+------+------+\n *    │       │      │      │      │      │     │\n *    │       │      └──────┼──────┼──────┼┐    │\n *    │       │             └──────┼──────┼┼────┼┐\n *    │       │      ┌─────────────┘      ││    ││\n *    │       │      │      ┌─────────────┘│    ││\n *    │       │      │      │      ┌───────┼────┘│\n *    │       │      │      │      │       │     │\n * +------+------+------+------+------+------+------+\n * | AAA  | BBB  | CCC  | DDD  | EEE  | FFF  | GGG  |  Data\n * +------+------+------+------+------+------+------+\n *\n * +------+------+------+\n * | 0/10 | 1/13 | 2/14 |  Keys after\n * +------+------+------+\n *    │       │      │\n *    │       │      └─────────────┐\n *    │       └────────────┐       │\n *    │                    │       │\n *    │                    │       │\n *    │                    │       │\n *    │                    │       │\n * +------+------+------+------+------+------+------+\n * | AAA  | BBB  | CCC  | DDD  | EEE  | FFF  | GGG  |  Data\n * +------+------+------+------+------+------+------+\n *           /│\\   /│\\                   /│\\   /│\\\n *            └──┬──┘                     └──┬──┘\n *           This data is marked as \"hole\" which\n *           means that can be replaced by new item\n *           when that will be created.\n *\n * map.obtain(2) // returns the value (\"EEE\") as it should. Access to the value is\n *               // changed (the key was downshifted). However, the internal index has not changed,\n *               // which means that the data does not need to be changed (spliced) too.\n *\n * After previous remove operation which creates some \"holes\" obtaining new\n * items replaces that \"holes\" as follows:\n *\n * // Obtains new item\n * map.obtain(90) // Returns \"NEW\" value\n *\n * +------+------+------+...+------+\n * | 0/10 | 1/13 | 2/14 |   | 90/0 |  Keys after\n * +------+------+------+...+------+\n *    │       │      │          │\n *    │       │      └──────────┼────────────┐\n *    │       └─────────────────┼─────┐      │\n *    └──────────┐              │     │      │\n *               │              │     │      │\n *    ┌──────────┼──────────────┘     │      │\n *    │          │                    │      │\n * +------+...+------+------+------+------+------+-----+\n * | NEW  |   | AAA  | BBB  | CCC  | DDD  | EEE  | FFF |  Data\n * +------+...+------+------+------+------+------+-----+\n *   /│\\\n *    │\n * The first \"hole\" (at index 0) item is permanently removed and replaced by a new item.\n * The hole index is taken from the hole collection which act as FIFO (First In First Out).\n */\n\n/* eslint-enable jsdoc/require-description-complete-sentence */\n\nvar LazyFactoryMap = /*#__PURE__*/function (_Symbol$iterator) {\n  function LazyFactoryMap(valueFactory) {\n    _classCallCheck(this, LazyFactoryMap);\n\n    this.valueFactory = valueFactory;\n    /**\n     * An array which contains data.\n     *\n     * @type {Array}\n     */\n\n    this.data = [];\n    /**\n     * An array of indexes where the key of the array is mapped to the value which points to the\n     * specific position of the data array.\n     *\n     * @type {number[]}\n     */\n\n    this.index = [];\n    /**\n     * The collection of indexes that points to the data items which can be replaced by obtaining new\n     * ones. The \"holes\" are an intended effect of deleting entries.\n     *\n     * The idea of \"holes\" generally allows us to not modify the \"data\" structure while removing\n     * items from the collection.\n     *\n     * @type {Set<number>}\n     */\n\n    this.holes = new Set();\n  }\n  /**\n   * Gets or if data not exist creates and returns new data.\n   *\n   * @param {number} key The item key as zero-based index.\n   * @returns {*}\n   */\n\n\n  _createClass(LazyFactoryMap, [{\n    key: \"obtain\",\n    value: function obtain(key) {\n      assert(function () {\n        return isUnsignedNumber(key);\n      }, 'Expecting an unsigned number.');\n\n      var dataIndex = this._getStorageIndexByKey(key);\n\n      var result;\n\n      if (dataIndex >= 0) {\n        result = this.data[dataIndex];\n\n        if (result === void 0) {\n          result = this.valueFactory(key);\n          this.data[dataIndex] = result;\n        }\n      } else {\n        result = this.valueFactory(key);\n\n        if (this.holes.size > 0) {\n          var reuseIndex = this.holes.values().next().value; // Gets first item from the collection\n\n          this.holes.delete(reuseIndex);\n          this.data[reuseIndex] = result;\n          this.index[key] = reuseIndex;\n        } else {\n          this.data.push(result);\n          this.index[key] = this.data.length - 1;\n        }\n      }\n\n      return result;\n    }\n    /**\n     * Inserts an empty data to the map. This method creates an empty space for obtaining\n     * new data.\n     *\n     * @param {number} key The key as volatile zero-based index at which to begin inserting space for new data.\n     * @param {number} [amount=1] Ammount of data to insert.\n     */\n\n  }, {\n    key: \"insert\",\n    value: function insert(key) {\n      var _this$index;\n\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      assert(function () {\n        return isUnsignedNumber(key) || isNullish(key);\n      }, 'Expecting an unsigned number or null/undefined argument.');\n      var newIndexes = [];\n      var dataLength = this.data.length;\n\n      for (var i = 0; i < amount; i++) {\n        newIndexes.push(dataLength + i);\n        this.data.push(void 0);\n      }\n\n      (_this$index = this.index).splice.apply(_this$index, [isNullish(key) ? this.index.length : key, 0].concat(newIndexes));\n    }\n    /**\n     * Removes (soft remove) data from \"index\" and according to the amount of data.\n     *\n     * @param {number} key The key as volatile zero-based index at which to begin removing the data.\n     * @param {number} [amount=1] Ammount data to remove.\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(key) {\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      assert(function () {\n        return isUnsignedNumber(key) || isNullish(key);\n      }, 'Expecting an unsigned number or null/undefined argument.');\n      var removed = this.index.splice(isNullish(key) ? this.index.length - amount : key, amount);\n\n      for (var i = 0; i < removed.length; i++) {\n        var removedIndex = removed[i];\n\n        if (typeof removedIndex === 'number') {\n          this.holes.add(removedIndex);\n        }\n      }\n    }\n    /**\n     * Returns the size of the data which this map holds.\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: \"size\",\n    value: function size() {\n      return this.data.length - this.holes.size;\n    }\n    /**\n     * Returns a new Iterator object that contains the values for each item in the LazyMap object.\n     *\n     * @returns {Iterator}\n     */\n\n  }, {\n    key: \"values\",\n    value: function values() {\n      var _this = this;\n\n      return arrayFilter(this.data, function (_, index) {\n        return !_this.holes.has(index);\n      })[Symbol.iterator]();\n    }\n    /**\n     * Returns a new Iterator object that contains an array of `[index, value]` for each item in the LazyMap object.\n     *\n     * @returns {Iterator}\n     */\n\n  }, {\n    key: \"entries\",\n    value: function entries() {\n      var validEntries = [];\n\n      for (var i = 0; i < this.data.length; i++) {\n        var keyIndex = this._getKeyByStorageIndex(i);\n\n        if (keyIndex !== -1) {\n          validEntries.push([keyIndex, this.data[i]]);\n        }\n      }\n\n      var dataIndex = 0;\n      return {\n        next: function next() {\n          if (dataIndex < validEntries.length) {\n            var value = validEntries[dataIndex];\n            dataIndex += 1;\n            return {\n              value: value,\n              done: false\n            };\n          }\n\n          return {\n            done: true\n          };\n        }\n      };\n    }\n    /**\n     * Clears the map.\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.data = [];\n      this.index = [];\n      this.holes.clear();\n    }\n    /**\n     * Gets storage index calculated from the key associated with the specified value.\n     *\n     * @param {number} key Volatile zero-based index.\n     * @returns {number} Returns index 0-N or -1 if no storage index found.\n     */\n\n  }, {\n    key: \"_getStorageIndexByKey\",\n    value: function _getStorageIndexByKey(key) {\n      return this.index.length > key ? this.index[key] : -1;\n    }\n    /**\n     * Gets the key associated with the specified value calculated from storage index.\n     *\n     * @param {number} dataIndex Zero-based storage index.\n     * @returns {number} Returns index 0-N or -1 if no key found.\n     */\n\n  }, {\n    key: \"_getKeyByStorageIndex\",\n    value: function _getKeyByStorageIndex(dataIndex) {\n      return this.index.indexOf(dataIndex);\n    }\n    /**\n     * Makes this object iterable.\n     *\n     * @returns {Iterator}\n     */\n\n  }, {\n    key: _Symbol$iterator,\n    value: function value() {\n      return this.entries();\n    }\n  }]);\n\n  return LazyFactoryMap;\n}(Symbol.iterator);\n\nexport { LazyFactoryMap as default };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}