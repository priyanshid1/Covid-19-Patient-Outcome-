{"ast":null,"code":"var _templateObject, _templateObject2, _templateObject3, _templateObject4;\nfunction _taggedTemplateLiteral(strings, raw) {\n  if (!raw) {\n    raw = strings.slice(0);\n  }\n  return Object.freeze(Object.defineProperties(strings, {\n    raw: {\n      value: Object.freeze(raw)\n    }\n  }));\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nimport { CellCoords, CellRange } from \"../../3rdparty/walkontable/src/index.mjs\";\nimport { toSingleLine } from \"../../helpers/templateLiteralTag.mjs\";\n/**\n * The `MergedCellCoords` class represents a single merged cell.\n *\n * @private\n * @class MergedCellCoords\n */\n\nvar MergedCellCoords = /*#__PURE__*/function () {\n  function MergedCellCoords(row, column, rowspan, colspan) {\n    _classCallCheck(this, MergedCellCoords);\n\n    /**\n     * The index of the topmost merged cell row.\n     *\n     * @type {number}\n     */\n    this.row = row;\n    /**\n     * The index of the leftmost column.\n     *\n     * @type {number}\n     */\n\n    this.col = column;\n    /**\n     * The `rowspan` value of the merged cell.\n     *\n     * @type {number}\n     */\n\n    this.rowspan = rowspan;\n    /**\n     * The `colspan` value of the merged cell.\n     *\n     * @type {number}\n     */\n\n    this.colspan = colspan;\n    /**\n     * `true` only if the merged cell is bound to be removed.\n     *\n     * @type {boolean}\n     */\n\n    this.removed = false;\n  }\n  /**\n   * Get a warning message for when the declared merged cell data contains negative values.\n   *\n   * @param {object} newMergedCell Object containg information about the merged cells that was about to be added.\n   * @returns {string}\n   */\n\n  _createClass(MergedCellCoords, [{\n    key: \"normalize\",\n    value:\n    /**\n     * Sanitize (prevent from going outside the boundaries) the merged cell.\n     *\n     * @param {Core} hotInstance The Handsontable instance.\n     */\n    function normalize(hotInstance) {\n      var totalRows = hotInstance.countRows();\n      var totalColumns = hotInstance.countCols();\n      if (this.row < 0) {\n        this.row = 0;\n      } else if (this.row > totalRows - 1) {\n        this.row = totalRows - 1;\n      }\n      if (this.col < 0) {\n        this.col = 0;\n      } else if (this.col > totalColumns - 1) {\n        this.col = totalColumns - 1;\n      }\n      if (this.row + this.rowspan > totalRows - 1) {\n        this.rowspan = totalRows - this.row;\n      }\n      if (this.col + this.colspan > totalColumns - 1) {\n        this.colspan = totalColumns - this.col;\n      }\n    }\n    /**\n     * Returns `true` if the provided coordinates are inside the merged cell.\n     *\n     * @param {number} row The row index.\n     * @param {number} column The column index.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"includes\",\n    value: function includes(row, column) {\n      return this.row <= row && this.col <= column && this.row + this.rowspan - 1 >= row && this.col + this.colspan - 1 >= column;\n    }\n    /**\n     * Returns `true` if the provided `column` property is within the column span of the merged cell.\n     *\n     * @param {number} column The column index.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"includesHorizontally\",\n    value: function includesHorizontally(column) {\n      return this.col <= column && this.col + this.colspan - 1 >= column;\n    }\n    /**\n     * Returns `true` if the provided `row` property is within the row span of the merged cell.\n     *\n     * @param {number} row Row index.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"includesVertically\",\n    value: function includesVertically(row) {\n      return this.row <= row && this.row + this.rowspan - 1 >= row;\n    }\n    /**\n     * Shift (and possibly resize, if needed) the merged cell.\n     *\n     * @param {Array} shiftVector 2-element array containing the information on the shifting in the `x` and `y` axis.\n     * @param {number} indexOfChange Index of the preceding change.\n     * @returns {boolean} Returns `false` if the whole merged cell was removed.\n     */\n  }, {\n    key: \"shift\",\n    value: function shift(shiftVector, indexOfChange) {\n      var shiftValue = shiftVector[0] || shiftVector[1];\n      var shiftedIndex = indexOfChange + Math.abs(shiftVector[0] || shiftVector[1]) - 1;\n      var span = shiftVector[0] ? 'colspan' : 'rowspan';\n      var index = shiftVector[0] ? 'col' : 'row';\n      var changeStart = Math.min(indexOfChange, shiftedIndex);\n      var changeEnd = Math.max(indexOfChange, shiftedIndex);\n      var mergeStart = this[index];\n      var mergeEnd = this[index] + this[span] - 1;\n      if (mergeStart >= indexOfChange) {\n        this[index] += shiftValue;\n      } // adding rows/columns\n\n      if (shiftValue > 0) {\n        if (indexOfChange <= mergeEnd && indexOfChange > mergeStart) {\n          this[span] += shiftValue;\n        } // removing rows/columns\n      } else if (shiftValue < 0) {\n        // removing the whole merge\n        if (changeStart <= mergeStart && changeEnd >= mergeEnd) {\n          this.removed = true;\n          return false; // removing the merge partially, including the beginning\n        } else if (mergeStart >= changeStart && mergeStart <= changeEnd) {\n          var removedOffset = changeEnd - mergeStart + 1;\n          var preRemovedOffset = Math.abs(shiftValue) - removedOffset;\n          this[index] -= preRemovedOffset + shiftValue;\n          this[span] -= removedOffset; // removing the middle part of the merge\n        } else if (mergeStart <= changeStart && mergeEnd >= changeEnd) {\n          this[span] += shiftValue; // removing the end part of the merge\n        } else if (mergeStart <= changeStart && mergeEnd >= changeStart && mergeEnd < changeEnd) {\n          var removedPart = mergeEnd - changeStart + 1;\n          this[span] -= removedPart;\n        }\n      }\n      return true;\n    }\n    /**\n     * Check if the second provided merged cell is \"farther\" in the provided direction.\n     *\n     * @param {MergedCellCoords} mergedCell The merged cell to check.\n     * @param {string} direction Drag direction.\n     * @returns {boolean|null} `true` if the second provided merged cell is \"farther\".\n     */\n  }, {\n    key: \"isFarther\",\n    value: function isFarther(mergedCell, direction) {\n      if (!mergedCell) {\n        return true;\n      }\n      if (direction === 'down') {\n        return mergedCell.row + mergedCell.rowspan - 1 < this.row + this.rowspan - 1;\n      } else if (direction === 'up') {\n        return mergedCell.row > this.row;\n      } else if (direction === 'right') {\n        return mergedCell.col + mergedCell.colspan - 1 < this.col + this.colspan - 1;\n      } else if (direction === 'left') {\n        return mergedCell.col > this.col;\n      }\n      return null;\n    }\n    /**\n     * Get the bottom row index of the merged cell.\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"getLastRow\",\n    value: function getLastRow() {\n      return this.row + this.rowspan - 1;\n    }\n    /**\n     * Get the rightmost column index of the merged cell.\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"getLastColumn\",\n    value: function getLastColumn() {\n      return this.col + this.colspan - 1;\n    }\n    /**\n     * Get the range coordinates of the merged cell.\n     *\n     * @returns {CellRange}\n     */\n  }, {\n    key: \"getRange\",\n    value: function getRange() {\n      return new CellRange(new CellCoords(this.row, this.col), new CellCoords(this.row, this.col), new CellCoords(this.getLastRow(), this.getLastColumn()));\n    }\n  }], [{\n    key: \"NEGATIVE_VALUES_WARNING\",\n    value: function NEGATIVE_VALUES_WARNING(newMergedCell) {\n      return toSingleLine(_templateObject || (_templateObject = _taggedTemplateLiteral([\"The merged cell declared with {row: \", \", col: \", \", \\n      rowspan: \", \", colspan: \", \"} contains negative values, which is \\n      not supported. It will not be added to the collection.\"], [\"The merged cell declared with {row: \", \", col: \", \",\\\\x20\\n      rowspan: \", \", colspan: \", \"} contains negative values, which is\\\\x20\\n      not supported. It will not be added to the collection.\"])), newMergedCell.row, newMergedCell.col, newMergedCell.rowspan, newMergedCell.colspan);\n    }\n    /**\n     * Get a warning message for when the declared merged cell data contains values exceeding the table limits.\n     *\n     * @param {object} newMergedCell Object containg information about the merged cells that was about to be added.\n     * @returns {string}\n     */\n  }, {\n    key: \"IS_OUT_OF_BOUNDS_WARNING\",\n    value: function IS_OUT_OF_BOUNDS_WARNING(newMergedCell) {\n      return toSingleLine(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"The merged cell declared at [\", \", \", \"] is positioned \\n      (or positioned partially) outside of the table range. It was not added to the table, please fix your setup.\"], [\"The merged cell declared at [\", \", \", \"] is positioned\\\\x20\\n      (or positioned partially) outside of the table range. It was not added to the table, please fix your setup.\"])), newMergedCell.row, newMergedCell.col);\n    }\n    /**\n     * Get a warning message for when the declared merged cell data represents a single cell.\n     *\n     * @param {object} newMergedCell Object containg information about the merged cells that was about to be added.\n     * @returns {string}\n     */\n  }, {\n    key: \"IS_SINGLE_CELL\",\n    value: function IS_SINGLE_CELL(newMergedCell) {\n      return toSingleLine(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"The merged cell declared at [\", \", \", \"] has both \\\"rowspan\\\" \\n      and \\\"colspan\\\" declared as \\\"1\\\", which makes it a single cell. It cannot be added to the collection.\"], [\"The merged cell declared at [\", \", \", \"] has both \\\"rowspan\\\"\\\\x20\\n      and \\\"colspan\\\" declared as \\\"1\\\", which makes it a single cell. It cannot be added to the collection.\"])), newMergedCell.row, newMergedCell.col);\n    }\n    /**\n     * Get a warning message for when the declared merged cell data contains \"colspan\" or \"rowspan\", that equals 0.\n     *\n     * @param {object} newMergedCell Object containg information about the merged cells that was about to be added.\n     * @returns {string}\n     */\n  }, {\n    key: \"ZERO_SPAN_WARNING\",\n    value: function ZERO_SPAN_WARNING(newMergedCell) {\n      return toSingleLine(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"The merged cell declared at [\", \", \", \"] has \\\"rowspan\\\" \\n      or \\\"colspan\\\" declared as \\\"0\\\", which is not supported. It cannot be added to the collection.\"], [\"The merged cell declared at [\", \", \", \"] has \\\"rowspan\\\"\\\\x20\\n      or \\\"colspan\\\" declared as \\\"0\\\", which is not supported. It cannot be added to the collection.\"])), newMergedCell.row, newMergedCell.col);\n    }\n    /**\n     * Check whether the values provided for a merged cell contain any negative values.\n     *\n     * @param {object} mergedCellInfo Object containing the `row`, `col`, `rowspan` and `colspan` properties.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"containsNegativeValues\",\n    value: function containsNegativeValues(mergedCellInfo) {\n      return mergedCellInfo.row < 0 || mergedCellInfo.col < 0 || mergedCellInfo.rowspan < 0 || mergedCellInfo.colspan < 0;\n    }\n    /**\n     * Check whether the provided merged cell information object represents a single cell.\n     *\n     * @private\n     * @param {object} mergedCellInfo An object with `row`, `col`, `rowspan` and `colspan` properties.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isSingleCell\",\n    value: function isSingleCell(mergedCellInfo) {\n      return mergedCellInfo.colspan === 1 && mergedCellInfo.rowspan === 1;\n    }\n    /**\n     * Check whether the provided merged cell information object contains a rowspan or colspan of 0.\n     *\n     * @private\n     * @param {object} mergedCellInfo An object with `row`, `col`, `rowspan` and `colspan` properties.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"containsZeroSpan\",\n    value: function containsZeroSpan(mergedCellInfo) {\n      return mergedCellInfo.colspan === 0 || mergedCellInfo.rowspan === 0;\n    }\n    /**\n     * Check whether the provided merged cell object is to be declared out of bounds of the table.\n     *\n     * @param {object} mergeCell Object containing the `row`, `col`, `rowspan` and `colspan` properties.\n     * @param {number} rowCount Number of rows in the table.\n     * @param {number} columnCount Number of rows in the table.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isOutOfBounds\",\n    value: function isOutOfBounds(mergeCell, rowCount, columnCount) {\n      return mergeCell.row < 0 || mergeCell.col < 0 || mergeCell.row >= rowCount || mergeCell.row + mergeCell.rowspan - 1 >= rowCount || mergeCell.col >= columnCount || mergeCell.col + mergeCell.colspan - 1 >= columnCount;\n    }\n  }]);\n  return MergedCellCoords;\n}();\nexport default MergedCellCoords;","map":{"version":3,"names":["_templateObject","_templateObject2","_templateObject3","_templateObject4","_taggedTemplateLiteral","strings","raw","slice","Object","freeze","defineProperties","value","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","prototype","CellCoords","CellRange","toSingleLine","MergedCellCoords","row","column","rowspan","colspan","col","removed","normalize","hotInstance","totalRows","countRows","totalColumns","countCols","includes","includesHorizontally","includesVertically","shift","shiftVector","indexOfChange","shiftValue","shiftedIndex","Math","abs","span","index","changeStart","min","changeEnd","max","mergeStart","mergeEnd","removedOffset","preRemovedOffset","removedPart","isFarther","mergedCell","direction","getLastRow","getLastColumn","getRange","NEGATIVE_VALUES_WARNING","newMergedCell","IS_OUT_OF_BOUNDS_WARNING","IS_SINGLE_CELL","ZERO_SPAN_WARNING","containsNegativeValues","mergedCellInfo","isSingleCell","containsZeroSpan","isOutOfBounds","mergeCell","rowCount","columnCount"],"sources":["/Users/priyadeliwala/Desktop/sales-dashboard/node_modules/handsontable/plugins/mergeCells/cellCoords.mjs"],"sourcesContent":["import \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.object.freeze.js\";\n\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4;\n\nfunction _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nimport { CellCoords, CellRange } from \"../../3rdparty/walkontable/src/index.mjs\";\nimport { toSingleLine } from \"../../helpers/templateLiteralTag.mjs\";\n/**\n * The `MergedCellCoords` class represents a single merged cell.\n *\n * @private\n * @class MergedCellCoords\n */\n\nvar MergedCellCoords = /*#__PURE__*/function () {\n  function MergedCellCoords(row, column, rowspan, colspan) {\n    _classCallCheck(this, MergedCellCoords);\n\n    /**\n     * The index of the topmost merged cell row.\n     *\n     * @type {number}\n     */\n    this.row = row;\n    /**\n     * The index of the leftmost column.\n     *\n     * @type {number}\n     */\n\n    this.col = column;\n    /**\n     * The `rowspan` value of the merged cell.\n     *\n     * @type {number}\n     */\n\n    this.rowspan = rowspan;\n    /**\n     * The `colspan` value of the merged cell.\n     *\n     * @type {number}\n     */\n\n    this.colspan = colspan;\n    /**\n     * `true` only if the merged cell is bound to be removed.\n     *\n     * @type {boolean}\n     */\n\n    this.removed = false;\n  }\n  /**\n   * Get a warning message for when the declared merged cell data contains negative values.\n   *\n   * @param {object} newMergedCell Object containg information about the merged cells that was about to be added.\n   * @returns {string}\n   */\n\n\n  _createClass(MergedCellCoords, [{\n    key: \"normalize\",\n    value:\n    /**\n     * Sanitize (prevent from going outside the boundaries) the merged cell.\n     *\n     * @param {Core} hotInstance The Handsontable instance.\n     */\n    function normalize(hotInstance) {\n      var totalRows = hotInstance.countRows();\n      var totalColumns = hotInstance.countCols();\n\n      if (this.row < 0) {\n        this.row = 0;\n      } else if (this.row > totalRows - 1) {\n        this.row = totalRows - 1;\n      }\n\n      if (this.col < 0) {\n        this.col = 0;\n      } else if (this.col > totalColumns - 1) {\n        this.col = totalColumns - 1;\n      }\n\n      if (this.row + this.rowspan > totalRows - 1) {\n        this.rowspan = totalRows - this.row;\n      }\n\n      if (this.col + this.colspan > totalColumns - 1) {\n        this.colspan = totalColumns - this.col;\n      }\n    }\n    /**\n     * Returns `true` if the provided coordinates are inside the merged cell.\n     *\n     * @param {number} row The row index.\n     * @param {number} column The column index.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"includes\",\n    value: function includes(row, column) {\n      return this.row <= row && this.col <= column && this.row + this.rowspan - 1 >= row && this.col + this.colspan - 1 >= column;\n    }\n    /**\n     * Returns `true` if the provided `column` property is within the column span of the merged cell.\n     *\n     * @param {number} column The column index.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"includesHorizontally\",\n    value: function includesHorizontally(column) {\n      return this.col <= column && this.col + this.colspan - 1 >= column;\n    }\n    /**\n     * Returns `true` if the provided `row` property is within the row span of the merged cell.\n     *\n     * @param {number} row Row index.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"includesVertically\",\n    value: function includesVertically(row) {\n      return this.row <= row && this.row + this.rowspan - 1 >= row;\n    }\n    /**\n     * Shift (and possibly resize, if needed) the merged cell.\n     *\n     * @param {Array} shiftVector 2-element array containing the information on the shifting in the `x` and `y` axis.\n     * @param {number} indexOfChange Index of the preceding change.\n     * @returns {boolean} Returns `false` if the whole merged cell was removed.\n     */\n\n  }, {\n    key: \"shift\",\n    value: function shift(shiftVector, indexOfChange) {\n      var shiftValue = shiftVector[0] || shiftVector[1];\n      var shiftedIndex = indexOfChange + Math.abs(shiftVector[0] || shiftVector[1]) - 1;\n      var span = shiftVector[0] ? 'colspan' : 'rowspan';\n      var index = shiftVector[0] ? 'col' : 'row';\n      var changeStart = Math.min(indexOfChange, shiftedIndex);\n      var changeEnd = Math.max(indexOfChange, shiftedIndex);\n      var mergeStart = this[index];\n      var mergeEnd = this[index] + this[span] - 1;\n\n      if (mergeStart >= indexOfChange) {\n        this[index] += shiftValue;\n      } // adding rows/columns\n\n\n      if (shiftValue > 0) {\n        if (indexOfChange <= mergeEnd && indexOfChange > mergeStart) {\n          this[span] += shiftValue;\n        } // removing rows/columns\n\n      } else if (shiftValue < 0) {\n        // removing the whole merge\n        if (changeStart <= mergeStart && changeEnd >= mergeEnd) {\n          this.removed = true;\n          return false; // removing the merge partially, including the beginning\n        } else if (mergeStart >= changeStart && mergeStart <= changeEnd) {\n          var removedOffset = changeEnd - mergeStart + 1;\n          var preRemovedOffset = Math.abs(shiftValue) - removedOffset;\n          this[index] -= preRemovedOffset + shiftValue;\n          this[span] -= removedOffset; // removing the middle part of the merge\n        } else if (mergeStart <= changeStart && mergeEnd >= changeEnd) {\n          this[span] += shiftValue; // removing the end part of the merge\n        } else if (mergeStart <= changeStart && mergeEnd >= changeStart && mergeEnd < changeEnd) {\n          var removedPart = mergeEnd - changeStart + 1;\n          this[span] -= removedPart;\n        }\n      }\n\n      return true;\n    }\n    /**\n     * Check if the second provided merged cell is \"farther\" in the provided direction.\n     *\n     * @param {MergedCellCoords} mergedCell The merged cell to check.\n     * @param {string} direction Drag direction.\n     * @returns {boolean|null} `true` if the second provided merged cell is \"farther\".\n     */\n\n  }, {\n    key: \"isFarther\",\n    value: function isFarther(mergedCell, direction) {\n      if (!mergedCell) {\n        return true;\n      }\n\n      if (direction === 'down') {\n        return mergedCell.row + mergedCell.rowspan - 1 < this.row + this.rowspan - 1;\n      } else if (direction === 'up') {\n        return mergedCell.row > this.row;\n      } else if (direction === 'right') {\n        return mergedCell.col + mergedCell.colspan - 1 < this.col + this.colspan - 1;\n      } else if (direction === 'left') {\n        return mergedCell.col > this.col;\n      }\n\n      return null;\n    }\n    /**\n     * Get the bottom row index of the merged cell.\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: \"getLastRow\",\n    value: function getLastRow() {\n      return this.row + this.rowspan - 1;\n    }\n    /**\n     * Get the rightmost column index of the merged cell.\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: \"getLastColumn\",\n    value: function getLastColumn() {\n      return this.col + this.colspan - 1;\n    }\n    /**\n     * Get the range coordinates of the merged cell.\n     *\n     * @returns {CellRange}\n     */\n\n  }, {\n    key: \"getRange\",\n    value: function getRange() {\n      return new CellRange(new CellCoords(this.row, this.col), new CellCoords(this.row, this.col), new CellCoords(this.getLastRow(), this.getLastColumn()));\n    }\n  }], [{\n    key: \"NEGATIVE_VALUES_WARNING\",\n    value: function NEGATIVE_VALUES_WARNING(newMergedCell) {\n      return toSingleLine(_templateObject || (_templateObject = _taggedTemplateLiteral([\"The merged cell declared with {row: \", \", col: \", \", \\n      rowspan: \", \", colspan: \", \"} contains negative values, which is \\n      not supported. It will not be added to the collection.\"], [\"The merged cell declared with {row: \", \", col: \", \",\\\\x20\\n      rowspan: \", \", colspan: \", \"} contains negative values, which is\\\\x20\\n      not supported. It will not be added to the collection.\"])), newMergedCell.row, newMergedCell.col, newMergedCell.rowspan, newMergedCell.colspan);\n    }\n    /**\n     * Get a warning message for when the declared merged cell data contains values exceeding the table limits.\n     *\n     * @param {object} newMergedCell Object containg information about the merged cells that was about to be added.\n     * @returns {string}\n     */\n\n  }, {\n    key: \"IS_OUT_OF_BOUNDS_WARNING\",\n    value: function IS_OUT_OF_BOUNDS_WARNING(newMergedCell) {\n      return toSingleLine(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"The merged cell declared at [\", \", \", \"] is positioned \\n      (or positioned partially) outside of the table range. It was not added to the table, please fix your setup.\"], [\"The merged cell declared at [\", \", \", \"] is positioned\\\\x20\\n      (or positioned partially) outside of the table range. It was not added to the table, please fix your setup.\"])), newMergedCell.row, newMergedCell.col);\n    }\n    /**\n     * Get a warning message for when the declared merged cell data represents a single cell.\n     *\n     * @param {object} newMergedCell Object containg information about the merged cells that was about to be added.\n     * @returns {string}\n     */\n\n  }, {\n    key: \"IS_SINGLE_CELL\",\n    value: function IS_SINGLE_CELL(newMergedCell) {\n      return toSingleLine(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"The merged cell declared at [\", \", \", \"] has both \\\"rowspan\\\" \\n      and \\\"colspan\\\" declared as \\\"1\\\", which makes it a single cell. It cannot be added to the collection.\"], [\"The merged cell declared at [\", \", \", \"] has both \\\"rowspan\\\"\\\\x20\\n      and \\\"colspan\\\" declared as \\\"1\\\", which makes it a single cell. It cannot be added to the collection.\"])), newMergedCell.row, newMergedCell.col);\n    }\n    /**\n     * Get a warning message for when the declared merged cell data contains \"colspan\" or \"rowspan\", that equals 0.\n     *\n     * @param {object} newMergedCell Object containg information about the merged cells that was about to be added.\n     * @returns {string}\n     */\n\n  }, {\n    key: \"ZERO_SPAN_WARNING\",\n    value: function ZERO_SPAN_WARNING(newMergedCell) {\n      return toSingleLine(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"The merged cell declared at [\", \", \", \"] has \\\"rowspan\\\" \\n      or \\\"colspan\\\" declared as \\\"0\\\", which is not supported. It cannot be added to the collection.\"], [\"The merged cell declared at [\", \", \", \"] has \\\"rowspan\\\"\\\\x20\\n      or \\\"colspan\\\" declared as \\\"0\\\", which is not supported. It cannot be added to the collection.\"])), newMergedCell.row, newMergedCell.col);\n    }\n    /**\n     * Check whether the values provided for a merged cell contain any negative values.\n     *\n     * @param {object} mergedCellInfo Object containing the `row`, `col`, `rowspan` and `colspan` properties.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"containsNegativeValues\",\n    value: function containsNegativeValues(mergedCellInfo) {\n      return mergedCellInfo.row < 0 || mergedCellInfo.col < 0 || mergedCellInfo.rowspan < 0 || mergedCellInfo.colspan < 0;\n    }\n    /**\n     * Check whether the provided merged cell information object represents a single cell.\n     *\n     * @private\n     * @param {object} mergedCellInfo An object with `row`, `col`, `rowspan` and `colspan` properties.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isSingleCell\",\n    value: function isSingleCell(mergedCellInfo) {\n      return mergedCellInfo.colspan === 1 && mergedCellInfo.rowspan === 1;\n    }\n    /**\n     * Check whether the provided merged cell information object contains a rowspan or colspan of 0.\n     *\n     * @private\n     * @param {object} mergedCellInfo An object with `row`, `col`, `rowspan` and `colspan` properties.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"containsZeroSpan\",\n    value: function containsZeroSpan(mergedCellInfo) {\n      return mergedCellInfo.colspan === 0 || mergedCellInfo.rowspan === 0;\n    }\n    /**\n     * Check whether the provided merged cell object is to be declared out of bounds of the table.\n     *\n     * @param {object} mergeCell Object containing the `row`, `col`, `rowspan` and `colspan` properties.\n     * @param {number} rowCount Number of rows in the table.\n     * @param {number} columnCount Number of rows in the table.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isOutOfBounds\",\n    value: function isOutOfBounds(mergeCell, rowCount, columnCount) {\n      return mergeCell.row < 0 || mergeCell.col < 0 || mergeCell.row >= rowCount || mergeCell.row + mergeCell.rowspan - 1 >= rowCount || mergeCell.col >= columnCount || mergeCell.col + mergeCell.colspan - 1 >= columnCount;\n    }\n  }]);\n\n  return MergedCellCoords;\n}();\n\nexport default MergedCellCoords;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}