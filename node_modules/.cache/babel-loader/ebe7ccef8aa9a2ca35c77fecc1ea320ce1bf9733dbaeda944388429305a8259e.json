{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _s, _e;\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n  return _arr;\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _get() {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n      if (desc.get) {\n        return desc.get.call(arguments.length < 3 ? target : receiver);\n      }\n      return desc.value;\n    };\n  }\n  return _get.apply(this, arguments);\n}\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n  return object;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn(this, result);\n  };\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n  return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\nimport { BasePlugin } from \"../base/index.mjs\";\nimport Hooks from \"../../pluginHooks.mjs\";\nimport { stopImmediatePropagation } from \"../../helpers/dom/event.mjs\";\nimport { CellCoords, CellRange } from \"../../3rdparty/walkontable/src/index.mjs\";\nimport MergedCellsCollection from \"./cellsCollection.mjs\";\nimport MergedCellCoords from \"./cellCoords.mjs\";\nimport AutofillCalculations from \"./calculations/autofill.mjs\";\nimport SelectionCalculations from \"./calculations/selection.mjs\";\nimport toggleMergeItem from \"./contextMenuItem/toggleMerge.mjs\";\nimport { arrayEach } from \"../../helpers/array.mjs\";\nimport { isObject, clone } from \"../../helpers/object.mjs\";\nimport { warn } from \"../../helpers/console.mjs\";\nimport { rangeEach } from \"../../helpers/number.mjs\";\nimport { applySpanProperties } from \"./utils.mjs\";\nHooks.getSingleton().register('beforeMergeCells');\nHooks.getSingleton().register('afterMergeCells');\nHooks.getSingleton().register('beforeUnmergeCells');\nHooks.getSingleton().register('afterUnmergeCells');\nexport var PLUGIN_KEY = 'mergeCells';\nexport var PLUGIN_PRIORITY = 150;\nvar privatePool = new WeakMap();\n/**\n * @plugin MergeCells\n * @class MergeCells\n *\n * @description\n * Plugin, which allows merging cells in the table (using the initial configuration, API or context menu).\n *\n * @example\n *\n * ```js\n * const hot = new Handsontable(document.getElementById('example'), {\n *  data: getData(),\n *  mergeCells: [\n *    {row: 0, col: 3, rowspan: 3, colspan: 3},\n *    {row: 2, col: 6, rowspan: 2, colspan: 2},\n *    {row: 4, col: 8, rowspan: 3, colspan: 3}\n *  ],\n * ```\n */\n\nexport var MergeCells = /*#__PURE__*/function (_BasePlugin) {\n  _inherits(MergeCells, _BasePlugin);\n  var _super = _createSuper(MergeCells);\n  function MergeCells(hotInstance) {\n    var _this;\n    _classCallCheck(this, MergeCells);\n    _this = _super.call(this, hotInstance);\n    privatePool.set(_assertThisInitialized(_this), {\n      lastDesiredCoords: null\n    });\n    /**\n     * A container for all the merged cells.\n     *\n     * @private\n     * @type {MergedCellsCollection}\n     */\n\n    _this.mergedCellsCollection = null;\n    /**\n     * Instance of the class responsible for all the autofill-related calculations.\n     *\n     * @private\n     * @type {AutofillCalculations}\n     */\n\n    _this.autofillCalculations = null;\n    /**\n     * Instance of the class responsible for the selection-related calculations.\n     *\n     * @private\n     * @type {SelectionCalculations}\n     */\n\n    _this.selectionCalculations = null;\n    return _this;\n  }\n  /**\n   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}\n   * hook and if it returns `true` than the {@link MergeCells#enablePlugin} method is called.\n   *\n   * @returns {boolean}\n   */\n\n  _createClass(MergeCells, [{\n    key: \"isEnabled\",\n    value: function isEnabled() {\n      return !!this.hot.getSettings()[PLUGIN_KEY];\n    }\n    /**\n     * Enables the plugin functionality for this Handsontable instance.\n     */\n  }, {\n    key: \"enablePlugin\",\n    value: function enablePlugin() {\n      var _this2 = this;\n      if (this.enabled) {\n        return;\n      }\n      this.mergedCellsCollection = new MergedCellsCollection(this);\n      this.autofillCalculations = new AutofillCalculations(this);\n      this.selectionCalculations = new SelectionCalculations(this);\n      this.addHook('afterInit', function () {\n        return _this2.onAfterInit.apply(_this2, arguments);\n      });\n      this.addHook('beforeKeyDown', function () {\n        return _this2.onBeforeKeyDown.apply(_this2, arguments);\n      });\n      this.addHook('modifyTransformStart', function () {\n        return _this2.onModifyTransformStart.apply(_this2, arguments);\n      });\n      this.addHook('afterModifyTransformStart', function () {\n        return _this2.onAfterModifyTransformStart.apply(_this2, arguments);\n      });\n      this.addHook('modifyTransformEnd', function () {\n        return _this2.onModifyTransformEnd.apply(_this2, arguments);\n      });\n      this.addHook('modifyGetCellCoords', function () {\n        return _this2.onModifyGetCellCoords.apply(_this2, arguments);\n      });\n      this.addHook('beforeSetRangeStart', function () {\n        return _this2.onBeforeSetRangeStart.apply(_this2, arguments);\n      });\n      this.addHook('beforeSetRangeStartOnly', function () {\n        return _this2.onBeforeSetRangeStart.apply(_this2, arguments);\n      });\n      this.addHook('beforeSetRangeEnd', function () {\n        return _this2.onBeforeSetRangeEnd.apply(_this2, arguments);\n      });\n      this.addHook('afterIsMultipleSelection', function () {\n        return _this2.onAfterIsMultipleSelection.apply(_this2, arguments);\n      });\n      this.addHook('afterRenderer', function () {\n        return _this2.onAfterRenderer.apply(_this2, arguments);\n      });\n      this.addHook('afterContextMenuDefaultOptions', function () {\n        return _this2.addMergeActionsToContextMenu.apply(_this2, arguments);\n      });\n      this.addHook('afterGetCellMeta', function () {\n        return _this2.onAfterGetCellMeta.apply(_this2, arguments);\n      });\n      this.addHook('afterViewportRowCalculatorOverride', function () {\n        return _this2.onAfterViewportRowCalculatorOverride.apply(_this2, arguments);\n      });\n      this.addHook('afterViewportColumnCalculatorOverride', function () {\n        return _this2.onAfterViewportColumnCalculatorOverride.apply(_this2, arguments);\n      });\n      this.addHook('modifyAutofillRange', function () {\n        return _this2.onModifyAutofillRange.apply(_this2, arguments);\n      });\n      this.addHook('afterCreateCol', function () {\n        return _this2.onAfterCreateCol.apply(_this2, arguments);\n      });\n      this.addHook('afterRemoveCol', function () {\n        return _this2.onAfterRemoveCol.apply(_this2, arguments);\n      });\n      this.addHook('afterCreateRow', function () {\n        return _this2.onAfterCreateRow.apply(_this2, arguments);\n      });\n      this.addHook('afterRemoveRow', function () {\n        return _this2.onAfterRemoveRow.apply(_this2, arguments);\n      });\n      this.addHook('afterChange', function () {\n        return _this2.onAfterChange.apply(_this2, arguments);\n      });\n      this.addHook('beforeDrawBorders', function () {\n        return _this2.onBeforeDrawAreaBorders.apply(_this2, arguments);\n      });\n      this.addHook('afterDrawSelection', function () {\n        return _this2.onAfterDrawSelection.apply(_this2, arguments);\n      });\n      this.addHook('beforeRemoveCellClassNames', function () {\n        return _this2.onBeforeRemoveCellClassNames.apply(_this2, arguments);\n      });\n      this.addHook('beforeUndoStackChange', function (action, source) {\n        if (source === 'MergeCells') {\n          return false;\n        }\n      });\n      _get(_getPrototypeOf(MergeCells.prototype), \"enablePlugin\", this).call(this);\n    }\n    /**\n     * Disables the plugin functionality for this Handsontable instance.\n     */\n  }, {\n    key: \"disablePlugin\",\n    value: function disablePlugin() {\n      this.clearCollections();\n      this.hot.render();\n      _get(_getPrototypeOf(MergeCells.prototype), \"disablePlugin\", this).call(this);\n    }\n    /**\n     * Updates the plugin state. This method is executed when {@link Core#updateSettings} is invoked.\n     */\n  }, {\n    key: \"updatePlugin\",\n    value: function updatePlugin() {\n      var settings = this.hot.getSettings()[PLUGIN_KEY];\n      this.disablePlugin();\n      this.enablePlugin();\n      this.generateFromSettings(settings);\n      _get(_getPrototypeOf(MergeCells.prototype), \"updatePlugin\", this).call(this);\n    }\n    /**\n     * Validates a single setting object, represented by a single merged cell information object.\n     *\n     * @private\n     * @param {object} setting An object with `row`, `col`, `rowspan` and `colspan` properties.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"validateSetting\",\n    value: function validateSetting(setting) {\n      var valid = true;\n      if (!setting) {\n        return false;\n      }\n      if (MergedCellCoords.containsNegativeValues(setting)) {\n        warn(MergedCellCoords.NEGATIVE_VALUES_WARNING(setting));\n        valid = false;\n      } else if (MergedCellCoords.isOutOfBounds(setting, this.hot.countRows(), this.hot.countCols())) {\n        warn(MergedCellCoords.IS_OUT_OF_BOUNDS_WARNING(setting));\n        valid = false;\n      } else if (MergedCellCoords.isSingleCell(setting)) {\n        warn(MergedCellCoords.IS_SINGLE_CELL(setting));\n        valid = false;\n      } else if (MergedCellCoords.containsZeroSpan(setting)) {\n        warn(MergedCellCoords.ZERO_SPAN_WARNING(setting));\n        valid = false;\n      }\n      return valid;\n    }\n    /**\n     * Generates the merged cells from the settings provided to the plugin.\n     *\n     * @private\n     * @param {Array|boolean} settings The settings provided to the plugin.\n     */\n  }, {\n    key: \"generateFromSettings\",\n    value: function generateFromSettings(settings) {\n      var _this3 = this;\n      if (Array.isArray(settings)) {\n        var _this$hot;\n        var populationArgumentsList = [];\n        arrayEach(settings, function (setting) {\n          if (!_this3.validateSetting(setting)) {\n            return;\n          }\n          var highlight = new CellCoords(setting.row, setting.col);\n          var rangeEnd = new CellCoords(setting.row + setting.rowspan - 1, setting.col + setting.colspan - 1);\n          var mergeRange = new CellRange(highlight, highlight, rangeEnd);\n          populationArgumentsList.push(_this3.mergeRange(mergeRange, true, true));\n        }); // remove 'empty' setting objects, caused by improper merge range declarations\n\n        populationArgumentsList = populationArgumentsList.filter(function (value) {\n          return value !== true;\n        });\n        var bulkPopulationData = this.getBulkCollectionData(populationArgumentsList);\n        (_this$hot = this.hot).populateFromArray.apply(_this$hot, _toConsumableArray(bulkPopulationData));\n      }\n    }\n    /**\n     * Generates a bulk set of all the data to be populated to fill the data \"under\" the added merged cells.\n     *\n     * @private\n     * @param {Array} populationArgumentsList Array in a form of `[row, column, dataUnderCollection]`.\n     * @returns {Array} Array in a form of `[row, column, dataOfAllCollections]`.\n     */\n  }, {\n    key: \"getBulkCollectionData\",\n    value: function getBulkCollectionData(populationArgumentsList) {\n      var _this$hot2;\n      var populationDataRange = this.getBulkCollectionDataRange(populationArgumentsList);\n      var dataAtRange = (_this$hot2 = this.hot).getData.apply(_this$hot2, _toConsumableArray(populationDataRange));\n      var newDataAtRange = dataAtRange.splice(0);\n      arrayEach(populationArgumentsList, function (mergedCellArguments) {\n        var _mergedCellArguments = _slicedToArray(mergedCellArguments, 3),\n          mergedCellRowIndex = _mergedCellArguments[0],\n          mergedCellColumnIndex = _mergedCellArguments[1],\n          mergedCellData = _mergedCellArguments[2];\n        arrayEach(mergedCellData, function (mergedCellRow, rowIndex) {\n          arrayEach(mergedCellRow, function (mergedCellElement, columnIndex) {\n            newDataAtRange[mergedCellRowIndex - populationDataRange[0] + rowIndex][mergedCellColumnIndex - populationDataRange[1] + columnIndex] = mergedCellElement; // eslint-disable-line max-len\n          });\n        });\n      });\n      return [populationDataRange[0], populationDataRange[1], newDataAtRange];\n    }\n    /**\n     * Gets the range of combined data ranges provided in a form of an array of arrays ([row, column, dataUnderCollection]).\n     *\n     * @private\n     * @param {Array} populationArgumentsList Array containing argument lists for the `populateFromArray` method - row, column and data for population.\n     * @returns {Array[]} Start and end coordinates of the merged cell range. (in a form of [rowIndex, columnIndex]).\n     */\n  }, {\n    key: \"getBulkCollectionDataRange\",\n    value: function getBulkCollectionDataRange(populationArgumentsList) {\n      var start = [0, 0];\n      var end = [0, 0];\n      var mergedCellRow = null;\n      var mergedCellColumn = null;\n      var mergedCellData = null;\n      arrayEach(populationArgumentsList, function (mergedCellArguments) {\n        mergedCellRow = mergedCellArguments[0];\n        mergedCellColumn = mergedCellArguments[1];\n        mergedCellData = mergedCellArguments[2];\n        start[0] = Math.min(mergedCellRow, start[0]);\n        start[1] = Math.min(mergedCellColumn, start[1]);\n        end[0] = Math.max(mergedCellRow + mergedCellData.length - 1, end[0]);\n        end[1] = Math.max(mergedCellColumn + mergedCellData[0].length - 1, end[1]);\n      });\n      return [].concat(start, end);\n    }\n    /**\n     * Clears the merged cells from the merged cell container.\n     */\n  }, {\n    key: \"clearCollections\",\n    value: function clearCollections() {\n      this.mergedCellsCollection.clear();\n    }\n    /**\n     * Returns `true` if a range is mergeable.\n     *\n     * @private\n     * @param {object} newMergedCellInfo Merged cell information object to test.\n     * @param {boolean} [auto=false] `true` if triggered at initialization.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"canMergeRange\",\n    value: function canMergeRange(newMergedCellInfo) {\n      var auto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return auto ? true : this.validateSetting(newMergedCellInfo);\n    }\n    /**\n     * Merge or unmerge, based on last selected range.\n     *\n     * @private\n     */\n  }, {\n    key: \"toggleMergeOnSelection\",\n    value: function toggleMergeOnSelection() {\n      var currentRange = this.hot.getSelectedRangeLast();\n      if (!currentRange) {\n        return;\n      }\n      currentRange.setDirection('NW-SE');\n      var from = currentRange.from,\n        to = currentRange.to;\n      this.toggleMerge(currentRange);\n      this.hot.selectCell(from.row, from.col, to.row, to.col, false);\n    }\n    /**\n     * Merges the selection provided as a cell range.\n     *\n     * @param {CellRange} [cellRange] Selection cell range.\n     */\n  }, {\n    key: \"mergeSelection\",\n    value: function mergeSelection() {\n      var cellRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.hot.getSelectedRangeLast();\n      if (!cellRange) {\n        return;\n      }\n      cellRange.setDirection('NW-SE');\n      var from = cellRange.from,\n        to = cellRange.to;\n      this.unmergeRange(cellRange, true);\n      this.mergeRange(cellRange);\n      this.hot.selectCell(from.row, from.col, to.row, to.col, false);\n    }\n    /**\n     * Unmerges the selection provided as a cell range.\n     *\n     * @param {CellRange} [cellRange] Selection cell range.\n     */\n  }, {\n    key: \"unmergeSelection\",\n    value: function unmergeSelection() {\n      var cellRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.hot.getSelectedRangeLast();\n      if (!cellRange) {\n        return;\n      }\n      var from = cellRange.from,\n        to = cellRange.to;\n      this.unmergeRange(cellRange, true);\n      this.hot.selectCell(from.row, from.col, to.row, to.col, false);\n    }\n    /**\n     * Merges cells in the provided cell range.\n     *\n     * @private\n     * @param {CellRange} cellRange Cell range to merge.\n     * @param {boolean} [auto=false] `true` if is called automatically, e.g. At initialization.\n     * @param {boolean} [preventPopulation=false] `true`, if the method should not run `populateFromArray` at the end, but rather return its arguments.\n     * @returns {Array|boolean} Returns an array of [row, column, dataUnderCollection] if preventPopulation is set to true. If the the merging process went successful, it returns `true`, otherwise - `false`.\n     * @fires Hooks#beforeMergeCells\n     * @fires Hooks#afterMergeCells\n     */\n  }, {\n    key: \"mergeRange\",\n    value: function mergeRange(cellRange) {\n      var _this4 = this;\n      var auto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var preventPopulation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var topLeft = cellRange.getTopLeftCorner();\n      var bottomRight = cellRange.getBottomRightCorner();\n      var mergeParent = {\n        row: topLeft.row,\n        col: topLeft.col,\n        rowspan: bottomRight.row - topLeft.row + 1,\n        colspan: bottomRight.col - topLeft.col + 1\n      };\n      var clearedData = [];\n      var populationInfo = null;\n      if (!this.canMergeRange(mergeParent, auto)) {\n        return false;\n      }\n      this.hot.runHooks('beforeMergeCells', cellRange, auto);\n      rangeEach(0, mergeParent.rowspan - 1, function (i) {\n        rangeEach(0, mergeParent.colspan - 1, function (j) {\n          var clearedValue = null;\n          if (!clearedData[i]) {\n            clearedData[i] = [];\n          }\n          if (i === 0 && j === 0) {\n            clearedValue = _this4.hot.getDataAtCell(mergeParent.row, mergeParent.col);\n          } else {\n            _this4.hot.setCellMeta(mergeParent.row + i, mergeParent.col + j, 'hidden', true);\n          }\n          clearedData[i][j] = clearedValue;\n        });\n      });\n      this.hot.setCellMeta(mergeParent.row, mergeParent.col, 'spanned', true);\n      var mergedCellAdded = this.mergedCellsCollection.add(mergeParent);\n      if (mergedCellAdded) {\n        if (preventPopulation) {\n          populationInfo = [mergeParent.row, mergeParent.col, clearedData];\n        } else {\n          this.hot.populateFromArray(mergeParent.row, mergeParent.col, clearedData, void 0, void 0, this.pluginName);\n        }\n        this.hot.runHooks('afterMergeCells', cellRange, mergeParent, auto);\n        return populationInfo;\n      }\n      return true;\n    }\n    /**\n     * Unmerges the selection provided as a cell range. If no cell range is provided, it uses the current selection.\n     *\n     * @private\n     * @param {CellRange} cellRange Selection cell range.\n     * @param {boolean} [auto=false] `true` if called automatically by the plugin.\n     *\n     * @fires Hooks#beforeUnmergeCells\n     * @fires Hooks#afterUnmergeCells\n     */\n  }, {\n    key: \"unmergeRange\",\n    value: function unmergeRange(cellRange) {\n      var _this5 = this;\n      var auto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var mergedCells = this.mergedCellsCollection.getWithinRange(cellRange);\n      if (!mergedCells) {\n        return;\n      }\n      this.hot.runHooks('beforeUnmergeCells', cellRange, auto);\n      arrayEach(mergedCells, function (currentCollection) {\n        _this5.mergedCellsCollection.remove(currentCollection.row, currentCollection.col);\n        rangeEach(0, currentCollection.rowspan - 1, function (i) {\n          rangeEach(0, currentCollection.colspan - 1, function (j) {\n            _this5.hot.removeCellMeta(currentCollection.row + i, currentCollection.col + j, 'hidden');\n          });\n        });\n        _this5.hot.removeCellMeta(currentCollection.row, currentCollection.col, 'spanned');\n      });\n      this.hot.runHooks('afterUnmergeCells', cellRange, auto);\n      this.hot.render();\n    }\n    /**\n     * Merges or unmerges, based on the cell range provided as `cellRange`.\n     *\n     * @private\n     * @param {CellRange} cellRange The cell range to merge or unmerged.\n     */\n  }, {\n    key: \"toggleMerge\",\n    value: function toggleMerge(cellRange) {\n      var mergedCell = this.mergedCellsCollection.get(cellRange.from.row, cellRange.from.col);\n      var mergedCellCoversWholeRange = mergedCell.row === cellRange.from.row && mergedCell.col === cellRange.from.col && mergedCell.row + mergedCell.rowspan - 1 === cellRange.to.row && mergedCell.col + mergedCell.colspan - 1 === cellRange.to.col;\n      if (mergedCellCoversWholeRange) {\n        this.unmergeRange(cellRange);\n      } else {\n        this.mergeSelection(cellRange);\n      }\n    }\n    /**\n     * Merges the specified range.\n     *\n     * @param {number} startRow Start row of the merged cell.\n     * @param {number} startColumn Start column of the merged cell.\n     * @param {number} endRow End row of the merged cell.\n     * @param {number} endColumn End column of the merged cell.\n     * @fires Hooks#beforeMergeCells\n     * @fires Hooks#afterMergeCells\n     */\n  }, {\n    key: \"merge\",\n    value: function merge(startRow, startColumn, endRow, endColumn) {\n      var start = new CellCoords(startRow, startColumn);\n      var end = new CellCoords(endRow, endColumn);\n      this.mergeRange(new CellRange(start, start, end));\n    }\n    /**\n     * Unmerges the merged cell in the provided range.\n     *\n     * @param {number} startRow Start row of the merged cell.\n     * @param {number} startColumn Start column of the merged cell.\n     * @param {number} endRow End row of the merged cell.\n     * @param {number} endColumn End column of the merged cell.\n     * @fires Hooks#beforeUnmergeCells\n     * @fires Hooks#afterUnmergeCells\n     */\n  }, {\n    key: \"unmerge\",\n    value: function unmerge(startRow, startColumn, endRow, endColumn) {\n      var start = new CellCoords(startRow, startColumn);\n      var end = new CellCoords(endRow, endColumn);\n      this.unmergeRange(new CellRange(start, start, end));\n    }\n    /**\n     * `afterInit` hook callback.\n     *\n     * @private\n     */\n  }, {\n    key: \"onAfterInit\",\n    value: function onAfterInit() {\n      this.generateFromSettings(this.hot.getSettings()[PLUGIN_KEY]);\n      this.hot.render();\n    }\n    /**\n     * `beforeKeyDown` hook callback.\n     *\n     * @private\n     * @param {KeyboardEvent} event The `keydown` event object.\n     */\n  }, {\n    key: \"onBeforeKeyDown\",\n    value: function onBeforeKeyDown(event) {\n      var ctrlDown = (event.ctrlKey || event.metaKey) && !event.altKey;\n      if (ctrlDown && event.keyCode === 77) {\n        // CTRL + M\n        this.toggleMerge(this.hot.getSelectedRangeLast());\n        this.hot.render();\n        stopImmediatePropagation(event);\n      }\n    }\n    /**\n     * Modifies the information on whether the current selection contains multiple cells. The `afterIsMultipleSelection` hook callback.\n     *\n     * @private\n     * @param {boolean} isMultiple Determines whether the current selection contains multiple cells.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"onAfterIsMultipleSelection\",\n    value: function onAfterIsMultipleSelection(isMultiple) {\n      if (isMultiple) {\n        var mergedCells = this.mergedCellsCollection.mergedCells;\n        var selectionRange = this.hot.getSelectedRangeLast();\n        for (var group = 0; group < mergedCells.length; group += 1) {\n          if (selectionRange.from.row === mergedCells[group].row && selectionRange.from.col === mergedCells[group].col && selectionRange.to.row === mergedCells[group].row + mergedCells[group].rowspan - 1 && selectionRange.to.col === mergedCells[group].col + mergedCells[group].colspan - 1) {\n            return false;\n          }\n        }\n      }\n      return isMultiple;\n    }\n    /**\n     * `modifyTransformStart` hook callback.\n     *\n     * @private\n     * @param {object} delta The transformation delta.\n     */\n  }, {\n    key: \"onModifyTransformStart\",\n    value: function onModifyTransformStart(delta) {\n      var priv = privatePool.get(this);\n      var currentlySelectedRange = this.hot.getSelectedRangeLast();\n      var newDelta = {\n        row: delta.row,\n        col: delta.col\n      };\n      var nextPosition = null;\n      var currentPosition = new CellCoords(currentlySelectedRange.highlight.row, currentlySelectedRange.highlight.col);\n      var mergedParent = this.mergedCellsCollection.get(currentPosition.row, currentPosition.col);\n      if (!priv.lastDesiredCoords) {\n        priv.lastDesiredCoords = new CellCoords(null, null);\n      }\n      if (mergedParent) {\n        // only merge selected\n        var mergeTopLeft = new CellCoords(mergedParent.row, mergedParent.col);\n        var mergeBottomRight = new CellCoords(mergedParent.row + mergedParent.rowspan - 1, mergedParent.col + mergedParent.colspan - 1);\n        var mergeRange = new CellRange(mergeTopLeft, mergeTopLeft, mergeBottomRight);\n        if (!mergeRange.includes(priv.lastDesiredCoords)) {\n          priv.lastDesiredCoords = new CellCoords(null, null); // reset outdated version of lastDesiredCoords\n        }\n        newDelta.row = priv.lastDesiredCoords.row ? priv.lastDesiredCoords.row - currentPosition.row : newDelta.row;\n        newDelta.col = priv.lastDesiredCoords.col ? priv.lastDesiredCoords.col - currentPosition.col : newDelta.col;\n        if (delta.row > 0) {\n          // moving down\n          newDelta.row = mergedParent.row + mergedParent.rowspan - 1 - currentPosition.row + delta.row;\n        } else if (delta.row < 0) {\n          // moving up\n          newDelta.row = currentPosition.row - mergedParent.row + delta.row;\n        }\n        if (delta.col > 0) {\n          // moving right\n          newDelta.col = mergedParent.col + mergedParent.colspan - 1 - currentPosition.col + delta.col;\n        } else if (delta.col < 0) {\n          // moving left\n          newDelta.col = currentPosition.col - mergedParent.col + delta.col;\n        }\n      }\n      nextPosition = new CellCoords(currentlySelectedRange.highlight.row + newDelta.row, currentlySelectedRange.highlight.col + newDelta.col);\n      var nextPositionMergedCell = this.mergedCellsCollection.get(nextPosition.row, nextPosition.col);\n      if (nextPositionMergedCell) {\n        // skipping the invisible cells in the merge range\n        var firstRenderableCoords = this.mergedCellsCollection.getFirstRenderableCoords(nextPositionMergedCell.row, nextPositionMergedCell.col);\n        priv.lastDesiredCoords = nextPosition;\n        newDelta = {\n          row: firstRenderableCoords.row - currentPosition.row,\n          col: firstRenderableCoords.col - currentPosition.col\n        };\n      }\n      if (newDelta.row !== 0) {\n        delta.row = newDelta.row;\n      }\n      if (newDelta.col !== 0) {\n        delta.col = newDelta.col;\n      }\n    }\n    /**\n     * `modifyTransformEnd` hook callback. Needed to handle \"jumping over\" merged merged cells, while selecting.\n     *\n     * @private\n     * @param {object} delta The transformation delta.\n     */\n  }, {\n    key: \"onModifyTransformEnd\",\n    value: function onModifyTransformEnd(delta) {\n      var _this6 = this;\n      var currentSelectionRange = this.hot.getSelectedRangeLast();\n      var newDelta = clone(delta);\n      var newSelectionRange = this.selectionCalculations.getUpdatedSelectionRange(currentSelectionRange, delta);\n      var tempDelta = clone(newDelta);\n      var mergedCellsWithinRange = this.mergedCellsCollection.getWithinRange(newSelectionRange, true);\n      do {\n        tempDelta = clone(newDelta);\n        this.selectionCalculations.getUpdatedSelectionRange(currentSelectionRange, newDelta);\n        arrayEach(mergedCellsWithinRange, function (mergedCell) {\n          _this6.selectionCalculations.snapDelta(newDelta, currentSelectionRange, mergedCell);\n        });\n      } while (newDelta.row !== tempDelta.row || newDelta.col !== tempDelta.col);\n      delta.row = newDelta.row;\n      delta.col = newDelta.col;\n    }\n    /**\n     * `modifyGetCellCoords` hook callback. Swaps the `getCell` coords with the merged parent coords.\n     *\n     * @private\n     * @param {number} row Row index.\n     * @param {number} column Visual column index.\n     * @returns {Array|undefined} Visual coordinates of the merge.\n     */\n  }, {\n    key: \"onModifyGetCellCoords\",\n    value: function onModifyGetCellCoords(row, column) {\n      if (row < 0 || column < 0) {\n        return;\n      }\n      var mergeParent = this.mergedCellsCollection.get(row, column);\n      if (!mergeParent) {\n        return;\n      }\n      var mergeRow = mergeParent.row,\n        mergeColumn = mergeParent.col,\n        colspan = mergeParent.colspan,\n        rowspan = mergeParent.rowspan;\n      return [\n      // Most top-left merged cell coords.\n      mergeRow, mergeColumn,\n      // Most bottom-right merged cell coords.\n      mergeRow + rowspan - 1, mergeColumn + colspan - 1];\n    }\n    /**\n     * `afterContextMenuDefaultOptions` hook callback.\n     *\n     * @private\n     * @param {object} defaultOptions The default context menu options.\n     */\n  }, {\n    key: \"addMergeActionsToContextMenu\",\n    value: function addMergeActionsToContextMenu(defaultOptions) {\n      defaultOptions.items.push({\n        name: '---------'\n      }, toggleMergeItem(this));\n    }\n    /**\n     * `afterRenderer` hook callback.\n     *\n     * @private\n     * @param {HTMLElement} TD The cell to be modified.\n     * @param {number} row Row index.\n     * @param {number} col Visual column index.\n     */\n  }, {\n    key: \"onAfterRenderer\",\n    value: function onAfterRenderer(TD, row, col) {\n      var mergedCell = this.mergedCellsCollection.get(row, col); // We shouldn't override data in the collection.\n\n      var mergedCellCopy = isObject(mergedCell) ? clone(mergedCell) : void 0;\n      if (isObject(mergedCellCopy)) {\n        var _this$hot3 = this.hot,\n          rowMapper = _this$hot3.rowIndexMapper,\n          columnMapper = _this$hot3.columnIndexMapper;\n        var mergeRow = mergedCellCopy.row,\n          mergeColumn = mergedCellCopy.col,\n          colspan = mergedCellCopy.colspan,\n          rowspan = mergedCellCopy.rowspan;\n        var _this$translateMerged = this.translateMergedCellToRenderable(mergeRow, rowspan, mergeColumn, colspan),\n          _this$translateMerged2 = _slicedToArray(_this$translateMerged, 2),\n          lastMergedRowIndex = _this$translateMerged2[0],\n          lastMergedColumnIndex = _this$translateMerged2[1];\n        var renderedRowIndex = rowMapper.getRenderableFromVisualIndex(row);\n        var renderedColumnIndex = columnMapper.getRenderableFromVisualIndex(col);\n        var maxRowSpan = lastMergedRowIndex - renderedRowIndex + 1; // Number of rendered columns.\n\n        var maxColSpan = lastMergedColumnIndex - renderedColumnIndex + 1; // Number of rendered columns.\n        // We just try to determine some values basing on the actual number of rendered indexes (some columns may be hidden).\n\n        mergedCellCopy.row = rowMapper.getFirstNotHiddenIndex(mergedCellCopy.row, 1); // We just try to determine some values basing on the actual number of rendered indexes (some columns may be hidden).\n\n        mergedCellCopy.col = columnMapper.getFirstNotHiddenIndex(mergedCellCopy.col, 1); // The `rowSpan` property for a `TD` element should be at most equal to number of rendered rows in the merge area.\n\n        mergedCellCopy.rowspan = Math.min(mergedCellCopy.rowspan, maxRowSpan); // The `colSpan` property for a `TD` element should be at most equal to number of rendered columns in the merge area.\n\n        mergedCellCopy.colspan = Math.min(mergedCellCopy.colspan, maxColSpan);\n      }\n      applySpanProperties(TD, mergedCellCopy, row, col);\n    }\n    /**\n     * `beforeSetRangeStart` and `beforeSetRangeStartOnly` hook callback.\n     * A selection within merge area should be rewritten to the start of merge area.\n     *\n     * @private\n     * @param {object} coords Cell coords.\n     */\n  }, {\n    key: \"onBeforeSetRangeStart\",\n    value: function onBeforeSetRangeStart(coords) {\n      // TODO: It is a workaround, but probably this hook may be needed. Every selection on the merge area\n      // could set start point of the selection to the start of the merge area. However, logic inside `expandByRange` need\n      // an initial start point. Click on the merge cell when there are some hidden indexes break the logic in some cases.\n      // Please take a look at #7010 for more information. I'm not sure if selection directions are calculated properly\n      // and what was idea for flipping direction inside `expandByRange` method.\n      if (this.mergedCellsCollection.isFirstRenderableMergedCell(coords.row, coords.col)) {\n        var mergeParent = this.mergedCellsCollection.get(coords.row, coords.col);\n        var _ref = [mergeParent.row, mergeParent.col];\n        coords.row = _ref[0];\n        coords.col = _ref[1];\n      }\n    }\n    /**\n     * `beforeSetRangeEnd` hook callback.\n     * While selecting cells with keyboard or mouse, make sure that rectangular area is expanded to the extent of the merged cell.\n     *\n     * Note: Please keep in mind that callback may modify both start and end range coordinates by the reference.\n     *\n     * @private\n     * @param {object} coords Cell coords.\n     */\n  }, {\n    key: \"onBeforeSetRangeEnd\",\n    value: function onBeforeSetRangeEnd(coords) {\n      var selRange = this.hot.getSelectedRangeLast();\n      selRange.highlight = new CellCoords(selRange.highlight.row, selRange.highlight.col); // clone in case we will modify its reference\n\n      selRange.to = coords;\n      var rangeExpanded = false;\n      if (this.hot.selection.isSelectedByColumnHeader() || this.hot.selection.isSelectedByRowHeader()) {\n        return;\n      }\n      do {\n        rangeExpanded = false;\n        for (var i = 0; i < this.mergedCellsCollection.mergedCells.length; i += 1) {\n          var cellInfo = this.mergedCellsCollection.mergedCells[i];\n          var mergedCellRange = cellInfo.getRange();\n          if (selRange.expandByRange(mergedCellRange)) {\n            coords.row = selRange.to.row;\n            coords.col = selRange.to.col;\n            rangeExpanded = true;\n          }\n        }\n      } while (rangeExpanded);\n    }\n    /**\n     * The `afterGetCellMeta` hook callback.\n     *\n     * @private\n     * @param {number} row Row index.\n     * @param {number} col Column index.\n     * @param {object} cellProperties The cell properties object.\n     */\n  }, {\n    key: \"onAfterGetCellMeta\",\n    value: function onAfterGetCellMeta(row, col, cellProperties) {\n      var mergeParent = this.mergedCellsCollection.get(row, col);\n      if (mergeParent) {\n        if (mergeParent.row !== row || mergeParent.col !== col) {\n          cellProperties.copyable = false;\n        } else {\n          cellProperties.rowspan = mergeParent.rowspan;\n          cellProperties.colspan = mergeParent.colspan;\n        }\n      }\n    }\n    /**\n     * `afterViewportRowCalculatorOverride` hook callback.\n     *\n     * @private\n     * @param {object} calc The row calculator object.\n     */\n  }, {\n    key: \"onAfterViewportRowCalculatorOverride\",\n    value: function onAfterViewportRowCalculatorOverride(calc) {\n      var nrOfColumns = this.hot.countCols();\n      this.modifyViewportRowStart(calc, nrOfColumns);\n      this.modifyViewportRowEnd(calc, nrOfColumns);\n    }\n    /**\n     * Modify viewport start when needed. We extend viewport when merged cells aren't fully visible.\n     *\n     * @private\n     * @param {object} calc The row calculator object.\n     * @param {number} nrOfColumns Number of visual columns.\n     */\n  }, {\n    key: \"modifyViewportRowStart\",\n    value: function modifyViewportRowStart(calc, nrOfColumns) {\n      var rowMapper = this.hot.rowIndexMapper;\n      var visualStartRow = rowMapper.getVisualFromRenderableIndex(calc.startRow);\n      for (var visualColumnIndex = 0; visualColumnIndex < nrOfColumns; visualColumnIndex += 1) {\n        var mergeParentForViewportStart = this.mergedCellsCollection.get(visualStartRow, visualColumnIndex);\n        if (isObject(mergeParentForViewportStart)) {\n          var renderableIndexAtMergeStart = rowMapper.getRenderableFromVisualIndex(rowMapper.getFirstNotHiddenIndex(mergeParentForViewportStart.row, 1)); // Merge start is out of the viewport (i.e. when we scrolled to the bottom and we can see just part of a merge).\n\n          if (renderableIndexAtMergeStart < calc.startRow) {\n            // We extend viewport when some rows have been merged.\n            calc.startRow = renderableIndexAtMergeStart; // We are looking for next merges inside already extended viewport (starting again from row equal to 0).\n\n            this.modifyViewportRowStart(calc, nrOfColumns); // recursively search upwards\n\n            return; // Finish the current loop. Everything will be checked from the beginning by above recursion.\n          }\n        }\n      }\n    }\n    /**\n     *  Modify viewport end when needed. We extend viewport when merged cells aren't fully visible.\n     *\n     * @private\n     * @param {object} calc The row calculator object.\n     * @param {number} nrOfColumns Number of visual columns.\n     */\n  }, {\n    key: \"modifyViewportRowEnd\",\n    value: function modifyViewportRowEnd(calc, nrOfColumns) {\n      var rowMapper = this.hot.rowIndexMapper;\n      var visualEndRow = rowMapper.getVisualFromRenderableIndex(calc.endRow);\n      for (var visualColumnIndex = 0; visualColumnIndex < nrOfColumns; visualColumnIndex += 1) {\n        var mergeParentForViewportEnd = this.mergedCellsCollection.get(visualEndRow, visualColumnIndex);\n        if (isObject(mergeParentForViewportEnd)) {\n          var mergeEnd = mergeParentForViewportEnd.row + mergeParentForViewportEnd.rowspan - 1;\n          var renderableIndexAtMergeEnd = rowMapper.getRenderableFromVisualIndex(rowMapper.getFirstNotHiddenIndex(mergeEnd, -1)); // Merge end is out of the viewport.\n\n          if (renderableIndexAtMergeEnd > calc.endRow) {\n            // We extend the viewport when some rows have been merged.\n            calc.endRow = renderableIndexAtMergeEnd; // We are looking for next merges inside already extended viewport (starting again from row equal to 0).\n\n            this.modifyViewportRowEnd(calc, nrOfColumns); // recursively search upwards\n\n            return; // Finish the current loop. Everything will be checked from the beginning by above recursion.\n          }\n        }\n      }\n    }\n    /**\n     * `afterViewportColumnCalculatorOverride` hook callback.\n     *\n     * @private\n     * @param {object} calc The column calculator object.\n     */\n  }, {\n    key: \"onAfterViewportColumnCalculatorOverride\",\n    value: function onAfterViewportColumnCalculatorOverride(calc) {\n      var nrOfRows = this.hot.countRows();\n      this.modifyViewportColumnStart(calc, nrOfRows);\n      this.modifyViewportColumnEnd(calc, nrOfRows);\n    }\n    /**\n     * Modify viewport start when needed. We extend viewport when merged cells aren't fully visible.\n     *\n     * @private\n     * @param {object} calc The column calculator object.\n     * @param {number} nrOfRows Number of visual rows.\n     */\n  }, {\n    key: \"modifyViewportColumnStart\",\n    value: function modifyViewportColumnStart(calc, nrOfRows) {\n      var columnMapper = this.hot.columnIndexMapper;\n      var visualStartCol = columnMapper.getVisualFromRenderableIndex(calc.startColumn);\n      for (var visualRowIndex = 0; visualRowIndex < nrOfRows; visualRowIndex += 1) {\n        var mergeParentForViewportStart = this.mergedCellsCollection.get(visualRowIndex, visualStartCol);\n        if (isObject(mergeParentForViewportStart)) {\n          var renderableIndexAtMergeStart = columnMapper.getRenderableFromVisualIndex(columnMapper.getFirstNotHiddenIndex(mergeParentForViewportStart.col, 1)); // Merge start is out of the viewport (i.e. when we scrolled to the right and we can see just part of a merge).\n\n          if (renderableIndexAtMergeStart < calc.startColumn) {\n            // We extend viewport when some columns have been merged.\n            calc.startColumn = renderableIndexAtMergeStart; // We are looking for next merges inside already extended viewport (starting again from column equal to 0).\n\n            this.modifyViewportColumnStart(calc, nrOfRows); // recursively search upwards\n\n            return; // Finish the current loop. Everything will be checked from the beginning by above recursion.\n          }\n        }\n      }\n    }\n    /**\n     *  Modify viewport end when needed. We extend viewport when merged cells aren't fully visible.\n     *\n     * @private\n     * @param {object} calc The column calculator object.\n     * @param {number} nrOfRows Number of visual rows.\n     */\n  }, {\n    key: \"modifyViewportColumnEnd\",\n    value: function modifyViewportColumnEnd(calc, nrOfRows) {\n      var columnMapper = this.hot.columnIndexMapper;\n      var visualEndCol = columnMapper.getVisualFromRenderableIndex(calc.endColumn);\n      for (var visualRowIndex = 0; visualRowIndex < nrOfRows; visualRowIndex += 1) {\n        var mergeParentForViewportEnd = this.mergedCellsCollection.get(visualRowIndex, visualEndCol);\n        if (isObject(mergeParentForViewportEnd)) {\n          var mergeEnd = mergeParentForViewportEnd.col + mergeParentForViewportEnd.colspan - 1;\n          var renderableIndexAtMergeEnd = columnMapper.getRenderableFromVisualIndex(columnMapper.getFirstNotHiddenIndex(mergeEnd, -1)); // Merge end is out of the viewport.\n\n          if (renderableIndexAtMergeEnd > calc.endColumn) {\n            // We extend the viewport when some columns have been merged.\n            calc.endColumn = renderableIndexAtMergeEnd; // We are looking for next merges inside already extended viewport (starting again from column equal to 0).\n\n            this.modifyViewportColumnEnd(calc, nrOfRows); // recursively search upwards\n\n            return; // Finish the current loop. Everything will be checked from the beginning by above recursion.\n          }\n        }\n      }\n    }\n    /**\n     * Translates merged cell coordinates to renderable indexes.\n     *\n     * @private\n     * @param {number} parentRow Visual row index.\n     * @param {number} rowspan Rowspan which describes shift which will be applied to parent row\n     *                         to calculate renderable index which points to the most bottom\n     *                         index position. Pass rowspan as `0` to calculate the most top\n     *                         index position.\n     * @param {number} parentColumn Visual column index.\n     * @param {number} colspan Colspan which describes shift which will be applied to parent column\n     *                         to calculate renderable index which points to the most right\n     *                         index position. Pass colspan as `0` to calculate the most left\n     *                         index position.\n     * @returns {number[]}\n     */\n  }, {\n    key: \"translateMergedCellToRenderable\",\n    value: function translateMergedCellToRenderable(parentRow, rowspan, parentColumn, colspan) {\n      var _this$hot4 = this.hot,\n        rowMapper = _this$hot4.rowIndexMapper,\n        columnMapper = _this$hot4.columnIndexMapper;\n      var firstNonHiddenRow;\n      var firstNonHiddenColumn;\n      if (rowspan === 0) {\n        firstNonHiddenRow = rowMapper.getFirstNotHiddenIndex(parentRow, 1);\n      } else {\n        firstNonHiddenRow = rowMapper.getFirstNotHiddenIndex(parentRow + rowspan - 1, -1);\n      }\n      if (colspan === 0) {\n        firstNonHiddenColumn = columnMapper.getFirstNotHiddenIndex(parentColumn, 1);\n      } else {\n        firstNonHiddenColumn = columnMapper.getFirstNotHiddenIndex(parentColumn + colspan - 1, -1);\n      }\n      var renderableRow = parentRow >= 0 ? rowMapper.getRenderableFromVisualIndex(firstNonHiddenRow) : parentRow;\n      var renderableColumn = parentColumn >= 0 ? columnMapper.getRenderableFromVisualIndex(firstNonHiddenColumn) : parentColumn;\n      return [renderableRow, renderableColumn];\n    }\n    /**\n     * The `modifyAutofillRange` hook callback.\n     *\n     * @private\n     * @param {Array} drag The drag area coordinates.\n     * @param {Array} select The selection information.\n     * @returns {Array} The new drag area.\n     */\n  }, {\n    key: \"onModifyAutofillRange\",\n    value: function onModifyAutofillRange(drag, select) {\n      this.autofillCalculations.correctSelectionAreaSize(select);\n      var dragDirection = this.autofillCalculations.getDirection(select, drag);\n      var dragArea = drag;\n      if (this.autofillCalculations.dragAreaOverlapsCollections(select, dragArea, dragDirection)) {\n        dragArea = select;\n        return dragArea;\n      }\n      var mergedCellsWithinSelectionArea = this.mergedCellsCollection.getWithinRange({\n        from: {\n          row: select[0],\n          col: select[1]\n        },\n        to: {\n          row: select[2],\n          col: select[3]\n        }\n      });\n      if (!mergedCellsWithinSelectionArea) {\n        return dragArea;\n      }\n      dragArea = this.autofillCalculations.snapDragArea(select, dragArea, dragDirection, mergedCellsWithinSelectionArea);\n      return dragArea;\n    }\n    /**\n     * `afterCreateCol` hook callback.\n     *\n     * @private\n     * @param {number} column Column index.\n     * @param {number} count Number of created columns.\n     */\n  }, {\n    key: \"onAfterCreateCol\",\n    value: function onAfterCreateCol(column, count) {\n      this.mergedCellsCollection.shiftCollections('right', column, count);\n    }\n    /**\n     * `afterRemoveCol` hook callback.\n     *\n     * @private\n     * @param {number} column Column index.\n     * @param {number} count Number of removed columns.\n     */\n  }, {\n    key: \"onAfterRemoveCol\",\n    value: function onAfterRemoveCol(column, count) {\n      this.mergedCellsCollection.shiftCollections('left', column, count);\n    }\n    /**\n     * `afterCreateRow` hook callback.\n     *\n     * @private\n     * @param {number} row Row index.\n     * @param {number} count Number of created rows.\n     * @param {string} source Source of change.\n     */\n  }, {\n    key: \"onAfterCreateRow\",\n    value: function onAfterCreateRow(row, count, source) {\n      if (source === 'auto') {\n        return;\n      }\n      this.mergedCellsCollection.shiftCollections('down', row, count);\n    }\n    /**\n     * `afterRemoveRow` hook callback.\n     *\n     * @private\n     * @param {number} row Row index.\n     * @param {number} count Number of removed rows.\n     */\n  }, {\n    key: \"onAfterRemoveRow\",\n    value: function onAfterRemoveRow(row, count) {\n      this.mergedCellsCollection.shiftCollections('up', row, count);\n    }\n    /**\n     * `afterChange` hook callback. Used to propagate merged cells after using Autofill.\n     *\n     * @private\n     * @param {Array} changes The changes array.\n     * @param {string} source Determines the source of the change.\n     */\n  }, {\n    key: \"onAfterChange\",\n    value: function onAfterChange(changes, source) {\n      if (source !== 'Autofill.fill') {\n        return;\n      }\n      this.autofillCalculations.recreateAfterDataPopulation(changes);\n    }\n    /**\n     * `beforeDrawAreaBorders` hook callback.\n     *\n     * @private\n     * @param {Array} corners Visual coordinates of the area corners.\n     * @param {string} className Class name for the area.\n     */\n  }, {\n    key: \"onBeforeDrawAreaBorders\",\n    value: function onBeforeDrawAreaBorders(corners, className) {\n      if (className && className === 'area') {\n        var selectedRange = this.hot.getSelectedRangeLast();\n        var mergedCellsWithinRange = this.mergedCellsCollection.getWithinRange(selectedRange);\n        arrayEach(mergedCellsWithinRange, function (mergedCell) {\n          if (selectedRange.getBottomRightCorner().row === mergedCell.getLastRow() && selectedRange.getBottomRightCorner().col === mergedCell.getLastColumn()) {\n            corners[2] = mergedCell.row;\n            corners[3] = mergedCell.col;\n          }\n        });\n      }\n    }\n    /**\n     * `afterModifyTransformStart` hook callback. Fixes a problem with navigating through merged cells at the edges of the table\n     * with the ENTER/SHIFT+ENTER/TAB/SHIFT+TAB keys.\n     *\n     * @private\n     * @param {CellCoords} coords Coordinates of the to-be-selected cell.\n     * @param {number} rowTransformDir Row transformation direction (negative value = up, 0 = none, positive value = down).\n     * @param {number} colTransformDir Column transformation direction (negative value = up, 0 = none, positive value = down).\n     */\n  }, {\n    key: \"onAfterModifyTransformStart\",\n    value: function onAfterModifyTransformStart(coords, rowTransformDir, colTransformDir) {\n      if (!this.enabled) {\n        return;\n      }\n      var mergedCellAtCoords = this.mergedCellsCollection.get(coords.row, coords.col);\n      if (!mergedCellAtCoords) {\n        return;\n      }\n      var goingDown = rowTransformDir > 0;\n      var goingUp = rowTransformDir < 0;\n      var goingLeft = colTransformDir < 0;\n      var goingRight = colTransformDir > 0;\n      var mergedCellOnBottomEdge = mergedCellAtCoords.row + mergedCellAtCoords.rowspan - 1 === this.hot.countRows() - 1;\n      var mergedCellOnTopEdge = mergedCellAtCoords.row === 0;\n      var mergedCellOnRightEdge = mergedCellAtCoords.col + mergedCellAtCoords.colspan - 1 === this.hot.countCols() - 1;\n      var mergedCellOnLeftEdge = mergedCellAtCoords.col === 0;\n      if (goingDown && mergedCellOnBottomEdge || goingUp && mergedCellOnTopEdge || goingRight && mergedCellOnRightEdge || goingLeft && mergedCellOnLeftEdge) {\n        coords.row = mergedCellAtCoords.row;\n        coords.col = mergedCellAtCoords.col;\n      }\n    }\n    /**\n     * `afterDrawSelection` hook callback. Used to add the additional class name for the entirely-selected merged cells.\n     *\n     * @private\n     * @param {number} currentRow Visual row index of the currently processed cell.\n     * @param {number} currentColumn Visual column index of the currently cell.\n     * @param {Array} cornersOfSelection Array of the current selection in a form of `[startRow, startColumn, endRow, endColumn]`.\n     * @param {number|undefined} layerLevel Number indicating which layer of selection is currently processed.\n     * @returns {string|undefined} A `String`, which will act as an additional `className` to be added to the currently processed cell.\n     */\n  }, {\n    key: \"onAfterDrawSelection\",\n    value: function onAfterDrawSelection(currentRow, currentColumn, cornersOfSelection, layerLevel) {\n      // Nothing's selected (hook might be triggered by the custom borders)\n      if (!cornersOfSelection) {\n        return;\n      }\n      return this.selectionCalculations.getSelectedMergedCellClassName(currentRow, currentColumn, cornersOfSelection, layerLevel);\n    }\n    /**\n     * `beforeRemoveCellClassNames` hook callback. Used to remove additional class name from all cells in the table.\n     *\n     * @private\n     * @returns {string[]} An `Array` of `String`s. Each of these strings will act like class names to be removed from all the cells in the table.\n     */\n  }, {\n    key: \"onBeforeRemoveCellClassNames\",\n    value: function onBeforeRemoveCellClassNames() {\n      return this.selectionCalculations.getSelectedMergedCellClassNameToRemove();\n    }\n  }], [{\n    key: \"PLUGIN_KEY\",\n    get: function get() {\n      return PLUGIN_KEY;\n    }\n  }, {\n    key: \"PLUGIN_PRIORITY\",\n    get: function get() {\n      return PLUGIN_PRIORITY;\n    }\n  }]);\n  return MergeCells;\n}(BasePlugin);","map":{"version":3,"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","TypeError","_i","_arr","_n","_d","_s","_e","call","next","done","push","value","length","err","Array","isArray","_toConsumableArray","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","o","minLen","_arrayLikeToArray","n","Object","toString","slice","name","from","test","iter","len","arr2","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","_get","Reflect","get","property","receiver","base","_superPropBase","desc","getOwnPropertyDescriptor","arguments","apply","object","hasOwnProperty","_getPrototypeOf","_inherits","subClass","superClass","create","_setPrototypeOf","p","setPrototypeOf","__proto__","_createSuper","Derived","hasNativeReflectConstruct","_isNativeReflectConstruct","_createSuperInternal","Super","result","NewTarget","construct","_possibleConstructorReturn","self","_assertThisInitialized","ReferenceError","sham","Proxy","Boolean","valueOf","e","getPrototypeOf","BasePlugin","Hooks","stopImmediatePropagation","CellCoords","CellRange","MergedCellsCollection","MergedCellCoords","AutofillCalculations","SelectionCalculations","toggleMergeItem","arrayEach","isObject","clone","warn","rangeEach","applySpanProperties","getSingleton","register","PLUGIN_KEY","PLUGIN_PRIORITY","privatePool","WeakMap","MergeCells","_BasePlugin","_super","hotInstance","_this","set","lastDesiredCoords","mergedCellsCollection","autofillCalculations","selectionCalculations","isEnabled","hot","getSettings","enablePlugin","_this2","enabled","addHook","onAfterInit","onBeforeKeyDown","onModifyTransformStart","onAfterModifyTransformStart","onModifyTransformEnd","onModifyGetCellCoords","onBeforeSetRangeStart","onBeforeSetRangeEnd","onAfterIsMultipleSelection","onAfterRenderer","addMergeActionsToContextMenu","onAfterGetCellMeta","onAfterViewportRowCalculatorOverride","onAfterViewportColumnCalculatorOverride","onModifyAutofillRange","onAfterCreateCol","onAfterRemoveCol","onAfterCreateRow","onAfterRemoveRow","onAfterChange","onBeforeDrawAreaBorders","onAfterDrawSelection","onBeforeRemoveCellClassNames","action","source","disablePlugin","clearCollections","render","updatePlugin","settings","generateFromSettings","validateSetting","setting","valid","containsNegativeValues","NEGATIVE_VALUES_WARNING","isOutOfBounds","countRows","countCols","IS_OUT_OF_BOUNDS_WARNING","isSingleCell","IS_SINGLE_CELL","containsZeroSpan","ZERO_SPAN_WARNING","_this3","_this$hot","populationArgumentsList","highlight","row","col","rangeEnd","rowspan","colspan","mergeRange","filter","bulkPopulationData","getBulkCollectionData","populateFromArray","_this$hot2","populationDataRange","getBulkCollectionDataRange","dataAtRange","getData","newDataAtRange","splice","mergedCellArguments","_mergedCellArguments","mergedCellRowIndex","mergedCellColumnIndex","mergedCellData","mergedCellRow","rowIndex","mergedCellElement","columnIndex","start","end","mergedCellColumn","Math","min","max","concat","clear","canMergeRange","newMergedCellInfo","auto","undefined","toggleMergeOnSelection","currentRange","getSelectedRangeLast","setDirection","to","toggleMerge","selectCell","mergeSelection","cellRange","unmergeRange","unmergeSelection","_this4","preventPopulation","topLeft","getTopLeftCorner","bottomRight","getBottomRightCorner","mergeParent","clearedData","populationInfo","runHooks","j","clearedValue","getDataAtCell","setCellMeta","mergedCellAdded","add","pluginName","_this5","mergedCells","getWithinRange","currentCollection","remove","removeCellMeta","mergedCell","mergedCellCoversWholeRange","merge","startRow","startColumn","endRow","endColumn","unmerge","event","ctrlDown","ctrlKey","metaKey","altKey","keyCode","isMultiple","selectionRange","group","delta","priv","currentlySelectedRange","newDelta","nextPosition","currentPosition","mergedParent","mergeTopLeft","mergeBottomRight","includes","nextPositionMergedCell","firstRenderableCoords","getFirstRenderableCoords","_this6","currentSelectionRange","newSelectionRange","getUpdatedSelectionRange","tempDelta","mergedCellsWithinRange","snapDelta","column","mergeRow","mergeColumn","defaultOptions","items","TD","mergedCellCopy","_this$hot3","rowMapper","rowIndexMapper","columnMapper","columnIndexMapper","_this$translateMerged","translateMergedCellToRenderable","_this$translateMerged2","lastMergedRowIndex","lastMergedColumnIndex","renderedRowIndex","getRenderableFromVisualIndex","renderedColumnIndex","maxRowSpan","maxColSpan","getFirstNotHiddenIndex","coords","isFirstRenderableMergedCell","_ref","selRange","rangeExpanded","selection","isSelectedByColumnHeader","isSelectedByRowHeader","cellInfo","mergedCellRange","getRange","expandByRange","cellProperties","copyable","calc","nrOfColumns","modifyViewportRowStart","modifyViewportRowEnd","visualStartRow","getVisualFromRenderableIndex","visualColumnIndex","mergeParentForViewportStart","renderableIndexAtMergeStart","visualEndRow","mergeParentForViewportEnd","mergeEnd","renderableIndexAtMergeEnd","nrOfRows","modifyViewportColumnStart","modifyViewportColumnEnd","visualStartCol","visualRowIndex","visualEndCol","parentRow","parentColumn","_this$hot4","firstNonHiddenRow","firstNonHiddenColumn","renderableRow","renderableColumn","drag","select","correctSelectionAreaSize","dragDirection","getDirection","dragArea","dragAreaOverlapsCollections","mergedCellsWithinSelectionArea","snapDragArea","count","shiftCollections","changes","recreateAfterDataPopulation","corners","className","selectedRange","getLastRow","getLastColumn","rowTransformDir","colTransformDir","mergedCellAtCoords","goingDown","goingUp","goingLeft","goingRight","mergedCellOnBottomEdge","mergedCellOnTopEdge","mergedCellOnRightEdge","mergedCellOnLeftEdge","currentRow","currentColumn","cornersOfSelection","layerLevel","getSelectedMergedCellClassName","getSelectedMergedCellClassNameToRemove"],"sources":["/Users/priyadeliwala/Desktop/sales-dashboard/node_modules/handsontable/plugins/mergeCells/mergeCells.mjs"],"sourcesContent":["function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _get() { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.weak-map.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/es.object.set-prototype-of.js\";\nimport \"core-js/modules/es.object.get-prototype-of.js\";\nimport \"core-js/modules/es.reflect.construct.js\";\nimport \"core-js/modules/es.reflect.get.js\";\nimport \"core-js/modules/es.object.get-own-property-descriptor.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport { BasePlugin } from \"../base/index.mjs\";\nimport Hooks from \"../../pluginHooks.mjs\";\nimport { stopImmediatePropagation } from \"../../helpers/dom/event.mjs\";\nimport { CellCoords, CellRange } from \"../../3rdparty/walkontable/src/index.mjs\";\nimport MergedCellsCollection from \"./cellsCollection.mjs\";\nimport MergedCellCoords from \"./cellCoords.mjs\";\nimport AutofillCalculations from \"./calculations/autofill.mjs\";\nimport SelectionCalculations from \"./calculations/selection.mjs\";\nimport toggleMergeItem from \"./contextMenuItem/toggleMerge.mjs\";\nimport { arrayEach } from \"../../helpers/array.mjs\";\nimport { isObject, clone } from \"../../helpers/object.mjs\";\nimport { warn } from \"../../helpers/console.mjs\";\nimport { rangeEach } from \"../../helpers/number.mjs\";\nimport { applySpanProperties } from \"./utils.mjs\";\nHooks.getSingleton().register('beforeMergeCells');\nHooks.getSingleton().register('afterMergeCells');\nHooks.getSingleton().register('beforeUnmergeCells');\nHooks.getSingleton().register('afterUnmergeCells');\nexport var PLUGIN_KEY = 'mergeCells';\nexport var PLUGIN_PRIORITY = 150;\nvar privatePool = new WeakMap();\n/**\n * @plugin MergeCells\n * @class MergeCells\n *\n * @description\n * Plugin, which allows merging cells in the table (using the initial configuration, API or context menu).\n *\n * @example\n *\n * ```js\n * const hot = new Handsontable(document.getElementById('example'), {\n *  data: getData(),\n *  mergeCells: [\n *    {row: 0, col: 3, rowspan: 3, colspan: 3},\n *    {row: 2, col: 6, rowspan: 2, colspan: 2},\n *    {row: 4, col: 8, rowspan: 3, colspan: 3}\n *  ],\n * ```\n */\n\nexport var MergeCells = /*#__PURE__*/function (_BasePlugin) {\n  _inherits(MergeCells, _BasePlugin);\n\n  var _super = _createSuper(MergeCells);\n\n  function MergeCells(hotInstance) {\n    var _this;\n\n    _classCallCheck(this, MergeCells);\n\n    _this = _super.call(this, hotInstance);\n    privatePool.set(_assertThisInitialized(_this), {\n      lastDesiredCoords: null\n    });\n    /**\n     * A container for all the merged cells.\n     *\n     * @private\n     * @type {MergedCellsCollection}\n     */\n\n    _this.mergedCellsCollection = null;\n    /**\n     * Instance of the class responsible for all the autofill-related calculations.\n     *\n     * @private\n     * @type {AutofillCalculations}\n     */\n\n    _this.autofillCalculations = null;\n    /**\n     * Instance of the class responsible for the selection-related calculations.\n     *\n     * @private\n     * @type {SelectionCalculations}\n     */\n\n    _this.selectionCalculations = null;\n    return _this;\n  }\n  /**\n   * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}\n   * hook and if it returns `true` than the {@link MergeCells#enablePlugin} method is called.\n   *\n   * @returns {boolean}\n   */\n\n\n  _createClass(MergeCells, [{\n    key: \"isEnabled\",\n    value: function isEnabled() {\n      return !!this.hot.getSettings()[PLUGIN_KEY];\n    }\n    /**\n     * Enables the plugin functionality for this Handsontable instance.\n     */\n\n  }, {\n    key: \"enablePlugin\",\n    value: function enablePlugin() {\n      var _this2 = this;\n\n      if (this.enabled) {\n        return;\n      }\n\n      this.mergedCellsCollection = new MergedCellsCollection(this);\n      this.autofillCalculations = new AutofillCalculations(this);\n      this.selectionCalculations = new SelectionCalculations(this);\n      this.addHook('afterInit', function () {\n        return _this2.onAfterInit.apply(_this2, arguments);\n      });\n      this.addHook('beforeKeyDown', function () {\n        return _this2.onBeforeKeyDown.apply(_this2, arguments);\n      });\n      this.addHook('modifyTransformStart', function () {\n        return _this2.onModifyTransformStart.apply(_this2, arguments);\n      });\n      this.addHook('afterModifyTransformStart', function () {\n        return _this2.onAfterModifyTransformStart.apply(_this2, arguments);\n      });\n      this.addHook('modifyTransformEnd', function () {\n        return _this2.onModifyTransformEnd.apply(_this2, arguments);\n      });\n      this.addHook('modifyGetCellCoords', function () {\n        return _this2.onModifyGetCellCoords.apply(_this2, arguments);\n      });\n      this.addHook('beforeSetRangeStart', function () {\n        return _this2.onBeforeSetRangeStart.apply(_this2, arguments);\n      });\n      this.addHook('beforeSetRangeStartOnly', function () {\n        return _this2.onBeforeSetRangeStart.apply(_this2, arguments);\n      });\n      this.addHook('beforeSetRangeEnd', function () {\n        return _this2.onBeforeSetRangeEnd.apply(_this2, arguments);\n      });\n      this.addHook('afterIsMultipleSelection', function () {\n        return _this2.onAfterIsMultipleSelection.apply(_this2, arguments);\n      });\n      this.addHook('afterRenderer', function () {\n        return _this2.onAfterRenderer.apply(_this2, arguments);\n      });\n      this.addHook('afterContextMenuDefaultOptions', function () {\n        return _this2.addMergeActionsToContextMenu.apply(_this2, arguments);\n      });\n      this.addHook('afterGetCellMeta', function () {\n        return _this2.onAfterGetCellMeta.apply(_this2, arguments);\n      });\n      this.addHook('afterViewportRowCalculatorOverride', function () {\n        return _this2.onAfterViewportRowCalculatorOverride.apply(_this2, arguments);\n      });\n      this.addHook('afterViewportColumnCalculatorOverride', function () {\n        return _this2.onAfterViewportColumnCalculatorOverride.apply(_this2, arguments);\n      });\n      this.addHook('modifyAutofillRange', function () {\n        return _this2.onModifyAutofillRange.apply(_this2, arguments);\n      });\n      this.addHook('afterCreateCol', function () {\n        return _this2.onAfterCreateCol.apply(_this2, arguments);\n      });\n      this.addHook('afterRemoveCol', function () {\n        return _this2.onAfterRemoveCol.apply(_this2, arguments);\n      });\n      this.addHook('afterCreateRow', function () {\n        return _this2.onAfterCreateRow.apply(_this2, arguments);\n      });\n      this.addHook('afterRemoveRow', function () {\n        return _this2.onAfterRemoveRow.apply(_this2, arguments);\n      });\n      this.addHook('afterChange', function () {\n        return _this2.onAfterChange.apply(_this2, arguments);\n      });\n      this.addHook('beforeDrawBorders', function () {\n        return _this2.onBeforeDrawAreaBorders.apply(_this2, arguments);\n      });\n      this.addHook('afterDrawSelection', function () {\n        return _this2.onAfterDrawSelection.apply(_this2, arguments);\n      });\n      this.addHook('beforeRemoveCellClassNames', function () {\n        return _this2.onBeforeRemoveCellClassNames.apply(_this2, arguments);\n      });\n      this.addHook('beforeUndoStackChange', function (action, source) {\n        if (source === 'MergeCells') {\n          return false;\n        }\n      });\n\n      _get(_getPrototypeOf(MergeCells.prototype), \"enablePlugin\", this).call(this);\n    }\n    /**\n     * Disables the plugin functionality for this Handsontable instance.\n     */\n\n  }, {\n    key: \"disablePlugin\",\n    value: function disablePlugin() {\n      this.clearCollections();\n      this.hot.render();\n\n      _get(_getPrototypeOf(MergeCells.prototype), \"disablePlugin\", this).call(this);\n    }\n    /**\n     * Updates the plugin state. This method is executed when {@link Core#updateSettings} is invoked.\n     */\n\n  }, {\n    key: \"updatePlugin\",\n    value: function updatePlugin() {\n      var settings = this.hot.getSettings()[PLUGIN_KEY];\n      this.disablePlugin();\n      this.enablePlugin();\n      this.generateFromSettings(settings);\n\n      _get(_getPrototypeOf(MergeCells.prototype), \"updatePlugin\", this).call(this);\n    }\n    /**\n     * Validates a single setting object, represented by a single merged cell information object.\n     *\n     * @private\n     * @param {object} setting An object with `row`, `col`, `rowspan` and `colspan` properties.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"validateSetting\",\n    value: function validateSetting(setting) {\n      var valid = true;\n\n      if (!setting) {\n        return false;\n      }\n\n      if (MergedCellCoords.containsNegativeValues(setting)) {\n        warn(MergedCellCoords.NEGATIVE_VALUES_WARNING(setting));\n        valid = false;\n      } else if (MergedCellCoords.isOutOfBounds(setting, this.hot.countRows(), this.hot.countCols())) {\n        warn(MergedCellCoords.IS_OUT_OF_BOUNDS_WARNING(setting));\n        valid = false;\n      } else if (MergedCellCoords.isSingleCell(setting)) {\n        warn(MergedCellCoords.IS_SINGLE_CELL(setting));\n        valid = false;\n      } else if (MergedCellCoords.containsZeroSpan(setting)) {\n        warn(MergedCellCoords.ZERO_SPAN_WARNING(setting));\n        valid = false;\n      }\n\n      return valid;\n    }\n    /**\n     * Generates the merged cells from the settings provided to the plugin.\n     *\n     * @private\n     * @param {Array|boolean} settings The settings provided to the plugin.\n     */\n\n  }, {\n    key: \"generateFromSettings\",\n    value: function generateFromSettings(settings) {\n      var _this3 = this;\n\n      if (Array.isArray(settings)) {\n        var _this$hot;\n\n        var populationArgumentsList = [];\n        arrayEach(settings, function (setting) {\n          if (!_this3.validateSetting(setting)) {\n            return;\n          }\n\n          var highlight = new CellCoords(setting.row, setting.col);\n          var rangeEnd = new CellCoords(setting.row + setting.rowspan - 1, setting.col + setting.colspan - 1);\n          var mergeRange = new CellRange(highlight, highlight, rangeEnd);\n          populationArgumentsList.push(_this3.mergeRange(mergeRange, true, true));\n        }); // remove 'empty' setting objects, caused by improper merge range declarations\n\n        populationArgumentsList = populationArgumentsList.filter(function (value) {\n          return value !== true;\n        });\n        var bulkPopulationData = this.getBulkCollectionData(populationArgumentsList);\n\n        (_this$hot = this.hot).populateFromArray.apply(_this$hot, _toConsumableArray(bulkPopulationData));\n      }\n    }\n    /**\n     * Generates a bulk set of all the data to be populated to fill the data \"under\" the added merged cells.\n     *\n     * @private\n     * @param {Array} populationArgumentsList Array in a form of `[row, column, dataUnderCollection]`.\n     * @returns {Array} Array in a form of `[row, column, dataOfAllCollections]`.\n     */\n\n  }, {\n    key: \"getBulkCollectionData\",\n    value: function getBulkCollectionData(populationArgumentsList) {\n      var _this$hot2;\n\n      var populationDataRange = this.getBulkCollectionDataRange(populationArgumentsList);\n\n      var dataAtRange = (_this$hot2 = this.hot).getData.apply(_this$hot2, _toConsumableArray(populationDataRange));\n\n      var newDataAtRange = dataAtRange.splice(0);\n      arrayEach(populationArgumentsList, function (mergedCellArguments) {\n        var _mergedCellArguments = _slicedToArray(mergedCellArguments, 3),\n            mergedCellRowIndex = _mergedCellArguments[0],\n            mergedCellColumnIndex = _mergedCellArguments[1],\n            mergedCellData = _mergedCellArguments[2];\n\n        arrayEach(mergedCellData, function (mergedCellRow, rowIndex) {\n          arrayEach(mergedCellRow, function (mergedCellElement, columnIndex) {\n            newDataAtRange[mergedCellRowIndex - populationDataRange[0] + rowIndex][mergedCellColumnIndex - populationDataRange[1] + columnIndex] = mergedCellElement; // eslint-disable-line max-len\n          });\n        });\n      });\n      return [populationDataRange[0], populationDataRange[1], newDataAtRange];\n    }\n    /**\n     * Gets the range of combined data ranges provided in a form of an array of arrays ([row, column, dataUnderCollection]).\n     *\n     * @private\n     * @param {Array} populationArgumentsList Array containing argument lists for the `populateFromArray` method - row, column and data for population.\n     * @returns {Array[]} Start and end coordinates of the merged cell range. (in a form of [rowIndex, columnIndex]).\n     */\n\n  }, {\n    key: \"getBulkCollectionDataRange\",\n    value: function getBulkCollectionDataRange(populationArgumentsList) {\n      var start = [0, 0];\n      var end = [0, 0];\n      var mergedCellRow = null;\n      var mergedCellColumn = null;\n      var mergedCellData = null;\n      arrayEach(populationArgumentsList, function (mergedCellArguments) {\n        mergedCellRow = mergedCellArguments[0];\n        mergedCellColumn = mergedCellArguments[1];\n        mergedCellData = mergedCellArguments[2];\n        start[0] = Math.min(mergedCellRow, start[0]);\n        start[1] = Math.min(mergedCellColumn, start[1]);\n        end[0] = Math.max(mergedCellRow + mergedCellData.length - 1, end[0]);\n        end[1] = Math.max(mergedCellColumn + mergedCellData[0].length - 1, end[1]);\n      });\n      return [].concat(start, end);\n    }\n    /**\n     * Clears the merged cells from the merged cell container.\n     */\n\n  }, {\n    key: \"clearCollections\",\n    value: function clearCollections() {\n      this.mergedCellsCollection.clear();\n    }\n    /**\n     * Returns `true` if a range is mergeable.\n     *\n     * @private\n     * @param {object} newMergedCellInfo Merged cell information object to test.\n     * @param {boolean} [auto=false] `true` if triggered at initialization.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"canMergeRange\",\n    value: function canMergeRange(newMergedCellInfo) {\n      var auto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return auto ? true : this.validateSetting(newMergedCellInfo);\n    }\n    /**\n     * Merge or unmerge, based on last selected range.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"toggleMergeOnSelection\",\n    value: function toggleMergeOnSelection() {\n      var currentRange = this.hot.getSelectedRangeLast();\n\n      if (!currentRange) {\n        return;\n      }\n\n      currentRange.setDirection('NW-SE');\n      var from = currentRange.from,\n          to = currentRange.to;\n      this.toggleMerge(currentRange);\n      this.hot.selectCell(from.row, from.col, to.row, to.col, false);\n    }\n    /**\n     * Merges the selection provided as a cell range.\n     *\n     * @param {CellRange} [cellRange] Selection cell range.\n     */\n\n  }, {\n    key: \"mergeSelection\",\n    value: function mergeSelection() {\n      var cellRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.hot.getSelectedRangeLast();\n\n      if (!cellRange) {\n        return;\n      }\n\n      cellRange.setDirection('NW-SE');\n      var from = cellRange.from,\n          to = cellRange.to;\n      this.unmergeRange(cellRange, true);\n      this.mergeRange(cellRange);\n      this.hot.selectCell(from.row, from.col, to.row, to.col, false);\n    }\n    /**\n     * Unmerges the selection provided as a cell range.\n     *\n     * @param {CellRange} [cellRange] Selection cell range.\n     */\n\n  }, {\n    key: \"unmergeSelection\",\n    value: function unmergeSelection() {\n      var cellRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.hot.getSelectedRangeLast();\n\n      if (!cellRange) {\n        return;\n      }\n\n      var from = cellRange.from,\n          to = cellRange.to;\n      this.unmergeRange(cellRange, true);\n      this.hot.selectCell(from.row, from.col, to.row, to.col, false);\n    }\n    /**\n     * Merges cells in the provided cell range.\n     *\n     * @private\n     * @param {CellRange} cellRange Cell range to merge.\n     * @param {boolean} [auto=false] `true` if is called automatically, e.g. At initialization.\n     * @param {boolean} [preventPopulation=false] `true`, if the method should not run `populateFromArray` at the end, but rather return its arguments.\n     * @returns {Array|boolean} Returns an array of [row, column, dataUnderCollection] if preventPopulation is set to true. If the the merging process went successful, it returns `true`, otherwise - `false`.\n     * @fires Hooks#beforeMergeCells\n     * @fires Hooks#afterMergeCells\n     */\n\n  }, {\n    key: \"mergeRange\",\n    value: function mergeRange(cellRange) {\n      var _this4 = this;\n\n      var auto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var preventPopulation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var topLeft = cellRange.getTopLeftCorner();\n      var bottomRight = cellRange.getBottomRightCorner();\n      var mergeParent = {\n        row: topLeft.row,\n        col: topLeft.col,\n        rowspan: bottomRight.row - topLeft.row + 1,\n        colspan: bottomRight.col - topLeft.col + 1\n      };\n      var clearedData = [];\n      var populationInfo = null;\n\n      if (!this.canMergeRange(mergeParent, auto)) {\n        return false;\n      }\n\n      this.hot.runHooks('beforeMergeCells', cellRange, auto);\n      rangeEach(0, mergeParent.rowspan - 1, function (i) {\n        rangeEach(0, mergeParent.colspan - 1, function (j) {\n          var clearedValue = null;\n\n          if (!clearedData[i]) {\n            clearedData[i] = [];\n          }\n\n          if (i === 0 && j === 0) {\n            clearedValue = _this4.hot.getDataAtCell(mergeParent.row, mergeParent.col);\n          } else {\n            _this4.hot.setCellMeta(mergeParent.row + i, mergeParent.col + j, 'hidden', true);\n          }\n\n          clearedData[i][j] = clearedValue;\n        });\n      });\n      this.hot.setCellMeta(mergeParent.row, mergeParent.col, 'spanned', true);\n      var mergedCellAdded = this.mergedCellsCollection.add(mergeParent);\n\n      if (mergedCellAdded) {\n        if (preventPopulation) {\n          populationInfo = [mergeParent.row, mergeParent.col, clearedData];\n        } else {\n          this.hot.populateFromArray(mergeParent.row, mergeParent.col, clearedData, void 0, void 0, this.pluginName);\n        }\n\n        this.hot.runHooks('afterMergeCells', cellRange, mergeParent, auto);\n        return populationInfo;\n      }\n\n      return true;\n    }\n    /**\n     * Unmerges the selection provided as a cell range. If no cell range is provided, it uses the current selection.\n     *\n     * @private\n     * @param {CellRange} cellRange Selection cell range.\n     * @param {boolean} [auto=false] `true` if called automatically by the plugin.\n     *\n     * @fires Hooks#beforeUnmergeCells\n     * @fires Hooks#afterUnmergeCells\n     */\n\n  }, {\n    key: \"unmergeRange\",\n    value: function unmergeRange(cellRange) {\n      var _this5 = this;\n\n      var auto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var mergedCells = this.mergedCellsCollection.getWithinRange(cellRange);\n\n      if (!mergedCells) {\n        return;\n      }\n\n      this.hot.runHooks('beforeUnmergeCells', cellRange, auto);\n      arrayEach(mergedCells, function (currentCollection) {\n        _this5.mergedCellsCollection.remove(currentCollection.row, currentCollection.col);\n\n        rangeEach(0, currentCollection.rowspan - 1, function (i) {\n          rangeEach(0, currentCollection.colspan - 1, function (j) {\n            _this5.hot.removeCellMeta(currentCollection.row + i, currentCollection.col + j, 'hidden');\n          });\n        });\n\n        _this5.hot.removeCellMeta(currentCollection.row, currentCollection.col, 'spanned');\n      });\n      this.hot.runHooks('afterUnmergeCells', cellRange, auto);\n      this.hot.render();\n    }\n    /**\n     * Merges or unmerges, based on the cell range provided as `cellRange`.\n     *\n     * @private\n     * @param {CellRange} cellRange The cell range to merge or unmerged.\n     */\n\n  }, {\n    key: \"toggleMerge\",\n    value: function toggleMerge(cellRange) {\n      var mergedCell = this.mergedCellsCollection.get(cellRange.from.row, cellRange.from.col);\n      var mergedCellCoversWholeRange = mergedCell.row === cellRange.from.row && mergedCell.col === cellRange.from.col && mergedCell.row + mergedCell.rowspan - 1 === cellRange.to.row && mergedCell.col + mergedCell.colspan - 1 === cellRange.to.col;\n\n      if (mergedCellCoversWholeRange) {\n        this.unmergeRange(cellRange);\n      } else {\n        this.mergeSelection(cellRange);\n      }\n    }\n    /**\n     * Merges the specified range.\n     *\n     * @param {number} startRow Start row of the merged cell.\n     * @param {number} startColumn Start column of the merged cell.\n     * @param {number} endRow End row of the merged cell.\n     * @param {number} endColumn End column of the merged cell.\n     * @fires Hooks#beforeMergeCells\n     * @fires Hooks#afterMergeCells\n     */\n\n  }, {\n    key: \"merge\",\n    value: function merge(startRow, startColumn, endRow, endColumn) {\n      var start = new CellCoords(startRow, startColumn);\n      var end = new CellCoords(endRow, endColumn);\n      this.mergeRange(new CellRange(start, start, end));\n    }\n    /**\n     * Unmerges the merged cell in the provided range.\n     *\n     * @param {number} startRow Start row of the merged cell.\n     * @param {number} startColumn Start column of the merged cell.\n     * @param {number} endRow End row of the merged cell.\n     * @param {number} endColumn End column of the merged cell.\n     * @fires Hooks#beforeUnmergeCells\n     * @fires Hooks#afterUnmergeCells\n     */\n\n  }, {\n    key: \"unmerge\",\n    value: function unmerge(startRow, startColumn, endRow, endColumn) {\n      var start = new CellCoords(startRow, startColumn);\n      var end = new CellCoords(endRow, endColumn);\n      this.unmergeRange(new CellRange(start, start, end));\n    }\n    /**\n     * `afterInit` hook callback.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"onAfterInit\",\n    value: function onAfterInit() {\n      this.generateFromSettings(this.hot.getSettings()[PLUGIN_KEY]);\n      this.hot.render();\n    }\n    /**\n     * `beforeKeyDown` hook callback.\n     *\n     * @private\n     * @param {KeyboardEvent} event The `keydown` event object.\n     */\n\n  }, {\n    key: \"onBeforeKeyDown\",\n    value: function onBeforeKeyDown(event) {\n      var ctrlDown = (event.ctrlKey || event.metaKey) && !event.altKey;\n\n      if (ctrlDown && event.keyCode === 77) {\n        // CTRL + M\n        this.toggleMerge(this.hot.getSelectedRangeLast());\n        this.hot.render();\n        stopImmediatePropagation(event);\n      }\n    }\n    /**\n     * Modifies the information on whether the current selection contains multiple cells. The `afterIsMultipleSelection` hook callback.\n     *\n     * @private\n     * @param {boolean} isMultiple Determines whether the current selection contains multiple cells.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"onAfterIsMultipleSelection\",\n    value: function onAfterIsMultipleSelection(isMultiple) {\n      if (isMultiple) {\n        var mergedCells = this.mergedCellsCollection.mergedCells;\n        var selectionRange = this.hot.getSelectedRangeLast();\n\n        for (var group = 0; group < mergedCells.length; group += 1) {\n          if (selectionRange.from.row === mergedCells[group].row && selectionRange.from.col === mergedCells[group].col && selectionRange.to.row === mergedCells[group].row + mergedCells[group].rowspan - 1 && selectionRange.to.col === mergedCells[group].col + mergedCells[group].colspan - 1) {\n            return false;\n          }\n        }\n      }\n\n      return isMultiple;\n    }\n    /**\n     * `modifyTransformStart` hook callback.\n     *\n     * @private\n     * @param {object} delta The transformation delta.\n     */\n\n  }, {\n    key: \"onModifyTransformStart\",\n    value: function onModifyTransformStart(delta) {\n      var priv = privatePool.get(this);\n      var currentlySelectedRange = this.hot.getSelectedRangeLast();\n      var newDelta = {\n        row: delta.row,\n        col: delta.col\n      };\n      var nextPosition = null;\n      var currentPosition = new CellCoords(currentlySelectedRange.highlight.row, currentlySelectedRange.highlight.col);\n      var mergedParent = this.mergedCellsCollection.get(currentPosition.row, currentPosition.col);\n\n      if (!priv.lastDesiredCoords) {\n        priv.lastDesiredCoords = new CellCoords(null, null);\n      }\n\n      if (mergedParent) {\n        // only merge selected\n        var mergeTopLeft = new CellCoords(mergedParent.row, mergedParent.col);\n        var mergeBottomRight = new CellCoords(mergedParent.row + mergedParent.rowspan - 1, mergedParent.col + mergedParent.colspan - 1);\n        var mergeRange = new CellRange(mergeTopLeft, mergeTopLeft, mergeBottomRight);\n\n        if (!mergeRange.includes(priv.lastDesiredCoords)) {\n          priv.lastDesiredCoords = new CellCoords(null, null); // reset outdated version of lastDesiredCoords\n        }\n\n        newDelta.row = priv.lastDesiredCoords.row ? priv.lastDesiredCoords.row - currentPosition.row : newDelta.row;\n        newDelta.col = priv.lastDesiredCoords.col ? priv.lastDesiredCoords.col - currentPosition.col : newDelta.col;\n\n        if (delta.row > 0) {\n          // moving down\n          newDelta.row = mergedParent.row + mergedParent.rowspan - 1 - currentPosition.row + delta.row;\n        } else if (delta.row < 0) {\n          // moving up\n          newDelta.row = currentPosition.row - mergedParent.row + delta.row;\n        }\n\n        if (delta.col > 0) {\n          // moving right\n          newDelta.col = mergedParent.col + mergedParent.colspan - 1 - currentPosition.col + delta.col;\n        } else if (delta.col < 0) {\n          // moving left\n          newDelta.col = currentPosition.col - mergedParent.col + delta.col;\n        }\n      }\n\n      nextPosition = new CellCoords(currentlySelectedRange.highlight.row + newDelta.row, currentlySelectedRange.highlight.col + newDelta.col);\n      var nextPositionMergedCell = this.mergedCellsCollection.get(nextPosition.row, nextPosition.col);\n\n      if (nextPositionMergedCell) {\n        // skipping the invisible cells in the merge range\n        var firstRenderableCoords = this.mergedCellsCollection.getFirstRenderableCoords(nextPositionMergedCell.row, nextPositionMergedCell.col);\n        priv.lastDesiredCoords = nextPosition;\n        newDelta = {\n          row: firstRenderableCoords.row - currentPosition.row,\n          col: firstRenderableCoords.col - currentPosition.col\n        };\n      }\n\n      if (newDelta.row !== 0) {\n        delta.row = newDelta.row;\n      }\n\n      if (newDelta.col !== 0) {\n        delta.col = newDelta.col;\n      }\n    }\n    /**\n     * `modifyTransformEnd` hook callback. Needed to handle \"jumping over\" merged merged cells, while selecting.\n     *\n     * @private\n     * @param {object} delta The transformation delta.\n     */\n\n  }, {\n    key: \"onModifyTransformEnd\",\n    value: function onModifyTransformEnd(delta) {\n      var _this6 = this;\n\n      var currentSelectionRange = this.hot.getSelectedRangeLast();\n      var newDelta = clone(delta);\n      var newSelectionRange = this.selectionCalculations.getUpdatedSelectionRange(currentSelectionRange, delta);\n      var tempDelta = clone(newDelta);\n      var mergedCellsWithinRange = this.mergedCellsCollection.getWithinRange(newSelectionRange, true);\n\n      do {\n        tempDelta = clone(newDelta);\n        this.selectionCalculations.getUpdatedSelectionRange(currentSelectionRange, newDelta);\n        arrayEach(mergedCellsWithinRange, function (mergedCell) {\n          _this6.selectionCalculations.snapDelta(newDelta, currentSelectionRange, mergedCell);\n        });\n      } while (newDelta.row !== tempDelta.row || newDelta.col !== tempDelta.col);\n\n      delta.row = newDelta.row;\n      delta.col = newDelta.col;\n    }\n    /**\n     * `modifyGetCellCoords` hook callback. Swaps the `getCell` coords with the merged parent coords.\n     *\n     * @private\n     * @param {number} row Row index.\n     * @param {number} column Visual column index.\n     * @returns {Array|undefined} Visual coordinates of the merge.\n     */\n\n  }, {\n    key: \"onModifyGetCellCoords\",\n    value: function onModifyGetCellCoords(row, column) {\n      if (row < 0 || column < 0) {\n        return;\n      }\n\n      var mergeParent = this.mergedCellsCollection.get(row, column);\n\n      if (!mergeParent) {\n        return;\n      }\n\n      var mergeRow = mergeParent.row,\n          mergeColumn = mergeParent.col,\n          colspan = mergeParent.colspan,\n          rowspan = mergeParent.rowspan;\n      return [// Most top-left merged cell coords.\n      mergeRow, mergeColumn, // Most bottom-right merged cell coords.\n      mergeRow + rowspan - 1, mergeColumn + colspan - 1];\n    }\n    /**\n     * `afterContextMenuDefaultOptions` hook callback.\n     *\n     * @private\n     * @param {object} defaultOptions The default context menu options.\n     */\n\n  }, {\n    key: \"addMergeActionsToContextMenu\",\n    value: function addMergeActionsToContextMenu(defaultOptions) {\n      defaultOptions.items.push({\n        name: '---------'\n      }, toggleMergeItem(this));\n    }\n    /**\n     * `afterRenderer` hook callback.\n     *\n     * @private\n     * @param {HTMLElement} TD The cell to be modified.\n     * @param {number} row Row index.\n     * @param {number} col Visual column index.\n     */\n\n  }, {\n    key: \"onAfterRenderer\",\n    value: function onAfterRenderer(TD, row, col) {\n      var mergedCell = this.mergedCellsCollection.get(row, col); // We shouldn't override data in the collection.\n\n      var mergedCellCopy = isObject(mergedCell) ? clone(mergedCell) : void 0;\n\n      if (isObject(mergedCellCopy)) {\n        var _this$hot3 = this.hot,\n            rowMapper = _this$hot3.rowIndexMapper,\n            columnMapper = _this$hot3.columnIndexMapper;\n        var mergeRow = mergedCellCopy.row,\n            mergeColumn = mergedCellCopy.col,\n            colspan = mergedCellCopy.colspan,\n            rowspan = mergedCellCopy.rowspan;\n\n        var _this$translateMerged = this.translateMergedCellToRenderable(mergeRow, rowspan, mergeColumn, colspan),\n            _this$translateMerged2 = _slicedToArray(_this$translateMerged, 2),\n            lastMergedRowIndex = _this$translateMerged2[0],\n            lastMergedColumnIndex = _this$translateMerged2[1];\n\n        var renderedRowIndex = rowMapper.getRenderableFromVisualIndex(row);\n        var renderedColumnIndex = columnMapper.getRenderableFromVisualIndex(col);\n        var maxRowSpan = lastMergedRowIndex - renderedRowIndex + 1; // Number of rendered columns.\n\n        var maxColSpan = lastMergedColumnIndex - renderedColumnIndex + 1; // Number of rendered columns.\n        // We just try to determine some values basing on the actual number of rendered indexes (some columns may be hidden).\n\n        mergedCellCopy.row = rowMapper.getFirstNotHiddenIndex(mergedCellCopy.row, 1); // We just try to determine some values basing on the actual number of rendered indexes (some columns may be hidden).\n\n        mergedCellCopy.col = columnMapper.getFirstNotHiddenIndex(mergedCellCopy.col, 1); // The `rowSpan` property for a `TD` element should be at most equal to number of rendered rows in the merge area.\n\n        mergedCellCopy.rowspan = Math.min(mergedCellCopy.rowspan, maxRowSpan); // The `colSpan` property for a `TD` element should be at most equal to number of rendered columns in the merge area.\n\n        mergedCellCopy.colspan = Math.min(mergedCellCopy.colspan, maxColSpan);\n      }\n\n      applySpanProperties(TD, mergedCellCopy, row, col);\n    }\n    /**\n     * `beforeSetRangeStart` and `beforeSetRangeStartOnly` hook callback.\n     * A selection within merge area should be rewritten to the start of merge area.\n     *\n     * @private\n     * @param {object} coords Cell coords.\n     */\n\n  }, {\n    key: \"onBeforeSetRangeStart\",\n    value: function onBeforeSetRangeStart(coords) {\n      // TODO: It is a workaround, but probably this hook may be needed. Every selection on the merge area\n      // could set start point of the selection to the start of the merge area. However, logic inside `expandByRange` need\n      // an initial start point. Click on the merge cell when there are some hidden indexes break the logic in some cases.\n      // Please take a look at #7010 for more information. I'm not sure if selection directions are calculated properly\n      // and what was idea for flipping direction inside `expandByRange` method.\n      if (this.mergedCellsCollection.isFirstRenderableMergedCell(coords.row, coords.col)) {\n        var mergeParent = this.mergedCellsCollection.get(coords.row, coords.col);\n        var _ref = [mergeParent.row, mergeParent.col];\n        coords.row = _ref[0];\n        coords.col = _ref[1];\n      }\n    }\n    /**\n     * `beforeSetRangeEnd` hook callback.\n     * While selecting cells with keyboard or mouse, make sure that rectangular area is expanded to the extent of the merged cell.\n     *\n     * Note: Please keep in mind that callback may modify both start and end range coordinates by the reference.\n     *\n     * @private\n     * @param {object} coords Cell coords.\n     */\n\n  }, {\n    key: \"onBeforeSetRangeEnd\",\n    value: function onBeforeSetRangeEnd(coords) {\n      var selRange = this.hot.getSelectedRangeLast();\n      selRange.highlight = new CellCoords(selRange.highlight.row, selRange.highlight.col); // clone in case we will modify its reference\n\n      selRange.to = coords;\n      var rangeExpanded = false;\n\n      if (this.hot.selection.isSelectedByColumnHeader() || this.hot.selection.isSelectedByRowHeader()) {\n        return;\n      }\n\n      do {\n        rangeExpanded = false;\n\n        for (var i = 0; i < this.mergedCellsCollection.mergedCells.length; i += 1) {\n          var cellInfo = this.mergedCellsCollection.mergedCells[i];\n          var mergedCellRange = cellInfo.getRange();\n\n          if (selRange.expandByRange(mergedCellRange)) {\n            coords.row = selRange.to.row;\n            coords.col = selRange.to.col;\n            rangeExpanded = true;\n          }\n        }\n      } while (rangeExpanded);\n    }\n    /**\n     * The `afterGetCellMeta` hook callback.\n     *\n     * @private\n     * @param {number} row Row index.\n     * @param {number} col Column index.\n     * @param {object} cellProperties The cell properties object.\n     */\n\n  }, {\n    key: \"onAfterGetCellMeta\",\n    value: function onAfterGetCellMeta(row, col, cellProperties) {\n      var mergeParent = this.mergedCellsCollection.get(row, col);\n\n      if (mergeParent) {\n        if (mergeParent.row !== row || mergeParent.col !== col) {\n          cellProperties.copyable = false;\n        } else {\n          cellProperties.rowspan = mergeParent.rowspan;\n          cellProperties.colspan = mergeParent.colspan;\n        }\n      }\n    }\n    /**\n     * `afterViewportRowCalculatorOverride` hook callback.\n     *\n     * @private\n     * @param {object} calc The row calculator object.\n     */\n\n  }, {\n    key: \"onAfterViewportRowCalculatorOverride\",\n    value: function onAfterViewportRowCalculatorOverride(calc) {\n      var nrOfColumns = this.hot.countCols();\n      this.modifyViewportRowStart(calc, nrOfColumns);\n      this.modifyViewportRowEnd(calc, nrOfColumns);\n    }\n    /**\n     * Modify viewport start when needed. We extend viewport when merged cells aren't fully visible.\n     *\n     * @private\n     * @param {object} calc The row calculator object.\n     * @param {number} nrOfColumns Number of visual columns.\n     */\n\n  }, {\n    key: \"modifyViewportRowStart\",\n    value: function modifyViewportRowStart(calc, nrOfColumns) {\n      var rowMapper = this.hot.rowIndexMapper;\n      var visualStartRow = rowMapper.getVisualFromRenderableIndex(calc.startRow);\n\n      for (var visualColumnIndex = 0; visualColumnIndex < nrOfColumns; visualColumnIndex += 1) {\n        var mergeParentForViewportStart = this.mergedCellsCollection.get(visualStartRow, visualColumnIndex);\n\n        if (isObject(mergeParentForViewportStart)) {\n          var renderableIndexAtMergeStart = rowMapper.getRenderableFromVisualIndex(rowMapper.getFirstNotHiddenIndex(mergeParentForViewportStart.row, 1)); // Merge start is out of the viewport (i.e. when we scrolled to the bottom and we can see just part of a merge).\n\n          if (renderableIndexAtMergeStart < calc.startRow) {\n            // We extend viewport when some rows have been merged.\n            calc.startRow = renderableIndexAtMergeStart; // We are looking for next merges inside already extended viewport (starting again from row equal to 0).\n\n            this.modifyViewportRowStart(calc, nrOfColumns); // recursively search upwards\n\n            return; // Finish the current loop. Everything will be checked from the beginning by above recursion.\n          }\n        }\n      }\n    }\n    /**\n     *  Modify viewport end when needed. We extend viewport when merged cells aren't fully visible.\n     *\n     * @private\n     * @param {object} calc The row calculator object.\n     * @param {number} nrOfColumns Number of visual columns.\n     */\n\n  }, {\n    key: \"modifyViewportRowEnd\",\n    value: function modifyViewportRowEnd(calc, nrOfColumns) {\n      var rowMapper = this.hot.rowIndexMapper;\n      var visualEndRow = rowMapper.getVisualFromRenderableIndex(calc.endRow);\n\n      for (var visualColumnIndex = 0; visualColumnIndex < nrOfColumns; visualColumnIndex += 1) {\n        var mergeParentForViewportEnd = this.mergedCellsCollection.get(visualEndRow, visualColumnIndex);\n\n        if (isObject(mergeParentForViewportEnd)) {\n          var mergeEnd = mergeParentForViewportEnd.row + mergeParentForViewportEnd.rowspan - 1;\n          var renderableIndexAtMergeEnd = rowMapper.getRenderableFromVisualIndex(rowMapper.getFirstNotHiddenIndex(mergeEnd, -1)); // Merge end is out of the viewport.\n\n          if (renderableIndexAtMergeEnd > calc.endRow) {\n            // We extend the viewport when some rows have been merged.\n            calc.endRow = renderableIndexAtMergeEnd; // We are looking for next merges inside already extended viewport (starting again from row equal to 0).\n\n            this.modifyViewportRowEnd(calc, nrOfColumns); // recursively search upwards\n\n            return; // Finish the current loop. Everything will be checked from the beginning by above recursion.\n          }\n        }\n      }\n    }\n    /**\n     * `afterViewportColumnCalculatorOverride` hook callback.\n     *\n     * @private\n     * @param {object} calc The column calculator object.\n     */\n\n  }, {\n    key: \"onAfterViewportColumnCalculatorOverride\",\n    value: function onAfterViewportColumnCalculatorOverride(calc) {\n      var nrOfRows = this.hot.countRows();\n      this.modifyViewportColumnStart(calc, nrOfRows);\n      this.modifyViewportColumnEnd(calc, nrOfRows);\n    }\n    /**\n     * Modify viewport start when needed. We extend viewport when merged cells aren't fully visible.\n     *\n     * @private\n     * @param {object} calc The column calculator object.\n     * @param {number} nrOfRows Number of visual rows.\n     */\n\n  }, {\n    key: \"modifyViewportColumnStart\",\n    value: function modifyViewportColumnStart(calc, nrOfRows) {\n      var columnMapper = this.hot.columnIndexMapper;\n      var visualStartCol = columnMapper.getVisualFromRenderableIndex(calc.startColumn);\n\n      for (var visualRowIndex = 0; visualRowIndex < nrOfRows; visualRowIndex += 1) {\n        var mergeParentForViewportStart = this.mergedCellsCollection.get(visualRowIndex, visualStartCol);\n\n        if (isObject(mergeParentForViewportStart)) {\n          var renderableIndexAtMergeStart = columnMapper.getRenderableFromVisualIndex(columnMapper.getFirstNotHiddenIndex(mergeParentForViewportStart.col, 1)); // Merge start is out of the viewport (i.e. when we scrolled to the right and we can see just part of a merge).\n\n          if (renderableIndexAtMergeStart < calc.startColumn) {\n            // We extend viewport when some columns have been merged.\n            calc.startColumn = renderableIndexAtMergeStart; // We are looking for next merges inside already extended viewport (starting again from column equal to 0).\n\n            this.modifyViewportColumnStart(calc, nrOfRows); // recursively search upwards\n\n            return; // Finish the current loop. Everything will be checked from the beginning by above recursion.\n          }\n        }\n      }\n    }\n    /**\n     *  Modify viewport end when needed. We extend viewport when merged cells aren't fully visible.\n     *\n     * @private\n     * @param {object} calc The column calculator object.\n     * @param {number} nrOfRows Number of visual rows.\n     */\n\n  }, {\n    key: \"modifyViewportColumnEnd\",\n    value: function modifyViewportColumnEnd(calc, nrOfRows) {\n      var columnMapper = this.hot.columnIndexMapper;\n      var visualEndCol = columnMapper.getVisualFromRenderableIndex(calc.endColumn);\n\n      for (var visualRowIndex = 0; visualRowIndex < nrOfRows; visualRowIndex += 1) {\n        var mergeParentForViewportEnd = this.mergedCellsCollection.get(visualRowIndex, visualEndCol);\n\n        if (isObject(mergeParentForViewportEnd)) {\n          var mergeEnd = mergeParentForViewportEnd.col + mergeParentForViewportEnd.colspan - 1;\n          var renderableIndexAtMergeEnd = columnMapper.getRenderableFromVisualIndex(columnMapper.getFirstNotHiddenIndex(mergeEnd, -1)); // Merge end is out of the viewport.\n\n          if (renderableIndexAtMergeEnd > calc.endColumn) {\n            // We extend the viewport when some columns have been merged.\n            calc.endColumn = renderableIndexAtMergeEnd; // We are looking for next merges inside already extended viewport (starting again from column equal to 0).\n\n            this.modifyViewportColumnEnd(calc, nrOfRows); // recursively search upwards\n\n            return; // Finish the current loop. Everything will be checked from the beginning by above recursion.\n          }\n        }\n      }\n    }\n    /**\n     * Translates merged cell coordinates to renderable indexes.\n     *\n     * @private\n     * @param {number} parentRow Visual row index.\n     * @param {number} rowspan Rowspan which describes shift which will be applied to parent row\n     *                         to calculate renderable index which points to the most bottom\n     *                         index position. Pass rowspan as `0` to calculate the most top\n     *                         index position.\n     * @param {number} parentColumn Visual column index.\n     * @param {number} colspan Colspan which describes shift which will be applied to parent column\n     *                         to calculate renderable index which points to the most right\n     *                         index position. Pass colspan as `0` to calculate the most left\n     *                         index position.\n     * @returns {number[]}\n     */\n\n  }, {\n    key: \"translateMergedCellToRenderable\",\n    value: function translateMergedCellToRenderable(parentRow, rowspan, parentColumn, colspan) {\n      var _this$hot4 = this.hot,\n          rowMapper = _this$hot4.rowIndexMapper,\n          columnMapper = _this$hot4.columnIndexMapper;\n      var firstNonHiddenRow;\n      var firstNonHiddenColumn;\n\n      if (rowspan === 0) {\n        firstNonHiddenRow = rowMapper.getFirstNotHiddenIndex(parentRow, 1);\n      } else {\n        firstNonHiddenRow = rowMapper.getFirstNotHiddenIndex(parentRow + rowspan - 1, -1);\n      }\n\n      if (colspan === 0) {\n        firstNonHiddenColumn = columnMapper.getFirstNotHiddenIndex(parentColumn, 1);\n      } else {\n        firstNonHiddenColumn = columnMapper.getFirstNotHiddenIndex(parentColumn + colspan - 1, -1);\n      }\n\n      var renderableRow = parentRow >= 0 ? rowMapper.getRenderableFromVisualIndex(firstNonHiddenRow) : parentRow;\n      var renderableColumn = parentColumn >= 0 ? columnMapper.getRenderableFromVisualIndex(firstNonHiddenColumn) : parentColumn;\n      return [renderableRow, renderableColumn];\n    }\n    /**\n     * The `modifyAutofillRange` hook callback.\n     *\n     * @private\n     * @param {Array} drag The drag area coordinates.\n     * @param {Array} select The selection information.\n     * @returns {Array} The new drag area.\n     */\n\n  }, {\n    key: \"onModifyAutofillRange\",\n    value: function onModifyAutofillRange(drag, select) {\n      this.autofillCalculations.correctSelectionAreaSize(select);\n      var dragDirection = this.autofillCalculations.getDirection(select, drag);\n      var dragArea = drag;\n\n      if (this.autofillCalculations.dragAreaOverlapsCollections(select, dragArea, dragDirection)) {\n        dragArea = select;\n        return dragArea;\n      }\n\n      var mergedCellsWithinSelectionArea = this.mergedCellsCollection.getWithinRange({\n        from: {\n          row: select[0],\n          col: select[1]\n        },\n        to: {\n          row: select[2],\n          col: select[3]\n        }\n      });\n\n      if (!mergedCellsWithinSelectionArea) {\n        return dragArea;\n      }\n\n      dragArea = this.autofillCalculations.snapDragArea(select, dragArea, dragDirection, mergedCellsWithinSelectionArea);\n      return dragArea;\n    }\n    /**\n     * `afterCreateCol` hook callback.\n     *\n     * @private\n     * @param {number} column Column index.\n     * @param {number} count Number of created columns.\n     */\n\n  }, {\n    key: \"onAfterCreateCol\",\n    value: function onAfterCreateCol(column, count) {\n      this.mergedCellsCollection.shiftCollections('right', column, count);\n    }\n    /**\n     * `afterRemoveCol` hook callback.\n     *\n     * @private\n     * @param {number} column Column index.\n     * @param {number} count Number of removed columns.\n     */\n\n  }, {\n    key: \"onAfterRemoveCol\",\n    value: function onAfterRemoveCol(column, count) {\n      this.mergedCellsCollection.shiftCollections('left', column, count);\n    }\n    /**\n     * `afterCreateRow` hook callback.\n     *\n     * @private\n     * @param {number} row Row index.\n     * @param {number} count Number of created rows.\n     * @param {string} source Source of change.\n     */\n\n  }, {\n    key: \"onAfterCreateRow\",\n    value: function onAfterCreateRow(row, count, source) {\n      if (source === 'auto') {\n        return;\n      }\n\n      this.mergedCellsCollection.shiftCollections('down', row, count);\n    }\n    /**\n     * `afterRemoveRow` hook callback.\n     *\n     * @private\n     * @param {number} row Row index.\n     * @param {number} count Number of removed rows.\n     */\n\n  }, {\n    key: \"onAfterRemoveRow\",\n    value: function onAfterRemoveRow(row, count) {\n      this.mergedCellsCollection.shiftCollections('up', row, count);\n    }\n    /**\n     * `afterChange` hook callback. Used to propagate merged cells after using Autofill.\n     *\n     * @private\n     * @param {Array} changes The changes array.\n     * @param {string} source Determines the source of the change.\n     */\n\n  }, {\n    key: \"onAfterChange\",\n    value: function onAfterChange(changes, source) {\n      if (source !== 'Autofill.fill') {\n        return;\n      }\n\n      this.autofillCalculations.recreateAfterDataPopulation(changes);\n    }\n    /**\n     * `beforeDrawAreaBorders` hook callback.\n     *\n     * @private\n     * @param {Array} corners Visual coordinates of the area corners.\n     * @param {string} className Class name for the area.\n     */\n\n  }, {\n    key: \"onBeforeDrawAreaBorders\",\n    value: function onBeforeDrawAreaBorders(corners, className) {\n      if (className && className === 'area') {\n        var selectedRange = this.hot.getSelectedRangeLast();\n        var mergedCellsWithinRange = this.mergedCellsCollection.getWithinRange(selectedRange);\n        arrayEach(mergedCellsWithinRange, function (mergedCell) {\n          if (selectedRange.getBottomRightCorner().row === mergedCell.getLastRow() && selectedRange.getBottomRightCorner().col === mergedCell.getLastColumn()) {\n            corners[2] = mergedCell.row;\n            corners[3] = mergedCell.col;\n          }\n        });\n      }\n    }\n    /**\n     * `afterModifyTransformStart` hook callback. Fixes a problem with navigating through merged cells at the edges of the table\n     * with the ENTER/SHIFT+ENTER/TAB/SHIFT+TAB keys.\n     *\n     * @private\n     * @param {CellCoords} coords Coordinates of the to-be-selected cell.\n     * @param {number} rowTransformDir Row transformation direction (negative value = up, 0 = none, positive value = down).\n     * @param {number} colTransformDir Column transformation direction (negative value = up, 0 = none, positive value = down).\n     */\n\n  }, {\n    key: \"onAfterModifyTransformStart\",\n    value: function onAfterModifyTransformStart(coords, rowTransformDir, colTransformDir) {\n      if (!this.enabled) {\n        return;\n      }\n\n      var mergedCellAtCoords = this.mergedCellsCollection.get(coords.row, coords.col);\n\n      if (!mergedCellAtCoords) {\n        return;\n      }\n\n      var goingDown = rowTransformDir > 0;\n      var goingUp = rowTransformDir < 0;\n      var goingLeft = colTransformDir < 0;\n      var goingRight = colTransformDir > 0;\n      var mergedCellOnBottomEdge = mergedCellAtCoords.row + mergedCellAtCoords.rowspan - 1 === this.hot.countRows() - 1;\n      var mergedCellOnTopEdge = mergedCellAtCoords.row === 0;\n      var mergedCellOnRightEdge = mergedCellAtCoords.col + mergedCellAtCoords.colspan - 1 === this.hot.countCols() - 1;\n      var mergedCellOnLeftEdge = mergedCellAtCoords.col === 0;\n\n      if (goingDown && mergedCellOnBottomEdge || goingUp && mergedCellOnTopEdge || goingRight && mergedCellOnRightEdge || goingLeft && mergedCellOnLeftEdge) {\n        coords.row = mergedCellAtCoords.row;\n        coords.col = mergedCellAtCoords.col;\n      }\n    }\n    /**\n     * `afterDrawSelection` hook callback. Used to add the additional class name for the entirely-selected merged cells.\n     *\n     * @private\n     * @param {number} currentRow Visual row index of the currently processed cell.\n     * @param {number} currentColumn Visual column index of the currently cell.\n     * @param {Array} cornersOfSelection Array of the current selection in a form of `[startRow, startColumn, endRow, endColumn]`.\n     * @param {number|undefined} layerLevel Number indicating which layer of selection is currently processed.\n     * @returns {string|undefined} A `String`, which will act as an additional `className` to be added to the currently processed cell.\n     */\n\n  }, {\n    key: \"onAfterDrawSelection\",\n    value: function onAfterDrawSelection(currentRow, currentColumn, cornersOfSelection, layerLevel) {\n      // Nothing's selected (hook might be triggered by the custom borders)\n      if (!cornersOfSelection) {\n        return;\n      }\n\n      return this.selectionCalculations.getSelectedMergedCellClassName(currentRow, currentColumn, cornersOfSelection, layerLevel);\n    }\n    /**\n     * `beforeRemoveCellClassNames` hook callback. Used to remove additional class name from all cells in the table.\n     *\n     * @private\n     * @returns {string[]} An `Array` of `String`s. Each of these strings will act like class names to be removed from all the cells in the table.\n     */\n\n  }, {\n    key: \"onBeforeRemoveCellClassNames\",\n    value: function onBeforeRemoveCellClassNames() {\n      return this.selectionCalculations.getSelectedMergedCellClassNameToRemove();\n    }\n  }], [{\n    key: \"PLUGIN_KEY\",\n    get: function get() {\n      return PLUGIN_KEY;\n    }\n  }, {\n    key: \"PLUGIN_PRIORITY\",\n    get: function get() {\n      return PLUGIN_PRIORITY;\n    }\n  }]);\n\n  return MergeCells;\n}(BasePlugin);"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}