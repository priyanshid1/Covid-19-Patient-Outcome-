{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nimport { getScrollbarWidth, getStyle, offset, outerHeight, outerWidth } from \"./../../../helpers/dom/element.mjs\";\nimport { objectEach } from \"./../../../helpers/object.mjs\";\nimport EventManager from \"./../../../eventManager.mjs\";\nimport { RENDER_TYPE, FULLY_VISIBLE_TYPE, ViewportColumnsCalculator, ViewportRowsCalculator } from \"./calculator/index.mjs\";\n/**\n * @class Viewport\n */\n\nvar Viewport = /*#__PURE__*/function () {\n  /**\n   * @param {Walkontable} wotInstance The Walkontable instance.\n   */\n  function Viewport(wotInstance) {\n    var _this = this;\n    _classCallCheck(this, Viewport);\n    this.wot = wotInstance; // legacy support\n\n    this.instance = this.wot;\n    this.oversizedRows = [];\n    this.oversizedColumnHeaders = [];\n    this.hasOversizedColumnHeadersMarked = {};\n    this.clientHeight = 0;\n    this.containerWidth = NaN;\n    this.rowHeaderWidth = NaN;\n    this.rowsVisibleCalculator = null;\n    this.columnsVisibleCalculator = null;\n    this.eventManager = new EventManager(this.wot);\n    this.eventManager.addEventListener(this.wot.rootWindow, 'resize', function () {\n      _this.clientHeight = _this.getWorkspaceHeight();\n    });\n  }\n  /**\n   * @returns {number}\n   */\n\n  _createClass(Viewport, [{\n    key: \"getWorkspaceHeight\",\n    value: function getWorkspaceHeight() {\n      var currentDocument = this.wot.rootDocument;\n      var trimmingContainer = this.instance.wtOverlays.topOverlay.trimmingContainer;\n      var height = 0;\n      if (trimmingContainer === this.wot.rootWindow) {\n        height = currentDocument.documentElement.clientHeight;\n      } else {\n        var elemHeight = outerHeight(trimmingContainer); // returns height without DIV scrollbar\n\n        height = elemHeight > 0 && trimmingContainer.clientHeight > 0 ? trimmingContainer.clientHeight : Infinity;\n      }\n      return height;\n    }\n  }, {\n    key: \"getWorkspaceWidth\",\n    value: function getWorkspaceWidth() {\n      var wot = this.wot;\n      var rootDocument = wot.rootDocument,\n        rootWindow = wot.rootWindow;\n      var trimmingContainer = this.instance.wtOverlays.leftOverlay.trimmingContainer;\n      var docOffsetWidth = rootDocument.documentElement.offsetWidth;\n      var totalColumns = wot.getSetting('totalColumns');\n      var preventOverflow = wot.getSetting('preventOverflow');\n      var width;\n      var overflow;\n      if (preventOverflow) {\n        return outerWidth(this.instance.wtTable.wtRootElement);\n      }\n      if (wot.getSetting('freezeOverlays')) {\n        width = Math.min(docOffsetWidth - this.getWorkspaceOffset().left, docOffsetWidth);\n      } else {\n        width = Math.min(this.getContainerFillWidth(), docOffsetWidth - this.getWorkspaceOffset().left, docOffsetWidth);\n      }\n      if (trimmingContainer === rootWindow && totalColumns > 0 && this.sumColumnWidths(0, totalColumns - 1) > width) {\n        // in case sum of column widths is higher than available stylesheet width, let's assume using the whole window\n        // otherwise continue below, which will allow stretching\n        // this is used in `scroll_window.html`\n        // TODO test me\n        return rootDocument.documentElement.clientWidth;\n      }\n      if (trimmingContainer !== rootWindow) {\n        overflow = getStyle(this.instance.wtOverlays.leftOverlay.trimmingContainer, 'overflow', rootWindow);\n        if (overflow === 'scroll' || overflow === 'hidden' || overflow === 'auto') {\n          // this is used in `scroll.html`\n          // TODO test me\n          return Math.max(width, trimmingContainer.clientWidth);\n        }\n      }\n      var stretchSetting = wot.getSetting('stretchH');\n      if (stretchSetting === 'none' || !stretchSetting) {\n        // if no stretching is used, return the maximum used workspace width\n        return Math.max(width, outerWidth(this.instance.wtTable.TABLE));\n      } // if stretching is used, return the actual container width, so the columns can fit inside it\n\n      return width;\n    }\n    /**\n     * Checks if viewport has vertical scroll.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"hasVerticalScroll\",\n    value: function hasVerticalScroll() {\n      return this.getWorkspaceActualHeight() > this.getWorkspaceHeight();\n    }\n    /**\n     * Checks if viewport has horizontal scroll.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"hasHorizontalScroll\",\n    value: function hasHorizontalScroll() {\n      return this.getWorkspaceActualWidth() > this.getWorkspaceWidth();\n    }\n    /**\n     * @param {number} from The visual column index from the width sum is start calculated.\n     * @param {number} length The length of the column to traverse.\n     * @returns {number}\n     */\n  }, {\n    key: \"sumColumnWidths\",\n    value: function sumColumnWidths(from, length) {\n      var wtTable = this.wot.wtTable;\n      var sum = 0;\n      var column = from;\n      while (column < length) {\n        sum += wtTable.getColumnWidth(column);\n        column += 1;\n      }\n      return sum;\n    }\n    /**\n     * @returns {number}\n     */\n  }, {\n    key: \"getContainerFillWidth\",\n    value: function getContainerFillWidth() {\n      if (this.containerWidth) {\n        return this.containerWidth;\n      }\n      var mainContainer = this.instance.wtTable.holder;\n      var dummyElement = this.wot.rootDocument.createElement('div');\n      dummyElement.style.width = '100%';\n      dummyElement.style.height = '1px';\n      mainContainer.appendChild(dummyElement);\n      var fillWidth = dummyElement.offsetWidth;\n      this.containerWidth = fillWidth;\n      mainContainer.removeChild(dummyElement);\n      return fillWidth;\n    }\n    /**\n     * @returns {number}\n     */\n  }, {\n    key: \"getWorkspaceOffset\",\n    value: function getWorkspaceOffset() {\n      return offset(this.wot.wtTable.TABLE);\n    }\n    /**\n     * @returns {number}\n     */\n  }, {\n    key: \"getWorkspaceActualHeight\",\n    value: function getWorkspaceActualHeight() {\n      return outerHeight(this.wot.wtTable.TABLE);\n    }\n    /**\n     * @returns {number}\n     */\n  }, {\n    key: \"getWorkspaceActualWidth\",\n    value: function getWorkspaceActualWidth() {\n      var wtTable = this.wot.wtTable;\n      return outerWidth(wtTable.TABLE) || outerWidth(wtTable.TBODY) || outerWidth(wtTable.THEAD); // IE8 reports 0 as <table> offsetWidth;\n    }\n    /**\n     * @returns {number}\n     */\n  }, {\n    key: \"getColumnHeaderHeight\",\n    value: function getColumnHeaderHeight() {\n      var columnHeaders = this.instance.getSetting('columnHeaders');\n      if (!columnHeaders.length) {\n        this.columnHeaderHeight = 0;\n      } else if (isNaN(this.columnHeaderHeight)) {\n        this.columnHeaderHeight = outerHeight(this.wot.wtTable.THEAD);\n      }\n      return this.columnHeaderHeight;\n    }\n    /**\n     * @returns {number}\n     */\n  }, {\n    key: \"getViewportHeight\",\n    value: function getViewportHeight() {\n      var containerHeight = this.getWorkspaceHeight();\n      if (containerHeight === Infinity) {\n        return containerHeight;\n      }\n      var columnHeaderHeight = this.getColumnHeaderHeight();\n      if (columnHeaderHeight > 0) {\n        containerHeight -= columnHeaderHeight;\n      }\n      return containerHeight;\n    }\n    /**\n     * @returns {number}\n     */\n  }, {\n    key: \"getRowHeaderWidth\",\n    value: function getRowHeaderWidth() {\n      var rowHeadersWidthSetting = this.instance.getSetting('rowHeaderWidth');\n      var rowHeaders = this.instance.getSetting('rowHeaders');\n      if (rowHeadersWidthSetting) {\n        this.rowHeaderWidth = 0;\n        for (var i = 0, len = rowHeaders.length; i < len; i++) {\n          this.rowHeaderWidth += rowHeadersWidthSetting[i] || rowHeadersWidthSetting;\n        }\n      }\n      if (this.wot.cloneSource) {\n        return this.wot.cloneSource.wtViewport.getRowHeaderWidth();\n      }\n      if (isNaN(this.rowHeaderWidth)) {\n        if (rowHeaders.length) {\n          var TH = this.instance.wtTable.TABLE.querySelector('TH');\n          this.rowHeaderWidth = 0;\n          for (var _i = 0, _len = rowHeaders.length; _i < _len; _i++) {\n            if (TH) {\n              this.rowHeaderWidth += outerWidth(TH);\n              TH = TH.nextSibling;\n            } else {\n              // yes this is a cheat but it worked like that before, just taking assumption from CSS instead of measuring.\n              // TODO: proper fix\n              this.rowHeaderWidth += 50;\n            }\n          }\n        } else {\n          this.rowHeaderWidth = 0;\n        }\n      }\n      this.rowHeaderWidth = this.instance.getSetting('onModifyRowHeaderWidth', this.rowHeaderWidth) || this.rowHeaderWidth;\n      return this.rowHeaderWidth;\n    }\n    /**\n     * @returns {number}\n     */\n  }, {\n    key: \"getViewportWidth\",\n    value: function getViewportWidth() {\n      var containerWidth = this.getWorkspaceWidth();\n      if (containerWidth === Infinity) {\n        return containerWidth;\n      }\n      var rowHeaderWidth = this.getRowHeaderWidth();\n      if (rowHeaderWidth > 0) {\n        return containerWidth - rowHeaderWidth;\n      }\n      return containerWidth;\n    }\n    /**\n     * Creates:\n     * - rowsRenderCalculator (before draw, to qualify rows for rendering)\n     * - rowsVisibleCalculator (after draw, to measure which rows are actually visible).\n     *\n     * @param {number} calculationType The render type ID, which determines for what type of\n     *                                 calculation calculator is created.\n     * @returns {ViewportRowsCalculator}\n     */\n  }, {\n    key: \"createRowsCalculator\",\n    value: function createRowsCalculator() {\n      var calculationType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : RENDER_TYPE;\n      var wot = this.wot;\n      var wtSettings = wot.wtSettings,\n        wtOverlays = wot.wtOverlays,\n        wtTable = wot.wtTable,\n        rootDocument = wot.rootDocument;\n      var height;\n      var scrollbarHeight;\n      var fixedRowsHeight;\n      this.rowHeaderWidth = NaN;\n      if (wtSettings.settings.renderAllRows && calculationType === RENDER_TYPE) {\n        height = Infinity;\n      } else {\n        height = this.getViewportHeight();\n      }\n      var pos = wtOverlays.topOverlay.getScrollPosition() - wtOverlays.topOverlay.getTableParentOffset();\n      if (pos < 0) {\n        pos = 0;\n      }\n      var fixedRowsTop = wot.getSetting('fixedRowsTop');\n      var fixedRowsBottom = wot.getSetting('fixedRowsBottom');\n      var totalRows = wot.getSetting('totalRows');\n      if (fixedRowsTop) {\n        fixedRowsHeight = wtOverlays.topOverlay.sumCellSizes(0, fixedRowsTop);\n        pos += fixedRowsHeight;\n        height -= fixedRowsHeight;\n      }\n      if (fixedRowsBottom && wtOverlays.bottomOverlay.clone) {\n        fixedRowsHeight = wtOverlays.bottomOverlay.sumCellSizes(totalRows - fixedRowsBottom, totalRows);\n        height -= fixedRowsHeight;\n      }\n      if (wtTable.holder.clientHeight === wtTable.holder.offsetHeight) {\n        scrollbarHeight = 0;\n      } else {\n        scrollbarHeight = getScrollbarWidth(rootDocument);\n      }\n      return new ViewportRowsCalculator({\n        viewportSize: height,\n        scrollOffset: pos,\n        totalItems: wot.getSetting('totalRows'),\n        itemSizeFn: function itemSizeFn(sourceRow) {\n          return wtTable.getRowHeight(sourceRow);\n        },\n        overrideFn: wtSettings.settings.viewportRowCalculatorOverride,\n        calculationType: calculationType,\n        scrollbarHeight: scrollbarHeight\n      });\n    }\n    /**\n     * Creates:\n     * - columnsRenderCalculator (before draw, to qualify columns for rendering)\n     * - columnsVisibleCalculator (after draw, to measure which columns are actually visible).\n     *\n     * @param {number} calculationType The render type ID, which determines for what type of\n     *                                 calculation calculator is created.\n     * @returns {ViewportRowsCalculator}\n     */\n  }, {\n    key: \"createColumnsCalculator\",\n    value: function createColumnsCalculator() {\n      var calculationType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : RENDER_TYPE;\n      var wot = this.wot;\n      var wtSettings = wot.wtSettings,\n        wtOverlays = wot.wtOverlays,\n        wtTable = wot.wtTable,\n        rootDocument = wot.rootDocument;\n      var width = this.getViewportWidth();\n      var pos = wtOverlays.leftOverlay.getScrollPosition() - wtOverlays.leftOverlay.getTableParentOffset();\n      this.columnHeaderHeight = NaN;\n      if (pos < 0) {\n        pos = 0;\n      }\n      var fixedColumnsLeft = wot.getSetting('fixedColumnsLeft');\n      if (fixedColumnsLeft) {\n        var fixedColumnsWidth = wtOverlays.leftOverlay.sumCellSizes(0, fixedColumnsLeft);\n        pos += fixedColumnsWidth;\n        width -= fixedColumnsWidth;\n      }\n      if (wtTable.holder.clientWidth !== wtTable.holder.offsetWidth) {\n        width -= getScrollbarWidth(rootDocument);\n      }\n      return new ViewportColumnsCalculator({\n        viewportSize: width,\n        scrollOffset: pos,\n        totalItems: wot.getSetting('totalColumns'),\n        itemSizeFn: function itemSizeFn(sourceCol) {\n          return wot.wtTable.getColumnWidth(sourceCol);\n        },\n        overrideFn: wtSettings.settings.viewportColumnCalculatorOverride,\n        calculationType: calculationType,\n        stretchMode: wot.getSetting('stretchH'),\n        stretchingItemWidthFn: function stretchingItemWidthFn(stretchedWidth, column) {\n          return wot.getSetting('onBeforeStretchingColumnWidth', stretchedWidth, column);\n        }\n      });\n    }\n    /**\n     * Creates rowsRenderCalculator and columnsRenderCalculator (before draw, to determine what rows and\n     * cols should be rendered).\n     *\n     * @param {boolean} fastDraw If `true`, will try to avoid full redraw and only update the border positions.\n     *                           If `false` or `undefined`, will perform a full redraw.\n     * @returns {boolean} The fastDraw value, possibly modified.\n     */\n  }, {\n    key: \"createRenderCalculators\",\n    value: function createRenderCalculators() {\n      var fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var runFastDraw = fastDraw;\n      if (runFastDraw) {\n        var proposedRowsVisibleCalculator = this.createRowsCalculator(FULLY_VISIBLE_TYPE);\n        var proposedColumnsVisibleCalculator = this.createColumnsCalculator(FULLY_VISIBLE_TYPE);\n        if (!(this.areAllProposedVisibleRowsAlreadyRendered(proposedRowsVisibleCalculator) && this.areAllProposedVisibleColumnsAlreadyRendered(proposedColumnsVisibleCalculator))) {\n          runFastDraw = false;\n        }\n      }\n      if (!runFastDraw) {\n        this.rowsRenderCalculator = this.createRowsCalculator(RENDER_TYPE);\n        this.columnsRenderCalculator = this.createColumnsCalculator(RENDER_TYPE);\n      } // delete temporarily to make sure that renderers always use rowsRenderCalculator, not rowsVisibleCalculator\n\n      this.rowsVisibleCalculator = null;\n      this.columnsVisibleCalculator = null;\n      return runFastDraw;\n    }\n    /**\n     * Creates rowsVisibleCalculator and columnsVisibleCalculator (after draw, to determine what are\n     * the actually fully visible rows and columns).\n     */\n  }, {\n    key: \"createVisibleCalculators\",\n    value: function createVisibleCalculators() {\n      this.rowsVisibleCalculator = this.createRowsCalculator(FULLY_VISIBLE_TYPE);\n      this.columnsVisibleCalculator = this.createColumnsCalculator(FULLY_VISIBLE_TYPE);\n    }\n    /**\n     * Returns information whether proposedRowsVisibleCalculator viewport\n     * is contained inside rows rendered in previous draw (cached in rowsRenderCalculator).\n     *\n     * @param {ViewportRowsCalculator} proposedRowsVisibleCalculator The instance of the viewport calculator to compare with.\n     * @returns {boolean} Returns `true` if all proposed visible rows are already rendered (meaning: redraw is not needed).\n     *                    Returns `false` if at least one proposed visible row is not already rendered (meaning: redraw is needed).\n     */\n  }, {\n    key: \"areAllProposedVisibleRowsAlreadyRendered\",\n    value: function areAllProposedVisibleRowsAlreadyRendered(proposedRowsVisibleCalculator) {\n      if (!this.rowsVisibleCalculator) {\n        return false;\n      }\n      var startRow = proposedRowsVisibleCalculator.startRow,\n        endRow = proposedRowsVisibleCalculator.endRow;\n      var _this$rowsRenderCalcu = this.rowsRenderCalculator,\n        renderedStartRow = _this$rowsRenderCalcu.startRow,\n        renderedEndRow = _this$rowsRenderCalcu.endRow;\n      if (startRow < renderedStartRow || startRow === renderedStartRow && startRow > 0) {\n        return false;\n      } else if (endRow > renderedEndRow || endRow === renderedEndRow && endRow < this.wot.getSetting('totalRows') - 1) {\n        return false;\n      }\n      return true;\n    }\n    /**\n     * Returns information whether proposedColumnsVisibleCalculator viewport\n     * is contained inside column rendered in previous draw (cached in columnsRenderCalculator).\n     *\n     * @param {ViewportRowsCalculator} proposedColumnsVisibleCalculator The instance of the viewport calculator to compare with.\n     * @returns {boolean} Returns `true` if all proposed visible columns are already rendered (meaning: redraw is not needed).\n     *                    Returns `false` if at least one proposed visible column is not already rendered (meaning: redraw is needed).\n     */\n  }, {\n    key: \"areAllProposedVisibleColumnsAlreadyRendered\",\n    value: function areAllProposedVisibleColumnsAlreadyRendered(proposedColumnsVisibleCalculator) {\n      if (!this.columnsVisibleCalculator) {\n        return false;\n      }\n      var startColumn = proposedColumnsVisibleCalculator.startColumn,\n        endColumn = proposedColumnsVisibleCalculator.endColumn;\n      var _this$columnsRenderCa = this.columnsRenderCalculator,\n        renderedStartColumn = _this$columnsRenderCa.startColumn,\n        renderedEndColumn = _this$columnsRenderCa.endColumn;\n      if (startColumn < renderedStartColumn || startColumn === renderedStartColumn && startColumn > 0) {\n        return false;\n      } else if (endColumn > renderedEndColumn || endColumn === renderedEndColumn && endColumn < this.wot.getSetting('totalColumns') - 1) {\n        return false;\n      }\n      return true;\n    }\n    /**\n     * Resets values in keys of the hasOversizedColumnHeadersMarked object after updateSettings.\n     */\n  }, {\n    key: \"resetHasOversizedColumnHeadersMarked\",\n    value: function resetHasOversizedColumnHeadersMarked() {\n      objectEach(this.hasOversizedColumnHeadersMarked, function (value, key, object) {\n        object[key] = void 0;\n      });\n    }\n  }]);\n  return Viewport;\n}();\nexport default Viewport;","map":{"version":3,"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","getScrollbarWidth","getStyle","offset","outerHeight","outerWidth","objectEach","EventManager","RENDER_TYPE","FULLY_VISIBLE_TYPE","ViewportColumnsCalculator","ViewportRowsCalculator","Viewport","wotInstance","_this","wot","oversizedRows","oversizedColumnHeaders","hasOversizedColumnHeadersMarked","clientHeight","containerWidth","NaN","rowHeaderWidth","rowsVisibleCalculator","columnsVisibleCalculator","eventManager","addEventListener","rootWindow","getWorkspaceHeight","value","currentDocument","rootDocument","trimmingContainer","wtOverlays","topOverlay","height","documentElement","elemHeight","Infinity","getWorkspaceWidth","leftOverlay","docOffsetWidth","offsetWidth","totalColumns","getSetting","preventOverflow","width","overflow","wtTable","wtRootElement","Math","min","getWorkspaceOffset","left","getContainerFillWidth","sumColumnWidths","clientWidth","max","stretchSetting","TABLE","hasVerticalScroll","getWorkspaceActualHeight","hasHorizontalScroll","getWorkspaceActualWidth","from","sum","column","getColumnWidth","mainContainer","holder","dummyElement","createElement","style","appendChild","fillWidth","removeChild","TBODY","THEAD","getColumnHeaderHeight","columnHeaders","columnHeaderHeight","isNaN","getViewportHeight","containerHeight","getRowHeaderWidth","rowHeadersWidthSetting","rowHeaders","len","cloneSource","wtViewport","TH","querySelector","_i","_len","nextSibling","getViewportWidth","createRowsCalculator","calculationType","arguments","undefined","wtSettings","scrollbarHeight","fixedRowsHeight","settings","renderAllRows","pos","getScrollPosition","getTableParentOffset","fixedRowsTop","fixedRowsBottom","totalRows","sumCellSizes","bottomOverlay","clone","offsetHeight","viewportSize","scrollOffset","totalItems","itemSizeFn","sourceRow","getRowHeight","overrideFn","viewportRowCalculatorOverride","createColumnsCalculator","fixedColumnsLeft","fixedColumnsWidth","sourceCol","viewportColumnCalculatorOverride","stretchMode","stretchingItemWidthFn","stretchedWidth","createRenderCalculators","fastDraw","runFastDraw","proposedRowsVisibleCalculator","proposedColumnsVisibleCalculator","areAllProposedVisibleRowsAlreadyRendered","areAllProposedVisibleColumnsAlreadyRendered","rowsRenderCalculator","columnsRenderCalculator","createVisibleCalculators","startRow","endRow","_this$rowsRenderCalcu","renderedStartRow","renderedEndRow","startColumn","endColumn","_this$columnsRenderCa","renderedStartColumn","renderedEndColumn","resetHasOversizedColumnHeadersMarked","object"],"sources":["/Users/priyadeliwala/Desktop/sales-dashboard/node_modules/handsontable/3rdparty/walkontable/src/viewport.mjs"],"sourcesContent":["function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nimport { getScrollbarWidth, getStyle, offset, outerHeight, outerWidth } from \"./../../../helpers/dom/element.mjs\";\nimport { objectEach } from \"./../../../helpers/object.mjs\";\nimport EventManager from \"./../../../eventManager.mjs\";\nimport { RENDER_TYPE, FULLY_VISIBLE_TYPE, ViewportColumnsCalculator, ViewportRowsCalculator } from \"./calculator/index.mjs\";\n/**\n * @class Viewport\n */\n\nvar Viewport = /*#__PURE__*/function () {\n  /**\n   * @param {Walkontable} wotInstance The Walkontable instance.\n   */\n  function Viewport(wotInstance) {\n    var _this = this;\n\n    _classCallCheck(this, Viewport);\n\n    this.wot = wotInstance; // legacy support\n\n    this.instance = this.wot;\n    this.oversizedRows = [];\n    this.oversizedColumnHeaders = [];\n    this.hasOversizedColumnHeadersMarked = {};\n    this.clientHeight = 0;\n    this.containerWidth = NaN;\n    this.rowHeaderWidth = NaN;\n    this.rowsVisibleCalculator = null;\n    this.columnsVisibleCalculator = null;\n    this.eventManager = new EventManager(this.wot);\n    this.eventManager.addEventListener(this.wot.rootWindow, 'resize', function () {\n      _this.clientHeight = _this.getWorkspaceHeight();\n    });\n  }\n  /**\n   * @returns {number}\n   */\n\n\n  _createClass(Viewport, [{\n    key: \"getWorkspaceHeight\",\n    value: function getWorkspaceHeight() {\n      var currentDocument = this.wot.rootDocument;\n      var trimmingContainer = this.instance.wtOverlays.topOverlay.trimmingContainer;\n      var height = 0;\n\n      if (trimmingContainer === this.wot.rootWindow) {\n        height = currentDocument.documentElement.clientHeight;\n      } else {\n        var elemHeight = outerHeight(trimmingContainer); // returns height without DIV scrollbar\n\n        height = elemHeight > 0 && trimmingContainer.clientHeight > 0 ? trimmingContainer.clientHeight : Infinity;\n      }\n\n      return height;\n    }\n  }, {\n    key: \"getWorkspaceWidth\",\n    value: function getWorkspaceWidth() {\n      var wot = this.wot;\n      var rootDocument = wot.rootDocument,\n          rootWindow = wot.rootWindow;\n      var trimmingContainer = this.instance.wtOverlays.leftOverlay.trimmingContainer;\n      var docOffsetWidth = rootDocument.documentElement.offsetWidth;\n      var totalColumns = wot.getSetting('totalColumns');\n      var preventOverflow = wot.getSetting('preventOverflow');\n      var width;\n      var overflow;\n\n      if (preventOverflow) {\n        return outerWidth(this.instance.wtTable.wtRootElement);\n      }\n\n      if (wot.getSetting('freezeOverlays')) {\n        width = Math.min(docOffsetWidth - this.getWorkspaceOffset().left, docOffsetWidth);\n      } else {\n        width = Math.min(this.getContainerFillWidth(), docOffsetWidth - this.getWorkspaceOffset().left, docOffsetWidth);\n      }\n\n      if (trimmingContainer === rootWindow && totalColumns > 0 && this.sumColumnWidths(0, totalColumns - 1) > width) {\n        // in case sum of column widths is higher than available stylesheet width, let's assume using the whole window\n        // otherwise continue below, which will allow stretching\n        // this is used in `scroll_window.html`\n        // TODO test me\n        return rootDocument.documentElement.clientWidth;\n      }\n\n      if (trimmingContainer !== rootWindow) {\n        overflow = getStyle(this.instance.wtOverlays.leftOverlay.trimmingContainer, 'overflow', rootWindow);\n\n        if (overflow === 'scroll' || overflow === 'hidden' || overflow === 'auto') {\n          // this is used in `scroll.html`\n          // TODO test me\n          return Math.max(width, trimmingContainer.clientWidth);\n        }\n      }\n\n      var stretchSetting = wot.getSetting('stretchH');\n\n      if (stretchSetting === 'none' || !stretchSetting) {\n        // if no stretching is used, return the maximum used workspace width\n        return Math.max(width, outerWidth(this.instance.wtTable.TABLE));\n      } // if stretching is used, return the actual container width, so the columns can fit inside it\n\n\n      return width;\n    }\n    /**\n     * Checks if viewport has vertical scroll.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"hasVerticalScroll\",\n    value: function hasVerticalScroll() {\n      return this.getWorkspaceActualHeight() > this.getWorkspaceHeight();\n    }\n    /**\n     * Checks if viewport has horizontal scroll.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"hasHorizontalScroll\",\n    value: function hasHorizontalScroll() {\n      return this.getWorkspaceActualWidth() > this.getWorkspaceWidth();\n    }\n    /**\n     * @param {number} from The visual column index from the width sum is start calculated.\n     * @param {number} length The length of the column to traverse.\n     * @returns {number}\n     */\n\n  }, {\n    key: \"sumColumnWidths\",\n    value: function sumColumnWidths(from, length) {\n      var wtTable = this.wot.wtTable;\n      var sum = 0;\n      var column = from;\n\n      while (column < length) {\n        sum += wtTable.getColumnWidth(column);\n        column += 1;\n      }\n\n      return sum;\n    }\n    /**\n     * @returns {number}\n     */\n\n  }, {\n    key: \"getContainerFillWidth\",\n    value: function getContainerFillWidth() {\n      if (this.containerWidth) {\n        return this.containerWidth;\n      }\n\n      var mainContainer = this.instance.wtTable.holder;\n      var dummyElement = this.wot.rootDocument.createElement('div');\n      dummyElement.style.width = '100%';\n      dummyElement.style.height = '1px';\n      mainContainer.appendChild(dummyElement);\n      var fillWidth = dummyElement.offsetWidth;\n      this.containerWidth = fillWidth;\n      mainContainer.removeChild(dummyElement);\n      return fillWidth;\n    }\n    /**\n     * @returns {number}\n     */\n\n  }, {\n    key: \"getWorkspaceOffset\",\n    value: function getWorkspaceOffset() {\n      return offset(this.wot.wtTable.TABLE);\n    }\n    /**\n     * @returns {number}\n     */\n\n  }, {\n    key: \"getWorkspaceActualHeight\",\n    value: function getWorkspaceActualHeight() {\n      return outerHeight(this.wot.wtTable.TABLE);\n    }\n    /**\n     * @returns {number}\n     */\n\n  }, {\n    key: \"getWorkspaceActualWidth\",\n    value: function getWorkspaceActualWidth() {\n      var wtTable = this.wot.wtTable;\n      return outerWidth(wtTable.TABLE) || outerWidth(wtTable.TBODY) || outerWidth(wtTable.THEAD); // IE8 reports 0 as <table> offsetWidth;\n    }\n    /**\n     * @returns {number}\n     */\n\n  }, {\n    key: \"getColumnHeaderHeight\",\n    value: function getColumnHeaderHeight() {\n      var columnHeaders = this.instance.getSetting('columnHeaders');\n\n      if (!columnHeaders.length) {\n        this.columnHeaderHeight = 0;\n      } else if (isNaN(this.columnHeaderHeight)) {\n        this.columnHeaderHeight = outerHeight(this.wot.wtTable.THEAD);\n      }\n\n      return this.columnHeaderHeight;\n    }\n    /**\n     * @returns {number}\n     */\n\n  }, {\n    key: \"getViewportHeight\",\n    value: function getViewportHeight() {\n      var containerHeight = this.getWorkspaceHeight();\n\n      if (containerHeight === Infinity) {\n        return containerHeight;\n      }\n\n      var columnHeaderHeight = this.getColumnHeaderHeight();\n\n      if (columnHeaderHeight > 0) {\n        containerHeight -= columnHeaderHeight;\n      }\n\n      return containerHeight;\n    }\n    /**\n     * @returns {number}\n     */\n\n  }, {\n    key: \"getRowHeaderWidth\",\n    value: function getRowHeaderWidth() {\n      var rowHeadersWidthSetting = this.instance.getSetting('rowHeaderWidth');\n      var rowHeaders = this.instance.getSetting('rowHeaders');\n\n      if (rowHeadersWidthSetting) {\n        this.rowHeaderWidth = 0;\n\n        for (var i = 0, len = rowHeaders.length; i < len; i++) {\n          this.rowHeaderWidth += rowHeadersWidthSetting[i] || rowHeadersWidthSetting;\n        }\n      }\n\n      if (this.wot.cloneSource) {\n        return this.wot.cloneSource.wtViewport.getRowHeaderWidth();\n      }\n\n      if (isNaN(this.rowHeaderWidth)) {\n        if (rowHeaders.length) {\n          var TH = this.instance.wtTable.TABLE.querySelector('TH');\n          this.rowHeaderWidth = 0;\n\n          for (var _i = 0, _len = rowHeaders.length; _i < _len; _i++) {\n            if (TH) {\n              this.rowHeaderWidth += outerWidth(TH);\n              TH = TH.nextSibling;\n            } else {\n              // yes this is a cheat but it worked like that before, just taking assumption from CSS instead of measuring.\n              // TODO: proper fix\n              this.rowHeaderWidth += 50;\n            }\n          }\n        } else {\n          this.rowHeaderWidth = 0;\n        }\n      }\n\n      this.rowHeaderWidth = this.instance.getSetting('onModifyRowHeaderWidth', this.rowHeaderWidth) || this.rowHeaderWidth;\n      return this.rowHeaderWidth;\n    }\n    /**\n     * @returns {number}\n     */\n\n  }, {\n    key: \"getViewportWidth\",\n    value: function getViewportWidth() {\n      var containerWidth = this.getWorkspaceWidth();\n\n      if (containerWidth === Infinity) {\n        return containerWidth;\n      }\n\n      var rowHeaderWidth = this.getRowHeaderWidth();\n\n      if (rowHeaderWidth > 0) {\n        return containerWidth - rowHeaderWidth;\n      }\n\n      return containerWidth;\n    }\n    /**\n     * Creates:\n     * - rowsRenderCalculator (before draw, to qualify rows for rendering)\n     * - rowsVisibleCalculator (after draw, to measure which rows are actually visible).\n     *\n     * @param {number} calculationType The render type ID, which determines for what type of\n     *                                 calculation calculator is created.\n     * @returns {ViewportRowsCalculator}\n     */\n\n  }, {\n    key: \"createRowsCalculator\",\n    value: function createRowsCalculator() {\n      var calculationType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : RENDER_TYPE;\n      var wot = this.wot;\n      var wtSettings = wot.wtSettings,\n          wtOverlays = wot.wtOverlays,\n          wtTable = wot.wtTable,\n          rootDocument = wot.rootDocument;\n      var height;\n      var scrollbarHeight;\n      var fixedRowsHeight;\n      this.rowHeaderWidth = NaN;\n\n      if (wtSettings.settings.renderAllRows && calculationType === RENDER_TYPE) {\n        height = Infinity;\n      } else {\n        height = this.getViewportHeight();\n      }\n\n      var pos = wtOverlays.topOverlay.getScrollPosition() - wtOverlays.topOverlay.getTableParentOffset();\n\n      if (pos < 0) {\n        pos = 0;\n      }\n\n      var fixedRowsTop = wot.getSetting('fixedRowsTop');\n      var fixedRowsBottom = wot.getSetting('fixedRowsBottom');\n      var totalRows = wot.getSetting('totalRows');\n\n      if (fixedRowsTop) {\n        fixedRowsHeight = wtOverlays.topOverlay.sumCellSizes(0, fixedRowsTop);\n        pos += fixedRowsHeight;\n        height -= fixedRowsHeight;\n      }\n\n      if (fixedRowsBottom && wtOverlays.bottomOverlay.clone) {\n        fixedRowsHeight = wtOverlays.bottomOverlay.sumCellSizes(totalRows - fixedRowsBottom, totalRows);\n        height -= fixedRowsHeight;\n      }\n\n      if (wtTable.holder.clientHeight === wtTable.holder.offsetHeight) {\n        scrollbarHeight = 0;\n      } else {\n        scrollbarHeight = getScrollbarWidth(rootDocument);\n      }\n\n      return new ViewportRowsCalculator({\n        viewportSize: height,\n        scrollOffset: pos,\n        totalItems: wot.getSetting('totalRows'),\n        itemSizeFn: function itemSizeFn(sourceRow) {\n          return wtTable.getRowHeight(sourceRow);\n        },\n        overrideFn: wtSettings.settings.viewportRowCalculatorOverride,\n        calculationType: calculationType,\n        scrollbarHeight: scrollbarHeight\n      });\n    }\n    /**\n     * Creates:\n     * - columnsRenderCalculator (before draw, to qualify columns for rendering)\n     * - columnsVisibleCalculator (after draw, to measure which columns are actually visible).\n     *\n     * @param {number} calculationType The render type ID, which determines for what type of\n     *                                 calculation calculator is created.\n     * @returns {ViewportRowsCalculator}\n     */\n\n  }, {\n    key: \"createColumnsCalculator\",\n    value: function createColumnsCalculator() {\n      var calculationType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : RENDER_TYPE;\n      var wot = this.wot;\n      var wtSettings = wot.wtSettings,\n          wtOverlays = wot.wtOverlays,\n          wtTable = wot.wtTable,\n          rootDocument = wot.rootDocument;\n      var width = this.getViewportWidth();\n      var pos = wtOverlays.leftOverlay.getScrollPosition() - wtOverlays.leftOverlay.getTableParentOffset();\n      this.columnHeaderHeight = NaN;\n\n      if (pos < 0) {\n        pos = 0;\n      }\n\n      var fixedColumnsLeft = wot.getSetting('fixedColumnsLeft');\n\n      if (fixedColumnsLeft) {\n        var fixedColumnsWidth = wtOverlays.leftOverlay.sumCellSizes(0, fixedColumnsLeft);\n        pos += fixedColumnsWidth;\n        width -= fixedColumnsWidth;\n      }\n\n      if (wtTable.holder.clientWidth !== wtTable.holder.offsetWidth) {\n        width -= getScrollbarWidth(rootDocument);\n      }\n\n      return new ViewportColumnsCalculator({\n        viewportSize: width,\n        scrollOffset: pos,\n        totalItems: wot.getSetting('totalColumns'),\n        itemSizeFn: function itemSizeFn(sourceCol) {\n          return wot.wtTable.getColumnWidth(sourceCol);\n        },\n        overrideFn: wtSettings.settings.viewportColumnCalculatorOverride,\n        calculationType: calculationType,\n        stretchMode: wot.getSetting('stretchH'),\n        stretchingItemWidthFn: function stretchingItemWidthFn(stretchedWidth, column) {\n          return wot.getSetting('onBeforeStretchingColumnWidth', stretchedWidth, column);\n        }\n      });\n    }\n    /**\n     * Creates rowsRenderCalculator and columnsRenderCalculator (before draw, to determine what rows and\n     * cols should be rendered).\n     *\n     * @param {boolean} fastDraw If `true`, will try to avoid full redraw and only update the border positions.\n     *                           If `false` or `undefined`, will perform a full redraw.\n     * @returns {boolean} The fastDraw value, possibly modified.\n     */\n\n  }, {\n    key: \"createRenderCalculators\",\n    value: function createRenderCalculators() {\n      var fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var runFastDraw = fastDraw;\n\n      if (runFastDraw) {\n        var proposedRowsVisibleCalculator = this.createRowsCalculator(FULLY_VISIBLE_TYPE);\n        var proposedColumnsVisibleCalculator = this.createColumnsCalculator(FULLY_VISIBLE_TYPE);\n\n        if (!(this.areAllProposedVisibleRowsAlreadyRendered(proposedRowsVisibleCalculator) && this.areAllProposedVisibleColumnsAlreadyRendered(proposedColumnsVisibleCalculator))) {\n          runFastDraw = false;\n        }\n      }\n\n      if (!runFastDraw) {\n        this.rowsRenderCalculator = this.createRowsCalculator(RENDER_TYPE);\n        this.columnsRenderCalculator = this.createColumnsCalculator(RENDER_TYPE);\n      } // delete temporarily to make sure that renderers always use rowsRenderCalculator, not rowsVisibleCalculator\n\n\n      this.rowsVisibleCalculator = null;\n      this.columnsVisibleCalculator = null;\n      return runFastDraw;\n    }\n    /**\n     * Creates rowsVisibleCalculator and columnsVisibleCalculator (after draw, to determine what are\n     * the actually fully visible rows and columns).\n     */\n\n  }, {\n    key: \"createVisibleCalculators\",\n    value: function createVisibleCalculators() {\n      this.rowsVisibleCalculator = this.createRowsCalculator(FULLY_VISIBLE_TYPE);\n      this.columnsVisibleCalculator = this.createColumnsCalculator(FULLY_VISIBLE_TYPE);\n    }\n    /**\n     * Returns information whether proposedRowsVisibleCalculator viewport\n     * is contained inside rows rendered in previous draw (cached in rowsRenderCalculator).\n     *\n     * @param {ViewportRowsCalculator} proposedRowsVisibleCalculator The instance of the viewport calculator to compare with.\n     * @returns {boolean} Returns `true` if all proposed visible rows are already rendered (meaning: redraw is not needed).\n     *                    Returns `false` if at least one proposed visible row is not already rendered (meaning: redraw is needed).\n     */\n\n  }, {\n    key: \"areAllProposedVisibleRowsAlreadyRendered\",\n    value: function areAllProposedVisibleRowsAlreadyRendered(proposedRowsVisibleCalculator) {\n      if (!this.rowsVisibleCalculator) {\n        return false;\n      }\n\n      var startRow = proposedRowsVisibleCalculator.startRow,\n          endRow = proposedRowsVisibleCalculator.endRow;\n      var _this$rowsRenderCalcu = this.rowsRenderCalculator,\n          renderedStartRow = _this$rowsRenderCalcu.startRow,\n          renderedEndRow = _this$rowsRenderCalcu.endRow;\n\n      if (startRow < renderedStartRow || startRow === renderedStartRow && startRow > 0) {\n        return false;\n      } else if (endRow > renderedEndRow || endRow === renderedEndRow && endRow < this.wot.getSetting('totalRows') - 1) {\n        return false;\n      }\n\n      return true;\n    }\n    /**\n     * Returns information whether proposedColumnsVisibleCalculator viewport\n     * is contained inside column rendered in previous draw (cached in columnsRenderCalculator).\n     *\n     * @param {ViewportRowsCalculator} proposedColumnsVisibleCalculator The instance of the viewport calculator to compare with.\n     * @returns {boolean} Returns `true` if all proposed visible columns are already rendered (meaning: redraw is not needed).\n     *                    Returns `false` if at least one proposed visible column is not already rendered (meaning: redraw is needed).\n     */\n\n  }, {\n    key: \"areAllProposedVisibleColumnsAlreadyRendered\",\n    value: function areAllProposedVisibleColumnsAlreadyRendered(proposedColumnsVisibleCalculator) {\n      if (!this.columnsVisibleCalculator) {\n        return false;\n      }\n\n      var startColumn = proposedColumnsVisibleCalculator.startColumn,\n          endColumn = proposedColumnsVisibleCalculator.endColumn;\n      var _this$columnsRenderCa = this.columnsRenderCalculator,\n          renderedStartColumn = _this$columnsRenderCa.startColumn,\n          renderedEndColumn = _this$columnsRenderCa.endColumn;\n\n      if (startColumn < renderedStartColumn || startColumn === renderedStartColumn && startColumn > 0) {\n        return false;\n      } else if (endColumn > renderedEndColumn || endColumn === renderedEndColumn && endColumn < this.wot.getSetting('totalColumns') - 1) {\n        return false;\n      }\n\n      return true;\n    }\n    /**\n     * Resets values in keys of the hasOversizedColumnHeadersMarked object after updateSettings.\n     */\n\n  }, {\n    key: \"resetHasOversizedColumnHeadersMarked\",\n    value: function resetHasOversizedColumnHeadersMarked() {\n      objectEach(this.hasOversizedColumnHeadersMarked, function (value, key, object) {\n        object[key] = void 0;\n      });\n    }\n  }]);\n\n  return Viewport;\n}();\n\nexport default Viewport;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}