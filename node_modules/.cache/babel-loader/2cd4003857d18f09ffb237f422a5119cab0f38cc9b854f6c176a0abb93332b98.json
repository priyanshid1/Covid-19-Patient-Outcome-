{"ast":null,"code":"import _taggedTemplateLiteral from \"/Users/priyadeliwala/Desktop/sales-dashboard/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js\";\nvar _templateObject;\nimport { toSingleLine } from \"../../../../helpers/templateLiteralTag.mjs\";\n/**\n * @param {TreeNode} nodeToProcess A tree node to process.\n * @param {number} gridColumnIndex The visual column index that triggers the node modification.\n *                                 The index can be between the root node column index and\n *                                 column index plus node colspan length.\n */\nexport function hideColumn(nodeToProcess, gridColumnIndex) {\n  if (!Number.isInteger(gridColumnIndex)) {\n    throw new Error('The passed gridColumnIndex argument has invalid type.');\n  }\n  if (nodeToProcess.childs.length > 0) {\n    throw new Error(toSingleLine(_templateObject || (_templateObject = _taggedTemplateLiteral([\"The passed node is not the last node on the tree. Only for \\nthe last node, the hide column modification can be applied.\"], [\"The passed node is not the last node on the tree. Only for\\\\x20\\nthe last node, the hide column modification can be applied.\"]))));\n  }\n  var crossHiddenColumns = nodeToProcess.data.crossHiddenColumns;\n  if (crossHiddenColumns.includes(gridColumnIndex)) {\n    return;\n  }\n  var isCollapsibleNode = false;\n  nodeToProcess.walkUp(function (node) {\n    var collapsible = node.data.collapsible;\n    if (collapsible) {\n      isCollapsibleNode = true;\n      return false; // Cancel tree traversing\n    }\n  });\n\n  // TODO: When the node is collapsible do not hide the column. Currently collapsible headers\n  // does not work with hidden columns (hidden index map types).\n  if (isCollapsibleNode) {\n    return;\n  }\n  nodeToProcess.walkUp(function (node) {\n    var data = node.data;\n    data.crossHiddenColumns.push(gridColumnIndex);\n    if (data.colspan > 1) {\n      data.colspan -= 1;\n    } else {\n      data.isHidden = true;\n    }\n  });\n}","map":{"version":3,"names":["toSingleLine","hideColumn","nodeToProcess","gridColumnIndex","Number","isInteger","Error","childs","length","_templateObject","_taggedTemplateLiteral","crossHiddenColumns","data","includes","isCollapsibleNode","walkUp","node","collapsible","push","colspan","isHidden"],"sources":["/Users/priyadeliwala/node_modules/handsontable/plugins/nestedHeaders/stateManager/nodeModifiers/hideColumn.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport { toSingleLine } from \"../../../../helpers/templateLiteralTag.mjs\";\n/**\n * @param {TreeNode} nodeToProcess A tree node to process.\n * @param {number} gridColumnIndex The visual column index that triggers the node modification.\n *                                 The index can be between the root node column index and\n *                                 column index plus node colspan length.\n */\nexport function hideColumn(nodeToProcess, gridColumnIndex) {\n  if (!Number.isInteger(gridColumnIndex)) {\n    throw new Error('The passed gridColumnIndex argument has invalid type.');\n  }\n  if (nodeToProcess.childs.length > 0) {\n    throw new Error(toSingleLine`The passed node is not the last node on the tree. Only for\\x20\nthe last node, the hide column modification can be applied.`);\n  }\n  const {\n    crossHiddenColumns\n  } = nodeToProcess.data;\n  if (crossHiddenColumns.includes(gridColumnIndex)) {\n    return;\n  }\n  let isCollapsibleNode = false;\n  nodeToProcess.walkUp(node => {\n    const {\n      data: {\n        collapsible\n      }\n    } = node;\n    if (collapsible) {\n      isCollapsibleNode = true;\n      return false; // Cancel tree traversing\n    }\n  });\n\n  // TODO: When the node is collapsible do not hide the column. Currently collapsible headers\n  // does not work with hidden columns (hidden index map types).\n  if (isCollapsibleNode) {\n    return;\n  }\n  nodeToProcess.walkUp(node => {\n    const {\n      data\n    } = node;\n    data.crossHiddenColumns.push(gridColumnIndex);\n    if (data.colspan > 1) {\n      data.colspan -= 1;\n    } else {\n      data.isHidden = true;\n    }\n  });\n}"],"mappings":";;AAEA,SAASA,YAAY,QAAQ,4CAA4C;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,UAAUA,CAACC,aAAa,EAAEC,eAAe,EAAE;EACzD,IAAI,CAACC,MAAM,CAACC,SAAS,CAACF,eAAe,CAAC,EAAE;IACtC,MAAM,IAAIG,KAAK,CAAC,uDAAuD,CAAC;EAC1E;EACA,IAAIJ,aAAa,CAACK,MAAM,CAACC,MAAM,GAAG,CAAC,EAAE;IACnC,MAAM,IAAIF,KAAK,CAACN,YAAY,CAAAS,eAAA,KAAAA,eAAA,GAAAC,sBAAA,kQAC4B,CAAC;EAC3D;EACA,IACEC,kBAAkB,GAChBT,aAAa,CAACU,IAAI,CADpBD,kBAAkB;EAEpB,IAAIA,kBAAkB,CAACE,QAAQ,CAACV,eAAe,CAAC,EAAE;IAChD;EACF;EACA,IAAIW,iBAAiB,GAAG,KAAK;EAC7BZ,aAAa,CAACa,MAAM,CAAC,UAAAC,IAAI,EAAI;IAC3B,IAEIC,WAAW,GAEXD,IAAI,CAHNJ,IAAI,CACFK,WAAW;IAGf,IAAIA,WAAW,EAAE;MACfH,iBAAiB,GAAG,IAAI;MACxB,OAAO,KAAK,CAAC,CAAC;IAChB;EACF,CAAC,CAAC;;EAEF;EACA;EACA,IAAIA,iBAAiB,EAAE;IACrB;EACF;EACAZ,aAAa,CAACa,MAAM,CAAC,UAAAC,IAAI,EAAI;IAC3B,IACEJ,IAAI,GACFI,IAAI,CADNJ,IAAI;IAENA,IAAI,CAACD,kBAAkB,CAACO,IAAI,CAACf,eAAe,CAAC;IAC7C,IAAIS,IAAI,CAACO,OAAO,GAAG,CAAC,EAAE;MACpBP,IAAI,CAACO,OAAO,IAAI,CAAC;IACnB,CAAC,MAAM;MACLP,IAAI,CAACQ,QAAQ,GAAG,IAAI;IACtB;EACF,CAAC,CAAC;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}