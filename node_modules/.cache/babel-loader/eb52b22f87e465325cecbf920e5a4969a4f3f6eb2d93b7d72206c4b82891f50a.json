{"ast":null,"code":"import { baseRenderer } from \"../baseRenderer/index.mjs\";\nimport EventManager from \"../../eventManager.mjs\";\nimport { empty, addClass, setAttribute } from \"../../helpers/dom/element.mjs\";\nimport { isEmpty, stringify } from \"../../helpers/mixed.mjs\";\nimport { EDITOR_EDIT_GROUP as SHORTCUTS_GROUP_EDITOR } from \"../../shortcutContexts/index.mjs\";\nimport Hooks from \"../../pluginHooks.mjs\";\nimport { A11Y_CHECKBOX, A11Y_CHECKED, A11Y_LABEL } from \"../../helpers/a11y.mjs\";\nimport { CHECKBOX_CHECKED, CHECKBOX_UNCHECKED } from \"../../i18n/constants.mjs\";\nconst isListeningKeyDownEvent = new WeakMap();\nconst isCheckboxListenerAdded = new WeakMap();\nconst BAD_VALUE_CLASS = 'htBadValue';\nconst ATTR_ROW = 'data-row';\nconst ATTR_COLUMN = 'data-col';\nconst SHORTCUTS_GROUP = 'checkboxRenderer';\nexport const RENDERER_TYPE = 'checkbox';\nHooks.getSingleton().add('modifyAutoColumnSizeSeed', function (bundleSeed, cellMeta, cellValue) {\n  const {\n    label,\n    type,\n    row,\n    column,\n    prop\n  } = cellMeta;\n  if (type !== RENDERER_TYPE) {\n    return;\n  }\n  if (label) {\n    const {\n      value: labelValue,\n      property: labelProperty\n    } = label;\n    let labelText = cellValue;\n    if (labelValue) {\n      labelText = typeof labelValue === 'function' ? labelValue(row, column, prop, cellValue) : labelValue;\n    } else if (labelProperty) {\n      const labelData = this.getDataAtRowProp(row, labelProperty);\n      labelText = labelData !== null ? labelData : cellValue;\n    }\n    bundleSeed = labelText;\n  }\n  return bundleSeed;\n});\n/**\n * Checkbox renderer.\n *\n * @private\n * @param {Core} hotInstance The Handsontable instance.\n * @param {HTMLTableCellElement} TD The rendered cell element.\n * @param {number} row The visual row index.\n * @param {number} col The visual column index.\n * @param {number|string} prop The column property (passed when datasource is an array of objects).\n * @param {*} value The rendered value.\n * @param {object} cellProperties The cell meta object (see {@link Core#getCellMeta}).\n */\nexport function checkboxRenderer(hotInstance, TD, row, col, prop, value, cellProperties) {\n  const {\n    rootDocument\n  } = hotInstance;\n  const ariaEnabled = hotInstance.getSettings().ariaTags;\n  baseRenderer.apply(this, [hotInstance, TD, row, col, prop, value, cellProperties]);\n  registerEvents(hotInstance);\n  let input = createInput(rootDocument);\n  const labelOptions = cellProperties.label;\n  let badValue = false;\n  if (typeof cellProperties.checkedTemplate === 'undefined') {\n    cellProperties.checkedTemplate = true;\n  }\n  if (typeof cellProperties.uncheckedTemplate === 'undefined') {\n    cellProperties.uncheckedTemplate = false;\n  }\n  empty(TD); // TODO identify under what circumstances this line can be removed\n\n  if (value === cellProperties.checkedTemplate || stringify(value).toLocaleLowerCase(cellProperties.locale) === stringify(cellProperties.checkedTemplate).toLocaleLowerCase(cellProperties.locale)) {\n    input.checked = true;\n  } else if (value === cellProperties.uncheckedTemplate || stringify(value).toLocaleLowerCase(cellProperties.locale) === stringify(cellProperties.uncheckedTemplate).toLocaleLowerCase(cellProperties.locale)) {\n    input.checked = false;\n  } else if (isEmpty(value)) {\n    // default value\n    addClass(input, 'noValue');\n  } else {\n    input.style.display = 'none';\n    addClass(input, BAD_VALUE_CLASS);\n    badValue = true;\n  }\n  setAttribute(input, [[ATTR_ROW, row], [ATTR_COLUMN, col]]);\n  if (ariaEnabled) {\n    setAttribute(input, [A11Y_LABEL(input.checked ? hotInstance.getTranslatedPhrase(CHECKBOX_CHECKED) : hotInstance.getTranslatedPhrase(CHECKBOX_UNCHECKED)), A11Y_CHECKED(input.checked), A11Y_CHECKBOX()]);\n  }\n  if (!badValue && labelOptions) {\n    let labelText = '';\n    if (labelOptions.value) {\n      labelText = typeof labelOptions.value === 'function' ? labelOptions.value.call(this, row, col, prop, value) : labelOptions.value;\n    } else if (labelOptions.property) {\n      const labelValue = hotInstance.getDataAtRowProp(row, labelOptions.property);\n      labelText = labelValue !== null ? labelValue : '';\n    }\n    const label = createLabel(rootDocument, labelText, labelOptions.separated !== true);\n    if (labelOptions.position === 'before') {\n      if (labelOptions.separated) {\n        TD.appendChild(label);\n        TD.appendChild(input);\n      } else {\n        label.appendChild(input);\n        input = label;\n      }\n    } else if (!labelOptions.position || labelOptions.position === 'after') {\n      if (labelOptions.separated) {\n        TD.appendChild(input);\n        TD.appendChild(label);\n      } else {\n        label.insertBefore(input, label.firstChild);\n        input = label;\n      }\n    }\n  }\n  if (!labelOptions || labelOptions && !labelOptions.separated) {\n    TD.appendChild(input);\n  }\n  if (badValue) {\n    TD.appendChild(rootDocument.createTextNode('#bad-value#'));\n  }\n  if (!isListeningKeyDownEvent.has(hotInstance)) {\n    isListeningKeyDownEvent.set(hotInstance, true);\n    registerShortcuts();\n  }\n\n  /**\n   * Register shortcuts responsible for toggling checkbox state.\n   *\n   * @private\n   */\n  function registerShortcuts() {\n    const shortcutManager = hotInstance.getShortcutManager();\n    const gridContext = shortcutManager.getContext('grid');\n    const config = {\n      group: SHORTCUTS_GROUP,\n      relativeToGroup: SHORTCUTS_GROUP_EDITOR,\n      position: 'before'\n    };\n    gridContext.addShortcuts([{\n      keys: [['space']],\n      callback: () => {\n        changeSelectedCheckboxesState();\n        return !areSelectedCheckboxCells(); // False blocks next action associated with the keyboard shortcut.\n      },\n      runOnlyIf: () => {\n        var _hotInstance$getSelec;\n        return (_hotInstance$getSelec = hotInstance.getSelectedRangeLast()) === null || _hotInstance$getSelec === void 0 ? void 0 : _hotInstance$getSelec.highlight.isCell();\n      }\n    }, {\n      keys: [['enter']],\n      callback: () => {\n        changeSelectedCheckboxesState();\n        return !areSelectedCheckboxCells(); // False blocks next action associated with the keyboard shortcut.\n      },\n      runOnlyIf: () => {\n        const range = hotInstance.getSelectedRangeLast();\n        return hotInstance.getSettings().enterBeginsEditing && (range === null || range === void 0 ? void 0 : range.isSingle()) && range.highlight.isCell();\n      }\n    }, {\n      keys: [['delete'], ['backspace']],\n      callback: () => {\n        changeSelectedCheckboxesState(true);\n        return !areSelectedCheckboxCells(); // False blocks next action associated with the keyboard shortcut.\n      },\n      runOnlyIf: () => {\n        var _hotInstance$getSelec2;\n        return (_hotInstance$getSelec2 = hotInstance.getSelectedRangeLast()) === null || _hotInstance$getSelec2 === void 0 ? void 0 : _hotInstance$getSelec2.highlight.isCell();\n      }\n    }], config);\n  }\n\n  /**\n   * Change checkbox checked property.\n   *\n   * @private\n   * @param {boolean} [uncheckCheckbox=false] The new \"checked\" state for the checkbox elements.\n   */\n  function changeSelectedCheckboxesState() {\n    let uncheckCheckbox = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const selRange = hotInstance.getSelectedRange();\n    const changesPerSubSelection = [];\n    const nonCheckboxChanges = new Map();\n    let changes = [];\n    let changeCounter = 0;\n    if (!selRange) {\n      return;\n    }\n    for (let key = 0; key < selRange.length; key++) {\n      const {\n        row: startRow,\n        col: startColumn\n      } = selRange[key].getTopStartCorner();\n      const {\n        row: endRow,\n        col: endColumn\n      } = selRange[key].getBottomEndCorner();\n      for (let visualRow = startRow; visualRow <= endRow; visualRow += 1) {\n        for (let visualColumn = startColumn; visualColumn <= endColumn; visualColumn += 1) {\n          const cachedCellProperties = hotInstance.getCellMeta(visualRow, visualColumn);\n          const templates = {\n            checkedTemplate: cachedCellProperties.checkedTemplate,\n            uncheckedTemplate: cachedCellProperties.uncheckedTemplate\n          };\n\n          // TODO: In the future it'd be better if non-checkbox changes were handled by the non-checkbox\n          //  `delete` keypress logic.\n          /* eslint-disable no-continue */\n          if (cachedCellProperties.type !== 'checkbox') {\n            if (uncheckCheckbox === true && !cachedCellProperties.readOnly) {\n              if (nonCheckboxChanges.has(changesPerSubSelection.length)) {\n                nonCheckboxChanges.set(changesPerSubSelection.length, [...nonCheckboxChanges.get(changesPerSubSelection.length), [visualRow, visualColumn, null]]);\n              } else {\n                nonCheckboxChanges.set(changesPerSubSelection.length, [[visualRow, visualColumn, null]]);\n              }\n            }\n            continue;\n          }\n\n          /* eslint-disable no-continue */\n          if (cachedCellProperties.readOnly === true) {\n            continue;\n          }\n          if (typeof cachedCellProperties.checkedTemplate === 'undefined') {\n            cachedCellProperties.checkedTemplate = true;\n          }\n          if (typeof cachedCellProperties.uncheckedTemplate === 'undefined') {\n            cachedCellProperties.uncheckedTemplate = false;\n          }\n          const dataAtCell = hotInstance.getDataAtCell(visualRow, visualColumn);\n          if (uncheckCheckbox === false) {\n            if ([cachedCellProperties.checkedTemplate, cachedCellProperties.checkedTemplate.toString()].includes(dataAtCell)) {\n              // eslint-disable-line max-len\n              changes.push([visualRow, visualColumn, cachedCellProperties.uncheckedTemplate, templates]);\n            } else if ([cachedCellProperties.uncheckedTemplate, cachedCellProperties.uncheckedTemplate.toString(), null, undefined].includes(dataAtCell)) {\n              // eslint-disable-line max-len\n              changes.push([visualRow, visualColumn, cachedCellProperties.checkedTemplate, templates]);\n            }\n          } else {\n            changes.push([visualRow, visualColumn, cachedCellProperties.uncheckedTemplate, templates]);\n          }\n          changeCounter += 1;\n        }\n      }\n      changesPerSubSelection.push(changeCounter);\n      changeCounter = 0;\n    }\n    if (!changes.every(_ref => {\n      let [,, cellValue] = _ref;\n      return cellValue === changes[0][2];\n    })) {\n      changes = changes.map(_ref2 => {\n        let [visualRow, visualColumn,, templates] = _ref2;\n        return [visualRow, visualColumn, templates.checkedTemplate];\n      });\n    } else {\n      changes = changes.map(_ref3 => {\n        let [visualRow, visualColumn, cellValue] = _ref3;\n        return [visualRow, visualColumn, cellValue];\n      });\n    }\n    if (changes.length > 0) {\n      // TODO: This is workaround for handsontable/dev-handsontable#1747 not being a breaking change.\n      // Technically, the changes don't need to be split into chunks when sent to `setDataAtCell`.\n      changesPerSubSelection.forEach((changesCount, sectionCount) => {\n        let changesChunk = changes.splice(0, changesCount);\n        if (nonCheckboxChanges.size && nonCheckboxChanges.has(sectionCount)) {\n          changesChunk = [...changesChunk, ...nonCheckboxChanges.get(sectionCount)];\n        }\n        hotInstance.setDataAtCell(changesChunk);\n      });\n    }\n  }\n\n  /**\n   * Check whether all selected cells are with checkbox type.\n   *\n   * @returns {boolean}\n   * @private\n   */\n  function areSelectedCheckboxCells() {\n    const selRange = hotInstance.getSelectedRange();\n    if (!selRange) {\n      return;\n    }\n    for (let key = 0; key < selRange.length; key++) {\n      const topLeft = selRange[key].getTopStartCorner();\n      const bottomRight = selRange[key].getBottomEndCorner();\n      for (let visualRow = topLeft.row; visualRow <= bottomRight.row; visualRow++) {\n        for (let visualColumn = topLeft.col; visualColumn <= bottomRight.col; visualColumn++) {\n          const cachedCellProperties = hotInstance.getCellMeta(visualRow, visualColumn);\n          const cell = hotInstance.getCell(visualRow, visualColumn);\n          if (cell === null || cell === undefined) {\n            return true;\n          } else {\n            const checkboxes = cell.querySelectorAll('input[type=checkbox]');\n            if (checkboxes.length > 0 && !cachedCellProperties.readOnly) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n    return false;\n  }\n}\ncheckboxRenderer.RENDERER_TYPE = RENDERER_TYPE;\n\n/**\n * Register checkbox listeners.\n *\n * @param {Core} instance The Handsontable instance.\n * @returns {EventManager}\n */\nfunction registerEvents(instance) {\n  let eventManager = isCheckboxListenerAdded.get(instance);\n  if (!eventManager) {\n    const {\n      rootElement\n    } = instance;\n    eventManager = new EventManager(instance);\n    eventManager.addEventListener(rootElement, 'click', event => onClick(event, instance));\n    eventManager.addEventListener(rootElement, 'mouseup', event => onMouseUp(event, instance));\n    eventManager.addEventListener(rootElement, 'change', event => onChange(event, instance));\n    isCheckboxListenerAdded.set(instance, eventManager);\n  }\n  return eventManager;\n}\n\n/**\n * Create input element.\n *\n * @param {Document} rootDocument The document owner.\n * @returns {Node}\n */\nfunction createInput(rootDocument) {\n  const input = rootDocument.createElement('input');\n  input.className = 'htCheckboxRendererInput';\n  input.type = 'checkbox';\n  input.setAttribute('tabindex', '-1');\n  return input.cloneNode(false);\n}\n\n/**\n * Create label element.\n *\n * @param {Document} rootDocument The document owner.\n * @param {string} text The label text.\n * @param {boolean} fullWidth Determines whether label should have full width.\n * @returns {Node}\n */\nfunction createLabel(rootDocument, text, fullWidth) {\n  const label = rootDocument.createElement('label');\n  label.className = `htCheckboxRendererLabel ${fullWidth ? 'fullWidth' : ''}`;\n  label.appendChild(rootDocument.createTextNode(text));\n  return label.cloneNode(true);\n}\n\n/**\n * `mouseup` callback.\n *\n * @private\n * @param {Event} event `mouseup` event.\n * @param {Core} instance The Handsontable instance.\n */\nfunction onMouseUp(event, instance) {\n  const {\n    target\n  } = event;\n  if (!isCheckboxInput(target)) {\n    return;\n  }\n  if (!target.hasAttribute(ATTR_ROW) || !target.hasAttribute(ATTR_COLUMN)) {\n    return;\n  }\n  setTimeout(instance.listen, 10);\n}\n\n/**\n * `click` callback.\n *\n * @private\n * @param {MouseEvent} event `click` event.\n * @param {Core} instance The Handsontable instance.\n */\nfunction onClick(event, instance) {\n  const {\n    target\n  } = event;\n  if (!isCheckboxInput(target)) {\n    return;\n  }\n  if (!target.hasAttribute(ATTR_ROW) || !target.hasAttribute(ATTR_COLUMN)) {\n    return;\n  }\n  const row = parseInt(target.getAttribute(ATTR_ROW), 10);\n  const col = parseInt(target.getAttribute(ATTR_COLUMN), 10);\n  const cellProperties = instance.getCellMeta(row, col);\n  if (cellProperties.readOnly) {\n    event.preventDefault();\n  }\n}\n\n/**\n * `change` callback.\n *\n * @param {Event} event `change` event.\n * @param {Core} instance The Handsontable instance.\n */\nfunction onChange(event, instance) {\n  const {\n    target\n  } = event;\n  if (!isCheckboxInput(target)) {\n    return;\n  }\n  if (!target.hasAttribute(ATTR_ROW) || !target.hasAttribute(ATTR_COLUMN)) {\n    return;\n  }\n  const row = parseInt(target.getAttribute(ATTR_ROW), 10);\n  const col = parseInt(target.getAttribute(ATTR_COLUMN), 10);\n  const cellProperties = instance.getCellMeta(row, col);\n  if (!cellProperties.readOnly) {\n    let newCheckboxValue = null;\n    if (event.target.checked) {\n      newCheckboxValue = cellProperties.uncheckedTemplate === undefined ? true : cellProperties.checkedTemplate;\n    } else {\n      newCheckboxValue = cellProperties.uncheckedTemplate === undefined ? false : cellProperties.uncheckedTemplate;\n    }\n    instance.setDataAtCell(row, col, newCheckboxValue);\n  }\n}\n\n/**\n * Check if the provided element is the checkbox input.\n *\n * @private\n * @param {HTMLElement} element The element in question.\n * @returns {boolean}\n */\nfunction isCheckboxInput(element) {\n  return element.tagName === 'INPUT' && element.getAttribute('type') === 'checkbox';\n}","map":{"version":3,"names":["baseRenderer","EventManager","empty","addClass","setAttribute","isEmpty","stringify","EDITOR_EDIT_GROUP","SHORTCUTS_GROUP_EDITOR","Hooks","A11Y_CHECKBOX","A11Y_CHECKED","A11Y_LABEL","CHECKBOX_CHECKED","CHECKBOX_UNCHECKED","isListeningKeyDownEvent","WeakMap","isCheckboxListenerAdded","BAD_VALUE_CLASS","ATTR_ROW","ATTR_COLUMN","SHORTCUTS_GROUP","RENDERER_TYPE","getSingleton","add","bundleSeed","cellMeta","cellValue","label","type","row","column","prop","value","labelValue","property","labelProperty","labelText","labelData","getDataAtRowProp","checkboxRenderer","hotInstance","TD","col","cellProperties","rootDocument","ariaEnabled","getSettings","ariaTags","apply","registerEvents","input","createInput","labelOptions","badValue","checkedTemplate","uncheckedTemplate","toLocaleLowerCase","locale","checked","style","display","getTranslatedPhrase","call","createLabel","separated","position","appendChild","insertBefore","firstChild","createTextNode","has","set","registerShortcuts","shortcutManager","getShortcutManager","gridContext","getContext","config","group","relativeToGroup","addShortcuts","keys","callback","changeSelectedCheckboxesState","areSelectedCheckboxCells","runOnlyIf","_hotInstance$getSelec","getSelectedRangeLast","highlight","isCell","range","enterBeginsEditing","isSingle","_hotInstance$getSelec2","uncheckCheckbox","arguments","length","undefined","selRange","getSelectedRange","changesPerSubSelection","nonCheckboxChanges","Map","changes","changeCounter","key","startRow","startColumn","getTopStartCorner","endRow","endColumn","getBottomEndCorner","visualRow","visualColumn","cachedCellProperties","getCellMeta","templates","readOnly","get","dataAtCell","getDataAtCell","toString","includes","push","every","_ref","map","_ref2","_ref3","forEach","changesCount","sectionCount","changesChunk","splice","size","setDataAtCell","topLeft","bottomRight","cell","getCell","checkboxes","querySelectorAll","instance","eventManager","rootElement","addEventListener","event","onClick","onMouseUp","onChange","createElement","className","cloneNode","text","fullWidth","target","isCheckboxInput","hasAttribute","setTimeout","listen","parseInt","getAttribute","preventDefault","newCheckboxValue","element","tagName"],"sources":["/Users/priyadeliwala/node_modules/handsontable/renderers/checkboxRenderer/checkboxRenderer.mjs"],"sourcesContent":["import \"core-js/modules/es.array.push.js\";\nimport { baseRenderer } from \"../baseRenderer/index.mjs\";\nimport EventManager from \"../../eventManager.mjs\";\nimport { empty, addClass, setAttribute } from \"../../helpers/dom/element.mjs\";\nimport { isEmpty, stringify } from \"../../helpers/mixed.mjs\";\nimport { EDITOR_EDIT_GROUP as SHORTCUTS_GROUP_EDITOR } from \"../../shortcutContexts/index.mjs\";\nimport Hooks from \"../../pluginHooks.mjs\";\nimport { A11Y_CHECKBOX, A11Y_CHECKED, A11Y_LABEL } from \"../../helpers/a11y.mjs\";\nimport { CHECKBOX_CHECKED, CHECKBOX_UNCHECKED } from \"../../i18n/constants.mjs\";\nconst isListeningKeyDownEvent = new WeakMap();\nconst isCheckboxListenerAdded = new WeakMap();\nconst BAD_VALUE_CLASS = 'htBadValue';\nconst ATTR_ROW = 'data-row';\nconst ATTR_COLUMN = 'data-col';\nconst SHORTCUTS_GROUP = 'checkboxRenderer';\nexport const RENDERER_TYPE = 'checkbox';\nHooks.getSingleton().add('modifyAutoColumnSizeSeed', function (bundleSeed, cellMeta, cellValue) {\n  const {\n    label,\n    type,\n    row,\n    column,\n    prop\n  } = cellMeta;\n  if (type !== RENDERER_TYPE) {\n    return;\n  }\n  if (label) {\n    const {\n      value: labelValue,\n      property: labelProperty\n    } = label;\n    let labelText = cellValue;\n    if (labelValue) {\n      labelText = typeof labelValue === 'function' ? labelValue(row, column, prop, cellValue) : labelValue;\n    } else if (labelProperty) {\n      const labelData = this.getDataAtRowProp(row, labelProperty);\n      labelText = labelData !== null ? labelData : cellValue;\n    }\n    bundleSeed = labelText;\n  }\n  return bundleSeed;\n});\n/**\n * Checkbox renderer.\n *\n * @private\n * @param {Core} hotInstance The Handsontable instance.\n * @param {HTMLTableCellElement} TD The rendered cell element.\n * @param {number} row The visual row index.\n * @param {number} col The visual column index.\n * @param {number|string} prop The column property (passed when datasource is an array of objects).\n * @param {*} value The rendered value.\n * @param {object} cellProperties The cell meta object (see {@link Core#getCellMeta}).\n */\nexport function checkboxRenderer(hotInstance, TD, row, col, prop, value, cellProperties) {\n  const {\n    rootDocument\n  } = hotInstance;\n  const ariaEnabled = hotInstance.getSettings().ariaTags;\n  baseRenderer.apply(this, [hotInstance, TD, row, col, prop, value, cellProperties]);\n  registerEvents(hotInstance);\n  let input = createInput(rootDocument);\n  const labelOptions = cellProperties.label;\n  let badValue = false;\n  if (typeof cellProperties.checkedTemplate === 'undefined') {\n    cellProperties.checkedTemplate = true;\n  }\n  if (typeof cellProperties.uncheckedTemplate === 'undefined') {\n    cellProperties.uncheckedTemplate = false;\n  }\n  empty(TD); // TODO identify under what circumstances this line can be removed\n\n  if (value === cellProperties.checkedTemplate || stringify(value).toLocaleLowerCase(cellProperties.locale) === stringify(cellProperties.checkedTemplate).toLocaleLowerCase(cellProperties.locale)) {\n    input.checked = true;\n  } else if (value === cellProperties.uncheckedTemplate || stringify(value).toLocaleLowerCase(cellProperties.locale) === stringify(cellProperties.uncheckedTemplate).toLocaleLowerCase(cellProperties.locale)) {\n    input.checked = false;\n  } else if (isEmpty(value)) {\n    // default value\n    addClass(input, 'noValue');\n  } else {\n    input.style.display = 'none';\n    addClass(input, BAD_VALUE_CLASS);\n    badValue = true;\n  }\n  setAttribute(input, [[ATTR_ROW, row], [ATTR_COLUMN, col]]);\n  if (ariaEnabled) {\n    setAttribute(input, [A11Y_LABEL(input.checked ? hotInstance.getTranslatedPhrase(CHECKBOX_CHECKED) : hotInstance.getTranslatedPhrase(CHECKBOX_UNCHECKED)), A11Y_CHECKED(input.checked), A11Y_CHECKBOX()]);\n  }\n  if (!badValue && labelOptions) {\n    let labelText = '';\n    if (labelOptions.value) {\n      labelText = typeof labelOptions.value === 'function' ? labelOptions.value.call(this, row, col, prop, value) : labelOptions.value;\n    } else if (labelOptions.property) {\n      const labelValue = hotInstance.getDataAtRowProp(row, labelOptions.property);\n      labelText = labelValue !== null ? labelValue : '';\n    }\n    const label = createLabel(rootDocument, labelText, labelOptions.separated !== true);\n    if (labelOptions.position === 'before') {\n      if (labelOptions.separated) {\n        TD.appendChild(label);\n        TD.appendChild(input);\n      } else {\n        label.appendChild(input);\n        input = label;\n      }\n    } else if (!labelOptions.position || labelOptions.position === 'after') {\n      if (labelOptions.separated) {\n        TD.appendChild(input);\n        TD.appendChild(label);\n      } else {\n        label.insertBefore(input, label.firstChild);\n        input = label;\n      }\n    }\n  }\n  if (!labelOptions || labelOptions && !labelOptions.separated) {\n    TD.appendChild(input);\n  }\n  if (badValue) {\n    TD.appendChild(rootDocument.createTextNode('#bad-value#'));\n  }\n  if (!isListeningKeyDownEvent.has(hotInstance)) {\n    isListeningKeyDownEvent.set(hotInstance, true);\n    registerShortcuts();\n  }\n\n  /**\n   * Register shortcuts responsible for toggling checkbox state.\n   *\n   * @private\n   */\n  function registerShortcuts() {\n    const shortcutManager = hotInstance.getShortcutManager();\n    const gridContext = shortcutManager.getContext('grid');\n    const config = {\n      group: SHORTCUTS_GROUP,\n      relativeToGroup: SHORTCUTS_GROUP_EDITOR,\n      position: 'before'\n    };\n    gridContext.addShortcuts([{\n      keys: [['space']],\n      callback: () => {\n        changeSelectedCheckboxesState();\n        return !areSelectedCheckboxCells(); // False blocks next action associated with the keyboard shortcut.\n      },\n      runOnlyIf: () => {\n        var _hotInstance$getSelec;\n        return (_hotInstance$getSelec = hotInstance.getSelectedRangeLast()) === null || _hotInstance$getSelec === void 0 ? void 0 : _hotInstance$getSelec.highlight.isCell();\n      }\n    }, {\n      keys: [['enter']],\n      callback: () => {\n        changeSelectedCheckboxesState();\n        return !areSelectedCheckboxCells(); // False blocks next action associated with the keyboard shortcut.\n      },\n      runOnlyIf: () => {\n        const range = hotInstance.getSelectedRangeLast();\n        return hotInstance.getSettings().enterBeginsEditing && (range === null || range === void 0 ? void 0 : range.isSingle()) && range.highlight.isCell();\n      }\n    }, {\n      keys: [['delete'], ['backspace']],\n      callback: () => {\n        changeSelectedCheckboxesState(true);\n        return !areSelectedCheckboxCells(); // False blocks next action associated with the keyboard shortcut.\n      },\n      runOnlyIf: () => {\n        var _hotInstance$getSelec2;\n        return (_hotInstance$getSelec2 = hotInstance.getSelectedRangeLast()) === null || _hotInstance$getSelec2 === void 0 ? void 0 : _hotInstance$getSelec2.highlight.isCell();\n      }\n    }], config);\n  }\n\n  /**\n   * Change checkbox checked property.\n   *\n   * @private\n   * @param {boolean} [uncheckCheckbox=false] The new \"checked\" state for the checkbox elements.\n   */\n  function changeSelectedCheckboxesState() {\n    let uncheckCheckbox = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const selRange = hotInstance.getSelectedRange();\n    const changesPerSubSelection = [];\n    const nonCheckboxChanges = new Map();\n    let changes = [];\n    let changeCounter = 0;\n    if (!selRange) {\n      return;\n    }\n    for (let key = 0; key < selRange.length; key++) {\n      const {\n        row: startRow,\n        col: startColumn\n      } = selRange[key].getTopStartCorner();\n      const {\n        row: endRow,\n        col: endColumn\n      } = selRange[key].getBottomEndCorner();\n      for (let visualRow = startRow; visualRow <= endRow; visualRow += 1) {\n        for (let visualColumn = startColumn; visualColumn <= endColumn; visualColumn += 1) {\n          const cachedCellProperties = hotInstance.getCellMeta(visualRow, visualColumn);\n          const templates = {\n            checkedTemplate: cachedCellProperties.checkedTemplate,\n            uncheckedTemplate: cachedCellProperties.uncheckedTemplate\n          };\n\n          // TODO: In the future it'd be better if non-checkbox changes were handled by the non-checkbox\n          //  `delete` keypress logic.\n          /* eslint-disable no-continue */\n          if (cachedCellProperties.type !== 'checkbox') {\n            if (uncheckCheckbox === true && !cachedCellProperties.readOnly) {\n              if (nonCheckboxChanges.has(changesPerSubSelection.length)) {\n                nonCheckboxChanges.set(changesPerSubSelection.length, [...nonCheckboxChanges.get(changesPerSubSelection.length), [visualRow, visualColumn, null]]);\n              } else {\n                nonCheckboxChanges.set(changesPerSubSelection.length, [[visualRow, visualColumn, null]]);\n              }\n            }\n            continue;\n          }\n\n          /* eslint-disable no-continue */\n          if (cachedCellProperties.readOnly === true) {\n            continue;\n          }\n          if (typeof cachedCellProperties.checkedTemplate === 'undefined') {\n            cachedCellProperties.checkedTemplate = true;\n          }\n          if (typeof cachedCellProperties.uncheckedTemplate === 'undefined') {\n            cachedCellProperties.uncheckedTemplate = false;\n          }\n          const dataAtCell = hotInstance.getDataAtCell(visualRow, visualColumn);\n          if (uncheckCheckbox === false) {\n            if ([cachedCellProperties.checkedTemplate, cachedCellProperties.checkedTemplate.toString()].includes(dataAtCell)) {\n              // eslint-disable-line max-len\n              changes.push([visualRow, visualColumn, cachedCellProperties.uncheckedTemplate, templates]);\n            } else if ([cachedCellProperties.uncheckedTemplate, cachedCellProperties.uncheckedTemplate.toString(), null, undefined].includes(dataAtCell)) {\n              // eslint-disable-line max-len\n              changes.push([visualRow, visualColumn, cachedCellProperties.checkedTemplate, templates]);\n            }\n          } else {\n            changes.push([visualRow, visualColumn, cachedCellProperties.uncheckedTemplate, templates]);\n          }\n          changeCounter += 1;\n        }\n      }\n      changesPerSubSelection.push(changeCounter);\n      changeCounter = 0;\n    }\n    if (!changes.every(_ref => {\n      let [,, cellValue] = _ref;\n      return cellValue === changes[0][2];\n    })) {\n      changes = changes.map(_ref2 => {\n        let [visualRow, visualColumn,, templates] = _ref2;\n        return [visualRow, visualColumn, templates.checkedTemplate];\n      });\n    } else {\n      changes = changes.map(_ref3 => {\n        let [visualRow, visualColumn, cellValue] = _ref3;\n        return [visualRow, visualColumn, cellValue];\n      });\n    }\n    if (changes.length > 0) {\n      // TODO: This is workaround for handsontable/dev-handsontable#1747 not being a breaking change.\n      // Technically, the changes don't need to be split into chunks when sent to `setDataAtCell`.\n      changesPerSubSelection.forEach((changesCount, sectionCount) => {\n        let changesChunk = changes.splice(0, changesCount);\n        if (nonCheckboxChanges.size && nonCheckboxChanges.has(sectionCount)) {\n          changesChunk = [...changesChunk, ...nonCheckboxChanges.get(sectionCount)];\n        }\n        hotInstance.setDataAtCell(changesChunk);\n      });\n    }\n  }\n\n  /**\n   * Check whether all selected cells are with checkbox type.\n   *\n   * @returns {boolean}\n   * @private\n   */\n  function areSelectedCheckboxCells() {\n    const selRange = hotInstance.getSelectedRange();\n    if (!selRange) {\n      return;\n    }\n    for (let key = 0; key < selRange.length; key++) {\n      const topLeft = selRange[key].getTopStartCorner();\n      const bottomRight = selRange[key].getBottomEndCorner();\n      for (let visualRow = topLeft.row; visualRow <= bottomRight.row; visualRow++) {\n        for (let visualColumn = topLeft.col; visualColumn <= bottomRight.col; visualColumn++) {\n          const cachedCellProperties = hotInstance.getCellMeta(visualRow, visualColumn);\n          const cell = hotInstance.getCell(visualRow, visualColumn);\n          if (cell === null || cell === undefined) {\n            return true;\n          } else {\n            const checkboxes = cell.querySelectorAll('input[type=checkbox]');\n            if (checkboxes.length > 0 && !cachedCellProperties.readOnly) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n    return false;\n  }\n}\ncheckboxRenderer.RENDERER_TYPE = RENDERER_TYPE;\n\n/**\n * Register checkbox listeners.\n *\n * @param {Core} instance The Handsontable instance.\n * @returns {EventManager}\n */\nfunction registerEvents(instance) {\n  let eventManager = isCheckboxListenerAdded.get(instance);\n  if (!eventManager) {\n    const {\n      rootElement\n    } = instance;\n    eventManager = new EventManager(instance);\n    eventManager.addEventListener(rootElement, 'click', event => onClick(event, instance));\n    eventManager.addEventListener(rootElement, 'mouseup', event => onMouseUp(event, instance));\n    eventManager.addEventListener(rootElement, 'change', event => onChange(event, instance));\n    isCheckboxListenerAdded.set(instance, eventManager);\n  }\n  return eventManager;\n}\n\n/**\n * Create input element.\n *\n * @param {Document} rootDocument The document owner.\n * @returns {Node}\n */\nfunction createInput(rootDocument) {\n  const input = rootDocument.createElement('input');\n  input.className = 'htCheckboxRendererInput';\n  input.type = 'checkbox';\n  input.setAttribute('tabindex', '-1');\n  return input.cloneNode(false);\n}\n\n/**\n * Create label element.\n *\n * @param {Document} rootDocument The document owner.\n * @param {string} text The label text.\n * @param {boolean} fullWidth Determines whether label should have full width.\n * @returns {Node}\n */\nfunction createLabel(rootDocument, text, fullWidth) {\n  const label = rootDocument.createElement('label');\n  label.className = `htCheckboxRendererLabel ${fullWidth ? 'fullWidth' : ''}`;\n  label.appendChild(rootDocument.createTextNode(text));\n  return label.cloneNode(true);\n}\n\n/**\n * `mouseup` callback.\n *\n * @private\n * @param {Event} event `mouseup` event.\n * @param {Core} instance The Handsontable instance.\n */\nfunction onMouseUp(event, instance) {\n  const {\n    target\n  } = event;\n  if (!isCheckboxInput(target)) {\n    return;\n  }\n  if (!target.hasAttribute(ATTR_ROW) || !target.hasAttribute(ATTR_COLUMN)) {\n    return;\n  }\n  setTimeout(instance.listen, 10);\n}\n\n/**\n * `click` callback.\n *\n * @private\n * @param {MouseEvent} event `click` event.\n * @param {Core} instance The Handsontable instance.\n */\nfunction onClick(event, instance) {\n  const {\n    target\n  } = event;\n  if (!isCheckboxInput(target)) {\n    return;\n  }\n  if (!target.hasAttribute(ATTR_ROW) || !target.hasAttribute(ATTR_COLUMN)) {\n    return;\n  }\n  const row = parseInt(target.getAttribute(ATTR_ROW), 10);\n  const col = parseInt(target.getAttribute(ATTR_COLUMN), 10);\n  const cellProperties = instance.getCellMeta(row, col);\n  if (cellProperties.readOnly) {\n    event.preventDefault();\n  }\n}\n\n/**\n * `change` callback.\n *\n * @param {Event} event `change` event.\n * @param {Core} instance The Handsontable instance.\n */\nfunction onChange(event, instance) {\n  const {\n    target\n  } = event;\n  if (!isCheckboxInput(target)) {\n    return;\n  }\n  if (!target.hasAttribute(ATTR_ROW) || !target.hasAttribute(ATTR_COLUMN)) {\n    return;\n  }\n  const row = parseInt(target.getAttribute(ATTR_ROW), 10);\n  const col = parseInt(target.getAttribute(ATTR_COLUMN), 10);\n  const cellProperties = instance.getCellMeta(row, col);\n  if (!cellProperties.readOnly) {\n    let newCheckboxValue = null;\n    if (event.target.checked) {\n      newCheckboxValue = cellProperties.uncheckedTemplate === undefined ? true : cellProperties.checkedTemplate;\n    } else {\n      newCheckboxValue = cellProperties.uncheckedTemplate === undefined ? false : cellProperties.uncheckedTemplate;\n    }\n    instance.setDataAtCell(row, col, newCheckboxValue);\n  }\n}\n\n/**\n * Check if the provided element is the checkbox input.\n *\n * @private\n * @param {HTMLElement} element The element in question.\n * @returns {boolean}\n */\nfunction isCheckboxInput(element) {\n  return element.tagName === 'INPUT' && element.getAttribute('type') === 'checkbox';\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}