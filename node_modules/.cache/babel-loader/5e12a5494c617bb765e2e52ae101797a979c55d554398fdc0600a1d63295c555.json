{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nimport { innerHeight, innerWidth, getScrollLeft, getScrollTop, offset } from \"./../../../helpers/dom/element.mjs\";\n/**\n * @class Scroll\n */\n\nvar Scroll = /*#__PURE__*/function () {\n  /**\n   * @param {Walkontable} wotInstance The Walkontable instance.\n   */\n  function Scroll(wotInstance) {\n    _classCallCheck(this, Scroll);\n    this.wot = wotInstance;\n  }\n  /**\n   * Scrolls viewport to a cell.\n   *\n   * @param {CellCoords} coords The cell coordinates.\n   * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.\n   * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right of the table.\n   * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom of the table.\n   * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left of the table.\n   * @returns {boolean}\n   */\n\n  _createClass(Scroll, [{\n    key: \"scrollViewport\",\n    value: function scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft) {\n      if (coords.col < 0 || coords.row < 0) {\n        return false;\n      }\n      var scrolledHorizontally = this.scrollViewportHorizontally(coords.col, snapToRight, snapToLeft);\n      var scrolledVertically = this.scrollViewportVertically(coords.row, snapToTop, snapToBottom);\n      return scrolledHorizontally || scrolledVertically;\n    }\n    /**\n     * Scrolls viewport to a column.\n     *\n     * @param {number} column Visual column index.\n     * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right of the table.\n     * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left of the table.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"scrollViewportHorizontally\",\n    value: function scrollViewportHorizontally(column, snapToRight, snapToLeft) {\n      if (!this.wot.drawn) {\n        return false;\n      }\n      var _this$_getVariables = this._getVariables(),\n        fixedColumnsLeft = _this$_getVariables.fixedColumnsLeft,\n        leftOverlay = _this$_getVariables.leftOverlay,\n        totalColumns = _this$_getVariables.totalColumns;\n      var result = false;\n      if (column >= 0 && column <= Math.max(totalColumns - 1, 0)) {\n        var firstVisibleColumn = this.getFirstVisibleColumn();\n        var lastVisibleColumn = this.getLastVisibleColumn();\n        if (column >= fixedColumnsLeft && firstVisibleColumn > -1 && (column < firstVisibleColumn || snapToLeft)) {\n          result = leftOverlay.scrollTo(column);\n        } else if (lastVisibleColumn === -1 || lastVisibleColumn > -1 && (column > lastVisibleColumn || snapToRight)) {\n          result = leftOverlay.scrollTo(column, true);\n        }\n      }\n      return result;\n    }\n    /**\n     * Scrolls viewport to a row.\n     *\n     * @param {number} row Visual row index.\n     * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.\n     * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom of the table.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"scrollViewportVertically\",\n    value: function scrollViewportVertically(row, snapToTop, snapToBottom) {\n      if (!this.wot.drawn) {\n        return false;\n      }\n      var _this$_getVariables2 = this._getVariables(),\n        fixedRowsBottom = _this$_getVariables2.fixedRowsBottom,\n        fixedRowsTop = _this$_getVariables2.fixedRowsTop,\n        topOverlay = _this$_getVariables2.topOverlay,\n        totalRows = _this$_getVariables2.totalRows;\n      var result = false;\n      if (row >= 0 && row <= Math.max(totalRows - 1, 0)) {\n        var firstVisibleRow = this.getFirstVisibleRow();\n        var lastVisibleRow = this.getLastVisibleRow();\n        if (row >= fixedRowsTop && firstVisibleRow > -1 && (row < firstVisibleRow || snapToTop)) {\n          result = topOverlay.scrollTo(row);\n        } else if (lastVisibleRow === -1 || lastVisibleRow > -1 && (row > lastVisibleRow && row < totalRows - fixedRowsBottom || snapToBottom)) {\n          result = topOverlay.scrollTo(row, true);\n        }\n      }\n      return result;\n    }\n    /**\n     * Get first visible row based on virtual dom and how table is visible in browser window viewport.\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"getFirstVisibleRow\",\n    value: function getFirstVisibleRow() {\n      var _this$_getVariables3 = this._getVariables(),\n        topOverlay = _this$_getVariables3.topOverlay,\n        wtTable = _this$_getVariables3.wtTable,\n        wtViewport = _this$_getVariables3.wtViewport,\n        totalRows = _this$_getVariables3.totalRows,\n        fixedRowsTop = _this$_getVariables3.fixedRowsTop;\n      var rootWindow = this.wot.rootWindow;\n      var firstVisibleRow = wtTable.getFirstVisibleRow();\n      if (topOverlay.mainTableScrollableElement === rootWindow) {\n        var rootElementOffset = offset(wtTable.wtRootElement);\n        var totalTableHeight = innerHeight(wtTable.hider);\n        var windowHeight = innerHeight(rootWindow);\n        var windowScrollTop = getScrollTop(rootWindow, rootWindow); // Only calculate firstVisibleRow when table didn't filled (from up) whole viewport space\n\n        if (rootElementOffset.top + totalTableHeight - windowHeight <= windowScrollTop) {\n          var rowsHeight = wtViewport.getColumnHeaderHeight();\n          rowsHeight += topOverlay.sumCellSizes(0, fixedRowsTop);\n          for (var row = totalRows; row > 0; row--) {\n            rowsHeight += topOverlay.sumCellSizes(row - 1, row);\n            if (rootElementOffset.top + totalTableHeight - rowsHeight <= windowScrollTop) {\n              // Return physical row + 1\n              firstVisibleRow = row;\n              break;\n            }\n          }\n        }\n      }\n      return firstVisibleRow;\n    }\n    /**\n     * Get last visible row based on virtual dom and how table is visible in browser window viewport.\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"getLastVisibleRow\",\n    value: function getLastVisibleRow() {\n      var _this$_getVariables4 = this._getVariables(),\n        topOverlay = _this$_getVariables4.topOverlay,\n        wtTable = _this$_getVariables4.wtTable,\n        wtViewport = _this$_getVariables4.wtViewport,\n        totalRows = _this$_getVariables4.totalRows;\n      var rootWindow = this.wot.rootWindow;\n      var lastVisibleRow = wtTable.getLastVisibleRow();\n      if (topOverlay.mainTableScrollableElement === rootWindow) {\n        var rootElementOffset = offset(wtTable.wtRootElement);\n        var windowScrollTop = getScrollTop(rootWindow, rootWindow); // Only calculate lastVisibleRow when table didn't filled (from bottom) whole viewport space\n\n        if (rootElementOffset.top > windowScrollTop) {\n          var windowHeight = innerHeight(rootWindow);\n          var rowsHeight = wtViewport.getColumnHeaderHeight();\n          for (var row = 1; row <= totalRows; row++) {\n            rowsHeight += topOverlay.sumCellSizes(row - 1, row);\n            if (rootElementOffset.top + rowsHeight - windowScrollTop >= windowHeight) {\n              // Return physical row - 1 (-2 because rangeEach gives row index + 1 - sumCellSizes requirements)\n              lastVisibleRow = row - 2;\n              break;\n            }\n          }\n        }\n      }\n      return lastVisibleRow;\n    }\n    /**\n     * Get first visible column based on virtual dom and how table is visible in browser window viewport.\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"getFirstVisibleColumn\",\n    value: function getFirstVisibleColumn() {\n      var _this$_getVariables5 = this._getVariables(),\n        leftOverlay = _this$_getVariables5.leftOverlay,\n        wtTable = _this$_getVariables5.wtTable,\n        wtViewport = _this$_getVariables5.wtViewport,\n        totalColumns = _this$_getVariables5.totalColumns;\n      var rootWindow = this.wot.rootWindow;\n      var firstVisibleColumn = wtTable.getFirstVisibleColumn();\n      if (leftOverlay.mainTableScrollableElement === rootWindow) {\n        var rootElementOffset = offset(wtTable.wtRootElement);\n        var totalTableWidth = innerWidth(wtTable.hider);\n        var windowWidth = innerWidth(rootWindow);\n        var windowScrollLeft = getScrollLeft(rootWindow, rootWindow); // Only calculate firstVisibleColumn when table didn't filled (from left) whole viewport space\n\n        if (rootElementOffset.left + totalTableWidth - windowWidth <= windowScrollLeft) {\n          var columnsWidth = wtViewport.getRowHeaderWidth();\n          for (var column = totalColumns; column > 0; column--) {\n            columnsWidth += leftOverlay.sumCellSizes(column - 1, column);\n            if (rootElementOffset.left + totalTableWidth - columnsWidth <= windowScrollLeft) {\n              // Return physical column + 1\n              firstVisibleColumn = column;\n              break;\n            }\n          }\n        }\n      }\n      return firstVisibleColumn;\n    }\n    /**\n     * Get last visible column based on virtual dom and how table is visible in browser window viewport.\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"getLastVisibleColumn\",\n    value: function getLastVisibleColumn() {\n      var _this$_getVariables6 = this._getVariables(),\n        leftOverlay = _this$_getVariables6.leftOverlay,\n        wtTable = _this$_getVariables6.wtTable,\n        wtViewport = _this$_getVariables6.wtViewport,\n        totalColumns = _this$_getVariables6.totalColumns;\n      var rootWindow = this.wot.rootWindow;\n      var lastVisibleColumn = wtTable.getLastVisibleColumn();\n      if (leftOverlay.mainTableScrollableElement === rootWindow) {\n        var rootElementOffset = offset(wtTable.wtRootElement);\n        var windowScrollLeft = getScrollLeft(rootWindow, rootWindow); // Only calculate lastVisibleColumn when table didn't filled (from right) whole viewport space\n\n        if (rootElementOffset.left > windowScrollLeft) {\n          var windowWidth = innerWidth(rootWindow);\n          var columnsWidth = wtViewport.getRowHeaderWidth();\n          for (var column = 1; column <= totalColumns; column++) {\n            columnsWidth += leftOverlay.sumCellSizes(column - 1, column);\n            if (rootElementOffset.left + columnsWidth - windowScrollLeft >= windowWidth) {\n              // Return physical column - 1 (-2 because rangeEach gives column index + 1 - sumCellSizes requirements)\n              lastVisibleColumn = column - 2;\n              break;\n            }\n          }\n        }\n      }\n      return lastVisibleColumn;\n    }\n    /**\n     * Returns collection of variables used to rows and columns visibility calculations.\n     *\n     * @returns {object}\n     * @private\n     */\n  }, {\n    key: \"_getVariables\",\n    value: function _getVariables() {\n      var wot = this.wot;\n      var topOverlay = wot.wtOverlays.topOverlay;\n      var leftOverlay = wot.wtOverlays.leftOverlay;\n      var wtTable = wot.wtTable;\n      var wtViewport = wot.wtViewport;\n      var totalRows = wot.getSetting('totalRows');\n      var totalColumns = wot.getSetting('totalColumns');\n      var fixedRowsTop = wot.getSetting('fixedRowsTop');\n      var fixedRowsBottom = wot.getSetting('fixedRowsBottom');\n      var fixedColumnsLeft = wot.getSetting('fixedColumnsLeft');\n      return {\n        topOverlay: topOverlay,\n        leftOverlay: leftOverlay,\n        wtTable: wtTable,\n        wtViewport: wtViewport,\n        totalRows: totalRows,\n        totalColumns: totalColumns,\n        fixedRowsTop: fixedRowsTop,\n        fixedRowsBottom: fixedRowsBottom,\n        fixedColumnsLeft: fixedColumnsLeft\n      };\n    }\n  }]);\n  return Scroll;\n}();\nexport default Scroll;","map":{"version":3,"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","innerHeight","innerWidth","getScrollLeft","getScrollTop","offset","Scroll","wotInstance","wot","value","scrollViewport","coords","snapToTop","snapToRight","snapToBottom","snapToLeft","col","row","scrolledHorizontally","scrollViewportHorizontally","scrolledVertically","scrollViewportVertically","column","drawn","_this$_getVariables","_getVariables","fixedColumnsLeft","leftOverlay","totalColumns","result","Math","max","firstVisibleColumn","getFirstVisibleColumn","lastVisibleColumn","getLastVisibleColumn","scrollTo","_this$_getVariables2","fixedRowsBottom","fixedRowsTop","topOverlay","totalRows","firstVisibleRow","getFirstVisibleRow","lastVisibleRow","getLastVisibleRow","_this$_getVariables3","wtTable","wtViewport","rootWindow","mainTableScrollableElement","rootElementOffset","wtRootElement","totalTableHeight","hider","windowHeight","windowScrollTop","top","rowsHeight","getColumnHeaderHeight","sumCellSizes","_this$_getVariables4","_this$_getVariables5","totalTableWidth","windowWidth","windowScrollLeft","left","columnsWidth","getRowHeaderWidth","_this$_getVariables6","wtOverlays","getSetting"],"sources":["/Users/priyadeliwala/Desktop/sales-dashboard/node_modules/handsontable/3rdparty/walkontable/src/scroll.mjs"],"sourcesContent":["function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nimport { innerHeight, innerWidth, getScrollLeft, getScrollTop, offset } from \"./../../../helpers/dom/element.mjs\";\n/**\n * @class Scroll\n */\n\nvar Scroll = /*#__PURE__*/function () {\n  /**\n   * @param {Walkontable} wotInstance The Walkontable instance.\n   */\n  function Scroll(wotInstance) {\n    _classCallCheck(this, Scroll);\n\n    this.wot = wotInstance;\n  }\n  /**\n   * Scrolls viewport to a cell.\n   *\n   * @param {CellCoords} coords The cell coordinates.\n   * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.\n   * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right of the table.\n   * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom of the table.\n   * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left of the table.\n   * @returns {boolean}\n   */\n\n\n  _createClass(Scroll, [{\n    key: \"scrollViewport\",\n    value: function scrollViewport(coords, snapToTop, snapToRight, snapToBottom, snapToLeft) {\n      if (coords.col < 0 || coords.row < 0) {\n        return false;\n      }\n\n      var scrolledHorizontally = this.scrollViewportHorizontally(coords.col, snapToRight, snapToLeft);\n      var scrolledVertically = this.scrollViewportVertically(coords.row, snapToTop, snapToBottom);\n      return scrolledHorizontally || scrolledVertically;\n    }\n    /**\n     * Scrolls viewport to a column.\n     *\n     * @param {number} column Visual column index.\n     * @param {boolean} [snapToRight] If `true`, viewport is scrolled to show the cell on the right of the table.\n     * @param {boolean} [snapToLeft] If `true`, viewport is scrolled to show the cell on the left of the table.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"scrollViewportHorizontally\",\n    value: function scrollViewportHorizontally(column, snapToRight, snapToLeft) {\n      if (!this.wot.drawn) {\n        return false;\n      }\n\n      var _this$_getVariables = this._getVariables(),\n          fixedColumnsLeft = _this$_getVariables.fixedColumnsLeft,\n          leftOverlay = _this$_getVariables.leftOverlay,\n          totalColumns = _this$_getVariables.totalColumns;\n\n      var result = false;\n\n      if (column >= 0 && column <= Math.max(totalColumns - 1, 0)) {\n        var firstVisibleColumn = this.getFirstVisibleColumn();\n        var lastVisibleColumn = this.getLastVisibleColumn();\n\n        if (column >= fixedColumnsLeft && firstVisibleColumn > -1 && (column < firstVisibleColumn || snapToLeft)) {\n          result = leftOverlay.scrollTo(column);\n        } else if (lastVisibleColumn === -1 || lastVisibleColumn > -1 && (column > lastVisibleColumn || snapToRight)) {\n          result = leftOverlay.scrollTo(column, true);\n        }\n      }\n\n      return result;\n    }\n    /**\n     * Scrolls viewport to a row.\n     *\n     * @param {number} row Visual row index.\n     * @param {boolean} [snapToTop] If `true`, viewport is scrolled to show the cell on the top of the table.\n     * @param {boolean} [snapToBottom] If `true`, viewport is scrolled to show the cell on the bottom of the table.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"scrollViewportVertically\",\n    value: function scrollViewportVertically(row, snapToTop, snapToBottom) {\n      if (!this.wot.drawn) {\n        return false;\n      }\n\n      var _this$_getVariables2 = this._getVariables(),\n          fixedRowsBottom = _this$_getVariables2.fixedRowsBottom,\n          fixedRowsTop = _this$_getVariables2.fixedRowsTop,\n          topOverlay = _this$_getVariables2.topOverlay,\n          totalRows = _this$_getVariables2.totalRows;\n\n      var result = false;\n\n      if (row >= 0 && row <= Math.max(totalRows - 1, 0)) {\n        var firstVisibleRow = this.getFirstVisibleRow();\n        var lastVisibleRow = this.getLastVisibleRow();\n\n        if (row >= fixedRowsTop && firstVisibleRow > -1 && (row < firstVisibleRow || snapToTop)) {\n          result = topOverlay.scrollTo(row);\n        } else if (lastVisibleRow === -1 || lastVisibleRow > -1 && (row > lastVisibleRow && row < totalRows - fixedRowsBottom || snapToBottom)) {\n          result = topOverlay.scrollTo(row, true);\n        }\n      }\n\n      return result;\n    }\n    /**\n     * Get first visible row based on virtual dom and how table is visible in browser window viewport.\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: \"getFirstVisibleRow\",\n    value: function getFirstVisibleRow() {\n      var _this$_getVariables3 = this._getVariables(),\n          topOverlay = _this$_getVariables3.topOverlay,\n          wtTable = _this$_getVariables3.wtTable,\n          wtViewport = _this$_getVariables3.wtViewport,\n          totalRows = _this$_getVariables3.totalRows,\n          fixedRowsTop = _this$_getVariables3.fixedRowsTop;\n\n      var rootWindow = this.wot.rootWindow;\n      var firstVisibleRow = wtTable.getFirstVisibleRow();\n\n      if (topOverlay.mainTableScrollableElement === rootWindow) {\n        var rootElementOffset = offset(wtTable.wtRootElement);\n        var totalTableHeight = innerHeight(wtTable.hider);\n        var windowHeight = innerHeight(rootWindow);\n        var windowScrollTop = getScrollTop(rootWindow, rootWindow); // Only calculate firstVisibleRow when table didn't filled (from up) whole viewport space\n\n        if (rootElementOffset.top + totalTableHeight - windowHeight <= windowScrollTop) {\n          var rowsHeight = wtViewport.getColumnHeaderHeight();\n          rowsHeight += topOverlay.sumCellSizes(0, fixedRowsTop);\n\n          for (var row = totalRows; row > 0; row--) {\n            rowsHeight += topOverlay.sumCellSizes(row - 1, row);\n\n            if (rootElementOffset.top + totalTableHeight - rowsHeight <= windowScrollTop) {\n              // Return physical row + 1\n              firstVisibleRow = row;\n              break;\n            }\n          }\n        }\n      }\n\n      return firstVisibleRow;\n    }\n    /**\n     * Get last visible row based on virtual dom and how table is visible in browser window viewport.\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: \"getLastVisibleRow\",\n    value: function getLastVisibleRow() {\n      var _this$_getVariables4 = this._getVariables(),\n          topOverlay = _this$_getVariables4.topOverlay,\n          wtTable = _this$_getVariables4.wtTable,\n          wtViewport = _this$_getVariables4.wtViewport,\n          totalRows = _this$_getVariables4.totalRows;\n\n      var rootWindow = this.wot.rootWindow;\n      var lastVisibleRow = wtTable.getLastVisibleRow();\n\n      if (topOverlay.mainTableScrollableElement === rootWindow) {\n        var rootElementOffset = offset(wtTable.wtRootElement);\n        var windowScrollTop = getScrollTop(rootWindow, rootWindow); // Only calculate lastVisibleRow when table didn't filled (from bottom) whole viewport space\n\n        if (rootElementOffset.top > windowScrollTop) {\n          var windowHeight = innerHeight(rootWindow);\n          var rowsHeight = wtViewport.getColumnHeaderHeight();\n\n          for (var row = 1; row <= totalRows; row++) {\n            rowsHeight += topOverlay.sumCellSizes(row - 1, row);\n\n            if (rootElementOffset.top + rowsHeight - windowScrollTop >= windowHeight) {\n              // Return physical row - 1 (-2 because rangeEach gives row index + 1 - sumCellSizes requirements)\n              lastVisibleRow = row - 2;\n              break;\n            }\n          }\n        }\n      }\n\n      return lastVisibleRow;\n    }\n    /**\n     * Get first visible column based on virtual dom and how table is visible in browser window viewport.\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: \"getFirstVisibleColumn\",\n    value: function getFirstVisibleColumn() {\n      var _this$_getVariables5 = this._getVariables(),\n          leftOverlay = _this$_getVariables5.leftOverlay,\n          wtTable = _this$_getVariables5.wtTable,\n          wtViewport = _this$_getVariables5.wtViewport,\n          totalColumns = _this$_getVariables5.totalColumns;\n\n      var rootWindow = this.wot.rootWindow;\n      var firstVisibleColumn = wtTable.getFirstVisibleColumn();\n\n      if (leftOverlay.mainTableScrollableElement === rootWindow) {\n        var rootElementOffset = offset(wtTable.wtRootElement);\n        var totalTableWidth = innerWidth(wtTable.hider);\n        var windowWidth = innerWidth(rootWindow);\n        var windowScrollLeft = getScrollLeft(rootWindow, rootWindow); // Only calculate firstVisibleColumn when table didn't filled (from left) whole viewport space\n\n        if (rootElementOffset.left + totalTableWidth - windowWidth <= windowScrollLeft) {\n          var columnsWidth = wtViewport.getRowHeaderWidth();\n\n          for (var column = totalColumns; column > 0; column--) {\n            columnsWidth += leftOverlay.sumCellSizes(column - 1, column);\n\n            if (rootElementOffset.left + totalTableWidth - columnsWidth <= windowScrollLeft) {\n              // Return physical column + 1\n              firstVisibleColumn = column;\n              break;\n            }\n          }\n        }\n      }\n\n      return firstVisibleColumn;\n    }\n    /**\n     * Get last visible column based on virtual dom and how table is visible in browser window viewport.\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: \"getLastVisibleColumn\",\n    value: function getLastVisibleColumn() {\n      var _this$_getVariables6 = this._getVariables(),\n          leftOverlay = _this$_getVariables6.leftOverlay,\n          wtTable = _this$_getVariables6.wtTable,\n          wtViewport = _this$_getVariables6.wtViewport,\n          totalColumns = _this$_getVariables6.totalColumns;\n\n      var rootWindow = this.wot.rootWindow;\n      var lastVisibleColumn = wtTable.getLastVisibleColumn();\n\n      if (leftOverlay.mainTableScrollableElement === rootWindow) {\n        var rootElementOffset = offset(wtTable.wtRootElement);\n        var windowScrollLeft = getScrollLeft(rootWindow, rootWindow); // Only calculate lastVisibleColumn when table didn't filled (from right) whole viewport space\n\n        if (rootElementOffset.left > windowScrollLeft) {\n          var windowWidth = innerWidth(rootWindow);\n          var columnsWidth = wtViewport.getRowHeaderWidth();\n\n          for (var column = 1; column <= totalColumns; column++) {\n            columnsWidth += leftOverlay.sumCellSizes(column - 1, column);\n\n            if (rootElementOffset.left + columnsWidth - windowScrollLeft >= windowWidth) {\n              // Return physical column - 1 (-2 because rangeEach gives column index + 1 - sumCellSizes requirements)\n              lastVisibleColumn = column - 2;\n              break;\n            }\n          }\n        }\n      }\n\n      return lastVisibleColumn;\n    }\n    /**\n     * Returns collection of variables used to rows and columns visibility calculations.\n     *\n     * @returns {object}\n     * @private\n     */\n\n  }, {\n    key: \"_getVariables\",\n    value: function _getVariables() {\n      var wot = this.wot;\n      var topOverlay = wot.wtOverlays.topOverlay;\n      var leftOverlay = wot.wtOverlays.leftOverlay;\n      var wtTable = wot.wtTable;\n      var wtViewport = wot.wtViewport;\n      var totalRows = wot.getSetting('totalRows');\n      var totalColumns = wot.getSetting('totalColumns');\n      var fixedRowsTop = wot.getSetting('fixedRowsTop');\n      var fixedRowsBottom = wot.getSetting('fixedRowsBottom');\n      var fixedColumnsLeft = wot.getSetting('fixedColumnsLeft');\n      return {\n        topOverlay: topOverlay,\n        leftOverlay: leftOverlay,\n        wtTable: wtTable,\n        wtViewport: wtViewport,\n        totalRows: totalRows,\n        totalColumns: totalColumns,\n        fixedRowsTop: fixedRowsTop,\n        fixedRowsBottom: fixedRowsBottom,\n        fixedColumnsLeft: fixedColumnsLeft\n      };\n    }\n  }]);\n\n  return Scroll;\n}();\n\nexport default Scroll;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}