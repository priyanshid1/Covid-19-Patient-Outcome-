{"ast":null,"code":"import _classCallCheck from \"/Users/priyadeliwala/Desktop/sales-dashboard/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/priyadeliwala/Desktop/sales-dashboard/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _callSuper from \"/Users/priyadeliwala/Desktop/sales-dashboard/node_modules/@babel/runtime/helpers/esm/callSuper.js\";\nimport _superPropGet from \"/Users/priyadeliwala/Desktop/sales-dashboard/node_modules/@babel/runtime/helpers/esm/superPropGet.js\";\nimport _inherits from \"/Users/priyadeliwala/Desktop/sales-dashboard/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nimport { Selection } from \"./../../3rdparty/walkontable/src/index.mjs\";\nvar VisualSelection = /*#__PURE__*/function (_Selection) {\n  function VisualSelection(settings, visualCellRange) {\n    var _this;\n    _classCallCheck(this, VisualSelection);\n    _this = _callSuper(this, VisualSelection, [settings, null]);\n    /**\n     * Range of selection visually. Visual representation may have representation in a rendered selection.\n     *\n     * @type {null|CellRange}\n     */\n    _defineProperty(_this, \"visualCellRange\", null);\n    _this.visualCellRange = visualCellRange || null;\n    _this.commit();\n    return _this;\n  }\n  /**\n   * Adds a cell coords to the selection.\n   *\n   * @param {CellCoords} coords Visual coordinates of a cell.\n   * @returns {VisualSelection}\n   */\n  _inherits(VisualSelection, _Selection);\n  return _createClass(VisualSelection, [{\n    key: \"add\",\n    value: function add(coords) {\n      if (this.visualCellRange === null) {\n        this.visualCellRange = this.settings.createCellRange(coords);\n      } else {\n        this.visualCellRange.expand(coords);\n      }\n      return this;\n    }\n\n    /**\n     * Clears visual and renderable selection.\n     *\n     * @returns {VisualSelection}\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.visualCellRange = null;\n      return _superPropGet(VisualSelection, \"clear\", this, 3)([]);\n    }\n\n    /**\n     * Trims the passed cell range object by removing all coordinates that points to the hidden rows\n     * or columns. The result is a new cell range object that points only to the visible indexes or `null`.\n     *\n     * @private\n     * @param {CellRange} cellRange Cells range object to be trimmed.\n     * @returns {CellRange} Visual non-hidden cells range coordinates.\n     */\n  }, {\n    key: \"trimToVisibleCellsRangeOnly\",\n    value: function trimToVisibleCellsRangeOnly(_ref) {\n      var from = _ref.from,\n        to = _ref.to;\n      var visibleFromCoords = this.getNearestNotHiddenCoords(from, 1);\n      var visibleToCoords = this.getNearestNotHiddenCoords(to, -1);\n      if (visibleFromCoords === null || visibleToCoords === null) {\n        return null;\n      }\n      if (visibleFromCoords.row > visibleToCoords.row || visibleFromCoords.col > visibleToCoords.col) {\n        visibleFromCoords = from;\n        visibleToCoords = to;\n      }\n      return this.settings.createCellRange(visibleFromCoords, visibleFromCoords, visibleToCoords);\n    }\n\n    /**\n     * Gets nearest coordinates that points to the visible row and column indexes. If there are no visible\n     * rows and/or columns the `null` value is returned.\n     *\n     * @private\n     * @param {CellCoords} coords The coords object as starting point for finding the nearest visible coordinates.\n     * @param {1|-1} rowSearchDirection The search direction. For value 1, it means searching from top to bottom for\n     *                                  rows and from left to right for columns. For -1, it is the other way around.\n     * @param {1|-1} columnSearchDirection The same as above but for rows.\n     * @returns {CellCoords|null} Visual cell coordinates.\n     */\n  }, {\n    key: \"getNearestNotHiddenCoords\",\n    value: function getNearestNotHiddenCoords(coords, rowSearchDirection) {\n      var columnSearchDirection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : rowSearchDirection;\n      var nextVisibleRow = this.getNearestNotHiddenIndex(this.settings.rowIndexMapper, coords.row, rowSearchDirection);\n\n      // There are no more visual rows in the range.\n      if (nextVisibleRow === null) {\n        return null;\n      }\n      var nextVisibleColumn = this.getNearestNotHiddenIndex(this.settings.columnIndexMapper, coords.col, columnSearchDirection);\n\n      // There are no more visual columns in the range.\n      if (nextVisibleColumn === null) {\n        return null;\n      }\n      return this.settings.createCellCoords(nextVisibleRow, nextVisibleColumn);\n    }\n\n    /**\n     * Gets nearest visual index. If there are no visible rows or columns the `null` value is returned.\n     *\n     * @private\n     * @param {IndexMapper} indexMapper The IndexMapper instance for specific axis.\n     * @param {number} visualIndex The index as starting point for finding the nearest visible index.\n     * @param {1|-1} searchDirection The search direction. For value 1, it means searching from top to bottom for\n     *                               rows and from left to right for columns. For -1, it is the other way around.\n     * @returns {number|null} Visual row/column index.\n     */\n  }, {\n    key: \"getNearestNotHiddenIndex\",\n    value: function getNearestNotHiddenIndex(indexMapper, visualIndex, searchDirection) {\n      if (visualIndex < 0) {\n        return visualIndex;\n      }\n      return indexMapper.getNearestNotHiddenIndex(visualIndex, searchDirection);\n    }\n\n    /**\n     * Override internally stored visual indexes added by the Selection's `add` function. It should be executed\n     * at the end of process of adding visual selection coordinates.\n     *\n     * @returns {VisualSelection}\n     */\n  }, {\n    key: \"commit\",\n    value: function commit() {\n      // There is no information about visual ranges, thus no selection may be displayed.\n      if (this.visualCellRange === null) {\n        return this;\n      }\n      var trimmedCellRange = this.trimToVisibleCellsRangeOnly(this.visualCellRange);\n\n      // There is no visual start point (and also visual end point) in the range.\n      if (trimmedCellRange === null) {\n        this.cellRange = null;\n      } else {\n        this.cellRange = this.createRenderableCellRange(trimmedCellRange.from, trimmedCellRange.to);\n      }\n      return this;\n    }\n\n    /**\n     * Some selection may be a part of broader cell range. This function sync coordinates of current selection\n     * and the broader cell range when needed (current selection can't be presented visually).\n     *\n     * @param {CellRange} broaderCellRange Visual range. Actual cell range may be contained in the broader cell range.\n     * When there is no way to represent some cell range visually we try to find range containing just the first visible cell.\n     *\n     * Warn: Please keep in mind that this function may change coordinates of the handled broader range.\n     *\n     * @returns {VisualSelection}\n     */\n  }, {\n    key: \"syncWith\",\n    value: function syncWith(broaderCellRange) {\n      var coordsFrom = broaderCellRange.from.clone().normalize();\n      var rowDirection = broaderCellRange.getVerticalDirection() === 'N-S' ? 1 : -1;\n      var columnDirection = broaderCellRange.getHorizontalDirection() === 'W-E' ? 1 : -1;\n      var renderableHighlight = this.settings.visualToRenderableCoords(this.visualCellRange.highlight);\n      var cellCoordsVisual = null;\n      if (renderableHighlight === null || renderableHighlight.col === null || renderableHighlight.row === null) {\n        cellCoordsVisual = this.getNearestNotHiddenCoords(coordsFrom, rowDirection, columnDirection);\n      }\n      if (cellCoordsVisual !== null && broaderCellRange.overlaps(cellCoordsVisual)) {\n        var currentHighlight = broaderCellRange.highlight.clone();\n        if (currentHighlight.row >= 0) {\n          currentHighlight.row = cellCoordsVisual.row;\n        }\n        if (currentHighlight.col >= 0) {\n          currentHighlight.col = cellCoordsVisual.col;\n        }\n\n        // We can't show selection visually now, but we found first visible range in the broader cell range.\n        if (this.cellRange === null) {\n          var cellCoordsRenderable = this.settings.visualToRenderableCoords(currentHighlight);\n          this.cellRange = this.settings.createCellRange(cellCoordsRenderable);\n        }\n\n        // TODO\n        // We set new highlight as it might change (for example, when showing/hiding some cells from the broader selection range)\n        // TODO: It is also handled by the `MergeCells` plugin while adjusting already modified coordinates. Should it?\n        broaderCellRange.setHighlight(currentHighlight);\n      }\n\n      // TODO\n      // Sync the highlight coords from the visual selection layer with logical coords.\n      if (this.settings.selectionType === 'focus' && renderableHighlight !== null && cellCoordsVisual === null) {\n        broaderCellRange.setHighlight(this.visualCellRange.highlight);\n      }\n      return this;\n    }\n\n    /**\n     * Returns the top left (TL) and bottom right (BR) selection coordinates (renderable indexes).\n     * The method overwrites the original method to support header selection for hidden cells.\n     * To make the header selection working, the CellCoords and CellRange have to support not\n     * complete coordinates (`null` values for example, `row: null`, `col: 2`).\n     *\n     * @returns {Array} Returns array of coordinates for example `[1, 1, 5, 5]`.\n     */\n  }, {\n    key: \"getCorners\",\n    value: function getCorners() {\n      var _this$cellRange = this.cellRange,\n        from = _this$cellRange.from,\n        to = _this$cellRange.to;\n      return [Math.min(from.row, to.row), Math.min(from.col, to.col), Math.max(from.row, to.row), Math.max(from.col, to.col)];\n    }\n\n    /**\n     * Returns the top left (or top right in RTL) and bottom right (or bottom left in RTL) selection\n     * coordinates (visual indexes).\n     *\n     * @returns {Array} Returns array of coordinates for example `[1, 1, 5, 5]`.\n     */\n  }, {\n    key: \"getVisualCorners\",\n    value: function getVisualCorners() {\n      var topStart = this.settings.renderableToVisualCoords(this.cellRange.getTopStartCorner());\n      var bottomEnd = this.settings.renderableToVisualCoords(this.cellRange.getBottomEndCorner());\n      return [topStart.row, topStart.col, bottomEnd.row, bottomEnd.col];\n    }\n\n    /**\n     * Creates a new CellRange object based on visual coordinates which before object creation are\n     * translated to renderable indexes.\n     *\n     * @param {CellCoords} visualFromCoords The CellCoords object which contains coordinates that\n     *                                      points to the beginning of the selection.\n     * @param {CellCoords} visualToCoords The CellCoords object which contains coordinates that\n     *                                    points to the end of the selection.\n     * @returns {CellRange|null}\n     */\n  }, {\n    key: \"createRenderableCellRange\",\n    value: function createRenderableCellRange(visualFromCoords, visualToCoords) {\n      var renderableFromCoords = this.settings.visualToRenderableCoords(visualFromCoords);\n      var renderableToCoords = this.settings.visualToRenderableCoords(visualToCoords);\n      if (renderableFromCoords.row === null || renderableFromCoords.col === null || renderableToCoords.row === null || renderableToCoords.col === null) {\n        return null;\n      }\n      return this.settings.createCellRange(renderableFromCoords, renderableFromCoords, renderableToCoords);\n    }\n  }]);\n}(Selection);\nexport default VisualSelection;","map":{"version":3,"names":["_defineProperty","e","r","t","_toPropertyKey","Object","defineProperty","value","enumerable","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","TypeError","String","Number","Selection","VisualSelection","_Selection","settings","visualCellRange","_this","_classCallCheck","_callSuper","commit","_inherits","_createClass","key","add","coords","createCellRange","expand","clear","_superPropGet","trimToVisibleCellsRangeOnly","_ref","from","to","visibleFromCoords","getNearestNotHiddenCoords","visibleToCoords","row","col","rowSearchDirection","columnSearchDirection","arguments","length","undefined","nextVisibleRow","getNearestNotHiddenIndex","rowIndexMapper","nextVisibleColumn","columnIndexMapper","createCellCoords","indexMapper","visualIndex","searchDirection","trimmedCellRange","cellRange","createRenderableCellRange","syncWith","broaderCellRange","coordsFrom","clone","normalize","rowDirection","getVerticalDirection","columnDirection","getHorizontalDirection","renderableHighlight","visualToRenderableCoords","highlight","cellCoordsVisual","overlaps","currentHighlight","cellCoordsRenderable","setHighlight","selectionType","getCorners","_this$cellRange","Math","min","max","getVisualCorners","topStart","renderableToVisualCoords","getTopStartCorner","bottomEnd","getBottomEndCorner","visualFromCoords","visualToCoords","renderableFromCoords","renderableToCoords"],"sources":["/Users/priyadeliwala/node_modules/handsontable/selection/highlight/visualSelection.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport { Selection } from \"./../../3rdparty/walkontable/src/index.mjs\";\nclass VisualSelection extends Selection {\n  constructor(settings, visualCellRange) {\n    super(settings, null);\n    /**\n     * Range of selection visually. Visual representation may have representation in a rendered selection.\n     *\n     * @type {null|CellRange}\n     */\n    _defineProperty(this, \"visualCellRange\", null);\n    this.visualCellRange = visualCellRange || null;\n    this.commit();\n  }\n  /**\n   * Adds a cell coords to the selection.\n   *\n   * @param {CellCoords} coords Visual coordinates of a cell.\n   * @returns {VisualSelection}\n   */\n  add(coords) {\n    if (this.visualCellRange === null) {\n      this.visualCellRange = this.settings.createCellRange(coords);\n    } else {\n      this.visualCellRange.expand(coords);\n    }\n    return this;\n  }\n\n  /**\n   * Clears visual and renderable selection.\n   *\n   * @returns {VisualSelection}\n   */\n  clear() {\n    this.visualCellRange = null;\n    return super.clear();\n  }\n\n  /**\n   * Trims the passed cell range object by removing all coordinates that points to the hidden rows\n   * or columns. The result is a new cell range object that points only to the visible indexes or `null`.\n   *\n   * @private\n   * @param {CellRange} cellRange Cells range object to be trimmed.\n   * @returns {CellRange} Visual non-hidden cells range coordinates.\n   */\n  trimToVisibleCellsRangeOnly(_ref) {\n    let {\n      from,\n      to\n    } = _ref;\n    let visibleFromCoords = this.getNearestNotHiddenCoords(from, 1);\n    let visibleToCoords = this.getNearestNotHiddenCoords(to, -1);\n    if (visibleFromCoords === null || visibleToCoords === null) {\n      return null;\n    }\n    if (visibleFromCoords.row > visibleToCoords.row || visibleFromCoords.col > visibleToCoords.col) {\n      visibleFromCoords = from;\n      visibleToCoords = to;\n    }\n    return this.settings.createCellRange(visibleFromCoords, visibleFromCoords, visibleToCoords);\n  }\n\n  /**\n   * Gets nearest coordinates that points to the visible row and column indexes. If there are no visible\n   * rows and/or columns the `null` value is returned.\n   *\n   * @private\n   * @param {CellCoords} coords The coords object as starting point for finding the nearest visible coordinates.\n   * @param {1|-1} rowSearchDirection The search direction. For value 1, it means searching from top to bottom for\n   *                                  rows and from left to right for columns. For -1, it is the other way around.\n   * @param {1|-1} columnSearchDirection The same as above but for rows.\n   * @returns {CellCoords|null} Visual cell coordinates.\n   */\n  getNearestNotHiddenCoords(coords, rowSearchDirection) {\n    let columnSearchDirection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : rowSearchDirection;\n    const nextVisibleRow = this.getNearestNotHiddenIndex(this.settings.rowIndexMapper, coords.row, rowSearchDirection);\n\n    // There are no more visual rows in the range.\n    if (nextVisibleRow === null) {\n      return null;\n    }\n    const nextVisibleColumn = this.getNearestNotHiddenIndex(this.settings.columnIndexMapper, coords.col, columnSearchDirection);\n\n    // There are no more visual columns in the range.\n    if (nextVisibleColumn === null) {\n      return null;\n    }\n    return this.settings.createCellCoords(nextVisibleRow, nextVisibleColumn);\n  }\n\n  /**\n   * Gets nearest visual index. If there are no visible rows or columns the `null` value is returned.\n   *\n   * @private\n   * @param {IndexMapper} indexMapper The IndexMapper instance for specific axis.\n   * @param {number} visualIndex The index as starting point for finding the nearest visible index.\n   * @param {1|-1} searchDirection The search direction. For value 1, it means searching from top to bottom for\n   *                               rows and from left to right for columns. For -1, it is the other way around.\n   * @returns {number|null} Visual row/column index.\n   */\n  getNearestNotHiddenIndex(indexMapper, visualIndex, searchDirection) {\n    if (visualIndex < 0) {\n      return visualIndex;\n    }\n    return indexMapper.getNearestNotHiddenIndex(visualIndex, searchDirection);\n  }\n\n  /**\n   * Override internally stored visual indexes added by the Selection's `add` function. It should be executed\n   * at the end of process of adding visual selection coordinates.\n   *\n   * @returns {VisualSelection}\n   */\n  commit() {\n    // There is no information about visual ranges, thus no selection may be displayed.\n    if (this.visualCellRange === null) {\n      return this;\n    }\n    const trimmedCellRange = this.trimToVisibleCellsRangeOnly(this.visualCellRange);\n\n    // There is no visual start point (and also visual end point) in the range.\n    if (trimmedCellRange === null) {\n      this.cellRange = null;\n    } else {\n      this.cellRange = this.createRenderableCellRange(trimmedCellRange.from, trimmedCellRange.to);\n    }\n    return this;\n  }\n\n  /**\n   * Some selection may be a part of broader cell range. This function sync coordinates of current selection\n   * and the broader cell range when needed (current selection can't be presented visually).\n   *\n   * @param {CellRange} broaderCellRange Visual range. Actual cell range may be contained in the broader cell range.\n   * When there is no way to represent some cell range visually we try to find range containing just the first visible cell.\n   *\n   * Warn: Please keep in mind that this function may change coordinates of the handled broader range.\n   *\n   * @returns {VisualSelection}\n   */\n  syncWith(broaderCellRange) {\n    const coordsFrom = broaderCellRange.from.clone().normalize();\n    const rowDirection = broaderCellRange.getVerticalDirection() === 'N-S' ? 1 : -1;\n    const columnDirection = broaderCellRange.getHorizontalDirection() === 'W-E' ? 1 : -1;\n    const renderableHighlight = this.settings.visualToRenderableCoords(this.visualCellRange.highlight);\n    let cellCoordsVisual = null;\n    if (renderableHighlight === null || renderableHighlight.col === null || renderableHighlight.row === null) {\n      cellCoordsVisual = this.getNearestNotHiddenCoords(coordsFrom, rowDirection, columnDirection);\n    }\n    if (cellCoordsVisual !== null && broaderCellRange.overlaps(cellCoordsVisual)) {\n      const currentHighlight = broaderCellRange.highlight.clone();\n      if (currentHighlight.row >= 0) {\n        currentHighlight.row = cellCoordsVisual.row;\n      }\n      if (currentHighlight.col >= 0) {\n        currentHighlight.col = cellCoordsVisual.col;\n      }\n\n      // We can't show selection visually now, but we found first visible range in the broader cell range.\n      if (this.cellRange === null) {\n        const cellCoordsRenderable = this.settings.visualToRenderableCoords(currentHighlight);\n        this.cellRange = this.settings.createCellRange(cellCoordsRenderable);\n      }\n\n      // TODO\n      // We set new highlight as it might change (for example, when showing/hiding some cells from the broader selection range)\n      // TODO: It is also handled by the `MergeCells` plugin while adjusting already modified coordinates. Should it?\n      broaderCellRange.setHighlight(currentHighlight);\n    }\n\n    // TODO\n    // Sync the highlight coords from the visual selection layer with logical coords.\n    if (this.settings.selectionType === 'focus' && renderableHighlight !== null && cellCoordsVisual === null) {\n      broaderCellRange.setHighlight(this.visualCellRange.highlight);\n    }\n    return this;\n  }\n\n  /**\n   * Returns the top left (TL) and bottom right (BR) selection coordinates (renderable indexes).\n   * The method overwrites the original method to support header selection for hidden cells.\n   * To make the header selection working, the CellCoords and CellRange have to support not\n   * complete coordinates (`null` values for example, `row: null`, `col: 2`).\n   *\n   * @returns {Array} Returns array of coordinates for example `[1, 1, 5, 5]`.\n   */\n  getCorners() {\n    const {\n      from,\n      to\n    } = this.cellRange;\n    return [Math.min(from.row, to.row), Math.min(from.col, to.col), Math.max(from.row, to.row), Math.max(from.col, to.col)];\n  }\n\n  /**\n   * Returns the top left (or top right in RTL) and bottom right (or bottom left in RTL) selection\n   * coordinates (visual indexes).\n   *\n   * @returns {Array} Returns array of coordinates for example `[1, 1, 5, 5]`.\n   */\n  getVisualCorners() {\n    const topStart = this.settings.renderableToVisualCoords(this.cellRange.getTopStartCorner());\n    const bottomEnd = this.settings.renderableToVisualCoords(this.cellRange.getBottomEndCorner());\n    return [topStart.row, topStart.col, bottomEnd.row, bottomEnd.col];\n  }\n\n  /**\n   * Creates a new CellRange object based on visual coordinates which before object creation are\n   * translated to renderable indexes.\n   *\n   * @param {CellCoords} visualFromCoords The CellCoords object which contains coordinates that\n   *                                      points to the beginning of the selection.\n   * @param {CellCoords} visualToCoords The CellCoords object which contains coordinates that\n   *                                    points to the end of the selection.\n   * @returns {CellRange|null}\n   */\n  createRenderableCellRange(visualFromCoords, visualToCoords) {\n    const renderableFromCoords = this.settings.visualToRenderableCoords(visualFromCoords);\n    const renderableToCoords = this.settings.visualToRenderableCoords(visualToCoords);\n    if (renderableFromCoords.row === null || renderableFromCoords.col === null || renderableToCoords.row === null || renderableToCoords.col === null) {\n      return null;\n    }\n    return this.settings.createCellRange(renderableFromCoords, renderableFromCoords, renderableToCoords);\n  }\n}\nexport default VisualSelection;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}