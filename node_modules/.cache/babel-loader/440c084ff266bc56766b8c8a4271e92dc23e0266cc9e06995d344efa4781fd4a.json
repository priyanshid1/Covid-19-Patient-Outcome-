{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _s, _e;\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n  return _arr;\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _get() {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n      if (desc.get) {\n        return desc.get.call(arguments.length < 3 ? target : receiver);\n      }\n      return desc.value;\n    };\n  }\n  return _get.apply(this, arguments);\n}\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n  return object;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn(this, result);\n  };\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n  return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\nimport { Selection, CellCoords, CellRange } from \"./../../3rdparty/walkontable/src/index.mjs\";\nvar VisualSelection = /*#__PURE__*/function (_Selection) {\n  _inherits(VisualSelection, _Selection);\n  var _super = _createSuper(VisualSelection);\n  function VisualSelection(settings, visualCellRange) {\n    var _this;\n    _classCallCheck(this, VisualSelection);\n    _this = _super.call(this, settings, null);\n    /**\n     * Range of selection visually. Visual representation may have representation in a rendered selection.\n     *\n     * @type {null|CellRange}\n     */\n\n    _this.visualCellRange = visualCellRange || null;\n    _this.commit();\n    return _this;\n  }\n  /**\n   * Adds a cell coords to the selection.\n   *\n   * @param {CellCoords} coords Visual coordinates of a cell.\n   * @returns {VisualSelection}\n   */\n\n  _createClass(VisualSelection, [{\n    key: \"add\",\n    value: function add(coords) {\n      if (this.visualCellRange === null) {\n        this.visualCellRange = new CellRange(coords);\n      } else {\n        this.visualCellRange.expand(coords);\n      }\n      return this;\n    }\n    /**\n     * Clears visual and renderable selection.\n     *\n     * @returns {VisualSelection}\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.visualCellRange = null;\n      return _get(_getPrototypeOf(VisualSelection.prototype), \"clear\", this).call(this);\n    }\n    /**\n     * Search for the first visible coordinates in the range as range may start and/or end with the hidden index.\n     *\n     * @private\n     * @param {CellCoords} startCoords Visual start coordinates for the range. Starting point for finding destination coordinates\n     * with visible coordinates (we are going from the starting coordinates to the end coordinates until the criteria are met).\n     * @param {CellCoords} endCoords Visual end coordinates for the range.\n     * @param {number} incrementByRow We are searching for a next visible rows by increasing (to be precise, or decreasing) indexes.\n     * This variable represent indexes shift. We are looking for an index:\n     * - for rows: from the left to the right (increasing indexes, then variable should have value 1) or\n     * other way around (decreasing indexes, then variable should have the value -1)\n     * - for columns: from the top to the bottom (increasing indexes, then variable should have value 1)\n     * or other way around (decreasing indexes, then variable should have the value -1).\n     * @param {number} incrementByColumn As above, just indexes shift for columns.\n     * @returns {null|CellCoords} Visual cell coordinates.\n     */\n  }, {\n    key: \"findVisibleCoordsInRange\",\n    value: function findVisibleCoordsInRange(startCoords, endCoords, incrementByRow) {\n      var incrementByColumn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : incrementByRow;\n      var nextVisibleRow = this.findVisibleCoordsInRowsRange(startCoords.row, endCoords.row, incrementByRow); // There are no more visual rows in the range.\n\n      if (nextVisibleRow === null) {\n        return null;\n      }\n      var nextVisibleColumn = this.findVisibleCoordsInColumnsRange(startCoords.col, endCoords.col, incrementByColumn); // There are no more visual columns in the range.\n\n      if (nextVisibleColumn === null) {\n        return null;\n      }\n      return new CellCoords(nextVisibleRow, nextVisibleColumn);\n    }\n    /**\n     * Searches the nearest visible row index, which is not hidden (is renderable).\n     *\n     * @private\n     * @param {CellCoords} startVisibleRow Visual row index which starts the range. Starting point for finding\n     * destination coordinates with visible coordinates (we are going from the starting coordinates to the end\n     * coordinates until the criteria are met).\n     * @param {CellCoords} endVisibleRow Visual row index which ends the range.\n     * @param {number} incrementBy We are searching for a next visible rows by increasing (to be precise, or decreasing)\n     * indexes. This variable represent indexes shift. From the left to the right (increasing indexes, then variable\n     * should have value 1) or other way around (decreasing indexes, then variable should have the value -1).\n     * @returns {number|null} The visual row index.\n     */\n  }, {\n    key: \"findVisibleCoordsInRowsRange\",\n    value: function findVisibleCoordsInRowsRange(startVisibleRow, endVisibleRow, incrementBy) {\n      var _this$settings$visual = this.settings.visualToRenderableCoords({\n          row: startVisibleRow,\n          col: -1\n        }),\n        startRowRenderable = _this$settings$visual.row; // There are no more visual rows in the range.\n\n      if (endVisibleRow === startVisibleRow && startRowRenderable === null) {\n        return null;\n      } // We are looking for a next visible row in the range.\n\n      if (startRowRenderable === null) {\n        return this.findVisibleCoordsInRowsRange(startVisibleRow + incrementBy, endVisibleRow, incrementBy);\n      } // We found visible row index in the range.\n\n      return startVisibleRow;\n    }\n    /**\n     * Searches the nearest visible column index, which is not hidden (is renderable).\n     *\n     * @private\n     * @param {CellCoords} startVisibleColumn Visual column index which starts the range. Starting point for finding\n     * destination coordinates with visible coordinates (we are going from the starting coordinates to the end\n     * coordinates until the criteria are met).\n     * @param {CellCoords} endVisibleColumn Visual column index which ends the range.\n     * @param {number} incrementBy We are searching for a next visible columns by increasing (to be precise, or decreasing)\n     * indexes. This variable represent indexes shift. From the top to the bottom (increasing indexes, then variable\n     * should have value 1) or other way around (decreasing indexes, then variable should have the value -1).\n     * @returns {number|null} The visual column index.\n     */\n  }, {\n    key: \"findVisibleCoordsInColumnsRange\",\n    value: function findVisibleCoordsInColumnsRange(startVisibleColumn, endVisibleColumn, incrementBy) {\n      var _this$settings$visual2 = this.settings.visualToRenderableCoords({\n          row: -1,\n          col: startVisibleColumn\n        }),\n        startColumnRenderable = _this$settings$visual2.col; // There are no more visual columns in the range.\n\n      if (endVisibleColumn === startVisibleColumn && startColumnRenderable === null) {\n        return null;\n      } // We are looking for a next visible column in the range.\n\n      if (startColumnRenderable === null) {\n        return this.findVisibleCoordsInColumnsRange(startVisibleColumn + incrementBy, endVisibleColumn, incrementBy);\n      } // We found visible column index in the range.\n\n      return startVisibleColumn;\n    }\n    /**\n     * Searches the nearest visible column and row index, which is not hidden (is renderable). If one\n     * of the axes' range is entirely hidden, then created CellCoords object will hold the `null` value\n     * under a specific axis. For example, when we select the hidden column, then the calculated `col`\n     * prop will be `null`. In that case, rows are calculated further (regardless of the column result)\n     * to make rows header highlightable.\n     *\n     * @private\n     * @param {CellCoords} visualFromCoords Visual start coordinates for the range. Starting point for finding destination coordinates\n     * with visible coordinates (we are going from the starting coordinates to the end coordinates until the criteria are met).\n     * @param {CellCoords} visualToCoords Visual end coordinates for the range.\n     * @param {number} incrementByRow We are searching for a next visible rows by increasing (to be precise, or decreasing) indexes.\n     * This variable represent indexes shift. We are looking for an index:\n     * - for rows: from the left to the right (increasing indexes, then variable should have value 1) or\n     * other way around (decreasing indexes, then variable should have the value -1)\n     * - for columns: from the top to the bottom (increasing indexes, then variable should have value 1)\n     * or other way around (decreasing indexes, then variable should have the value -1).\n     * @param {number} incrementByColumn As above, just indexes shift for columns.\n     * @returns {CellCoords[]|null} Visual cell coordinates.\n     */\n  }, {\n    key: \"findVisibleHeaderRange\",\n    value: function findVisibleHeaderRange(visualFromCoords, visualToCoords, incrementByRow, incrementByColumn) {\n      var fromRangeVisualRow = this.findVisibleCoordsInRowsRange(visualFromCoords.row, visualToCoords.row, incrementByRow);\n      var toRangeVisualRow = this.findVisibleCoordsInRowsRange(visualToCoords.row, visualFromCoords.row, -incrementByRow);\n      var fromRangeVisualColumn = this.findVisibleCoordsInColumnsRange(visualFromCoords.col, visualToCoords.col, incrementByColumn);\n      var toRangeVisualColumn = this.findVisibleCoordsInColumnsRange(visualToCoords.col, visualFromCoords.col, -incrementByColumn); // All rows and columns ranges are hidden.\n\n      if (fromRangeVisualRow === null && toRangeVisualRow === null && fromRangeVisualColumn === null && toRangeVisualColumn === null) {\n        return null;\n      }\n      return [new CellCoords(fromRangeVisualRow, fromRangeVisualColumn), new CellCoords(toRangeVisualRow, toRangeVisualColumn)];\n    }\n    /**\n     * Override internally stored visual indexes added by the Selection's `add` function. It should be executed\n     * at the end of process of adding visual selection coordinates.\n     *\n     * @returns {VisualSelection}\n     */\n  }, {\n    key: \"commit\",\n    value: function commit() {\n      // There is no information about visual ranges, thus no selection may be displayed.\n      if (this.visualCellRange === null) {\n        return this;\n      }\n      var _this$visualCellRange = this.visualCellRange,\n        visualFromCoords = _this$visualCellRange.from,\n        visualToCoords = _this$visualCellRange.to; // We may move in two different directions while searching for visible rows and visible columns.\n\n      var incrementByRow = this.getRowSearchDirection(this.visualCellRange);\n      var incrementByColumn = this.getColumnSearchDirection(this.visualCellRange);\n      var fromRangeVisual = this.findVisibleCoordsInRange(visualFromCoords, visualToCoords, incrementByRow, incrementByColumn);\n      var toRangeVisual = this.findVisibleCoordsInRange(visualToCoords, visualFromCoords, -incrementByRow, -incrementByColumn); // There is no visual start point (and also visual end point) in the range.\n      // We are looking for the first visible cell in a broader range.\n\n      if (fromRangeVisual === null || toRangeVisual === null) {\n        var isHeaderSelectionType = this.settings.type === 'header';\n        var cellRange = null; // For the \"header\" selection type, find rows and column indexes, which should be\n        // highlighted, although one of the axes is completely hidden.\n\n        if (isHeaderSelectionType) {\n          var _this$findVisibleHead = this.findVisibleHeaderRange(visualFromCoords, visualToCoords, incrementByRow, incrementByColumn),\n            _this$findVisibleHead2 = _slicedToArray(_this$findVisibleHead, 2),\n            fromRangeVisualHeader = _this$findVisibleHead2[0],\n            toRangeVisualHeader = _this$findVisibleHead2[1];\n          cellRange = this.createRenderableCellRange(fromRangeVisualHeader, toRangeVisualHeader);\n        }\n        this.cellRange = cellRange;\n      } else {\n        this.cellRange = this.createRenderableCellRange(fromRangeVisual, toRangeVisual);\n      }\n      return this;\n    }\n    /**\n     * Some selection may be a part of broader cell range. This function adjusting coordinates of current selection\n     * and the broader cell range when needed (current selection can't be presented visually).\n     *\n     * @param {CellRange} broaderCellRange Visual range. Actual cell range may be contained in the broader cell range.\n     * When there is no way to represent some cell range visually we try to find range containing just the first visible cell.\n     *\n     * Warn: Please keep in mind that this function may change coordinates of the handled broader range.\n     *\n     * @returns {VisualSelection}\n     */\n  }, {\n    key: \"adjustCoordinates\",\n    value: function adjustCoordinates(broaderCellRange) {\n      // We may move in two different directions while searching for visible rows and visible columns.\n      var incrementByRow = this.getRowSearchDirection(broaderCellRange);\n      var incrementByColumn = this.getColumnSearchDirection(broaderCellRange);\n      var normFromCoords = broaderCellRange.from.clone().normalize();\n      var normToCoords = broaderCellRange.to.clone().normalize();\n      var singleCellRangeVisual = this.findVisibleCoordsInRange(normFromCoords, normToCoords, incrementByRow, incrementByColumn);\n      if (singleCellRangeVisual !== null) {\n        // We can't show selection visually now, but we found fist visible range in the broader cell range.\n        if (this.cellRange === null) {\n          var singleCellRangeRenderable = this.settings.visualToRenderableCoords(singleCellRangeVisual);\n          this.cellRange = new CellRange(singleCellRangeRenderable);\n        } // We set new highlight as it might change (for example, when showing/hiding some cells from the broader selection range)\n        // TODO: It is also handled by the `MergeCells` plugin while adjusting already modified coordinates. Should it?\n\n        broaderCellRange.setHighlight(singleCellRangeVisual);\n        return this;\n      } // Fallback to the start of the range. It resets the previous highlight (for example, when all columns have been hidden).\n\n      broaderCellRange.setHighlight(broaderCellRange.from);\n      return this;\n    }\n    /**\n     * Returns the top left (TL) and bottom right (BR) selection coordinates (renderable indexes).\n     * The method overwrites the original method to support header selection for hidden cells.\n     * To make the header selection working, the CellCoords and CellRange have to support not\n     * complete coordinates (`null` values for example, `row: null`, `col: 2`).\n     *\n     * @returns {Array} Returns array of coordinates for example `[1, 1, 5, 5]`.\n     */\n  }, {\n    key: \"getCorners\",\n    value: function getCorners() {\n      var _this$cellRange = this.cellRange,\n        from = _this$cellRange.from,\n        to = _this$cellRange.to;\n      var isRowUndefined = from.row === null || to.row === null;\n      var isColumnUndefined = from.col === null || to.col === null;\n      var topLeftCorner = new CellCoords(isRowUndefined ? null : Math.min(from.row, to.row), isColumnUndefined ? null : Math.min(from.col, to.col));\n      var bottomRightCorner = new CellCoords(isRowUndefined ? null : Math.max(from.row, to.row), isColumnUndefined ? null : Math.max(from.col, to.col));\n      return [topLeftCorner.row, topLeftCorner.col, bottomRightCorner.row, bottomRightCorner.col];\n    }\n    /**\n     * Returns the top left (TL) and bottom right (BR) selection coordinates (visual indexes).\n     *\n     * @returns {Array} Returns array of coordinates for example `[1, 1, 5, 5]`.\n     */\n  }, {\n    key: \"getVisualCorners\",\n    value: function getVisualCorners() {\n      var topLeft = this.settings.renderableToVisualCoords(this.cellRange.getTopLeftCorner());\n      var bottomRight = this.settings.renderableToVisualCoords(this.cellRange.getBottomRightCorner());\n      return [topLeft.row, topLeft.col, bottomRight.row, bottomRight.col];\n    }\n    /**\n     * Creates a new CellRange object based on visual coordinates which before object creation are\n     * translated to renderable indexes.\n     *\n     * @param {CellCoords} visualFromCoords The CellCoords object which contains coordinates that\n     *                                      points to the begining of the selection.\n     * @param {CellCoords} visualToCoords The CellCoords object which contains coordinates that\n     *                                    points to the end of the selection.\n     * @returns {CellRange}\n     */\n  }, {\n    key: \"createRenderableCellRange\",\n    value: function createRenderableCellRange(visualFromCoords, visualToCoords) {\n      var renderableFromCoords = this.settings.visualToRenderableCoords(visualFromCoords);\n      var renderableToCoords = this.settings.visualToRenderableCoords(visualToCoords);\n      return new CellRange(renderableFromCoords, renderableFromCoords, renderableToCoords);\n    }\n    /**\n     * It returns rows shift needed for searching visual row.\n     *\n     * @private\n     * @param {CellRange} cellRange Selection range.\n     * @returns {number} Rows shift. It return 1 when we should increase indexes (moving from the top to the bottom) or\n     * -1 when we should decrease indexes (moving other way around).\n     */\n  }, {\n    key: \"getRowSearchDirection\",\n    value: function getRowSearchDirection(cellRange) {\n      if (cellRange.from.row < cellRange.to.row) {\n        return 1; // Increasing row indexes.\n      }\n      return -1; // Decreasing row indexes.\n    }\n    /**\n     * It returns columns shift needed for searching visual column.\n     *\n     * @private\n     * @param {CellRange} cellRange Selection range.\n     * @returns {number} Columns shift. It return 1 when we should increase indexes (moving from the left to the right) or\n     * -1 when we should decrease indexes (moving other way around).\n     */\n  }, {\n    key: \"getColumnSearchDirection\",\n    value: function getColumnSearchDirection(cellRange) {\n      if (cellRange.from.col < cellRange.to.col) {\n        return 1; // Increasing column indexes.\n      }\n      return -1; // Decreasing column indexes.\n    }\n  }]);\n  return VisualSelection;\n}(Selection);\nexport default VisualSelection;","map":{"version":3,"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","TypeError","o","minLen","_arrayLikeToArray","n","Object","toString","call","slice","name","Array","from","test","len","length","arr2","_i","_arr","_n","_d","_s","_e","next","done","push","value","err","isArray","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","_get","Reflect","get","property","receiver","base","_superPropBase","desc","getOwnPropertyDescriptor","arguments","apply","object","hasOwnProperty","_getPrototypeOf","_inherits","subClass","superClass","create","_setPrototypeOf","p","setPrototypeOf","__proto__","_createSuper","Derived","hasNativeReflectConstruct","_isNativeReflectConstruct","_createSuperInternal","Super","result","NewTarget","construct","_possibleConstructorReturn","self","_assertThisInitialized","ReferenceError","sham","Proxy","Boolean","valueOf","e","getPrototypeOf","Selection","CellCoords","CellRange","VisualSelection","_Selection","_super","settings","visualCellRange","_this","commit","add","coords","expand","clear","findVisibleCoordsInRange","startCoords","endCoords","incrementByRow","incrementByColumn","undefined","nextVisibleRow","findVisibleCoordsInRowsRange","row","nextVisibleColumn","findVisibleCoordsInColumnsRange","col","startVisibleRow","endVisibleRow","incrementBy","_this$settings$visual","visualToRenderableCoords","startRowRenderable","startVisibleColumn","endVisibleColumn","_this$settings$visual2","startColumnRenderable","findVisibleHeaderRange","visualFromCoords","visualToCoords","fromRangeVisualRow","toRangeVisualRow","fromRangeVisualColumn","toRangeVisualColumn","_this$visualCellRange","to","getRowSearchDirection","getColumnSearchDirection","fromRangeVisual","toRangeVisual","isHeaderSelectionType","type","cellRange","_this$findVisibleHead","_this$findVisibleHead2","fromRangeVisualHeader","toRangeVisualHeader","createRenderableCellRange","adjustCoordinates","broaderCellRange","normFromCoords","clone","normalize","normToCoords","singleCellRangeVisual","singleCellRangeRenderable","setHighlight","getCorners","_this$cellRange","isRowUndefined","isColumnUndefined","topLeftCorner","Math","min","bottomRightCorner","max","getVisualCorners","topLeft","renderableToVisualCoords","getTopLeftCorner","bottomRight","getBottomRightCorner","renderableFromCoords","renderableToCoords"],"sources":["/Users/priyadeliwala/Desktop/sales-dashboard/node_modules/handsontable/selection/highlight/visualSelection.mjs"],"sourcesContent":["function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nimport \"core-js/modules/es.object.set-prototype-of.js\";\nimport \"core-js/modules/es.object.get-prototype-of.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.reflect.construct.js\";\nimport \"core-js/modules/es.reflect.get.js\";\nimport \"core-js/modules/es.object.get-own-property-descriptor.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _get() { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nimport { Selection, CellCoords, CellRange } from \"./../../3rdparty/walkontable/src/index.mjs\";\n\nvar VisualSelection = /*#__PURE__*/function (_Selection) {\n  _inherits(VisualSelection, _Selection);\n\n  var _super = _createSuper(VisualSelection);\n\n  function VisualSelection(settings, visualCellRange) {\n    var _this;\n\n    _classCallCheck(this, VisualSelection);\n\n    _this = _super.call(this, settings, null);\n    /**\n     * Range of selection visually. Visual representation may have representation in a rendered selection.\n     *\n     * @type {null|CellRange}\n     */\n\n    _this.visualCellRange = visualCellRange || null;\n\n    _this.commit();\n\n    return _this;\n  }\n  /**\n   * Adds a cell coords to the selection.\n   *\n   * @param {CellCoords} coords Visual coordinates of a cell.\n   * @returns {VisualSelection}\n   */\n\n\n  _createClass(VisualSelection, [{\n    key: \"add\",\n    value: function add(coords) {\n      if (this.visualCellRange === null) {\n        this.visualCellRange = new CellRange(coords);\n      } else {\n        this.visualCellRange.expand(coords);\n      }\n\n      return this;\n    }\n    /**\n     * Clears visual and renderable selection.\n     *\n     * @returns {VisualSelection}\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.visualCellRange = null;\n      return _get(_getPrototypeOf(VisualSelection.prototype), \"clear\", this).call(this);\n    }\n    /**\n     * Search for the first visible coordinates in the range as range may start and/or end with the hidden index.\n     *\n     * @private\n     * @param {CellCoords} startCoords Visual start coordinates for the range. Starting point for finding destination coordinates\n     * with visible coordinates (we are going from the starting coordinates to the end coordinates until the criteria are met).\n     * @param {CellCoords} endCoords Visual end coordinates for the range.\n     * @param {number} incrementByRow We are searching for a next visible rows by increasing (to be precise, or decreasing) indexes.\n     * This variable represent indexes shift. We are looking for an index:\n     * - for rows: from the left to the right (increasing indexes, then variable should have value 1) or\n     * other way around (decreasing indexes, then variable should have the value -1)\n     * - for columns: from the top to the bottom (increasing indexes, then variable should have value 1)\n     * or other way around (decreasing indexes, then variable should have the value -1).\n     * @param {number} incrementByColumn As above, just indexes shift for columns.\n     * @returns {null|CellCoords} Visual cell coordinates.\n     */\n\n  }, {\n    key: \"findVisibleCoordsInRange\",\n    value: function findVisibleCoordsInRange(startCoords, endCoords, incrementByRow) {\n      var incrementByColumn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : incrementByRow;\n      var nextVisibleRow = this.findVisibleCoordsInRowsRange(startCoords.row, endCoords.row, incrementByRow); // There are no more visual rows in the range.\n\n      if (nextVisibleRow === null) {\n        return null;\n      }\n\n      var nextVisibleColumn = this.findVisibleCoordsInColumnsRange(startCoords.col, endCoords.col, incrementByColumn); // There are no more visual columns in the range.\n\n      if (nextVisibleColumn === null) {\n        return null;\n      }\n\n      return new CellCoords(nextVisibleRow, nextVisibleColumn);\n    }\n    /**\n     * Searches the nearest visible row index, which is not hidden (is renderable).\n     *\n     * @private\n     * @param {CellCoords} startVisibleRow Visual row index which starts the range. Starting point for finding\n     * destination coordinates with visible coordinates (we are going from the starting coordinates to the end\n     * coordinates until the criteria are met).\n     * @param {CellCoords} endVisibleRow Visual row index which ends the range.\n     * @param {number} incrementBy We are searching for a next visible rows by increasing (to be precise, or decreasing)\n     * indexes. This variable represent indexes shift. From the left to the right (increasing indexes, then variable\n     * should have value 1) or other way around (decreasing indexes, then variable should have the value -1).\n     * @returns {number|null} The visual row index.\n     */\n\n  }, {\n    key: \"findVisibleCoordsInRowsRange\",\n    value: function findVisibleCoordsInRowsRange(startVisibleRow, endVisibleRow, incrementBy) {\n      var _this$settings$visual = this.settings.visualToRenderableCoords({\n        row: startVisibleRow,\n        col: -1\n      }),\n          startRowRenderable = _this$settings$visual.row; // There are no more visual rows in the range.\n\n\n      if (endVisibleRow === startVisibleRow && startRowRenderable === null) {\n        return null;\n      } // We are looking for a next visible row in the range.\n\n\n      if (startRowRenderable === null) {\n        return this.findVisibleCoordsInRowsRange(startVisibleRow + incrementBy, endVisibleRow, incrementBy);\n      } // We found visible row index in the range.\n\n\n      return startVisibleRow;\n    }\n    /**\n     * Searches the nearest visible column index, which is not hidden (is renderable).\n     *\n     * @private\n     * @param {CellCoords} startVisibleColumn Visual column index which starts the range. Starting point for finding\n     * destination coordinates with visible coordinates (we are going from the starting coordinates to the end\n     * coordinates until the criteria are met).\n     * @param {CellCoords} endVisibleColumn Visual column index which ends the range.\n     * @param {number} incrementBy We are searching for a next visible columns by increasing (to be precise, or decreasing)\n     * indexes. This variable represent indexes shift. From the top to the bottom (increasing indexes, then variable\n     * should have value 1) or other way around (decreasing indexes, then variable should have the value -1).\n     * @returns {number|null} The visual column index.\n     */\n\n  }, {\n    key: \"findVisibleCoordsInColumnsRange\",\n    value: function findVisibleCoordsInColumnsRange(startVisibleColumn, endVisibleColumn, incrementBy) {\n      var _this$settings$visual2 = this.settings.visualToRenderableCoords({\n        row: -1,\n        col: startVisibleColumn\n      }),\n          startColumnRenderable = _this$settings$visual2.col; // There are no more visual columns in the range.\n\n\n      if (endVisibleColumn === startVisibleColumn && startColumnRenderable === null) {\n        return null;\n      } // We are looking for a next visible column in the range.\n\n\n      if (startColumnRenderable === null) {\n        return this.findVisibleCoordsInColumnsRange(startVisibleColumn + incrementBy, endVisibleColumn, incrementBy);\n      } // We found visible column index in the range.\n\n\n      return startVisibleColumn;\n    }\n    /**\n     * Searches the nearest visible column and row index, which is not hidden (is renderable). If one\n     * of the axes' range is entirely hidden, then created CellCoords object will hold the `null` value\n     * under a specific axis. For example, when we select the hidden column, then the calculated `col`\n     * prop will be `null`. In that case, rows are calculated further (regardless of the column result)\n     * to make rows header highlightable.\n     *\n     * @private\n     * @param {CellCoords} visualFromCoords Visual start coordinates for the range. Starting point for finding destination coordinates\n     * with visible coordinates (we are going from the starting coordinates to the end coordinates until the criteria are met).\n     * @param {CellCoords} visualToCoords Visual end coordinates for the range.\n     * @param {number} incrementByRow We are searching for a next visible rows by increasing (to be precise, or decreasing) indexes.\n     * This variable represent indexes shift. We are looking for an index:\n     * - for rows: from the left to the right (increasing indexes, then variable should have value 1) or\n     * other way around (decreasing indexes, then variable should have the value -1)\n     * - for columns: from the top to the bottom (increasing indexes, then variable should have value 1)\n     * or other way around (decreasing indexes, then variable should have the value -1).\n     * @param {number} incrementByColumn As above, just indexes shift for columns.\n     * @returns {CellCoords[]|null} Visual cell coordinates.\n     */\n\n  }, {\n    key: \"findVisibleHeaderRange\",\n    value: function findVisibleHeaderRange(visualFromCoords, visualToCoords, incrementByRow, incrementByColumn) {\n      var fromRangeVisualRow = this.findVisibleCoordsInRowsRange(visualFromCoords.row, visualToCoords.row, incrementByRow);\n      var toRangeVisualRow = this.findVisibleCoordsInRowsRange(visualToCoords.row, visualFromCoords.row, -incrementByRow);\n      var fromRangeVisualColumn = this.findVisibleCoordsInColumnsRange(visualFromCoords.col, visualToCoords.col, incrementByColumn);\n      var toRangeVisualColumn = this.findVisibleCoordsInColumnsRange(visualToCoords.col, visualFromCoords.col, -incrementByColumn); // All rows and columns ranges are hidden.\n\n      if (fromRangeVisualRow === null && toRangeVisualRow === null && fromRangeVisualColumn === null && toRangeVisualColumn === null) {\n        return null;\n      }\n\n      return [new CellCoords(fromRangeVisualRow, fromRangeVisualColumn), new CellCoords(toRangeVisualRow, toRangeVisualColumn)];\n    }\n    /**\n     * Override internally stored visual indexes added by the Selection's `add` function. It should be executed\n     * at the end of process of adding visual selection coordinates.\n     *\n     * @returns {VisualSelection}\n     */\n\n  }, {\n    key: \"commit\",\n    value: function commit() {\n      // There is no information about visual ranges, thus no selection may be displayed.\n      if (this.visualCellRange === null) {\n        return this;\n      }\n\n      var _this$visualCellRange = this.visualCellRange,\n          visualFromCoords = _this$visualCellRange.from,\n          visualToCoords = _this$visualCellRange.to; // We may move in two different directions while searching for visible rows and visible columns.\n\n      var incrementByRow = this.getRowSearchDirection(this.visualCellRange);\n      var incrementByColumn = this.getColumnSearchDirection(this.visualCellRange);\n      var fromRangeVisual = this.findVisibleCoordsInRange(visualFromCoords, visualToCoords, incrementByRow, incrementByColumn);\n      var toRangeVisual = this.findVisibleCoordsInRange(visualToCoords, visualFromCoords, -incrementByRow, -incrementByColumn); // There is no visual start point (and also visual end point) in the range.\n      // We are looking for the first visible cell in a broader range.\n\n      if (fromRangeVisual === null || toRangeVisual === null) {\n        var isHeaderSelectionType = this.settings.type === 'header';\n        var cellRange = null; // For the \"header\" selection type, find rows and column indexes, which should be\n        // highlighted, although one of the axes is completely hidden.\n\n        if (isHeaderSelectionType) {\n          var _this$findVisibleHead = this.findVisibleHeaderRange(visualFromCoords, visualToCoords, incrementByRow, incrementByColumn),\n              _this$findVisibleHead2 = _slicedToArray(_this$findVisibleHead, 2),\n              fromRangeVisualHeader = _this$findVisibleHead2[0],\n              toRangeVisualHeader = _this$findVisibleHead2[1];\n\n          cellRange = this.createRenderableCellRange(fromRangeVisualHeader, toRangeVisualHeader);\n        }\n\n        this.cellRange = cellRange;\n      } else {\n        this.cellRange = this.createRenderableCellRange(fromRangeVisual, toRangeVisual);\n      }\n\n      return this;\n    }\n    /**\n     * Some selection may be a part of broader cell range. This function adjusting coordinates of current selection\n     * and the broader cell range when needed (current selection can't be presented visually).\n     *\n     * @param {CellRange} broaderCellRange Visual range. Actual cell range may be contained in the broader cell range.\n     * When there is no way to represent some cell range visually we try to find range containing just the first visible cell.\n     *\n     * Warn: Please keep in mind that this function may change coordinates of the handled broader range.\n     *\n     * @returns {VisualSelection}\n     */\n\n  }, {\n    key: \"adjustCoordinates\",\n    value: function adjustCoordinates(broaderCellRange) {\n      // We may move in two different directions while searching for visible rows and visible columns.\n      var incrementByRow = this.getRowSearchDirection(broaderCellRange);\n      var incrementByColumn = this.getColumnSearchDirection(broaderCellRange);\n      var normFromCoords = broaderCellRange.from.clone().normalize();\n      var normToCoords = broaderCellRange.to.clone().normalize();\n      var singleCellRangeVisual = this.findVisibleCoordsInRange(normFromCoords, normToCoords, incrementByRow, incrementByColumn);\n\n      if (singleCellRangeVisual !== null) {\n        // We can't show selection visually now, but we found fist visible range in the broader cell range.\n        if (this.cellRange === null) {\n          var singleCellRangeRenderable = this.settings.visualToRenderableCoords(singleCellRangeVisual);\n          this.cellRange = new CellRange(singleCellRangeRenderable);\n        } // We set new highlight as it might change (for example, when showing/hiding some cells from the broader selection range)\n        // TODO: It is also handled by the `MergeCells` plugin while adjusting already modified coordinates. Should it?\n\n\n        broaderCellRange.setHighlight(singleCellRangeVisual);\n        return this;\n      } // Fallback to the start of the range. It resets the previous highlight (for example, when all columns have been hidden).\n\n\n      broaderCellRange.setHighlight(broaderCellRange.from);\n      return this;\n    }\n    /**\n     * Returns the top left (TL) and bottom right (BR) selection coordinates (renderable indexes).\n     * The method overwrites the original method to support header selection for hidden cells.\n     * To make the header selection working, the CellCoords and CellRange have to support not\n     * complete coordinates (`null` values for example, `row: null`, `col: 2`).\n     *\n     * @returns {Array} Returns array of coordinates for example `[1, 1, 5, 5]`.\n     */\n\n  }, {\n    key: \"getCorners\",\n    value: function getCorners() {\n      var _this$cellRange = this.cellRange,\n          from = _this$cellRange.from,\n          to = _this$cellRange.to;\n      var isRowUndefined = from.row === null || to.row === null;\n      var isColumnUndefined = from.col === null || to.col === null;\n      var topLeftCorner = new CellCoords(isRowUndefined ? null : Math.min(from.row, to.row), isColumnUndefined ? null : Math.min(from.col, to.col));\n      var bottomRightCorner = new CellCoords(isRowUndefined ? null : Math.max(from.row, to.row), isColumnUndefined ? null : Math.max(from.col, to.col));\n      return [topLeftCorner.row, topLeftCorner.col, bottomRightCorner.row, bottomRightCorner.col];\n    }\n    /**\n     * Returns the top left (TL) and bottom right (BR) selection coordinates (visual indexes).\n     *\n     * @returns {Array} Returns array of coordinates for example `[1, 1, 5, 5]`.\n     */\n\n  }, {\n    key: \"getVisualCorners\",\n    value: function getVisualCorners() {\n      var topLeft = this.settings.renderableToVisualCoords(this.cellRange.getTopLeftCorner());\n      var bottomRight = this.settings.renderableToVisualCoords(this.cellRange.getBottomRightCorner());\n      return [topLeft.row, topLeft.col, bottomRight.row, bottomRight.col];\n    }\n    /**\n     * Creates a new CellRange object based on visual coordinates which before object creation are\n     * translated to renderable indexes.\n     *\n     * @param {CellCoords} visualFromCoords The CellCoords object which contains coordinates that\n     *                                      points to the begining of the selection.\n     * @param {CellCoords} visualToCoords The CellCoords object which contains coordinates that\n     *                                    points to the end of the selection.\n     * @returns {CellRange}\n     */\n\n  }, {\n    key: \"createRenderableCellRange\",\n    value: function createRenderableCellRange(visualFromCoords, visualToCoords) {\n      var renderableFromCoords = this.settings.visualToRenderableCoords(visualFromCoords);\n      var renderableToCoords = this.settings.visualToRenderableCoords(visualToCoords);\n      return new CellRange(renderableFromCoords, renderableFromCoords, renderableToCoords);\n    }\n    /**\n     * It returns rows shift needed for searching visual row.\n     *\n     * @private\n     * @param {CellRange} cellRange Selection range.\n     * @returns {number} Rows shift. It return 1 when we should increase indexes (moving from the top to the bottom) or\n     * -1 when we should decrease indexes (moving other way around).\n     */\n\n  }, {\n    key: \"getRowSearchDirection\",\n    value: function getRowSearchDirection(cellRange) {\n      if (cellRange.from.row < cellRange.to.row) {\n        return 1; // Increasing row indexes.\n      }\n\n      return -1; // Decreasing row indexes.\n    }\n    /**\n     * It returns columns shift needed for searching visual column.\n     *\n     * @private\n     * @param {CellRange} cellRange Selection range.\n     * @returns {number} Columns shift. It return 1 when we should increase indexes (moving from the left to the right) or\n     * -1 when we should decrease indexes (moving other way around).\n     */\n\n  }, {\n    key: \"getColumnSearchDirection\",\n    value: function getColumnSearchDirection(cellRange) {\n      if (cellRange.from.col < cellRange.to.col) {\n        return 1; // Increasing column indexes.\n      }\n\n      return -1; // Decreasing column indexes.\n    }\n  }]);\n\n  return VisualSelection;\n}(Selection);\n\nexport default VisualSelection;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}