{"ast":null,"code":"function _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nimport { rangeEach } from \"../../../helpers/number.mjs\";\nimport { objectEach } from \"../../../helpers/object.mjs\";\nimport { arrayEach } from \"../../../helpers/array.mjs\";\n/**\n * Class responsible for making data operations.\n *\n * @private\n */\n\nvar DataManager = /*#__PURE__*/function () {\n  function DataManager(nestedRowsPlugin, hotInstance) {\n    _classCallCheck(this, DataManager);\n\n    /**\n     * Main Handsontable instance reference.\n     *\n     * @type {object}\n     */\n    this.hot = hotInstance;\n    /**\n     * Reference to the source data object.\n     *\n     * @type {Handsontable.CellValue[][]|Handsontable.RowObject[]}\n     */\n\n    this.data = null;\n    /**\n     * Reference to the NestedRows plugin.\n     *\n     * @type {object}\n     */\n\n    this.plugin = nestedRowsPlugin;\n    /**\n     * Map of row object parents.\n     *\n     * @type {WeakMap}\n     */\n\n    this.parentReference = new WeakMap();\n    /**\n     * Nested structure cache.\n     *\n     * @type {object}\n     */\n\n    this.cache = {\n      levels: [],\n      levelCount: 0,\n      rows: [],\n      nodeInfo: new WeakMap()\n    };\n  }\n  /**\n   * Set the data for the manager.\n   *\n   * @param {Handsontable.CellValue[][]|Handsontable.RowObject[]} data Data for the manager.\n   */\n\n  _createClass(DataManager, [{\n    key: \"setData\",\n    value: function setData(data) {\n      this.data = data;\n    }\n    /**\n     * Get the data cached in the manager.\n     *\n     * @returns {Handsontable.CellValue[][]|Handsontable.RowObject[]}\n     */\n  }, {\n    key: \"getData\",\n    value: function getData() {\n      return this.data;\n    }\n    /**\n     * Load the \"raw\" source data, without NestedRows' modifications.\n     *\n     * @returns {Handsontable.CellValue[][]|Handsontable.RowObject[]}\n     */\n  }, {\n    key: \"getRawSourceData\",\n    value: function getRawSourceData() {\n      var rawSourceData = null;\n      this.plugin.disableCoreAPIModifiers();\n      rawSourceData = this.hot.getSourceData();\n      this.plugin.enableCoreAPIModifiers();\n      return rawSourceData;\n    }\n    /**\n     * Update the Data Manager with new data and refresh cache.\n     *\n     * @param {Handsontable.CellValue[][]|Handsontable.RowObject[]} data Data for the manager.\n     */\n  }, {\n    key: \"updateWithData\",\n    value: function updateWithData(data) {\n      this.setData(data);\n      this.rewriteCache();\n    }\n    /**\n     * Rewrite the nested structure cache.\n     *\n     * @private\n     */\n  }, {\n    key: \"rewriteCache\",\n    value: function rewriteCache() {\n      var _this = this;\n      this.cache = {\n        levels: [],\n        levelCount: 0,\n        rows: [],\n        nodeInfo: new WeakMap()\n      };\n      rangeEach(0, this.data.length - 1, function (i) {\n        _this.cacheNode(_this.data[i], 0, null);\n      });\n    }\n    /**\n     * Cache a data node.\n     *\n     * @private\n     * @param {object} node Node to cache.\n     * @param {number} level Level of the node.\n     * @param {object} parent Parent of the node.\n     */\n  }, {\n    key: \"cacheNode\",\n    value: function cacheNode(node, level, parent) {\n      var _this2 = this;\n      if (!this.cache.levels[level]) {\n        this.cache.levels[level] = [];\n        this.cache.levelCount += 1;\n      }\n      this.cache.levels[level].push(node);\n      this.cache.rows.push(node);\n      this.cache.nodeInfo.set(node, {\n        parent: parent,\n        row: this.cache.rows.length - 1,\n        level: level\n      });\n      if (this.hasChildren(node)) {\n        arrayEach(node.__children, function (elem) {\n          _this2.cacheNode(elem, level + 1, node);\n        });\n      }\n    }\n    /**\n     * Get the date for the provided visual row number.\n     *\n     * @param {number} row Row index.\n     * @returns {object}\n     */\n  }, {\n    key: \"getDataObject\",\n    value: function getDataObject(row) {\n      return row === null || row === void 0 ? null : this.cache.rows[row];\n    }\n    /**\n     * Read the row tree in search for a specific row index or row object.\n     *\n     * @private\n     * @param {object} parent The initial parent object.\n     * @param {number} readCount Number of read nodes.\n     * @param {number} neededIndex The row index we search for.\n     * @param {object} neededObject The row object we search for.\n     * @returns {number|object}\n     */\n  }, {\n    key: \"readTreeNodes\",\n    value: function readTreeNodes(parent, readCount, neededIndex, neededObject) {\n      var _this3 = this;\n      var rootLevel = false;\n      var readNodesCount = readCount;\n      if (isNaN(readNodesCount) && readNodesCount.end) {\n        return readNodesCount;\n      }\n      var parentObj = parent;\n      if (!parentObj) {\n        parentObj = {\n          __children: this.data\n        };\n        rootLevel = true;\n        readNodesCount -= 1;\n      }\n      if (neededIndex !== null && neededIndex !== void 0 && readNodesCount === neededIndex) {\n        return {\n          result: parentObj,\n          end: true\n        };\n      }\n      if (neededObject !== null && neededObject !== void 0 && parentObj === neededObject) {\n        return {\n          result: readNodesCount,\n          end: true\n        };\n      }\n      readNodesCount += 1;\n      if (parentObj.__children) {\n        arrayEach(parentObj.__children, function (val) {\n          _this3.parentReference.set(val, rootLevel ? null : parentObj);\n          readNodesCount = _this3.readTreeNodes(val, readNodesCount, neededIndex, neededObject);\n          if (isNaN(readNodesCount) && readNodesCount.end) {\n            return false;\n          }\n        });\n      }\n      return readNodesCount;\n    }\n    /**\n     * Mock a parent node.\n     *\n     * @private\n     * @returns {*}\n     */\n  }, {\n    key: \"mockParent\",\n    value: function mockParent() {\n      var fakeParent = this.mockNode();\n      fakeParent.__children = this.data;\n      return fakeParent;\n    }\n    /**\n     * Mock a data node.\n     *\n     * @private\n     * @returns {{}}\n     */\n  }, {\n    key: \"mockNode\",\n    value: function mockNode() {\n      var fakeNode = {};\n      objectEach(this.data[0], function (val, key) {\n        fakeNode[key] = null;\n      });\n      return fakeNode;\n    }\n    /**\n     * Get the row index for the provided row object.\n     *\n     * @param {object} rowObj The row object.\n     * @returns {number} Row index.\n     */\n  }, {\n    key: \"getRowIndex\",\n    value: function getRowIndex(rowObj) {\n      return rowObj === null || rowObj === void 0 ? null : this.cache.nodeInfo.get(rowObj).row;\n    }\n    /**\n     * Get the index of the provided row index/row object within its parent.\n     *\n     * @param {number|object} row Row index / row object.\n     * @returns {number}\n     */\n  }, {\n    key: \"getRowIndexWithinParent\",\n    value: function getRowIndexWithinParent(row) {\n      var rowObj = null;\n      if (isNaN(row)) {\n        rowObj = row;\n      } else {\n        rowObj = this.getDataObject(row);\n      }\n      var parent = this.getRowParent(row);\n      if (parent === null || parent === void 0) {\n        return this.data.indexOf(rowObj);\n      }\n      return parent.__children.indexOf(rowObj);\n    }\n    /**\n     * Count all rows (including all parents and children).\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"countAllRows\",\n    value: function countAllRows() {\n      var rootNodeMock = {\n        __children: this.data\n      };\n      return this.countChildren(rootNodeMock);\n    }\n    /**\n     * Count children of the provided parent.\n     *\n     * @param {object|number} parent Parent node.\n     * @returns {number} Children count.\n     */\n  }, {\n    key: \"countChildren\",\n    value: function countChildren(parent) {\n      var _this4 = this;\n      var rowCount = 0;\n      var parentNode = parent;\n      if (!isNaN(parentNode)) {\n        parentNode = this.getDataObject(parentNode);\n      }\n      if (!parentNode || !parentNode.__children) {\n        return 0;\n      }\n      arrayEach(parentNode.__children, function (elem) {\n        rowCount += 1;\n        if (elem.__children) {\n          rowCount += _this4.countChildren(elem);\n        }\n      });\n      return rowCount;\n    }\n    /**\n     * Get the parent of the row at the provided index.\n     *\n     * @param {number|object} row Physical row index.\n     * @returns {object}\n     */\n  }, {\n    key: \"getRowParent\",\n    value: function getRowParent(row) {\n      var rowObject;\n      if (isNaN(row)) {\n        rowObject = row;\n      } else {\n        rowObject = this.getDataObject(row);\n      }\n      return this.getRowObjectParent(rowObject);\n    }\n    /**\n     * Get the parent of the provided row object.\n     *\n     * @private\n     * @param {object} rowObject The row object (tree node).\n     * @returns {object|null}\n     */\n  }, {\n    key: \"getRowObjectParent\",\n    value: function getRowObjectParent(rowObject) {\n      if (!rowObject || _typeof(rowObject) !== 'object') {\n        return null;\n      }\n      return this.cache.nodeInfo.get(rowObject).parent;\n    }\n    /**\n     * Get the nesting level for the row with the provided row index.\n     *\n     * @param {number} row Row index.\n     * @returns {number|null} Row level or null, when row doesn't exist.\n     */\n  }, {\n    key: \"getRowLevel\",\n    value: function getRowLevel(row) {\n      var rowObject = null;\n      if (isNaN(row)) {\n        rowObject = row;\n      } else {\n        rowObject = this.getDataObject(row);\n      }\n      return rowObject ? this.getRowObjectLevel(rowObject) : null;\n    }\n    /**\n     * Get the nesting level for the row with the provided row index.\n     *\n     * @private\n     * @param {object} rowObject Row object.\n     * @returns {number} Row level.\n     */\n  }, {\n    key: \"getRowObjectLevel\",\n    value: function getRowObjectLevel(rowObject) {\n      return rowObject === null || rowObject === void 0 ? null : this.cache.nodeInfo.get(rowObject).level;\n    }\n    /**\n     * Check if the provided row/row element has children.\n     *\n     * @param {number|object} row Row number or row element.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"hasChildren\",\n    value: function hasChildren(row) {\n      var rowObj = row;\n      if (!isNaN(rowObj)) {\n        rowObj = this.getDataObject(rowObj);\n      }\n      return !!(rowObj.__children && rowObj.__children.length);\n    }\n    /**\n     * Returns `true` if the row at the provided index has a parent.\n     *\n     * @param {number} index Row index.\n     * @returns {boolean} `true` if the row at the provided index has a parent, `false` otherwise.\n     */\n  }, {\n    key: \"isChild\",\n    value: function isChild(index) {\n      return this.getRowParent(index) !== null;\n    }\n    /**\n     * Get child at a provided index from the parent element.\n     *\n     * @param {object} parent The parent row object.\n     * @param {number} index Index of the child element to be retrieved.\n     * @returns {object|null} The child element or `null` if the child doesn't exist.\n     */\n  }, {\n    key: \"getChild\",\n    value: function getChild(parent, index) {\n      var _parent$__children;\n      return ((_parent$__children = parent.__children) === null || _parent$__children === void 0 ? void 0 : _parent$__children[index]) || null;\n    }\n    /**\n     * Return `true` of the row at the provided index is located at the topmost level.\n     *\n     * @param {number} index Row index.\n     * @returns {boolean} `true` of the row at the provided index is located at the topmost level, `false` otherwise.\n     */\n  }, {\n    key: \"isRowHighestLevel\",\n    value: function isRowHighestLevel(index) {\n      return !this.isChild(index);\n    }\n    /**\n     * Return `true` if the provided row index / row object represents a parent in the nested structure.\n     *\n     * @param {number|object} row Row index / row object.\n     * @returns {boolean} `true` if the row is a parent, `false` otherwise.\n     */\n  }, {\n    key: \"isParent\",\n    value: function isParent(row) {\n      var _rowObj$__children;\n      var rowObj = row;\n      if (!isNaN(rowObj)) {\n        rowObj = this.getDataObject(rowObj);\n      }\n      return rowObj && !!rowObj.__children && ((_rowObj$__children = rowObj.__children) === null || _rowObj$__children === void 0 ? void 0 : _rowObj$__children.length) !== 0;\n    }\n    /**\n     * Add a child to the provided parent. It's optional to add a row object as the \"element\".\n     *\n     * @param {object} parent The parent row object.\n     * @param {object} [element] The element to add as a child.\n     */\n  }, {\n    key: \"addChild\",\n    value: function addChild(parent, element) {\n      var childElement = element;\n      this.hot.runHooks('beforeAddChild', parent, childElement);\n      var parentIndex = null;\n      if (parent) {\n        parentIndex = this.getRowIndex(parent);\n      }\n      this.hot.runHooks('beforeCreateRow', parentIndex + this.countChildren(parent) + 1, 1);\n      var functionalParent = parent;\n      if (!parent) {\n        functionalParent = this.mockParent();\n      }\n      if (!functionalParent.__children) {\n        functionalParent.__children = [];\n      }\n      if (!childElement) {\n        childElement = this.mockNode();\n      }\n      functionalParent.__children.push(childElement);\n      this.rewriteCache();\n      var newRowIndex = this.getRowIndex(childElement);\n      this.hot.rowIndexMapper.insertIndexes(newRowIndex, 1);\n      this.hot.runHooks('afterCreateRow', newRowIndex, 1);\n      this.hot.runHooks('afterAddChild', parent, childElement);\n    }\n    /**\n     * Add a child node to the provided parent at a specified index.\n     *\n     * @param {object} parent Parent node.\n     * @param {number} index Index to insert the child element at.\n     * @param {object} [element] Element (node) to insert.\n     */\n  }, {\n    key: \"addChildAtIndex\",\n    value: function addChildAtIndex(parent, index, element) {\n      var childElement = element;\n      var flattenedIndex;\n      if (!childElement) {\n        childElement = this.mockNode();\n      }\n      this.hot.runHooks('beforeAddChild', parent, childElement, index);\n      if (parent) {\n        var parentIndex = this.getRowIndex(parent);\n        var finalChildIndex = parentIndex + index + 1;\n        this.hot.runHooks('beforeCreateRow', finalChildIndex, 1);\n        parent.__children.splice(index, null, childElement);\n        this.rewriteCache();\n        this.plugin.disableCoreAPIModifiers();\n        this.hot.setSourceDataAtCell(this.getRowIndexWithinParent(parent), '__children', parent.__children, 'NestedRows.addChildAtIndex');\n        this.hot.rowIndexMapper.insertIndexes(finalChildIndex, 1);\n        this.plugin.enableCoreAPIModifiers();\n        this.hot.runHooks('afterCreateRow', finalChildIndex, 1);\n        flattenedIndex = finalChildIndex;\n      } else {\n        this.plugin.disableCoreAPIModifiers();\n        this.hot.alter('insert_row', index, 1, 'NestedRows.addChildAtIndex');\n        this.plugin.enableCoreAPIModifiers();\n        flattenedIndex = this.getRowIndex(this.data[index]);\n      } // Workaround for refreshing cache losing the reference to the mocked row.\n\n      childElement = this.getDataObject(flattenedIndex);\n      this.hot.runHooks('afterAddChild', parent, childElement, index);\n    }\n    /**\n     * Add a sibling element at the specified index.\n     *\n     * @param {number} index New element sibling's index.\n     * @param {('above'|'below')} where Direction in which the sibling is to be created.\n     */\n  }, {\n    key: \"addSibling\",\n    value: function addSibling(index) {\n      var where = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'below';\n      var translatedIndex = this.translateTrimmedRow(index);\n      var parent = this.getRowParent(translatedIndex);\n      var indexWithinParent = this.getRowIndexWithinParent(translatedIndex);\n      switch (where) {\n        case 'below':\n          this.addChildAtIndex(parent, indexWithinParent + 1, null);\n          break;\n        case 'above':\n          this.addChildAtIndex(parent, indexWithinParent, null);\n          break;\n        default:\n          break;\n      }\n    }\n    /**\n     * Detach the provided element from its parent and add it right after it.\n     *\n     * @param {object|Array} elements Row object or an array of selected coordinates.\n     * @param {boolean} [forceRender=true] If true (default), it triggers render after finished.\n     */\n  }, {\n    key: \"detachFromParent\",\n    value: function detachFromParent(elements) {\n      var _this5 = this;\n      var forceRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var element = null;\n      var rowObjects = [];\n      if (Array.isArray(elements)) {\n        rangeEach(elements[0], elements[2], function (i) {\n          var translatedIndex = _this5.translateTrimmedRow(i);\n          rowObjects.push(_this5.getDataObject(translatedIndex));\n        });\n        rangeEach(0, rowObjects.length - 2, function (i) {\n          _this5.detachFromParent(rowObjects[i], false);\n        });\n        element = rowObjects[rowObjects.length - 1];\n      } else {\n        element = elements;\n      }\n      var childRowIndex = this.getRowIndex(element);\n      var childCount = this.countChildren(element);\n      var indexWithinParent = this.getRowIndexWithinParent(element);\n      var parent = this.getRowParent(element);\n      var grandparent = this.getRowParent(parent);\n      var grandparentRowIndex = this.getRowIndex(grandparent);\n      var movedElementRowIndex = null;\n      this.hot.runHooks('beforeDetachChild', parent, element);\n      if (indexWithinParent !== null && indexWithinParent !== void 0) {\n        var removedRowIndexes = Array.from(new Array(childRowIndex + childCount + 1).keys()).splice(-1 * (childCount + 1));\n        this.hot.runHooks('beforeRemoveRow', childRowIndex, childCount + 1, removedRowIndexes, this.plugin.pluginName);\n        parent.__children.splice(indexWithinParent, 1);\n        this.rewriteCache();\n        this.hot.runHooks('afterRemoveRow', childRowIndex, childCount + 1, removedRowIndexes, this.plugin.pluginName);\n        if (grandparent) {\n          movedElementRowIndex = grandparentRowIndex + this.countChildren(grandparent);\n          var lastGrandparentChild = this.getChild(grandparent, this.countChildren(grandparent) - 1);\n          var lastGrandparentChildIndex = this.getRowIndex(lastGrandparentChild);\n          this.hot.runHooks('beforeCreateRow', lastGrandparentChildIndex + 1, childCount + 1, this.plugin.pluginName);\n          grandparent.__children.push(element);\n        } else {\n          movedElementRowIndex = this.hot.countRows() + 1;\n          this.hot.runHooks('beforeCreateRow', movedElementRowIndex - 2, childCount + 1, this.plugin.pluginName);\n          this.data.push(element);\n        }\n      }\n      this.rewriteCache();\n      this.hot.runHooks('afterCreateRow', movedElementRowIndex - 2, childCount + 1, this.plugin.pluginName);\n      this.hot.runHooks('afterDetachChild', parent, element, this.getRowIndex(element));\n      if (forceRender) {\n        this.hot.render();\n      }\n    }\n    /**\n     * Filter the data by the `logicRows` array.\n     *\n     * @private\n     * @param {number} index Index of the first row to remove.\n     * @param {number} amount Number of elements to remove.\n     * @param {Array} logicRows Array of indexes to remove.\n     */\n  }, {\n    key: \"filterData\",\n    value: function filterData(index, amount, logicRows) {\n      var _this6 = this;\n\n      // TODO: why are the first 2 arguments not used?\n      var elementsToRemove = [];\n      arrayEach(logicRows, function (elem) {\n        elementsToRemove.push(_this6.getDataObject(elem));\n      });\n      arrayEach(elementsToRemove, function (elem) {\n        var indexWithinParent = _this6.getRowIndexWithinParent(elem);\n        var tempParent = _this6.getRowParent(elem);\n        if (tempParent === null) {\n          _this6.data.splice(indexWithinParent, 1);\n        } else {\n          tempParent.__children.splice(indexWithinParent, 1);\n        }\n      });\n      this.rewriteCache();\n    }\n    /**\n     * Used to splice the source data. Needed to properly modify the nested structure, which wouldn't work with the\n     * default script.\n     *\n     * @private\n     * @param {number} index Physical index of the element at the splice beginning.\n     * @param {number} amount Number of elements to be removed.\n     * @param {object[]} elements Array of row objects to add.\n     */\n  }, {\n    key: \"spliceData\",\n    value: function spliceData(index, amount, elements) {\n      var previousElement = this.getDataObject(index - 1);\n      var newRowParent = null;\n      var indexWithinParent = index;\n      if (previousElement && previousElement.__children && previousElement.__children.length === 0) {\n        newRowParent = previousElement;\n        indexWithinParent = 0;\n      } else if (index < this.countAllRows()) {\n        newRowParent = this.getRowParent(index);\n        indexWithinParent = this.getRowIndexWithinParent(index);\n      }\n      if (newRowParent) {\n        if (elements) {\n          var _newRowParent$__child;\n          (_newRowParent$__child = newRowParent.__children).splice.apply(_newRowParent$__child, [indexWithinParent, amount].concat(_toConsumableArray(elements)));\n        } else {\n          newRowParent.__children.splice(indexWithinParent, amount);\n        }\n      } else if (elements) {\n        var _this$data;\n        (_this$data = this.data).splice.apply(_this$data, [indexWithinParent, amount].concat(_toConsumableArray(elements)));\n      } else {\n        this.data.splice(indexWithinParent, amount);\n      }\n      this.rewriteCache();\n    }\n    /**\n     * Update the `__children` key of the upmost parent of the provided row object.\n     *\n     * @private\n     * @param {object} rowElement Row object.\n     */\n  }, {\n    key: \"syncRowWithRawSource\",\n    value: function syncRowWithRawSource(rowElement) {\n      var upmostParent = rowElement;\n      var tempParent = null;\n      do {\n        tempParent = this.getRowParent(tempParent);\n        if (tempParent !== null) {\n          upmostParent = tempParent;\n        }\n      } while (tempParent !== null);\n      this.plugin.disableCoreAPIModifiers();\n      this.hot.setSourceDataAtCell(this.getRowIndex(upmostParent), '__children', upmostParent.__children, 'NestedRows.syncRowWithRawSource');\n      this.plugin.enableCoreAPIModifiers();\n    }\n    /* eslint-disable jsdoc/require-param */\n\n    /**\n     * Move a single row.\n     *\n     * @param {number} fromIndex Index of the row to be moved.\n     * @param {number} toIndex Index of the destination.\n     * @param {boolean} moveToCollapsed `true` if moving a row to a collapsed parent.\n     * @param {boolean} moveToLastChild `true` if moving a row to be a last child of the new parent.\n     */\n\n    /* eslint-enable jsdoc/require-param */\n  }, {\n    key: \"moveRow\",\n    value: function moveRow(fromIndex, toIndex, moveToCollapsed, moveToLastChild) {\n      var moveToLastRow = toIndex === this.hot.countRows();\n      var fromParent = this.getRowParent(fromIndex);\n      var indexInFromParent = this.getRowIndexWithinParent(fromIndex);\n      var elemToMove = fromParent.__children.slice(indexInFromParent, indexInFromParent + 1);\n      var movingUp = fromIndex > toIndex;\n      var toParent = moveToLastRow ? this.getRowParent(toIndex - 1) : this.getRowParent(toIndex);\n      if (toParent === null || toParent === void 0) {\n        toParent = this.getRowParent(toIndex - 1);\n      }\n      if (toParent === null || toParent === void 0) {\n        toParent = this.getDataObject(toIndex - 1);\n      }\n      if (!toParent) {\n        toParent = this.getDataObject(toIndex);\n        toParent.__children = [];\n      } else if (!toParent.__children) {\n        toParent.__children = [];\n      }\n      var indexInTargetParent = moveToLastRow || moveToCollapsed || moveToLastChild ? toParent.__children.length : this.getRowIndexWithinParent(toIndex);\n      var sameParent = fromParent === toParent;\n      toParent.__children.splice(indexInTargetParent, 0, elemToMove[0]);\n      fromParent.__children.splice(indexInFromParent + (movingUp && sameParent ? 1 : 0), 1); // Sync the changes in the cached data with the actual data stored in HOT.\n\n      this.syncRowWithRawSource(fromParent);\n      if (!sameParent) {\n        this.syncRowWithRawSource(toParent);\n      }\n    }\n    /**\n     * Translate the visual row index to the physical index, taking into consideration the state of collapsed rows.\n     *\n     * @private\n     * @param {number} row Row index.\n     * @returns {number}\n     */\n  }, {\n    key: \"translateTrimmedRow\",\n    value: function translateTrimmedRow(row) {\n      if (this.plugin.collapsingUI) {\n        return this.plugin.collapsingUI.translateTrimmedRow(row);\n      }\n      return row;\n    }\n    /**\n     * Translate the physical row index to the visual index, taking into consideration the state of collapsed rows.\n     *\n     * @private\n     * @param {number} row Row index.\n     * @returns {number}\n     */\n  }, {\n    key: \"untranslateTrimmedRow\",\n    value: function untranslateTrimmedRow(row) {\n      if (this.plugin.collapsingUI) {\n        return this.plugin.collapsingUI.untranslateTrimmedRow(row);\n      }\n      return row;\n    }\n  }]);\n  return DataManager;\n}();\nexport default DataManager;","map":{"version":3,"names":["_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","TypeError","o","minLen","_arrayLikeToArray","n","Object","prototype","toString","call","slice","constructor","name","Array","from","test","iter","Symbol","iterator","isArray","len","length","i","arr2","_typeof","obj","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","rangeEach","objectEach","arrayEach","DataManager","nestedRowsPlugin","hotInstance","hot","data","plugin","parentReference","WeakMap","cache","levels","levelCount","rows","nodeInfo","value","setData","getData","getRawSourceData","rawSourceData","disableCoreAPIModifiers","getSourceData","enableCoreAPIModifiers","updateWithData","rewriteCache","_this","cacheNode","node","level","parent","_this2","push","set","row","hasChildren","__children","elem","getDataObject","readTreeNodes","readCount","neededIndex","neededObject","_this3","rootLevel","readNodesCount","isNaN","end","parentObj","result","val","mockParent","fakeParent","mockNode","fakeNode","getRowIndex","rowObj","get","getRowIndexWithinParent","getRowParent","indexOf","countAllRows","rootNodeMock","countChildren","_this4","rowCount","parentNode","rowObject","getRowObjectParent","getRowLevel","getRowObjectLevel","isChild","index","getChild","_parent$__children","isRowHighestLevel","isParent","_rowObj$__children","addChild","element","childElement","runHooks","parentIndex","functionalParent","newRowIndex","rowIndexMapper","insertIndexes","addChildAtIndex","flattenedIndex","finalChildIndex","splice","setSourceDataAtCell","alter","addSibling","where","arguments","undefined","translatedIndex","translateTrimmedRow","indexWithinParent","detachFromParent","elements","_this5","forceRender","rowObjects","childRowIndex","childCount","grandparent","grandparentRowIndex","movedElementRowIndex","removedRowIndexes","keys","pluginName","lastGrandparentChild","lastGrandparentChildIndex","countRows","render","filterData","amount","logicRows","_this6","elementsToRemove","tempParent","spliceData","previousElement","newRowParent","_newRowParent$__child","apply","concat","_this$data","syncRowWithRawSource","rowElement","upmostParent","moveRow","fromIndex","toIndex","moveToCollapsed","moveToLastChild","moveToLastRow","fromParent","indexInFromParent","elemToMove","movingUp","toParent","indexInTargetParent","sameParent","collapsingUI","untranslateTrimmedRow"],"sources":["/Users/priyadeliwala/Desktop/sales-dashboard/node_modules/handsontable/plugins/nestedRows/data/dataManager.mjs"],"sourcesContent":["function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.weak-map.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nimport { rangeEach } from \"../../../helpers/number.mjs\";\nimport { objectEach } from \"../../../helpers/object.mjs\";\nimport { arrayEach } from \"../../../helpers/array.mjs\";\n/**\n * Class responsible for making data operations.\n *\n * @private\n */\n\nvar DataManager = /*#__PURE__*/function () {\n  function DataManager(nestedRowsPlugin, hotInstance) {\n    _classCallCheck(this, DataManager);\n\n    /**\n     * Main Handsontable instance reference.\n     *\n     * @type {object}\n     */\n    this.hot = hotInstance;\n    /**\n     * Reference to the source data object.\n     *\n     * @type {Handsontable.CellValue[][]|Handsontable.RowObject[]}\n     */\n\n    this.data = null;\n    /**\n     * Reference to the NestedRows plugin.\n     *\n     * @type {object}\n     */\n\n    this.plugin = nestedRowsPlugin;\n    /**\n     * Map of row object parents.\n     *\n     * @type {WeakMap}\n     */\n\n    this.parentReference = new WeakMap();\n    /**\n     * Nested structure cache.\n     *\n     * @type {object}\n     */\n\n    this.cache = {\n      levels: [],\n      levelCount: 0,\n      rows: [],\n      nodeInfo: new WeakMap()\n    };\n  }\n  /**\n   * Set the data for the manager.\n   *\n   * @param {Handsontable.CellValue[][]|Handsontable.RowObject[]} data Data for the manager.\n   */\n\n\n  _createClass(DataManager, [{\n    key: \"setData\",\n    value: function setData(data) {\n      this.data = data;\n    }\n    /**\n     * Get the data cached in the manager.\n     *\n     * @returns {Handsontable.CellValue[][]|Handsontable.RowObject[]}\n     */\n\n  }, {\n    key: \"getData\",\n    value: function getData() {\n      return this.data;\n    }\n    /**\n     * Load the \"raw\" source data, without NestedRows' modifications.\n     *\n     * @returns {Handsontable.CellValue[][]|Handsontable.RowObject[]}\n     */\n\n  }, {\n    key: \"getRawSourceData\",\n    value: function getRawSourceData() {\n      var rawSourceData = null;\n      this.plugin.disableCoreAPIModifiers();\n      rawSourceData = this.hot.getSourceData();\n      this.plugin.enableCoreAPIModifiers();\n      return rawSourceData;\n    }\n    /**\n     * Update the Data Manager with new data and refresh cache.\n     *\n     * @param {Handsontable.CellValue[][]|Handsontable.RowObject[]} data Data for the manager.\n     */\n\n  }, {\n    key: \"updateWithData\",\n    value: function updateWithData(data) {\n      this.setData(data);\n      this.rewriteCache();\n    }\n    /**\n     * Rewrite the nested structure cache.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"rewriteCache\",\n    value: function rewriteCache() {\n      var _this = this;\n\n      this.cache = {\n        levels: [],\n        levelCount: 0,\n        rows: [],\n        nodeInfo: new WeakMap()\n      };\n      rangeEach(0, this.data.length - 1, function (i) {\n        _this.cacheNode(_this.data[i], 0, null);\n      });\n    }\n    /**\n     * Cache a data node.\n     *\n     * @private\n     * @param {object} node Node to cache.\n     * @param {number} level Level of the node.\n     * @param {object} parent Parent of the node.\n     */\n\n  }, {\n    key: \"cacheNode\",\n    value: function cacheNode(node, level, parent) {\n      var _this2 = this;\n\n      if (!this.cache.levels[level]) {\n        this.cache.levels[level] = [];\n        this.cache.levelCount += 1;\n      }\n\n      this.cache.levels[level].push(node);\n      this.cache.rows.push(node);\n      this.cache.nodeInfo.set(node, {\n        parent: parent,\n        row: this.cache.rows.length - 1,\n        level: level\n      });\n\n      if (this.hasChildren(node)) {\n        arrayEach(node.__children, function (elem) {\n          _this2.cacheNode(elem, level + 1, node);\n        });\n      }\n    }\n    /**\n     * Get the date for the provided visual row number.\n     *\n     * @param {number} row Row index.\n     * @returns {object}\n     */\n\n  }, {\n    key: \"getDataObject\",\n    value: function getDataObject(row) {\n      return row === null || row === void 0 ? null : this.cache.rows[row];\n    }\n    /**\n     * Read the row tree in search for a specific row index or row object.\n     *\n     * @private\n     * @param {object} parent The initial parent object.\n     * @param {number} readCount Number of read nodes.\n     * @param {number} neededIndex The row index we search for.\n     * @param {object} neededObject The row object we search for.\n     * @returns {number|object}\n     */\n\n  }, {\n    key: \"readTreeNodes\",\n    value: function readTreeNodes(parent, readCount, neededIndex, neededObject) {\n      var _this3 = this;\n\n      var rootLevel = false;\n      var readNodesCount = readCount;\n\n      if (isNaN(readNodesCount) && readNodesCount.end) {\n        return readNodesCount;\n      }\n\n      var parentObj = parent;\n\n      if (!parentObj) {\n        parentObj = {\n          __children: this.data\n        };\n        rootLevel = true;\n        readNodesCount -= 1;\n      }\n\n      if (neededIndex !== null && neededIndex !== void 0 && readNodesCount === neededIndex) {\n        return {\n          result: parentObj,\n          end: true\n        };\n      }\n\n      if (neededObject !== null && neededObject !== void 0 && parentObj === neededObject) {\n        return {\n          result: readNodesCount,\n          end: true\n        };\n      }\n\n      readNodesCount += 1;\n\n      if (parentObj.__children) {\n        arrayEach(parentObj.__children, function (val) {\n          _this3.parentReference.set(val, rootLevel ? null : parentObj);\n\n          readNodesCount = _this3.readTreeNodes(val, readNodesCount, neededIndex, neededObject);\n\n          if (isNaN(readNodesCount) && readNodesCount.end) {\n            return false;\n          }\n        });\n      }\n\n      return readNodesCount;\n    }\n    /**\n     * Mock a parent node.\n     *\n     * @private\n     * @returns {*}\n     */\n\n  }, {\n    key: \"mockParent\",\n    value: function mockParent() {\n      var fakeParent = this.mockNode();\n      fakeParent.__children = this.data;\n      return fakeParent;\n    }\n    /**\n     * Mock a data node.\n     *\n     * @private\n     * @returns {{}}\n     */\n\n  }, {\n    key: \"mockNode\",\n    value: function mockNode() {\n      var fakeNode = {};\n      objectEach(this.data[0], function (val, key) {\n        fakeNode[key] = null;\n      });\n      return fakeNode;\n    }\n    /**\n     * Get the row index for the provided row object.\n     *\n     * @param {object} rowObj The row object.\n     * @returns {number} Row index.\n     */\n\n  }, {\n    key: \"getRowIndex\",\n    value: function getRowIndex(rowObj) {\n      return rowObj === null || rowObj === void 0 ? null : this.cache.nodeInfo.get(rowObj).row;\n    }\n    /**\n     * Get the index of the provided row index/row object within its parent.\n     *\n     * @param {number|object} row Row index / row object.\n     * @returns {number}\n     */\n\n  }, {\n    key: \"getRowIndexWithinParent\",\n    value: function getRowIndexWithinParent(row) {\n      var rowObj = null;\n\n      if (isNaN(row)) {\n        rowObj = row;\n      } else {\n        rowObj = this.getDataObject(row);\n      }\n\n      var parent = this.getRowParent(row);\n\n      if (parent === null || parent === void 0) {\n        return this.data.indexOf(rowObj);\n      }\n\n      return parent.__children.indexOf(rowObj);\n    }\n    /**\n     * Count all rows (including all parents and children).\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: \"countAllRows\",\n    value: function countAllRows() {\n      var rootNodeMock = {\n        __children: this.data\n      };\n      return this.countChildren(rootNodeMock);\n    }\n    /**\n     * Count children of the provided parent.\n     *\n     * @param {object|number} parent Parent node.\n     * @returns {number} Children count.\n     */\n\n  }, {\n    key: \"countChildren\",\n    value: function countChildren(parent) {\n      var _this4 = this;\n\n      var rowCount = 0;\n      var parentNode = parent;\n\n      if (!isNaN(parentNode)) {\n        parentNode = this.getDataObject(parentNode);\n      }\n\n      if (!parentNode || !parentNode.__children) {\n        return 0;\n      }\n\n      arrayEach(parentNode.__children, function (elem) {\n        rowCount += 1;\n\n        if (elem.__children) {\n          rowCount += _this4.countChildren(elem);\n        }\n      });\n      return rowCount;\n    }\n    /**\n     * Get the parent of the row at the provided index.\n     *\n     * @param {number|object} row Physical row index.\n     * @returns {object}\n     */\n\n  }, {\n    key: \"getRowParent\",\n    value: function getRowParent(row) {\n      var rowObject;\n\n      if (isNaN(row)) {\n        rowObject = row;\n      } else {\n        rowObject = this.getDataObject(row);\n      }\n\n      return this.getRowObjectParent(rowObject);\n    }\n    /**\n     * Get the parent of the provided row object.\n     *\n     * @private\n     * @param {object} rowObject The row object (tree node).\n     * @returns {object|null}\n     */\n\n  }, {\n    key: \"getRowObjectParent\",\n    value: function getRowObjectParent(rowObject) {\n      if (!rowObject || _typeof(rowObject) !== 'object') {\n        return null;\n      }\n\n      return this.cache.nodeInfo.get(rowObject).parent;\n    }\n    /**\n     * Get the nesting level for the row with the provided row index.\n     *\n     * @param {number} row Row index.\n     * @returns {number|null} Row level or null, when row doesn't exist.\n     */\n\n  }, {\n    key: \"getRowLevel\",\n    value: function getRowLevel(row) {\n      var rowObject = null;\n\n      if (isNaN(row)) {\n        rowObject = row;\n      } else {\n        rowObject = this.getDataObject(row);\n      }\n\n      return rowObject ? this.getRowObjectLevel(rowObject) : null;\n    }\n    /**\n     * Get the nesting level for the row with the provided row index.\n     *\n     * @private\n     * @param {object} rowObject Row object.\n     * @returns {number} Row level.\n     */\n\n  }, {\n    key: \"getRowObjectLevel\",\n    value: function getRowObjectLevel(rowObject) {\n      return rowObject === null || rowObject === void 0 ? null : this.cache.nodeInfo.get(rowObject).level;\n    }\n    /**\n     * Check if the provided row/row element has children.\n     *\n     * @param {number|object} row Row number or row element.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"hasChildren\",\n    value: function hasChildren(row) {\n      var rowObj = row;\n\n      if (!isNaN(rowObj)) {\n        rowObj = this.getDataObject(rowObj);\n      }\n\n      return !!(rowObj.__children && rowObj.__children.length);\n    }\n    /**\n     * Returns `true` if the row at the provided index has a parent.\n     *\n     * @param {number} index Row index.\n     * @returns {boolean} `true` if the row at the provided index has a parent, `false` otherwise.\n     */\n\n  }, {\n    key: \"isChild\",\n    value: function isChild(index) {\n      return this.getRowParent(index) !== null;\n    }\n    /**\n     * Get child at a provided index from the parent element.\n     *\n     * @param {object} parent The parent row object.\n     * @param {number} index Index of the child element to be retrieved.\n     * @returns {object|null} The child element or `null` if the child doesn't exist.\n     */\n\n  }, {\n    key: \"getChild\",\n    value: function getChild(parent, index) {\n      var _parent$__children;\n\n      return ((_parent$__children = parent.__children) === null || _parent$__children === void 0 ? void 0 : _parent$__children[index]) || null;\n    }\n    /**\n     * Return `true` of the row at the provided index is located at the topmost level.\n     *\n     * @param {number} index Row index.\n     * @returns {boolean} `true` of the row at the provided index is located at the topmost level, `false` otherwise.\n     */\n\n  }, {\n    key: \"isRowHighestLevel\",\n    value: function isRowHighestLevel(index) {\n      return !this.isChild(index);\n    }\n    /**\n     * Return `true` if the provided row index / row object represents a parent in the nested structure.\n     *\n     * @param {number|object} row Row index / row object.\n     * @returns {boolean} `true` if the row is a parent, `false` otherwise.\n     */\n\n  }, {\n    key: \"isParent\",\n    value: function isParent(row) {\n      var _rowObj$__children;\n\n      var rowObj = row;\n\n      if (!isNaN(rowObj)) {\n        rowObj = this.getDataObject(rowObj);\n      }\n\n      return rowObj && !!rowObj.__children && ((_rowObj$__children = rowObj.__children) === null || _rowObj$__children === void 0 ? void 0 : _rowObj$__children.length) !== 0;\n    }\n    /**\n     * Add a child to the provided parent. It's optional to add a row object as the \"element\".\n     *\n     * @param {object} parent The parent row object.\n     * @param {object} [element] The element to add as a child.\n     */\n\n  }, {\n    key: \"addChild\",\n    value: function addChild(parent, element) {\n      var childElement = element;\n      this.hot.runHooks('beforeAddChild', parent, childElement);\n      var parentIndex = null;\n\n      if (parent) {\n        parentIndex = this.getRowIndex(parent);\n      }\n\n      this.hot.runHooks('beforeCreateRow', parentIndex + this.countChildren(parent) + 1, 1);\n      var functionalParent = parent;\n\n      if (!parent) {\n        functionalParent = this.mockParent();\n      }\n\n      if (!functionalParent.__children) {\n        functionalParent.__children = [];\n      }\n\n      if (!childElement) {\n        childElement = this.mockNode();\n      }\n\n      functionalParent.__children.push(childElement);\n\n      this.rewriteCache();\n      var newRowIndex = this.getRowIndex(childElement);\n      this.hot.rowIndexMapper.insertIndexes(newRowIndex, 1);\n      this.hot.runHooks('afterCreateRow', newRowIndex, 1);\n      this.hot.runHooks('afterAddChild', parent, childElement);\n    }\n    /**\n     * Add a child node to the provided parent at a specified index.\n     *\n     * @param {object} parent Parent node.\n     * @param {number} index Index to insert the child element at.\n     * @param {object} [element] Element (node) to insert.\n     */\n\n  }, {\n    key: \"addChildAtIndex\",\n    value: function addChildAtIndex(parent, index, element) {\n      var childElement = element;\n      var flattenedIndex;\n\n      if (!childElement) {\n        childElement = this.mockNode();\n      }\n\n      this.hot.runHooks('beforeAddChild', parent, childElement, index);\n\n      if (parent) {\n        var parentIndex = this.getRowIndex(parent);\n        var finalChildIndex = parentIndex + index + 1;\n        this.hot.runHooks('beforeCreateRow', finalChildIndex, 1);\n\n        parent.__children.splice(index, null, childElement);\n\n        this.rewriteCache();\n        this.plugin.disableCoreAPIModifiers();\n        this.hot.setSourceDataAtCell(this.getRowIndexWithinParent(parent), '__children', parent.__children, 'NestedRows.addChildAtIndex');\n        this.hot.rowIndexMapper.insertIndexes(finalChildIndex, 1);\n        this.plugin.enableCoreAPIModifiers();\n        this.hot.runHooks('afterCreateRow', finalChildIndex, 1);\n        flattenedIndex = finalChildIndex;\n      } else {\n        this.plugin.disableCoreAPIModifiers();\n        this.hot.alter('insert_row', index, 1, 'NestedRows.addChildAtIndex');\n        this.plugin.enableCoreAPIModifiers();\n        flattenedIndex = this.getRowIndex(this.data[index]);\n      } // Workaround for refreshing cache losing the reference to the mocked row.\n\n\n      childElement = this.getDataObject(flattenedIndex);\n      this.hot.runHooks('afterAddChild', parent, childElement, index);\n    }\n    /**\n     * Add a sibling element at the specified index.\n     *\n     * @param {number} index New element sibling's index.\n     * @param {('above'|'below')} where Direction in which the sibling is to be created.\n     */\n\n  }, {\n    key: \"addSibling\",\n    value: function addSibling(index) {\n      var where = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'below';\n      var translatedIndex = this.translateTrimmedRow(index);\n      var parent = this.getRowParent(translatedIndex);\n      var indexWithinParent = this.getRowIndexWithinParent(translatedIndex);\n\n      switch (where) {\n        case 'below':\n          this.addChildAtIndex(parent, indexWithinParent + 1, null);\n          break;\n\n        case 'above':\n          this.addChildAtIndex(parent, indexWithinParent, null);\n          break;\n\n        default:\n          break;\n      }\n    }\n    /**\n     * Detach the provided element from its parent and add it right after it.\n     *\n     * @param {object|Array} elements Row object or an array of selected coordinates.\n     * @param {boolean} [forceRender=true] If true (default), it triggers render after finished.\n     */\n\n  }, {\n    key: \"detachFromParent\",\n    value: function detachFromParent(elements) {\n      var _this5 = this;\n\n      var forceRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var element = null;\n      var rowObjects = [];\n\n      if (Array.isArray(elements)) {\n        rangeEach(elements[0], elements[2], function (i) {\n          var translatedIndex = _this5.translateTrimmedRow(i);\n\n          rowObjects.push(_this5.getDataObject(translatedIndex));\n        });\n        rangeEach(0, rowObjects.length - 2, function (i) {\n          _this5.detachFromParent(rowObjects[i], false);\n        });\n        element = rowObjects[rowObjects.length - 1];\n      } else {\n        element = elements;\n      }\n\n      var childRowIndex = this.getRowIndex(element);\n      var childCount = this.countChildren(element);\n      var indexWithinParent = this.getRowIndexWithinParent(element);\n      var parent = this.getRowParent(element);\n      var grandparent = this.getRowParent(parent);\n      var grandparentRowIndex = this.getRowIndex(grandparent);\n      var movedElementRowIndex = null;\n      this.hot.runHooks('beforeDetachChild', parent, element);\n\n      if (indexWithinParent !== null && indexWithinParent !== void 0) {\n        var removedRowIndexes = Array.from(new Array(childRowIndex + childCount + 1).keys()).splice(-1 * (childCount + 1));\n        this.hot.runHooks('beforeRemoveRow', childRowIndex, childCount + 1, removedRowIndexes, this.plugin.pluginName);\n\n        parent.__children.splice(indexWithinParent, 1);\n\n        this.rewriteCache();\n        this.hot.runHooks('afterRemoveRow', childRowIndex, childCount + 1, removedRowIndexes, this.plugin.pluginName);\n\n        if (grandparent) {\n          movedElementRowIndex = grandparentRowIndex + this.countChildren(grandparent);\n          var lastGrandparentChild = this.getChild(grandparent, this.countChildren(grandparent) - 1);\n          var lastGrandparentChildIndex = this.getRowIndex(lastGrandparentChild);\n          this.hot.runHooks('beforeCreateRow', lastGrandparentChildIndex + 1, childCount + 1, this.plugin.pluginName);\n\n          grandparent.__children.push(element);\n        } else {\n          movedElementRowIndex = this.hot.countRows() + 1;\n          this.hot.runHooks('beforeCreateRow', movedElementRowIndex - 2, childCount + 1, this.plugin.pluginName);\n          this.data.push(element);\n        }\n      }\n\n      this.rewriteCache();\n      this.hot.runHooks('afterCreateRow', movedElementRowIndex - 2, childCount + 1, this.plugin.pluginName);\n      this.hot.runHooks('afterDetachChild', parent, element, this.getRowIndex(element));\n\n      if (forceRender) {\n        this.hot.render();\n      }\n    }\n    /**\n     * Filter the data by the `logicRows` array.\n     *\n     * @private\n     * @param {number} index Index of the first row to remove.\n     * @param {number} amount Number of elements to remove.\n     * @param {Array} logicRows Array of indexes to remove.\n     */\n\n  }, {\n    key: \"filterData\",\n    value: function filterData(index, amount, logicRows) {\n      var _this6 = this;\n\n      // TODO: why are the first 2 arguments not used?\n      var elementsToRemove = [];\n      arrayEach(logicRows, function (elem) {\n        elementsToRemove.push(_this6.getDataObject(elem));\n      });\n      arrayEach(elementsToRemove, function (elem) {\n        var indexWithinParent = _this6.getRowIndexWithinParent(elem);\n\n        var tempParent = _this6.getRowParent(elem);\n\n        if (tempParent === null) {\n          _this6.data.splice(indexWithinParent, 1);\n        } else {\n          tempParent.__children.splice(indexWithinParent, 1);\n        }\n      });\n      this.rewriteCache();\n    }\n    /**\n     * Used to splice the source data. Needed to properly modify the nested structure, which wouldn't work with the\n     * default script.\n     *\n     * @private\n     * @param {number} index Physical index of the element at the splice beginning.\n     * @param {number} amount Number of elements to be removed.\n     * @param {object[]} elements Array of row objects to add.\n     */\n\n  }, {\n    key: \"spliceData\",\n    value: function spliceData(index, amount, elements) {\n      var previousElement = this.getDataObject(index - 1);\n      var newRowParent = null;\n      var indexWithinParent = index;\n\n      if (previousElement && previousElement.__children && previousElement.__children.length === 0) {\n        newRowParent = previousElement;\n        indexWithinParent = 0;\n      } else if (index < this.countAllRows()) {\n        newRowParent = this.getRowParent(index);\n        indexWithinParent = this.getRowIndexWithinParent(index);\n      }\n\n      if (newRowParent) {\n        if (elements) {\n          var _newRowParent$__child;\n\n          (_newRowParent$__child = newRowParent.__children).splice.apply(_newRowParent$__child, [indexWithinParent, amount].concat(_toConsumableArray(elements)));\n        } else {\n          newRowParent.__children.splice(indexWithinParent, amount);\n        }\n      } else if (elements) {\n        var _this$data;\n\n        (_this$data = this.data).splice.apply(_this$data, [indexWithinParent, amount].concat(_toConsumableArray(elements)));\n      } else {\n        this.data.splice(indexWithinParent, amount);\n      }\n\n      this.rewriteCache();\n    }\n    /**\n     * Update the `__children` key of the upmost parent of the provided row object.\n     *\n     * @private\n     * @param {object} rowElement Row object.\n     */\n\n  }, {\n    key: \"syncRowWithRawSource\",\n    value: function syncRowWithRawSource(rowElement) {\n      var upmostParent = rowElement;\n      var tempParent = null;\n\n      do {\n        tempParent = this.getRowParent(tempParent);\n\n        if (tempParent !== null) {\n          upmostParent = tempParent;\n        }\n      } while (tempParent !== null);\n\n      this.plugin.disableCoreAPIModifiers();\n      this.hot.setSourceDataAtCell(this.getRowIndex(upmostParent), '__children', upmostParent.__children, 'NestedRows.syncRowWithRawSource');\n      this.plugin.enableCoreAPIModifiers();\n    }\n    /* eslint-disable jsdoc/require-param */\n\n    /**\n     * Move a single row.\n     *\n     * @param {number} fromIndex Index of the row to be moved.\n     * @param {number} toIndex Index of the destination.\n     * @param {boolean} moveToCollapsed `true` if moving a row to a collapsed parent.\n     * @param {boolean} moveToLastChild `true` if moving a row to be a last child of the new parent.\n     */\n\n    /* eslint-enable jsdoc/require-param */\n\n  }, {\n    key: \"moveRow\",\n    value: function moveRow(fromIndex, toIndex, moveToCollapsed, moveToLastChild) {\n      var moveToLastRow = toIndex === this.hot.countRows();\n      var fromParent = this.getRowParent(fromIndex);\n      var indexInFromParent = this.getRowIndexWithinParent(fromIndex);\n\n      var elemToMove = fromParent.__children.slice(indexInFromParent, indexInFromParent + 1);\n\n      var movingUp = fromIndex > toIndex;\n      var toParent = moveToLastRow ? this.getRowParent(toIndex - 1) : this.getRowParent(toIndex);\n\n      if (toParent === null || toParent === void 0) {\n        toParent = this.getRowParent(toIndex - 1);\n      }\n\n      if (toParent === null || toParent === void 0) {\n        toParent = this.getDataObject(toIndex - 1);\n      }\n\n      if (!toParent) {\n        toParent = this.getDataObject(toIndex);\n        toParent.__children = [];\n      } else if (!toParent.__children) {\n        toParent.__children = [];\n      }\n\n      var indexInTargetParent = moveToLastRow || moveToCollapsed || moveToLastChild ? toParent.__children.length : this.getRowIndexWithinParent(toIndex);\n      var sameParent = fromParent === toParent;\n\n      toParent.__children.splice(indexInTargetParent, 0, elemToMove[0]);\n\n      fromParent.__children.splice(indexInFromParent + (movingUp && sameParent ? 1 : 0), 1); // Sync the changes in the cached data with the actual data stored in HOT.\n\n\n      this.syncRowWithRawSource(fromParent);\n\n      if (!sameParent) {\n        this.syncRowWithRawSource(toParent);\n      }\n    }\n    /**\n     * Translate the visual row index to the physical index, taking into consideration the state of collapsed rows.\n     *\n     * @private\n     * @param {number} row Row index.\n     * @returns {number}\n     */\n\n  }, {\n    key: \"translateTrimmedRow\",\n    value: function translateTrimmedRow(row) {\n      if (this.plugin.collapsingUI) {\n        return this.plugin.collapsingUI.translateTrimmedRow(row);\n      }\n\n      return row;\n    }\n    /**\n     * Translate the physical row index to the visual index, taking into consideration the state of collapsed rows.\n     *\n     * @private\n     * @param {number} row Row index.\n     * @returns {number}\n     */\n\n  }, {\n    key: \"untranslateTrimmedRow\",\n    value: function untranslateTrimmedRow(row) {\n      if (this.plugin.collapsingUI) {\n        return this.plugin.collapsingUI.untranslateTrimmedRow(row);\n      }\n\n      return row;\n    }\n  }]);\n\n  return DataManager;\n}();\n\nexport default DataManager;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}