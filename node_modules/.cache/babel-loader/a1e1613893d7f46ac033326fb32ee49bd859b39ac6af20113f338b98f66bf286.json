{"ast":null,"code":"import _classCallCheck from \"/Users/priyadeliwala/Desktop/sales-dashboard/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/priyadeliwala/Desktop/sales-dashboard/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nfunction _classPrivateFieldInitSpec(e, t, a) {\n  _checkPrivateRedeclaration(e, t), t.set(e, a);\n}\nfunction _checkPrivateRedeclaration(e, t) {\n  if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n}\nfunction _classPrivateFieldGet(s, a) {\n  return s.get(_assertClassBrand(s, a));\n}\nfunction _classPrivateFieldSet(s, a, r) {\n  return s.set(_assertClassBrand(s, a), r), r;\n}\nfunction _assertClassBrand(e, t, n) {\n  if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;\n  throw new TypeError(\"Private element is not present on this object\");\n}\nimport { toUpperCaseFirst } from \"../../../helpers/string.mjs\";\nimport { getMoves } from \"../../../helpers/moves.mjs\";\n/**\n * @private\n * @class IndexSyncer\n * @description\n *\n * Indexes synchronizer responsible for providing logic for particular axis. It respects an idea to represent trimmed\n * elements in HF's engine to perform formulas calculations on them. It also provides method for translation from visual\n * row/column indexes to HF's row/column indexes.\n */\nvar _axis = /*#__PURE__*/new WeakMap();\nvar _indexMapper = /*#__PURE__*/new WeakMap();\nvar _indexSyncer = /*#__PURE__*/new WeakMap();\nvar _indexesSequence = /*#__PURE__*/new WeakMap();\nvar _movedIndexes = /*#__PURE__*/new WeakMap();\nvar _finalIndex = /*#__PURE__*/new WeakMap();\nvar _removedIndexes = /*#__PURE__*/new WeakMap();\nvar AxisSyncer = /*#__PURE__*/function () {\n  function AxisSyncer(axis, indexMapper, indexSyncer) {\n    _classCallCheck(this, AxisSyncer);\n    /**\n     * The axis for which the actions are performed.\n     *\n     * @private\n     * @type {'row'|'column'}\n     */\n    _classPrivateFieldInitSpec(this, _axis, void 0);\n    /**\n     * Reference to index mapper.\n     *\n     * @private\n     * @type {IndexMapper}\n     */\n    _classPrivateFieldInitSpec(this, _indexMapper, void 0);\n    /**\n     * The index synchronizer for both axis (is storing some more general information).\n     *\n     * @private\n     * @type {IndexSyncer}\n     */\n    _classPrivateFieldInitSpec(this, _indexSyncer, void 0);\n    /**\n     * Sequence of physical indexes stored for watching changes and calculating some transformations.\n     *\n     * @private\n     * @type {Array<number>}\n     */\n    _classPrivateFieldInitSpec(this, _indexesSequence, []);\n    /**\n     * List of moved HF indexes, stored before performing move on HOT to calculate transformation needed on HF's engine.\n     *\n     * @private\n     * @type {Array<number>}\n     */\n    _classPrivateFieldInitSpec(this, _movedIndexes, []);\n    /**\n     * Final HF's place where to move indexes, stored before performing move on HOT to calculate transformation needed on HF's engine.\n     *\n     * @private\n     * @type {number|undefined}\n     */\n    _classPrivateFieldInitSpec(this, _finalIndex, void 0);\n    /**\n     * List of removed HF indexes, stored before performing removal on HOT to calculate transformation needed on HF's engine.\n     *\n     * @private\n     * @type {Array<number>}\n     */\n    _classPrivateFieldInitSpec(this, _removedIndexes, []);\n    _classPrivateFieldSet(_axis, this, axis);\n    _classPrivateFieldSet(_indexMapper, this, indexMapper);\n    _classPrivateFieldSet(_indexSyncer, this, indexSyncer);\n  }\n\n  /**\n   * Sets removed HF indexes (it should be done right before performing move on HOT).\n   *\n   * @param {Array<number>} removedIndexes List of removed physical indexes.\n   * @returns {Array<number>} List of removed visual indexes.\n   */\n  return _createClass(AxisSyncer, [{\n    key: \"setRemovedHfIndexes\",\n    value: function setRemovedHfIndexes(removedIndexes) {\n      var _this = this;\n      _classPrivateFieldSet(_removedIndexes, this, removedIndexes.map(function (physicalIndex) {\n        var visualIndex = _classPrivateFieldGet(_indexMapper, _this).getVisualFromPhysicalIndex(physicalIndex);\n        return _this.getHfIndexFromVisualIndex(visualIndex);\n      }));\n      return _classPrivateFieldGet(_removedIndexes, this);\n    }\n\n    /**\n     * Gets removed HF indexes (right before performing removal on HOT).\n     *\n     * @returns {Array<number>} List of removed HF indexes.\n     */\n  }, {\n    key: \"getRemovedHfIndexes\",\n    value: function getRemovedHfIndexes() {\n      return _classPrivateFieldGet(_removedIndexes, this);\n    }\n\n    /**\n     * Gets corresponding HyperFormula index for particular visual index. It's respecting the idea that HF's engine\n     * is fed also with trimmed indexes (business requirements for formula result calculation also for trimmed elements).\n     *\n     * @param {number} visualIndex Visual index.\n     * @returns {number}\n     */\n  }, {\n    key: \"getHfIndexFromVisualIndex\",\n    value: function getHfIndexFromVisualIndex(visualIndex) {\n      var indexesSequence = _classPrivateFieldGet(_indexMapper, this).getIndexesSequence();\n      var notTrimmedIndexes = _classPrivateFieldGet(_indexMapper, this).getNotTrimmedIndexes();\n      return indexesSequence.indexOf(notTrimmedIndexes[visualIndex]);\n    }\n\n    /**\n     * Synchronizes moves done on HOT to HF engine (based on previously calculated positions).\n     *\n     * @private\n     * @param {Array<{from: number, to: number}>} moves Calculated HF's move positions.\n     */\n  }, {\n    key: \"syncMoves\",\n    value: function syncMoves(moves) {\n      var _this2 = this;\n      var NUMBER_OF_MOVED_INDEXES = 1;\n      var SYNC_MOVE_METHOD_NAME = \"move\".concat(toUpperCaseFirst(_classPrivateFieldGet(_axis, this)), \"s\");\n      _classPrivateFieldGet(_indexSyncer, this).getEngine().batch(function () {\n        moves.forEach(function (move) {\n          var moveToTheSamePosition = move.from !== move.to;\n          // Moving from left to right (or top to bottom) to a line (drop index) right after already moved element.\n          var anotherMoveWithoutEffect = move.from + 1 !== move.to;\n          if (moveToTheSamePosition && anotherMoveWithoutEffect) {\n            _classPrivateFieldGet(_indexSyncer, _this2).getEngine()[SYNC_MOVE_METHOD_NAME](_classPrivateFieldGet(_indexSyncer, _this2).getSheetId(), move.from, NUMBER_OF_MOVED_INDEXES, move.to);\n          }\n        });\n      });\n    }\n\n    /**\n     * Stores information about performed HOT moves for purpose of calculating where to move HF elements.\n     *\n     * @param {Array<number>} movedVisualIndexes Sequence of moved visual indexes for certain axis.\n     * @param {number} visualFinalIndex Final visual place where to move HOT indexes.\n     * @param {boolean} movePossible Indicates if it's possible to move HOT indexes to the desired position.\n     */\n  }, {\n    key: \"storeMovesInformation\",\n    value: function storeMovesInformation(movedVisualIndexes, visualFinalIndex, movePossible) {\n      var _this3 = this;\n      if (movePossible === false) {\n        return;\n      }\n      _classPrivateFieldSet(_movedIndexes, this, movedVisualIndexes.map(function (index) {\n        return _this3.getHfIndexFromVisualIndex(index);\n      }));\n      _classPrivateFieldSet(_finalIndex, this, this.getHfIndexFromVisualIndex(visualFinalIndex));\n    }\n\n    /**\n     * Calculating where to move HF elements and performing already calculated moves.\n     *\n     * @param {boolean} movePossible Indicates if it was possible to move HOT indexes to the desired position.\n     * @param {boolean} orderChanged Indicates if order of HOT indexes was changed by move.\n     */\n  }, {\n    key: \"calculateAndSyncMoves\",\n    value: function calculateAndSyncMoves(movePossible, orderChanged) {\n      var _this4 = this;\n      if (_classPrivateFieldGet(_indexSyncer, this).isPerformingUndoRedo()) {\n        return;\n      }\n      if (movePossible === false || orderChanged === false) {\n        return;\n      }\n      var calculatedMoves = getMoves(_classPrivateFieldGet(_movedIndexes, this), _classPrivateFieldGet(_finalIndex, this), _classPrivateFieldGet(_indexMapper, this).getNumberOfIndexes());\n      if (_classPrivateFieldGet(_indexSyncer, this).getSheetId() === null) {\n        _classPrivateFieldGet(_indexSyncer, this).getPostponeAction(function () {\n          return _this4.syncMoves(calculatedMoves);\n        });\n      } else {\n        this.syncMoves(calculatedMoves);\n      }\n    }\n\n    /**\n     * Gets callback for hook triggered after performing change of indexes order.\n     *\n     * @returns {Function}\n     */\n  }, {\n    key: \"getIndexesChangeSyncMethod\",\n    value: function getIndexesChangeSyncMethod() {\n      var _this5 = this;\n      var SYNC_ORDER_CHANGE_METHOD_NAME = \"set\".concat(toUpperCaseFirst(_classPrivateFieldGet(_axis, this)), \"Order\");\n      return function (source) {\n        if (_classPrivateFieldGet(_indexSyncer, _this5).isPerformingUndoRedo()) {\n          return;\n        }\n        var newSequence = _classPrivateFieldGet(_indexMapper, _this5).getIndexesSequence();\n        if (source === 'update' && newSequence.length > 0) {\n          var relativeTransformation = _classPrivateFieldGet(_indexesSequence, _this5).map(function (index) {\n            return newSequence.indexOf(index);\n          });\n          var sheetDimensions = _classPrivateFieldGet(_indexSyncer, _this5).getEngine().getSheetDimensions(_classPrivateFieldGet(_indexSyncer, _this5).getSheetId());\n          var sizeForAxis;\n          if (_classPrivateFieldGet(_axis, _this5) === 'row') {\n            sizeForAxis = sheetDimensions.height;\n          } else {\n            sizeForAxis = sheetDimensions.width;\n          }\n          var numberOfReorganisedIndexes = relativeTransformation.length;\n\n          // Sheet dimension can be changed by HF's engine for purpose of calculating values. It extends dependency\n          // graph to calculate values outside of a defined dataset. This part of code could be removed after resolving\n          // feature request from HF issue board (handsontable/hyperformula#1179).\n          for (var i = numberOfReorganisedIndexes; i < sizeForAxis; i += 1) {\n            relativeTransformation.push(i);\n          }\n          _classPrivateFieldGet(_indexSyncer, _this5).getEngine()[SYNC_ORDER_CHANGE_METHOD_NAME](_classPrivateFieldGet(_indexSyncer, _this5).getSheetId(), relativeTransformation);\n        }\n        _classPrivateFieldSet(_indexesSequence, _this5, newSequence);\n      };\n    }\n\n    /**\n     * Initialize the AxisSyncer.\n     */\n  }, {\n    key: \"init\",\n    value: function init() {\n      _classPrivateFieldSet(_indexesSequence, this, _classPrivateFieldGet(_indexMapper, this).getIndexesSequence());\n    }\n  }]);\n}();\nexport default AxisSyncer;","map":{"version":3,"names":["_classPrivateFieldInitSpec","e","t","a","_checkPrivateRedeclaration","set","has","TypeError","_classPrivateFieldGet","s","get","_assertClassBrand","_classPrivateFieldSet","r","n","arguments","length","toUpperCaseFirst","getMoves","_axis","WeakMap","_indexMapper","_indexSyncer","_indexesSequence","_movedIndexes","_finalIndex","_removedIndexes","AxisSyncer","axis","indexMapper","indexSyncer","_classCallCheck","_createClass","key","value","setRemovedHfIndexes","removedIndexes","_this","map","physicalIndex","visualIndex","getVisualFromPhysicalIndex","getHfIndexFromVisualIndex","getRemovedHfIndexes","indexesSequence","getIndexesSequence","notTrimmedIndexes","getNotTrimmedIndexes","indexOf","syncMoves","moves","_this2","NUMBER_OF_MOVED_INDEXES","SYNC_MOVE_METHOD_NAME","concat","getEngine","batch","forEach","move","moveToTheSamePosition","from","to","anotherMoveWithoutEffect","getSheetId","storeMovesInformation","movedVisualIndexes","visualFinalIndex","movePossible","_this3","index","calculateAndSyncMoves","orderChanged","_this4","isPerformingUndoRedo","calculatedMoves","getNumberOfIndexes","getPostponeAction","getIndexesChangeSyncMethod","_this5","SYNC_ORDER_CHANGE_METHOD_NAME","source","newSequence","relativeTransformation","sheetDimensions","getSheetDimensions","sizeForAxis","height","width","numberOfReorganisedIndexes","i","push","init"],"sources":["/Users/priyadeliwala/node_modules/handsontable/plugins/formulas/indexSyncer/axisSyncer.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nfunction _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }\nfunction _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); }\nfunction _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }\nfunction _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }\nfunction _assertClassBrand(e, t, n) { if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError(\"Private element is not present on this object\"); }\nimport { toUpperCaseFirst } from \"../../../helpers/string.mjs\";\nimport { getMoves } from \"../../../helpers/moves.mjs\";\n/**\n * @private\n * @class IndexSyncer\n * @description\n *\n * Indexes synchronizer responsible for providing logic for particular axis. It respects an idea to represent trimmed\n * elements in HF's engine to perform formulas calculations on them. It also provides method for translation from visual\n * row/column indexes to HF's row/column indexes.\n */\nvar _axis = /*#__PURE__*/new WeakMap();\nvar _indexMapper = /*#__PURE__*/new WeakMap();\nvar _indexSyncer = /*#__PURE__*/new WeakMap();\nvar _indexesSequence = /*#__PURE__*/new WeakMap();\nvar _movedIndexes = /*#__PURE__*/new WeakMap();\nvar _finalIndex = /*#__PURE__*/new WeakMap();\nvar _removedIndexes = /*#__PURE__*/new WeakMap();\nclass AxisSyncer {\n  constructor(axis, indexMapper, indexSyncer) {\n    /**\n     * The axis for which the actions are performed.\n     *\n     * @private\n     * @type {'row'|'column'}\n     */\n    _classPrivateFieldInitSpec(this, _axis, void 0);\n    /**\n     * Reference to index mapper.\n     *\n     * @private\n     * @type {IndexMapper}\n     */\n    _classPrivateFieldInitSpec(this, _indexMapper, void 0);\n    /**\n     * The index synchronizer for both axis (is storing some more general information).\n     *\n     * @private\n     * @type {IndexSyncer}\n     */\n    _classPrivateFieldInitSpec(this, _indexSyncer, void 0);\n    /**\n     * Sequence of physical indexes stored for watching changes and calculating some transformations.\n     *\n     * @private\n     * @type {Array<number>}\n     */\n    _classPrivateFieldInitSpec(this, _indexesSequence, []);\n    /**\n     * List of moved HF indexes, stored before performing move on HOT to calculate transformation needed on HF's engine.\n     *\n     * @private\n     * @type {Array<number>}\n     */\n    _classPrivateFieldInitSpec(this, _movedIndexes, []);\n    /**\n     * Final HF's place where to move indexes, stored before performing move on HOT to calculate transformation needed on HF's engine.\n     *\n     * @private\n     * @type {number|undefined}\n     */\n    _classPrivateFieldInitSpec(this, _finalIndex, void 0);\n    /**\n     * List of removed HF indexes, stored before performing removal on HOT to calculate transformation needed on HF's engine.\n     *\n     * @private\n     * @type {Array<number>}\n     */\n    _classPrivateFieldInitSpec(this, _removedIndexes, []);\n    _classPrivateFieldSet(_axis, this, axis);\n    _classPrivateFieldSet(_indexMapper, this, indexMapper);\n    _classPrivateFieldSet(_indexSyncer, this, indexSyncer);\n  }\n\n  /**\n   * Sets removed HF indexes (it should be done right before performing move on HOT).\n   *\n   * @param {Array<number>} removedIndexes List of removed physical indexes.\n   * @returns {Array<number>} List of removed visual indexes.\n   */\n  setRemovedHfIndexes(removedIndexes) {\n    _classPrivateFieldSet(_removedIndexes, this, removedIndexes.map(physicalIndex => {\n      const visualIndex = _classPrivateFieldGet(_indexMapper, this).getVisualFromPhysicalIndex(physicalIndex);\n      return this.getHfIndexFromVisualIndex(visualIndex);\n    }));\n    return _classPrivateFieldGet(_removedIndexes, this);\n  }\n\n  /**\n   * Gets removed HF indexes (right before performing removal on HOT).\n   *\n   * @returns {Array<number>} List of removed HF indexes.\n   */\n  getRemovedHfIndexes() {\n    return _classPrivateFieldGet(_removedIndexes, this);\n  }\n\n  /**\n   * Gets corresponding HyperFormula index for particular visual index. It's respecting the idea that HF's engine\n   * is fed also with trimmed indexes (business requirements for formula result calculation also for trimmed elements).\n   *\n   * @param {number} visualIndex Visual index.\n   * @returns {number}\n   */\n  getHfIndexFromVisualIndex(visualIndex) {\n    const indexesSequence = _classPrivateFieldGet(_indexMapper, this).getIndexesSequence();\n    const notTrimmedIndexes = _classPrivateFieldGet(_indexMapper, this).getNotTrimmedIndexes();\n    return indexesSequence.indexOf(notTrimmedIndexes[visualIndex]);\n  }\n\n  /**\n   * Synchronizes moves done on HOT to HF engine (based on previously calculated positions).\n   *\n   * @private\n   * @param {Array<{from: number, to: number}>} moves Calculated HF's move positions.\n   */\n  syncMoves(moves) {\n    const NUMBER_OF_MOVED_INDEXES = 1;\n    const SYNC_MOVE_METHOD_NAME = `move${toUpperCaseFirst(_classPrivateFieldGet(_axis, this))}s`;\n    _classPrivateFieldGet(_indexSyncer, this).getEngine().batch(() => {\n      moves.forEach(move => {\n        const moveToTheSamePosition = move.from !== move.to;\n        // Moving from left to right (or top to bottom) to a line (drop index) right after already moved element.\n        const anotherMoveWithoutEffect = move.from + 1 !== move.to;\n        if (moveToTheSamePosition && anotherMoveWithoutEffect) {\n          _classPrivateFieldGet(_indexSyncer, this).getEngine()[SYNC_MOVE_METHOD_NAME](_classPrivateFieldGet(_indexSyncer, this).getSheetId(), move.from, NUMBER_OF_MOVED_INDEXES, move.to);\n        }\n      });\n    });\n  }\n\n  /**\n   * Stores information about performed HOT moves for purpose of calculating where to move HF elements.\n   *\n   * @param {Array<number>} movedVisualIndexes Sequence of moved visual indexes for certain axis.\n   * @param {number} visualFinalIndex Final visual place where to move HOT indexes.\n   * @param {boolean} movePossible Indicates if it's possible to move HOT indexes to the desired position.\n   */\n  storeMovesInformation(movedVisualIndexes, visualFinalIndex, movePossible) {\n    if (movePossible === false) {\n      return;\n    }\n    _classPrivateFieldSet(_movedIndexes, this, movedVisualIndexes.map(index => this.getHfIndexFromVisualIndex(index)));\n    _classPrivateFieldSet(_finalIndex, this, this.getHfIndexFromVisualIndex(visualFinalIndex));\n  }\n\n  /**\n   * Calculating where to move HF elements and performing already calculated moves.\n   *\n   * @param {boolean} movePossible Indicates if it was possible to move HOT indexes to the desired position.\n   * @param {boolean} orderChanged Indicates if order of HOT indexes was changed by move.\n   */\n  calculateAndSyncMoves(movePossible, orderChanged) {\n    if (_classPrivateFieldGet(_indexSyncer, this).isPerformingUndoRedo()) {\n      return;\n    }\n    if (movePossible === false || orderChanged === false) {\n      return;\n    }\n    const calculatedMoves = getMoves(_classPrivateFieldGet(_movedIndexes, this), _classPrivateFieldGet(_finalIndex, this), _classPrivateFieldGet(_indexMapper, this).getNumberOfIndexes());\n    if (_classPrivateFieldGet(_indexSyncer, this).getSheetId() === null) {\n      _classPrivateFieldGet(_indexSyncer, this).getPostponeAction(() => this.syncMoves(calculatedMoves));\n    } else {\n      this.syncMoves(calculatedMoves);\n    }\n  }\n\n  /**\n   * Gets callback for hook triggered after performing change of indexes order.\n   *\n   * @returns {Function}\n   */\n  getIndexesChangeSyncMethod() {\n    const SYNC_ORDER_CHANGE_METHOD_NAME = `set${toUpperCaseFirst(_classPrivateFieldGet(_axis, this))}Order`;\n    return source => {\n      if (_classPrivateFieldGet(_indexSyncer, this).isPerformingUndoRedo()) {\n        return;\n      }\n      const newSequence = _classPrivateFieldGet(_indexMapper, this).getIndexesSequence();\n      if (source === 'update' && newSequence.length > 0) {\n        const relativeTransformation = _classPrivateFieldGet(_indexesSequence, this).map(index => newSequence.indexOf(index));\n        const sheetDimensions = _classPrivateFieldGet(_indexSyncer, this).getEngine().getSheetDimensions(_classPrivateFieldGet(_indexSyncer, this).getSheetId());\n        let sizeForAxis;\n        if (_classPrivateFieldGet(_axis, this) === 'row') {\n          sizeForAxis = sheetDimensions.height;\n        } else {\n          sizeForAxis = sheetDimensions.width;\n        }\n        const numberOfReorganisedIndexes = relativeTransformation.length;\n\n        // Sheet dimension can be changed by HF's engine for purpose of calculating values. It extends dependency\n        // graph to calculate values outside of a defined dataset. This part of code could be removed after resolving\n        // feature request from HF issue board (handsontable/hyperformula#1179).\n        for (let i = numberOfReorganisedIndexes; i < sizeForAxis; i += 1) {\n          relativeTransformation.push(i);\n        }\n        _classPrivateFieldGet(_indexSyncer, this).getEngine()[SYNC_ORDER_CHANGE_METHOD_NAME](_classPrivateFieldGet(_indexSyncer, this).getSheetId(), relativeTransformation);\n      }\n      _classPrivateFieldSet(_indexesSequence, this, newSequence);\n    };\n  }\n\n  /**\n   * Initialize the AxisSyncer.\n   */\n  init() {\n    _classPrivateFieldSet(_indexesSequence, this, _classPrivateFieldGet(_indexMapper, this).getIndexesSequence());\n  }\n}\nexport default AxisSyncer;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}