{"ast":null,"code":"import _taggedTemplateLiteral from \"/Users/priyadeliwala/Desktop/sales-dashboard/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js\";\nvar _templateObject;\nimport { toSingleLine } from \"../../../../helpers/templateLiteralTag.mjs\";\n/**\n * @param {TreeNode} nodeToProcess A tree node to process.\n * @param {number} gridColumnIndex The visual column index that triggers the node modification.\n *                                 The index can be between the root node column index and\n *                                 column index plus node colspan length.\n */\nexport function showColumn(nodeToProcess, gridColumnIndex) {\n  if (!Number.isInteger(gridColumnIndex)) {\n    throw new Error('The passed gridColumnIndex argument has invalid type.');\n  }\n  if (nodeToProcess.childs.length > 0) {\n    throw new Error(toSingleLine(_templateObject || (_templateObject = _taggedTemplateLiteral([\"The passed node is not the last node on the tree. Only for \\nthe last node, the show column modification can be applied.\"], [\"The passed node is not the last node on the tree. Only for\\\\x20\\nthe last node, the show column modification can be applied.\"]))));\n  }\n  var crossHiddenColumns = nodeToProcess.data.crossHiddenColumns;\n  if (!crossHiddenColumns.includes(gridColumnIndex)) {\n    return;\n  }\n  var isCollapsibleNode = false;\n  nodeToProcess.walkUp(function (node) {\n    var collapsible = node.data.collapsible;\n    if (collapsible) {\n      isCollapsibleNode = true;\n      return false; // Cancel tree traversing\n    }\n  });\n\n  // TODO: When the node is collapsible do not show the column. Currently collapsible headers\n  // does not work with hidden columns (hidden index map types).\n  if (isCollapsibleNode) {\n    return;\n  }\n  nodeToProcess.walkUp(function (node) {\n    var data = node.data;\n    data.crossHiddenColumns.splice(data.crossHiddenColumns.indexOf(gridColumnIndex), 1);\n    if (!data.isHidden && data.colspan < data.origColspan) {\n      data.colspan += 1;\n    }\n    data.isHidden = false;\n  });\n}","map":{"version":3,"names":["toSingleLine","showColumn","nodeToProcess","gridColumnIndex","Number","isInteger","Error","childs","length","_templateObject","_taggedTemplateLiteral","crossHiddenColumns","data","includes","isCollapsibleNode","walkUp","node","collapsible","splice","indexOf","isHidden","colspan","origColspan"],"sources":["/Users/priyadeliwala/node_modules/handsontable/plugins/nestedHeaders/stateManager/nodeModifiers/showColumn.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nimport { toSingleLine } from \"../../../../helpers/templateLiteralTag.mjs\";\n/**\n * @param {TreeNode} nodeToProcess A tree node to process.\n * @param {number} gridColumnIndex The visual column index that triggers the node modification.\n *                                 The index can be between the root node column index and\n *                                 column index plus node colspan length.\n */\nexport function showColumn(nodeToProcess, gridColumnIndex) {\n  if (!Number.isInteger(gridColumnIndex)) {\n    throw new Error('The passed gridColumnIndex argument has invalid type.');\n  }\n  if (nodeToProcess.childs.length > 0) {\n    throw new Error(toSingleLine`The passed node is not the last node on the tree. Only for\\x20\nthe last node, the show column modification can be applied.`);\n  }\n  const {\n    crossHiddenColumns\n  } = nodeToProcess.data;\n  if (!crossHiddenColumns.includes(gridColumnIndex)) {\n    return;\n  }\n  let isCollapsibleNode = false;\n  nodeToProcess.walkUp(node => {\n    const {\n      data: {\n        collapsible\n      }\n    } = node;\n    if (collapsible) {\n      isCollapsibleNode = true;\n      return false; // Cancel tree traversing\n    }\n  });\n\n  // TODO: When the node is collapsible do not show the column. Currently collapsible headers\n  // does not work with hidden columns (hidden index map types).\n  if (isCollapsibleNode) {\n    return;\n  }\n  nodeToProcess.walkUp(node => {\n    const {\n      data\n    } = node;\n    data.crossHiddenColumns.splice(data.crossHiddenColumns.indexOf(gridColumnIndex), 1);\n    if (!data.isHidden && data.colspan < data.origColspan) {\n      data.colspan += 1;\n    }\n    data.isHidden = false;\n  });\n}"],"mappings":";;AACA,SAASA,YAAY,QAAQ,4CAA4C;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,UAAUA,CAACC,aAAa,EAAEC,eAAe,EAAE;EACzD,IAAI,CAACC,MAAM,CAACC,SAAS,CAACF,eAAe,CAAC,EAAE;IACtC,MAAM,IAAIG,KAAK,CAAC,uDAAuD,CAAC;EAC1E;EACA,IAAIJ,aAAa,CAACK,MAAM,CAACC,MAAM,GAAG,CAAC,EAAE;IACnC,MAAM,IAAIF,KAAK,CAACN,YAAY,CAAAS,eAAA,KAAAA,eAAA,GAAAC,sBAAA,kQAC4B,CAAC;EAC3D;EACA,IACEC,kBAAkB,GAChBT,aAAa,CAACU,IAAI,CADpBD,kBAAkB;EAEpB,IAAI,CAACA,kBAAkB,CAACE,QAAQ,CAACV,eAAe,CAAC,EAAE;IACjD;EACF;EACA,IAAIW,iBAAiB,GAAG,KAAK;EAC7BZ,aAAa,CAACa,MAAM,CAAC,UAAAC,IAAI,EAAI;IAC3B,IAEIC,WAAW,GAEXD,IAAI,CAHNJ,IAAI,CACFK,WAAW;IAGf,IAAIA,WAAW,EAAE;MACfH,iBAAiB,GAAG,IAAI;MACxB,OAAO,KAAK,CAAC,CAAC;IAChB;EACF,CAAC,CAAC;;EAEF;EACA;EACA,IAAIA,iBAAiB,EAAE;IACrB;EACF;EACAZ,aAAa,CAACa,MAAM,CAAC,UAAAC,IAAI,EAAI;IAC3B,IACEJ,IAAI,GACFI,IAAI,CADNJ,IAAI;IAENA,IAAI,CAACD,kBAAkB,CAACO,MAAM,CAACN,IAAI,CAACD,kBAAkB,CAACQ,OAAO,CAAChB,eAAe,CAAC,EAAE,CAAC,CAAC;IACnF,IAAI,CAACS,IAAI,CAACQ,QAAQ,IAAIR,IAAI,CAACS,OAAO,GAAGT,IAAI,CAACU,WAAW,EAAE;MACrDV,IAAI,CAACS,OAAO,IAAI,CAAC;IACnB;IACAT,IAAI,CAACQ,QAAQ,GAAG,KAAK;EACvB,CAAC,CAAC;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}