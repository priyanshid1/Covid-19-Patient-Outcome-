{"ast":null,"code":"import _objectSpread from \"/Users/priyadeliwala/Desktop/sales-dashboard/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/Users/priyadeliwala/Desktop/sales-dashboard/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _classCallCheck from \"/Users/priyadeliwala/Desktop/sales-dashboard/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/priyadeliwala/Desktop/sales-dashboard/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nvar _excluded = [\"row\", \"col\"];\nfunction _classPrivateFieldInitSpec(e, t, a) {\n  _checkPrivateRedeclaration(e, t), t.set(e, a);\n}\nfunction _checkPrivateRedeclaration(e, t) {\n  if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n}\nfunction _classPrivateFieldGet(s, a) {\n  return s.get(_assertClassBrand(s, a));\n}\nfunction _classPrivateFieldSet(s, a, r) {\n  return s.set(_assertClassBrand(s, a), r), r;\n}\nfunction _assertClassBrand(e, t, n) {\n  if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;\n  throw new TypeError(\"Private element is not present on this object\");\n}\nimport { extend, isObject } from \"../../../helpers/object.mjs\";\nimport { arrayEach } from \"../../../helpers/array.mjs\";\nimport { normalizeSettings } from \"./settingsNormalizer.mjs\";\n/**\n * List of properties which are configurable. That properties can be changed using public API.\n *\n * @type {string[]}\n */\nexport var HEADER_CONFIGURABLE_PROPS = ['label', 'collapsible'];\n\n/**\n * The class manages and normalizes settings passed by the developer\n * into the nested headers plugin. The SourceSettings class is a\n * source of truth for tree builder (HeaderTree) module.\n *\n * @private\n * @class SourceSettings\n */\nvar _data = /*#__PURE__*/new WeakMap();\nvar _dataLength = /*#__PURE__*/new WeakMap();\nvar _columnsLimit = /*#__PURE__*/new WeakMap();\nvar SourceSettings = /*#__PURE__*/function () {\n  function SourceSettings() {\n    _classCallCheck(this, SourceSettings);\n    /**\n     * The normalized source data (normalized user-defined settings for nested headers).\n     *\n     * @private\n     * @type {Array[]}\n     */\n    _classPrivateFieldInitSpec(this, _data, []);\n    /**\n     * The total length of the nested header layers.\n     *\n     * @private\n     * @type {number}\n     */\n    _classPrivateFieldInitSpec(this, _dataLength, 0);\n    /**\n     * Columns count limit value trims source settings to that value. If columns\n     * count limit intersects nested header, the header's colspan value is reduced\n     * to keep the whole structure stable (trimmed precisely where the limit is set).\n     *\n     * @type {number}\n     */\n    _classPrivateFieldInitSpec(this, _columnsLimit, Infinity);\n  }\n  /**\n   * Sets columns limit to the source settings will be trimmed. All headers which\n   * overlap the column limit will be reduced to keep the structure solid.\n   *\n   * @param {number} columnsCount The number of columns to limit to.\n   */\n  return _createClass(SourceSettings, [{\n    key: \"setColumnsLimit\",\n    value: function setColumnsLimit(columnsCount) {\n      _classPrivateFieldSet(_columnsLimit, this, columnsCount);\n    }\n\n    /**\n     * Sets a new nested header configuration.\n     *\n     * @param {Array[]} [nestedHeadersSettings=[]] The user-defined nested headers settings.\n     */\n  }, {\n    key: \"setData\",\n    value: function setData() {\n      var nestedHeadersSettings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      _classPrivateFieldSet(_data, this, normalizeSettings(nestedHeadersSettings, _classPrivateFieldGet(_columnsLimit, this)));\n      _classPrivateFieldSet(_dataLength, this, _classPrivateFieldGet(_data, this).length);\n    }\n\n    /**\n     * Gets normalized source settings.\n     *\n     * @returns {Array[]}\n     */\n  }, {\n    key: \"getData\",\n    value: function getData() {\n      return _classPrivateFieldGet(_data, this);\n    }\n\n    /**\n     * Merges settings with current source settings.\n     *\n     * @param {object[]} additionalSettings An array of objects with `row`, `col` and additional\n     *                                      properties to merge with current source settings.\n     */\n  }, {\n    key: \"mergeWith\",\n    value: function mergeWith(additionalSettings) {\n      var _this = this;\n      arrayEach(additionalSettings, function (_ref) {\n        var row = _ref.row,\n          col = _ref.col,\n          rest = _objectWithoutProperties(_ref, _excluded);\n        var headerSettings = _this.getHeaderSettings(row, col);\n        if (headerSettings !== null) {\n          extend(headerSettings, rest, HEADER_CONFIGURABLE_PROPS);\n        }\n      });\n    }\n\n    /**\n     * Maps the current state with a callback. For each source settings the callback function\n     * is called. If the function returns value that value is merged with the source settings.\n     *\n     * @param {Function} callback A function that is called for every header settings.\n     *                            Each time the callback is called, the returned value extends\n     *                            header settings.\n     */\n  }, {\n    key: \"map\",\n    value: function map(callback) {\n      arrayEach(_classPrivateFieldGet(_data, this), function (header) {\n        arrayEach(header, function (headerSettings) {\n          var propsToExtend = callback(_objectSpread({}, headerSettings));\n          if (isObject(propsToExtend)) {\n            extend(headerSettings, propsToExtend, HEADER_CONFIGURABLE_PROPS);\n          }\n        });\n      });\n    }\n\n    /**\n     * Gets source column header settings for a specified header. The returned\n     * object contains information about the header label, its colspan length,\n     * or if it is hidden in the header renderers.\n     *\n     * @param {number} headerLevel Header level (0 = most distant to the table).\n     * @param {number} columnIndex A visual column index.\n     * @returns {object|null}\n     */\n  }, {\n    key: \"getHeaderSettings\",\n    value: function getHeaderSettings(headerLevel, columnIndex) {\n      var _headersSettings$colu;\n      if (headerLevel >= _classPrivateFieldGet(_dataLength, this) || headerLevel < 0) {\n        return null;\n      }\n      var headersSettings = _classPrivateFieldGet(_data, this)[headerLevel];\n      if (Array.isArray(headersSettings) === false || columnIndex >= headersSettings.length) {\n        return null;\n      }\n      return (_headersSettings$colu = headersSettings[columnIndex]) !== null && _headersSettings$colu !== void 0 ? _headersSettings$colu : null;\n    }\n\n    /**\n     * Gets source of column headers settings for specified headers. If the retrieved column\n     * settings overlap the range \"box\" determined by \"columnIndex\" and \"columnsLength\"\n     * the exception will be thrown.\n     *\n     * @param {number} headerLevel Header level (0 = most distant to the table).\n     * @param {number} columnIndex A visual column index from which the settings will be extracted.\n     * @param {number} [columnsLength=1] The number of columns involved in the extraction of settings.\n     * @returns {object}\n     */\n  }, {\n    key: \"getHeadersSettings\",\n    value: function getHeadersSettings(headerLevel, columnIndex) {\n      var columnsLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      var headersSettingsChunks = [];\n      if (headerLevel >= _classPrivateFieldGet(_dataLength, this) || headerLevel < 0) {\n        return headersSettingsChunks;\n      }\n      var headersSettings = _classPrivateFieldGet(_data, this)[headerLevel];\n      var currentLength = 0;\n      for (var i = columnIndex; i < headersSettings.length; i++) {\n        var headerSettings = headersSettings[i];\n        if (headerSettings.isPlaceholder) {\n          throw new Error('The first column settings cannot overlap the other header layers');\n        }\n        currentLength += headerSettings.colspan;\n        headersSettingsChunks.push(headerSettings);\n        if (headerSettings.colspan > 1) {\n          i += headerSettings.colspan - 1;\n        }\n\n        // We met the current sum of the child colspans\n        if (currentLength === columnsLength) {\n          break;\n        }\n        // We exceeds the current sum of the child colspans, the last columns colspan overlaps the \"columnsLength\" length.\n        if (currentLength > columnsLength) {\n          throw new Error('The last column settings cannot overlap the other header layers');\n        }\n      }\n      return headersSettingsChunks;\n    }\n\n    /**\n     * Gets a total number of headers levels.\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"getLayersCount\",\n    value: function getLayersCount() {\n      return _classPrivateFieldGet(_dataLength, this);\n    }\n\n    /**\n     * Gets a total number of columns count.\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"getColumnsCount\",\n    value: function getColumnsCount() {\n      return _classPrivateFieldGet(_dataLength, this) > 0 ? _classPrivateFieldGet(_data, this)[0].length : 0;\n    }\n\n    /**\n     * Clears the data.\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      _classPrivateFieldSet(_data, this, []);\n      _classPrivateFieldSet(_dataLength, this, 0);\n    }\n  }]);\n}();\nexport { SourceSettings as default };","map":{"version":3,"names":["_classPrivateFieldInitSpec","e","t","a","_checkPrivateRedeclaration","set","has","TypeError","_classPrivateFieldGet","s","get","_assertClassBrand","_classPrivateFieldSet","r","n","arguments","length","extend","isObject","arrayEach","normalizeSettings","HEADER_CONFIGURABLE_PROPS","_data","WeakMap","_dataLength","_columnsLimit","SourceSettings","_classCallCheck","Infinity","_createClass","key","value","setColumnsLimit","columnsCount","setData","nestedHeadersSettings","undefined","getData","mergeWith","additionalSettings","_this","_ref","row","col","rest","_objectWithoutProperties","_excluded","headerSettings","getHeaderSettings","map","callback","header","propsToExtend","_objectSpread","headerLevel","columnIndex","_headersSettings$colu","headersSettings","Array","isArray","getHeadersSettings","columnsLength","headersSettingsChunks","currentLength","i","isPlaceholder","Error","colspan","push","getLayersCount","getColumnsCount","clear","default"],"sources":["/Users/priyadeliwala/node_modules/handsontable/plugins/nestedHeaders/stateManager/sourceSettings.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nfunction _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }\nfunction _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); }\nfunction _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }\nfunction _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }\nfunction _assertClassBrand(e, t, n) { if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError(\"Private element is not present on this object\"); }\nimport { extend, isObject } from \"../../../helpers/object.mjs\";\nimport { arrayEach } from \"../../../helpers/array.mjs\";\nimport { normalizeSettings } from \"./settingsNormalizer.mjs\";\n/**\n * List of properties which are configurable. That properties can be changed using public API.\n *\n * @type {string[]}\n */\nexport const HEADER_CONFIGURABLE_PROPS = ['label', 'collapsible'];\n\n/**\n * The class manages and normalizes settings passed by the developer\n * into the nested headers plugin. The SourceSettings class is a\n * source of truth for tree builder (HeaderTree) module.\n *\n * @private\n * @class SourceSettings\n */\nvar _data = /*#__PURE__*/new WeakMap();\nvar _dataLength = /*#__PURE__*/new WeakMap();\nvar _columnsLimit = /*#__PURE__*/new WeakMap();\nexport default class SourceSettings {\n  constructor() {\n    /**\n     * The normalized source data (normalized user-defined settings for nested headers).\n     *\n     * @private\n     * @type {Array[]}\n     */\n    _classPrivateFieldInitSpec(this, _data, []);\n    /**\n     * The total length of the nested header layers.\n     *\n     * @private\n     * @type {number}\n     */\n    _classPrivateFieldInitSpec(this, _dataLength, 0);\n    /**\n     * Columns count limit value trims source settings to that value. If columns\n     * count limit intersects nested header, the header's colspan value is reduced\n     * to keep the whole structure stable (trimmed precisely where the limit is set).\n     *\n     * @type {number}\n     */\n    _classPrivateFieldInitSpec(this, _columnsLimit, Infinity);\n  }\n  /**\n   * Sets columns limit to the source settings will be trimmed. All headers which\n   * overlap the column limit will be reduced to keep the structure solid.\n   *\n   * @param {number} columnsCount The number of columns to limit to.\n   */\n  setColumnsLimit(columnsCount) {\n    _classPrivateFieldSet(_columnsLimit, this, columnsCount);\n  }\n\n  /**\n   * Sets a new nested header configuration.\n   *\n   * @param {Array[]} [nestedHeadersSettings=[]] The user-defined nested headers settings.\n   */\n  setData() {\n    let nestedHeadersSettings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    _classPrivateFieldSet(_data, this, normalizeSettings(nestedHeadersSettings, _classPrivateFieldGet(_columnsLimit, this)));\n    _classPrivateFieldSet(_dataLength, this, _classPrivateFieldGet(_data, this).length);\n  }\n\n  /**\n   * Gets normalized source settings.\n   *\n   * @returns {Array[]}\n   */\n  getData() {\n    return _classPrivateFieldGet(_data, this);\n  }\n\n  /**\n   * Merges settings with current source settings.\n   *\n   * @param {object[]} additionalSettings An array of objects with `row`, `col` and additional\n   *                                      properties to merge with current source settings.\n   */\n  mergeWith(additionalSettings) {\n    arrayEach(additionalSettings, _ref => {\n      let {\n        row,\n        col,\n        ...rest\n      } = _ref;\n      const headerSettings = this.getHeaderSettings(row, col);\n      if (headerSettings !== null) {\n        extend(headerSettings, rest, HEADER_CONFIGURABLE_PROPS);\n      }\n    });\n  }\n\n  /**\n   * Maps the current state with a callback. For each source settings the callback function\n   * is called. If the function returns value that value is merged with the source settings.\n   *\n   * @param {Function} callback A function that is called for every header settings.\n   *                            Each time the callback is called, the returned value extends\n   *                            header settings.\n   */\n  map(callback) {\n    arrayEach(_classPrivateFieldGet(_data, this), header => {\n      arrayEach(header, headerSettings => {\n        const propsToExtend = callback({\n          ...headerSettings\n        });\n        if (isObject(propsToExtend)) {\n          extend(headerSettings, propsToExtend, HEADER_CONFIGURABLE_PROPS);\n        }\n      });\n    });\n  }\n\n  /**\n   * Gets source column header settings for a specified header. The returned\n   * object contains information about the header label, its colspan length,\n   * or if it is hidden in the header renderers.\n   *\n   * @param {number} headerLevel Header level (0 = most distant to the table).\n   * @param {number} columnIndex A visual column index.\n   * @returns {object|null}\n   */\n  getHeaderSettings(headerLevel, columnIndex) {\n    var _headersSettings$colu;\n    if (headerLevel >= _classPrivateFieldGet(_dataLength, this) || headerLevel < 0) {\n      return null;\n    }\n    const headersSettings = _classPrivateFieldGet(_data, this)[headerLevel];\n    if (Array.isArray(headersSettings) === false || columnIndex >= headersSettings.length) {\n      return null;\n    }\n    return (_headersSettings$colu = headersSettings[columnIndex]) !== null && _headersSettings$colu !== void 0 ? _headersSettings$colu : null;\n  }\n\n  /**\n   * Gets source of column headers settings for specified headers. If the retrieved column\n   * settings overlap the range \"box\" determined by \"columnIndex\" and \"columnsLength\"\n   * the exception will be thrown.\n   *\n   * @param {number} headerLevel Header level (0 = most distant to the table).\n   * @param {number} columnIndex A visual column index from which the settings will be extracted.\n   * @param {number} [columnsLength=1] The number of columns involved in the extraction of settings.\n   * @returns {object}\n   */\n  getHeadersSettings(headerLevel, columnIndex) {\n    let columnsLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    const headersSettingsChunks = [];\n    if (headerLevel >= _classPrivateFieldGet(_dataLength, this) || headerLevel < 0) {\n      return headersSettingsChunks;\n    }\n    const headersSettings = _classPrivateFieldGet(_data, this)[headerLevel];\n    let currentLength = 0;\n    for (let i = columnIndex; i < headersSettings.length; i++) {\n      const headerSettings = headersSettings[i];\n      if (headerSettings.isPlaceholder) {\n        throw new Error('The first column settings cannot overlap the other header layers');\n      }\n      currentLength += headerSettings.colspan;\n      headersSettingsChunks.push(headerSettings);\n      if (headerSettings.colspan > 1) {\n        i += headerSettings.colspan - 1;\n      }\n\n      // We met the current sum of the child colspans\n      if (currentLength === columnsLength) {\n        break;\n      }\n      // We exceeds the current sum of the child colspans, the last columns colspan overlaps the \"columnsLength\" length.\n      if (currentLength > columnsLength) {\n        throw new Error('The last column settings cannot overlap the other header layers');\n      }\n    }\n    return headersSettingsChunks;\n  }\n\n  /**\n   * Gets a total number of headers levels.\n   *\n   * @returns {number}\n   */\n  getLayersCount() {\n    return _classPrivateFieldGet(_dataLength, this);\n  }\n\n  /**\n   * Gets a total number of columns count.\n   *\n   * @returns {number}\n   */\n  getColumnsCount() {\n    return _classPrivateFieldGet(_dataLength, this) > 0 ? _classPrivateFieldGet(_data, this)[0].length : 0;\n  }\n\n  /**\n   * Clears the data.\n   */\n  clear() {\n    _classPrivateFieldSet(_data, this, []);\n    _classPrivateFieldSet(_dataLength, this, 0);\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}