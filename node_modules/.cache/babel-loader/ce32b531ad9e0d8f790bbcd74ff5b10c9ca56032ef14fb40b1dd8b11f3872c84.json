{"ast":null,"code":"var _templateObject;\nfunction _taggedTemplateLiteral(strings, raw) {\n  if (!raw) {\n    raw = strings.slice(0);\n  }\n  return Object.freeze(Object.defineProperties(strings, {\n    raw: {\n      value: Object.freeze(raw)\n    }\n  }));\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nimport MergedCellCoords from \"./cellCoords.mjs\";\nimport { CellCoords, CellRange } from \"../../3rdparty/walkontable/src/index.mjs\";\nimport { rangeEach, rangeEachReverse } from \"../../helpers/number.mjs\";\nimport { warn } from \"../../helpers/console.mjs\";\nimport { arrayEach } from \"../../helpers/array.mjs\";\nimport { applySpanProperties } from \"./utils.mjs\";\nimport { toSingleLine } from \"../../helpers/templateLiteralTag.mjs\";\n/**\n * Defines a container object for the merged cells.\n *\n * @private\n * @class MergedCellsCollection\n */\n\nvar MergedCellsCollection = /*#__PURE__*/function () {\n  function MergedCellsCollection(plugin) {\n    _classCallCheck(this, MergedCellsCollection);\n\n    /**\n     * Reference to the Merge Cells plugin.\n     *\n     * @type {MergeCells}\n     */\n    this.plugin = plugin;\n    /**\n     * Array of merged cells.\n     *\n     * @type {Array}\n     */\n\n    this.mergedCells = [];\n    /**\n     * The Handsontable instance.\n     *\n     * @type {Handsontable}\n     */\n\n    this.hot = plugin.hot;\n  }\n  /**\n   * Get a warning message for when the declared merged cell data overlaps already existing merged cells.\n   *\n   * @param {object} newMergedCell Object containg information about the merged cells that was about to be added.\n   * @returns {string}\n   */\n\n  _createClass(MergedCellsCollection, [{\n    key: \"get\",\n    value:\n    /**\n     * Get a merged cell from the container, based on the provided arguments. You can provide either the \"starting coordinates\"\n     * of a merged cell, or any coordinates from the body of the merged cell.\n     *\n     * @param {number} row Row index.\n     * @param {number} column Column index.\n     * @returns {MergedCellCoords|boolean} Returns a wanted merged cell on success and `false` on failure.\n     */\n    function get(row, column) {\n      var mergedCells = this.mergedCells;\n      var result = false;\n      arrayEach(mergedCells, function (mergedCell) {\n        if (mergedCell.row <= row && mergedCell.row + mergedCell.rowspan - 1 >= row && mergedCell.col <= column && mergedCell.col + mergedCell.colspan - 1 >= column) {\n          result = mergedCell;\n          return false;\n        }\n        return true;\n      });\n      return result;\n    }\n    /**\n     * Get a merged cell containing the provided range.\n     *\n     * @param {CellRange|object} range The range to search merged cells for.\n     * @returns {MergedCellCoords|boolean}\n     */\n  }, {\n    key: \"getByRange\",\n    value: function getByRange(range) {\n      var mergedCells = this.mergedCells;\n      var result = false;\n      arrayEach(mergedCells, function (mergedCell) {\n        if (mergedCell.row <= range.from.row && mergedCell.row + mergedCell.rowspan - 1 >= range.to.row && mergedCell.col <= range.from.col && mergedCell.col + mergedCell.colspan - 1 >= range.to.col) {\n          result = mergedCell;\n          return result;\n        }\n        return true;\n      });\n      return result;\n    }\n    /**\n     * Get a merged cell contained in the provided range.\n     *\n     * @param {CellRange|object} range The range to search merged cells in.\n     * @param {boolean} [countPartials=false] If set to `true`, all the merged cells overlapping the range will be taken into calculation.\n     * @returns {Array|boolean} Array of found merged cells of `false` if none were found.\n     */\n  }, {\n    key: \"getWithinRange\",\n    value: function getWithinRange(range) {\n      var countPartials = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var mergedCells = this.mergedCells;\n      var foundMergedCells = [];\n      var testedRange = range;\n      if (!testedRange.includesRange) {\n        var from = new CellCoords(testedRange.from.row, testedRange.from.col);\n        var to = new CellCoords(testedRange.to.row, testedRange.to.col);\n        testedRange = new CellRange(from, from, to);\n      }\n      arrayEach(mergedCells, function (mergedCell) {\n        var mergedCellTopLeft = new CellCoords(mergedCell.row, mergedCell.col);\n        var mergedCellBottomRight = new CellCoords(mergedCell.row + mergedCell.rowspan - 1, mergedCell.col + mergedCell.colspan - 1);\n        var mergedCellRange = new CellRange(mergedCellTopLeft, mergedCellTopLeft, mergedCellBottomRight);\n        if (countPartials) {\n          if (testedRange.overlaps(mergedCellRange)) {\n            foundMergedCells.push(mergedCell);\n          }\n        } else if (testedRange.includesRange(mergedCellRange)) {\n          foundMergedCells.push(mergedCell);\n        }\n      });\n      return foundMergedCells.length ? foundMergedCells : false;\n    }\n    /**\n     * Add a merged cell to the container.\n     *\n     * @param {object} mergedCellInfo The merged cell information object. Has to contain `row`, `col`, `colspan` and `rowspan` properties.\n     * @returns {MergedCellCoords|boolean} Returns the new merged cell on success and `false` on failure.\n     */\n  }, {\n    key: \"add\",\n    value: function add(mergedCellInfo) {\n      var mergedCells = this.mergedCells;\n      var row = mergedCellInfo.row;\n      var column = mergedCellInfo.col;\n      var rowspan = mergedCellInfo.rowspan;\n      var colspan = mergedCellInfo.colspan;\n      var newMergedCell = new MergedCellCoords(row, column, rowspan, colspan);\n      var alreadyExists = this.get(row, column);\n      var isOverlapping = this.isOverlapping(newMergedCell);\n      if (!alreadyExists && !isOverlapping) {\n        if (this.hot) {\n          newMergedCell.normalize(this.hot);\n        }\n        mergedCells.push(newMergedCell);\n        return newMergedCell;\n      }\n      warn(MergedCellsCollection.IS_OVERLAPPING_WARNING(newMergedCell));\n      return false;\n    }\n    /**\n     * Remove a merged cell from the container. You can provide either the \"starting coordinates\"\n     * of a merged cell, or any coordinates from the body of the merged cell.\n     *\n     * @param {number} row Row index.\n     * @param {number} column Column index.\n     * @returns {MergedCellCoords|boolean} Returns the removed merged cell on success and `false` on failure.\n     */\n  }, {\n    key: \"remove\",\n    value: function remove(row, column) {\n      var mergedCells = this.mergedCells;\n      var wantedCollection = this.get(row, column);\n      var wantedCollectionIndex = wantedCollection ? this.mergedCells.indexOf(wantedCollection) : -1;\n      if (wantedCollection && wantedCollectionIndex !== -1) {\n        mergedCells.splice(wantedCollectionIndex, 1);\n        return wantedCollection;\n      }\n      return false;\n    }\n    /**\n     * Clear all the merged cells.\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      var _this = this;\n      var mergedCells = this.mergedCells;\n      var mergedCellParentsToClear = [];\n      var hiddenCollectionElements = [];\n      arrayEach(mergedCells, function (mergedCell) {\n        var TD = _this.hot.getCell(mergedCell.row, mergedCell.col);\n        if (TD) {\n          mergedCellParentsToClear.push([TD, _this.get(mergedCell.row, mergedCell.col), mergedCell.row, mergedCell.col]);\n        }\n      });\n      this.mergedCells.length = 0;\n      arrayEach(mergedCellParentsToClear, function (mergedCell, i) {\n        rangeEach(0, mergedCell.rowspan - 1, function (j) {\n          rangeEach(0, mergedCell.colspan - 1, function (k) {\n            if (k !== 0 || j !== 0) {\n              var TD = _this.hot.getCell(mergedCell.row + j, mergedCell.col + k);\n              if (TD) {\n                hiddenCollectionElements.push([TD, null, null, null]);\n              }\n            }\n          });\n        });\n        mergedCellParentsToClear[i][1] = null;\n      });\n      arrayEach(mergedCellParentsToClear, function (mergedCellParents) {\n        applySpanProperties.apply(void 0, _toConsumableArray(mergedCellParents));\n      });\n      arrayEach(hiddenCollectionElements, function (hiddenCollectionElement) {\n        applySpanProperties.apply(void 0, _toConsumableArray(hiddenCollectionElement));\n      });\n    }\n    /**\n     * Check if the provided merged cell overlaps with the others in the container.\n     *\n     * @param {MergedCellCoords} mergedCell The merged cell to check against all others in the container.\n     * @returns {boolean} `true` if the provided merged cell overlaps with the others, `false` otherwise.\n     */\n  }, {\n    key: \"isOverlapping\",\n    value: function isOverlapping(mergedCell) {\n      var mergedCellRange = new CellRange(new CellCoords(0, 0), new CellCoords(mergedCell.row, mergedCell.col), new CellCoords(mergedCell.row + mergedCell.rowspan - 1, mergedCell.col + mergedCell.colspan - 1));\n      var result = false;\n      arrayEach(this.mergedCells, function (col) {\n        var currentRange = new CellRange(new CellCoords(0, 0), new CellCoords(col.row, col.col), new CellCoords(col.row + col.rowspan - 1, col.col + col.colspan - 1));\n        if (currentRange.overlaps(mergedCellRange)) {\n          result = true;\n          return false;\n        }\n        return true;\n      });\n      return result;\n    }\n    /**\n     * Check whether the provided row/col coordinates direct to a first not hidden cell within merge area.\n     *\n     * @param {number} row Visual row index.\n     * @param {number} column Visual column index.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isFirstRenderableMergedCell\",\n    value: function isFirstRenderableMergedCell(row, column) {\n      var mergeParent = this.get(row, column); // Return if row and column indexes are within merge area and if they are first rendered indexes within the area.\n\n      return mergeParent && this.hot.rowIndexMapper.getFirstNotHiddenIndex(mergeParent.row, 1) === row && this.hot.columnIndexMapper.getFirstNotHiddenIndex(mergeParent.col, 1) === column;\n    }\n    /**\n     * Get the first renderable coords of the merged cell at the provided coordinates.\n     *\n     * @param {number} row Visual row index.\n     * @param {number} column Visual column index.\n     * @returns {CellCoords} A `CellCoords` object with the coordinates to the first renderable cell within the\n     *                        merged cell.\n     */\n  }, {\n    key: \"getFirstRenderableCoords\",\n    value: function getFirstRenderableCoords(row, column) {\n      var mergeParent = this.get(row, column);\n      if (!mergeParent || this.isFirstRenderableMergedCell(row, column)) {\n        return new CellCoords(row, column);\n      }\n      var firstRenderableRow = this.hot.rowIndexMapper.getFirstNotHiddenIndex(mergeParent.row, 1);\n      var firstRenderableColumn = this.hot.columnIndexMapper.getFirstNotHiddenIndex(mergeParent.col, 1);\n      return new CellCoords(firstRenderableRow, firstRenderableColumn);\n    }\n    /**\n     * Shift the merged cell in the direction and by an offset defined in the arguments.\n     *\n     * @param {string} direction `right`, `left`, `up` or `down`.\n     * @param {number} index Index where the change, which caused the shifting took place.\n     * @param {number} count Number of rows/columns added/removed in the preceding action.\n     */\n  }, {\n    key: \"shiftCollections\",\n    value: function shiftCollections(direction, index, count) {\n      var _this2 = this;\n      var shiftVector = [0, 0];\n      switch (direction) {\n        case 'right':\n          shiftVector[0] += count;\n          break;\n        case 'left':\n          shiftVector[0] -= count;\n          break;\n        case 'down':\n          shiftVector[1] += count;\n          break;\n        case 'up':\n          shiftVector[1] -= count;\n          break;\n        default:\n      }\n      arrayEach(this.mergedCells, function (currentMerge) {\n        currentMerge.shift(shiftVector, index);\n      });\n      rangeEachReverse(this.mergedCells.length - 1, 0, function (i) {\n        var currentMerge = _this2.mergedCells[i];\n        if (currentMerge && currentMerge.removed) {\n          _this2.mergedCells.splice(_this2.mergedCells.indexOf(currentMerge), 1);\n        }\n      });\n    }\n  }], [{\n    key: \"IS_OVERLAPPING_WARNING\",\n    value: function IS_OVERLAPPING_WARNING(newMergedCell) {\n      return toSingleLine(_templateObject || (_templateObject = _taggedTemplateLiteral([\"The merged cell declared at [\", \", \", \"], overlaps \\n      with the other declared merged cell. The overlapping merged cell was not added to the table, please \\n      fix your setup.\"], [\"The merged cell declared at [\", \", \", \"], overlaps\\\\x20\\n      with the other declared merged cell. The overlapping merged cell was not added to the table, please\\\\x20\\n      fix your setup.\"])), newMergedCell.row, newMergedCell.col);\n    }\n  }]);\n  return MergedCellsCollection;\n}();\nexport default MergedCellsCollection;","map":{"version":3,"names":["_templateObject","_taggedTemplateLiteral","strings","raw","slice","Object","freeze","defineProperties","value","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","TypeError","o","minLen","_arrayLikeToArray","n","prototype","toString","call","constructor","name","Array","from","test","iter","Symbol","iterator","isArray","len","length","i","arr2","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","MergedCellCoords","CellCoords","CellRange","rangeEach","rangeEachReverse","warn","arrayEach","applySpanProperties","toSingleLine","MergedCellsCollection","plugin","mergedCells","hot","get","row","column","result","mergedCell","rowspan","col","colspan","getByRange","range","to","getWithinRange","countPartials","arguments","undefined","foundMergedCells","testedRange","includesRange","mergedCellTopLeft","mergedCellBottomRight","mergedCellRange","overlaps","push","add","mergedCellInfo","newMergedCell","alreadyExists","isOverlapping","normalize","IS_OVERLAPPING_WARNING","remove","wantedCollection","wantedCollectionIndex","indexOf","splice","clear","_this","mergedCellParentsToClear","hiddenCollectionElements","TD","getCell","j","k","mergedCellParents","apply","hiddenCollectionElement","currentRange","isFirstRenderableMergedCell","mergeParent","rowIndexMapper","getFirstNotHiddenIndex","columnIndexMapper","getFirstRenderableCoords","firstRenderableRow","firstRenderableColumn","shiftCollections","direction","index","count","_this2","shiftVector","currentMerge","shift","removed"],"sources":["/Users/priyadeliwala/Desktop/sales-dashboard/node_modules/handsontable/plugins/mergeCells/cellsCollection.mjs"],"sourcesContent":["var _templateObject;\n\nfunction _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.splice.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.object.freeze.js\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nimport MergedCellCoords from \"./cellCoords.mjs\";\nimport { CellCoords, CellRange } from \"../../3rdparty/walkontable/src/index.mjs\";\nimport { rangeEach, rangeEachReverse } from \"../../helpers/number.mjs\";\nimport { warn } from \"../../helpers/console.mjs\";\nimport { arrayEach } from \"../../helpers/array.mjs\";\nimport { applySpanProperties } from \"./utils.mjs\";\nimport { toSingleLine } from \"../../helpers/templateLiteralTag.mjs\";\n/**\n * Defines a container object for the merged cells.\n *\n * @private\n * @class MergedCellsCollection\n */\n\nvar MergedCellsCollection = /*#__PURE__*/function () {\n  function MergedCellsCollection(plugin) {\n    _classCallCheck(this, MergedCellsCollection);\n\n    /**\n     * Reference to the Merge Cells plugin.\n     *\n     * @type {MergeCells}\n     */\n    this.plugin = plugin;\n    /**\n     * Array of merged cells.\n     *\n     * @type {Array}\n     */\n\n    this.mergedCells = [];\n    /**\n     * The Handsontable instance.\n     *\n     * @type {Handsontable}\n     */\n\n    this.hot = plugin.hot;\n  }\n  /**\n   * Get a warning message for when the declared merged cell data overlaps already existing merged cells.\n   *\n   * @param {object} newMergedCell Object containg information about the merged cells that was about to be added.\n   * @returns {string}\n   */\n\n\n  _createClass(MergedCellsCollection, [{\n    key: \"get\",\n    value:\n    /**\n     * Get a merged cell from the container, based on the provided arguments. You can provide either the \"starting coordinates\"\n     * of a merged cell, or any coordinates from the body of the merged cell.\n     *\n     * @param {number} row Row index.\n     * @param {number} column Column index.\n     * @returns {MergedCellCoords|boolean} Returns a wanted merged cell on success and `false` on failure.\n     */\n    function get(row, column) {\n      var mergedCells = this.mergedCells;\n      var result = false;\n      arrayEach(mergedCells, function (mergedCell) {\n        if (mergedCell.row <= row && mergedCell.row + mergedCell.rowspan - 1 >= row && mergedCell.col <= column && mergedCell.col + mergedCell.colspan - 1 >= column) {\n          result = mergedCell;\n          return false;\n        }\n\n        return true;\n      });\n      return result;\n    }\n    /**\n     * Get a merged cell containing the provided range.\n     *\n     * @param {CellRange|object} range The range to search merged cells for.\n     * @returns {MergedCellCoords|boolean}\n     */\n\n  }, {\n    key: \"getByRange\",\n    value: function getByRange(range) {\n      var mergedCells = this.mergedCells;\n      var result = false;\n      arrayEach(mergedCells, function (mergedCell) {\n        if (mergedCell.row <= range.from.row && mergedCell.row + mergedCell.rowspan - 1 >= range.to.row && mergedCell.col <= range.from.col && mergedCell.col + mergedCell.colspan - 1 >= range.to.col) {\n          result = mergedCell;\n          return result;\n        }\n\n        return true;\n      });\n      return result;\n    }\n    /**\n     * Get a merged cell contained in the provided range.\n     *\n     * @param {CellRange|object} range The range to search merged cells in.\n     * @param {boolean} [countPartials=false] If set to `true`, all the merged cells overlapping the range will be taken into calculation.\n     * @returns {Array|boolean} Array of found merged cells of `false` if none were found.\n     */\n\n  }, {\n    key: \"getWithinRange\",\n    value: function getWithinRange(range) {\n      var countPartials = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var mergedCells = this.mergedCells;\n      var foundMergedCells = [];\n      var testedRange = range;\n\n      if (!testedRange.includesRange) {\n        var from = new CellCoords(testedRange.from.row, testedRange.from.col);\n        var to = new CellCoords(testedRange.to.row, testedRange.to.col);\n        testedRange = new CellRange(from, from, to);\n      }\n\n      arrayEach(mergedCells, function (mergedCell) {\n        var mergedCellTopLeft = new CellCoords(mergedCell.row, mergedCell.col);\n        var mergedCellBottomRight = new CellCoords(mergedCell.row + mergedCell.rowspan - 1, mergedCell.col + mergedCell.colspan - 1);\n        var mergedCellRange = new CellRange(mergedCellTopLeft, mergedCellTopLeft, mergedCellBottomRight);\n\n        if (countPartials) {\n          if (testedRange.overlaps(mergedCellRange)) {\n            foundMergedCells.push(mergedCell);\n          }\n        } else if (testedRange.includesRange(mergedCellRange)) {\n          foundMergedCells.push(mergedCell);\n        }\n      });\n      return foundMergedCells.length ? foundMergedCells : false;\n    }\n    /**\n     * Add a merged cell to the container.\n     *\n     * @param {object} mergedCellInfo The merged cell information object. Has to contain `row`, `col`, `colspan` and `rowspan` properties.\n     * @returns {MergedCellCoords|boolean} Returns the new merged cell on success and `false` on failure.\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(mergedCellInfo) {\n      var mergedCells = this.mergedCells;\n      var row = mergedCellInfo.row;\n      var column = mergedCellInfo.col;\n      var rowspan = mergedCellInfo.rowspan;\n      var colspan = mergedCellInfo.colspan;\n      var newMergedCell = new MergedCellCoords(row, column, rowspan, colspan);\n      var alreadyExists = this.get(row, column);\n      var isOverlapping = this.isOverlapping(newMergedCell);\n\n      if (!alreadyExists && !isOverlapping) {\n        if (this.hot) {\n          newMergedCell.normalize(this.hot);\n        }\n\n        mergedCells.push(newMergedCell);\n        return newMergedCell;\n      }\n\n      warn(MergedCellsCollection.IS_OVERLAPPING_WARNING(newMergedCell));\n      return false;\n    }\n    /**\n     * Remove a merged cell from the container. You can provide either the \"starting coordinates\"\n     * of a merged cell, or any coordinates from the body of the merged cell.\n     *\n     * @param {number} row Row index.\n     * @param {number} column Column index.\n     * @returns {MergedCellCoords|boolean} Returns the removed merged cell on success and `false` on failure.\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(row, column) {\n      var mergedCells = this.mergedCells;\n      var wantedCollection = this.get(row, column);\n      var wantedCollectionIndex = wantedCollection ? this.mergedCells.indexOf(wantedCollection) : -1;\n\n      if (wantedCollection && wantedCollectionIndex !== -1) {\n        mergedCells.splice(wantedCollectionIndex, 1);\n        return wantedCollection;\n      }\n\n      return false;\n    }\n    /**\n     * Clear all the merged cells.\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      var _this = this;\n\n      var mergedCells = this.mergedCells;\n      var mergedCellParentsToClear = [];\n      var hiddenCollectionElements = [];\n      arrayEach(mergedCells, function (mergedCell) {\n        var TD = _this.hot.getCell(mergedCell.row, mergedCell.col);\n\n        if (TD) {\n          mergedCellParentsToClear.push([TD, _this.get(mergedCell.row, mergedCell.col), mergedCell.row, mergedCell.col]);\n        }\n      });\n      this.mergedCells.length = 0;\n      arrayEach(mergedCellParentsToClear, function (mergedCell, i) {\n        rangeEach(0, mergedCell.rowspan - 1, function (j) {\n          rangeEach(0, mergedCell.colspan - 1, function (k) {\n            if (k !== 0 || j !== 0) {\n              var TD = _this.hot.getCell(mergedCell.row + j, mergedCell.col + k);\n\n              if (TD) {\n                hiddenCollectionElements.push([TD, null, null, null]);\n              }\n            }\n          });\n        });\n        mergedCellParentsToClear[i][1] = null;\n      });\n      arrayEach(mergedCellParentsToClear, function (mergedCellParents) {\n        applySpanProperties.apply(void 0, _toConsumableArray(mergedCellParents));\n      });\n      arrayEach(hiddenCollectionElements, function (hiddenCollectionElement) {\n        applySpanProperties.apply(void 0, _toConsumableArray(hiddenCollectionElement));\n      });\n    }\n    /**\n     * Check if the provided merged cell overlaps with the others in the container.\n     *\n     * @param {MergedCellCoords} mergedCell The merged cell to check against all others in the container.\n     * @returns {boolean} `true` if the provided merged cell overlaps with the others, `false` otherwise.\n     */\n\n  }, {\n    key: \"isOverlapping\",\n    value: function isOverlapping(mergedCell) {\n      var mergedCellRange = new CellRange(new CellCoords(0, 0), new CellCoords(mergedCell.row, mergedCell.col), new CellCoords(mergedCell.row + mergedCell.rowspan - 1, mergedCell.col + mergedCell.colspan - 1));\n      var result = false;\n      arrayEach(this.mergedCells, function (col) {\n        var currentRange = new CellRange(new CellCoords(0, 0), new CellCoords(col.row, col.col), new CellCoords(col.row + col.rowspan - 1, col.col + col.colspan - 1));\n\n        if (currentRange.overlaps(mergedCellRange)) {\n          result = true;\n          return false;\n        }\n\n        return true;\n      });\n      return result;\n    }\n    /**\n     * Check whether the provided row/col coordinates direct to a first not hidden cell within merge area.\n     *\n     * @param {number} row Visual row index.\n     * @param {number} column Visual column index.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isFirstRenderableMergedCell\",\n    value: function isFirstRenderableMergedCell(row, column) {\n      var mergeParent = this.get(row, column); // Return if row and column indexes are within merge area and if they are first rendered indexes within the area.\n\n      return mergeParent && this.hot.rowIndexMapper.getFirstNotHiddenIndex(mergeParent.row, 1) === row && this.hot.columnIndexMapper.getFirstNotHiddenIndex(mergeParent.col, 1) === column;\n    }\n    /**\n     * Get the first renderable coords of the merged cell at the provided coordinates.\n     *\n     * @param {number} row Visual row index.\n     * @param {number} column Visual column index.\n     * @returns {CellCoords} A `CellCoords` object with the coordinates to the first renderable cell within the\n     *                        merged cell.\n     */\n\n  }, {\n    key: \"getFirstRenderableCoords\",\n    value: function getFirstRenderableCoords(row, column) {\n      var mergeParent = this.get(row, column);\n\n      if (!mergeParent || this.isFirstRenderableMergedCell(row, column)) {\n        return new CellCoords(row, column);\n      }\n\n      var firstRenderableRow = this.hot.rowIndexMapper.getFirstNotHiddenIndex(mergeParent.row, 1);\n      var firstRenderableColumn = this.hot.columnIndexMapper.getFirstNotHiddenIndex(mergeParent.col, 1);\n      return new CellCoords(firstRenderableRow, firstRenderableColumn);\n    }\n    /**\n     * Shift the merged cell in the direction and by an offset defined in the arguments.\n     *\n     * @param {string} direction `right`, `left`, `up` or `down`.\n     * @param {number} index Index where the change, which caused the shifting took place.\n     * @param {number} count Number of rows/columns added/removed in the preceding action.\n     */\n\n  }, {\n    key: \"shiftCollections\",\n    value: function shiftCollections(direction, index, count) {\n      var _this2 = this;\n\n      var shiftVector = [0, 0];\n\n      switch (direction) {\n        case 'right':\n          shiftVector[0] += count;\n          break;\n\n        case 'left':\n          shiftVector[0] -= count;\n          break;\n\n        case 'down':\n          shiftVector[1] += count;\n          break;\n\n        case 'up':\n          shiftVector[1] -= count;\n          break;\n\n        default:\n      }\n\n      arrayEach(this.mergedCells, function (currentMerge) {\n        currentMerge.shift(shiftVector, index);\n      });\n      rangeEachReverse(this.mergedCells.length - 1, 0, function (i) {\n        var currentMerge = _this2.mergedCells[i];\n\n        if (currentMerge && currentMerge.removed) {\n          _this2.mergedCells.splice(_this2.mergedCells.indexOf(currentMerge), 1);\n        }\n      });\n    }\n  }], [{\n    key: \"IS_OVERLAPPING_WARNING\",\n    value: function IS_OVERLAPPING_WARNING(newMergedCell) {\n      return toSingleLine(_templateObject || (_templateObject = _taggedTemplateLiteral([\"The merged cell declared at [\", \", \", \"], overlaps \\n      with the other declared merged cell. The overlapping merged cell was not added to the table, please \\n      fix your setup.\"], [\"The merged cell declared at [\", \", \", \"], overlaps\\\\x20\\n      with the other declared merged cell. The overlapping merged cell was not added to the table, please\\\\x20\\n      fix your setup.\"])), newMergedCell.row, newMergedCell.col);\n    }\n  }]);\n\n  return MergedCellsCollection;\n}();\n\nexport default MergedCellsCollection;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}