{"ast":null,"code":"function _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _s, _e;\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n  return _arr;\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nimport { hasClass, index, offset, removeClass, removeTextNodes, overlayContainsElement, closest, outerWidth, innerHeight, isVisible as _isVisible } from \"./../../../helpers/dom/element.mjs\";\nimport { isFunction } from \"./../../../helpers/function.mjs\";\nimport CellCoords from \"./cell/coords.mjs\";\nimport ColumnFilter from \"./filter/column.mjs\";\nimport RowFilter from \"./filter/row.mjs\";\nimport { Renderer } from \"./renderer/index.mjs\";\nimport ColumnUtils from \"./utils/column.mjs\";\nimport RowUtils from \"./utils/row.mjs\";\nimport { isOverlayTypeOf } from \"./overlay/registerer.mjs\";\nimport { CLONE_TOP, CLONE_BOTTOM, CLONE_LEFT, CLONE_TOP_LEFT_CORNER, CLONE_BOTTOM_LEFT_CORNER } from \"./overlay/constants.mjs\";\n/**\n *\n */\n\nvar Table = /*#__PURE__*/function () {\n  /**\n   * @param {Walkontable} wotInstance The Walkontable instance.\n   * @param {HTMLTableElement} table An element to the Walkontable generated table is injected.\n   */\n  function Table(wotInstance, table) {\n    var _this = this;\n    _classCallCheck(this, Table);\n\n    /**\n     * Indicates if this instance is of type `MasterTable` (i.e. It is NOT an overlay).\n     *\n     * @type {boolean}\n     */\n    this.isMaster = !wotInstance.cloneOverlay; // \"instanceof\" operator isn't used, because it caused a circular reference in Webpack\n\n    this.wot = wotInstance; // legacy support\n\n    this.instance = this.wot;\n    this.TABLE = table;\n    this.TBODY = null;\n    this.THEAD = null;\n    this.COLGROUP = null;\n    this.tableOffset = 0;\n    this.holderOffset = 0;\n    /**\n     * Indicates if the table has height bigger than 0px.\n     *\n     * @type {boolean}\n     */\n\n    this.hasTableHeight = true;\n    /**\n     * Indicates if the table has width bigger than 0px.\n     *\n     * @type {boolean}\n     */\n\n    this.hasTableWidth = true;\n    /**\n     * Indicates if the table is visible. By visible, it means that the holder\n     * element has CSS 'display' property different than 'none'.\n     *\n     * @type {boolean}\n     */\n\n    this.isTableVisible = false;\n    removeTextNodes(this.TABLE);\n    this.spreader = this.createSpreader(this.TABLE);\n    this.hider = this.createHider(this.spreader);\n    this.holder = this.createHolder(this.hider);\n    this.wtRootElement = this.holder.parentNode;\n    if (this.isMaster) {\n      this.alignOverlaysWithTrimmingContainer();\n    }\n    this.fixTableDomTree();\n    this.rowFilter = null;\n    this.columnFilter = null;\n    this.correctHeaderWidth = false;\n    var origRowHeaderWidth = this.wot.wtSettings.settings.rowHeaderWidth; // Fix for jumping row headers (https://github.com/handsontable/handsontable/issues/3850)\n\n    this.wot.wtSettings.settings.rowHeaderWidth = function () {\n      return _this._modifyRowHeaderWidth(origRowHeaderWidth);\n    };\n    this.rowUtils = new RowUtils(this.wot);\n    this.columnUtils = new ColumnUtils(this.wot);\n    this.tableRenderer = new Renderer({\n      TABLE: this.TABLE,\n      THEAD: this.THEAD,\n      COLGROUP: this.COLGROUP,\n      TBODY: this.TBODY,\n      rowUtils: this.rowUtils,\n      columnUtils: this.columnUtils,\n      cellRenderer: this.wot.wtSettings.settings.cellRenderer\n    });\n  }\n  /**\n   * Returns a boolean that is true if this intance of Table represents a specific overlay, identified by the overlay name.\n   * For MasterTable, it returns false.\n   *\n   * @param {string} overlayTypeName The overlay type.\n   * @returns {boolean}\n   */\n\n  _createClass(Table, [{\n    key: \"is\",\n    value: function is(overlayTypeName) {\n      return isOverlayTypeOf(this.wot.cloneOverlay, overlayTypeName);\n    }\n    /**\n     *\n     */\n  }, {\n    key: \"fixTableDomTree\",\n    value: function fixTableDomTree() {\n      var rootDocument = this.wot.rootDocument;\n      this.TBODY = this.TABLE.querySelector('tbody');\n      if (!this.TBODY) {\n        this.TBODY = rootDocument.createElement('tbody');\n        this.TABLE.appendChild(this.TBODY);\n      }\n      this.THEAD = this.TABLE.querySelector('thead');\n      if (!this.THEAD) {\n        this.THEAD = rootDocument.createElement('thead');\n        this.TABLE.insertBefore(this.THEAD, this.TBODY);\n      }\n      this.COLGROUP = this.TABLE.querySelector('colgroup');\n      if (!this.COLGROUP) {\n        this.COLGROUP = rootDocument.createElement('colgroup');\n        this.TABLE.insertBefore(this.COLGROUP, this.THEAD);\n      }\n      if (this.wot.getSetting('columnHeaders').length && !this.THEAD.childNodes.length) {\n        this.THEAD.appendChild(rootDocument.createElement('TR'));\n      }\n    }\n    /**\n     * @param {HTMLTableElement} table An element to process.\n     * @returns {HTMLElement}\n     */\n  }, {\n    key: \"createSpreader\",\n    value: function createSpreader(table) {\n      var parent = table.parentNode;\n      var spreader;\n      if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !hasClass(parent, 'wtHolder')) {\n        spreader = this.wot.rootDocument.createElement('div');\n        spreader.className = 'wtSpreader';\n        if (parent) {\n          // if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it\n          parent.insertBefore(spreader, table);\n        }\n        spreader.appendChild(table);\n      }\n      spreader.style.position = 'relative';\n      return spreader;\n    }\n    /**\n     * @param {HTMLElement} spreader An element to the hider element is injected.\n     * @returns {HTMLElement}\n     */\n  }, {\n    key: \"createHider\",\n    value: function createHider(spreader) {\n      var parent = spreader.parentNode;\n      var hider;\n      if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !hasClass(parent, 'wtHolder')) {\n        hider = this.wot.rootDocument.createElement('div');\n        hider.className = 'wtHider';\n        if (parent) {\n          // if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it\n          parent.insertBefore(hider, spreader);\n        }\n        hider.appendChild(spreader);\n      }\n      return hider;\n    }\n    /**\n     *\n     * @param {HTMLElement} hider An element to the holder element is injected.\n     * @returns {HTMLElement}\n     */\n  }, {\n    key: \"createHolder\",\n    value: function createHolder(hider) {\n      var parent = hider.parentNode;\n      var holder;\n      if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !hasClass(parent, 'wtHolder')) {\n        holder = this.wot.rootDocument.createElement('div');\n        holder.style.position = 'relative';\n        holder.className = 'wtHolder';\n        if (parent) {\n          // if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it\n          parent.insertBefore(holder, hider);\n        }\n        if (this.isMaster) {\n          holder.parentNode.className += 'ht_master handsontable';\n        }\n        holder.appendChild(hider);\n      }\n      return holder;\n    }\n    /**\n     * Redraws the table.\n     *\n     * @param {boolean} [fastDraw=false] If TRUE, will try to avoid full redraw and only update the border positions.\n     *                                   If FALSE or UNDEFINED, will perform a full redraw.\n     * @returns {Table}\n     */\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      var fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var wot = this.wot;\n      var wtOverlays = wot.wtOverlays,\n        wtViewport = wot.wtViewport;\n      var totalRows = wot.getSetting('totalRows');\n      var totalColumns = wot.getSetting('totalColumns');\n      var rowHeaders = wot.getSetting('rowHeaders');\n      var rowHeadersCount = rowHeaders.length;\n      var columnHeaders = wot.getSetting('columnHeaders');\n      var columnHeadersCount = columnHeaders.length;\n      var syncScroll = false;\n      var runFastDraw = fastDraw;\n      if (this.isMaster) {\n        this.holderOffset = offset(this.holder);\n        runFastDraw = wtViewport.createRenderCalculators(runFastDraw);\n        if (rowHeadersCount && !wot.getSetting('fixedColumnsLeft')) {\n          var leftScrollPos = wtOverlays.leftOverlay.getScrollPosition();\n          var previousState = this.correctHeaderWidth;\n          this.correctHeaderWidth = leftScrollPos > 0;\n          if (previousState !== this.correctHeaderWidth) {\n            runFastDraw = false;\n          }\n        }\n      }\n      if (this.isMaster) {\n        syncScroll = wtOverlays.prepareOverlays();\n      }\n      if (runFastDraw) {\n        if (this.isMaster) {\n          // in case we only scrolled without redraw, update visible rows information in oldRowsCalculator\n          wtViewport.createVisibleCalculators();\n        }\n        if (wtOverlays) {\n          wtOverlays.refresh(true);\n        }\n      } else {\n        if (this.isMaster) {\n          this.tableOffset = offset(this.TABLE);\n        } else {\n          this.tableOffset = this.wot.cloneSource.wtTable.tableOffset;\n        }\n        var startRow = totalRows > 0 ? this.getFirstRenderedRow() : 0;\n        var startColumn = totalColumns > 0 ? this.getFirstRenderedColumn() : 0;\n        this.rowFilter = new RowFilter(startRow, totalRows, columnHeadersCount);\n        this.columnFilter = new ColumnFilter(startColumn, totalColumns, rowHeadersCount);\n        var performRedraw = true; // Only master table rendering can be skipped\n\n        if (this.isMaster) {\n          this.alignOverlaysWithTrimmingContainer();\n          var skipRender = {};\n          this.wot.getSetting('beforeDraw', true, skipRender);\n          performRedraw = skipRender.skipRender !== true;\n        }\n        if (performRedraw) {\n          this.tableRenderer.setHeaderContentRenderers(rowHeaders, columnHeaders);\n          if (this.is(CLONE_BOTTOM) || this.is(CLONE_BOTTOM_LEFT_CORNER)) {\n            // do NOT render headers on the bottom or bottom-left corner overlay\n            this.tableRenderer.setHeaderContentRenderers(rowHeaders, []);\n          }\n          this.resetOversizedRows();\n          this.tableRenderer.setViewportSize(this.getRenderedRowsCount(), this.getRenderedColumnsCount()).setFilters(this.rowFilter, this.columnFilter).render();\n          var workspaceWidth;\n          if (this.isMaster) {\n            workspaceWidth = this.wot.wtViewport.getWorkspaceWidth();\n            this.wot.wtViewport.containerWidth = null;\n            this.markOversizedColumnHeaders();\n          }\n          this.adjustColumnHeaderHeights();\n          if (this.isMaster || this.is(CLONE_BOTTOM)) {\n            this.markOversizedRows();\n          }\n          if (this.isMaster) {\n            this.wot.wtViewport.createVisibleCalculators();\n            this.wot.wtOverlays.refresh(false);\n            this.wot.wtOverlays.applyToDOM();\n            var hiderWidth = outerWidth(this.hider);\n            var tableWidth = outerWidth(this.TABLE);\n            if (hiderWidth !== 0 && tableWidth !== hiderWidth) {\n              // Recalculate the column widths, if width changes made in the overlays removed the scrollbar, thus changing the viewport width.\n              this.columnUtils.calculateWidths();\n              this.tableRenderer.renderer.colGroup.render();\n            }\n            if (workspaceWidth !== this.wot.wtViewport.getWorkspaceWidth()) {\n              // workspace width changed though to shown/hidden vertical scrollbar. Let's reapply stretching\n              this.wot.wtViewport.containerWidth = null;\n              this.columnUtils.calculateWidths();\n              this.tableRenderer.renderer.colGroup.render();\n            }\n            this.wot.getSetting('onDraw', true);\n          } else if (this.is(CLONE_BOTTOM)) {\n            this.wot.cloneSource.wtOverlays.adjustElementsSize();\n          }\n        }\n      }\n      if (this.isMaster) {\n        var positionChanged = wtOverlays.topOverlay.resetFixedPosition();\n        if (wtOverlays.bottomOverlay.clone) {\n          positionChanged = wtOverlays.bottomOverlay.resetFixedPosition() || positionChanged;\n        }\n        positionChanged = wtOverlays.leftOverlay.resetFixedPosition() || positionChanged;\n        if (wtOverlays.topLeftCornerOverlay) {\n          wtOverlays.topLeftCornerOverlay.resetFixedPosition();\n        }\n        if (wtOverlays.bottomLeftCornerOverlay && wtOverlays.bottomLeftCornerOverlay.clone) {\n          wtOverlays.bottomLeftCornerOverlay.resetFixedPosition();\n        }\n        if (positionChanged) {\n          // It refreshes the cells borders caused by a 1px shift (introduced by overlays which add or\n          // remove `innerBorderTop` and `innerBorderLeft` CSS classes to the DOM element. This happens\n          // when there is a switch between rendering from 0 to N rows/columns and vice versa).\n          wtOverlays.refreshAll();\n          wtOverlays.adjustElementsSize();\n        }\n      }\n      this.refreshSelections(runFastDraw);\n      if (syncScroll) {\n        wtOverlays.syncScrollWithMaster();\n      }\n      wot.drawn = true;\n      return this;\n    }\n    /**\n     * @param {number} col The visual column index.\n     */\n  }, {\n    key: \"markIfOversizedColumnHeader\",\n    value: function markIfOversizedColumnHeader(col) {\n      var sourceColIndex = this.wot.wtTable.columnFilter.renderedToSource(col);\n      var level = this.wot.getSetting('columnHeaders').length;\n      var defaultRowHeight = this.wot.wtSettings.settings.defaultRowHeight;\n      var previousColHeaderHeight;\n      var currentHeader;\n      var currentHeaderHeight;\n      var columnHeaderHeightSetting = this.wot.getSetting('columnHeaderHeight') || [];\n      while (level) {\n        level -= 1;\n        previousColHeaderHeight = this.wot.wtTable.getColumnHeaderHeight(level);\n        currentHeader = this.wot.wtTable.getColumnHeader(sourceColIndex, level);\n        if (!currentHeader) {\n          /* eslint-disable no-continue */\n          continue;\n        }\n        currentHeaderHeight = innerHeight(currentHeader);\n        if (!previousColHeaderHeight && defaultRowHeight < currentHeaderHeight || previousColHeaderHeight < currentHeaderHeight) {\n          this.wot.wtViewport.oversizedColumnHeaders[level] = currentHeaderHeight;\n        }\n        if (Array.isArray(columnHeaderHeightSetting)) {\n          if (columnHeaderHeightSetting[level] !== null && columnHeaderHeightSetting[level] !== void 0) {\n            this.wot.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting[level];\n          }\n        } else if (!isNaN(columnHeaderHeightSetting)) {\n          this.wot.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting;\n        }\n        if (this.wot.wtViewport.oversizedColumnHeaders[level] < (columnHeaderHeightSetting[level] || columnHeaderHeightSetting)) {\n          this.wot.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting[level] || columnHeaderHeightSetting; // eslint-disable-line max-len\n        }\n      }\n    }\n    /**\n     *\n     */\n  }, {\n    key: \"adjustColumnHeaderHeights\",\n    value: function adjustColumnHeaderHeights() {\n      var wot = this.wot;\n      var children = wot.wtTable.THEAD.childNodes;\n      var oversizedColumnHeaders = wot.wtViewport.oversizedColumnHeaders;\n      var columnHeaders = wot.getSetting('columnHeaders');\n      for (var i = 0, len = columnHeaders.length; i < len; i++) {\n        if (oversizedColumnHeaders[i]) {\n          if (!children[i] || children[i].childNodes.length === 0) {\n            return;\n          }\n          children[i].childNodes[0].style.height = \"\".concat(oversizedColumnHeaders[i], \"px\");\n        }\n      }\n    }\n    /**\n     * Resets cache of row heights. The cache should be cached for each render cycle in a case\n     * when new cell values have content which increases/decreases cell height.\n     */\n  }, {\n    key: \"resetOversizedRows\",\n    value: function resetOversizedRows() {\n      var wot = this.wot;\n      if (!this.isMaster && !this.is(CLONE_BOTTOM)) {\n        return;\n      }\n      if (!wot.getSetting('externalRowCalculator')) {\n        var rowsToRender = this.getRenderedRowsCount(); // Reset the oversized row cache for rendered rows\n\n        for (var visibleRowIndex = 0; visibleRowIndex < rowsToRender; visibleRowIndex++) {\n          var sourceRow = this.rowFilter.renderedToSource(visibleRowIndex);\n          if (wot.wtViewport.oversizedRows && wot.wtViewport.oversizedRows[sourceRow]) {\n            wot.wtViewport.oversizedRows[sourceRow] = void 0;\n          }\n        }\n      }\n    }\n    /**\n     * @param {string} className The CSS class name to remove from the table cells.\n     */\n  }, {\n    key: \"removeClassFromCells\",\n    value: function removeClassFromCells(className) {\n      var nodes = this.TABLE.querySelectorAll(\".\".concat(className));\n      for (var i = 0, len = nodes.length; i < len; i++) {\n        removeClass(nodes[i], className);\n      }\n    }\n    /**\n     * Refresh the table selection by re-rendering Selection instances connected with that instance.\n     *\n     * @param {boolean} fastDraw If fast drawing is enabled than additionally className clearing is applied.\n     */\n  }, {\n    key: \"refreshSelections\",\n    value: function refreshSelections(fastDraw) {\n      var wot = this.wot;\n      if (!wot.selections) {\n        return;\n      }\n      var highlights = Array.from(wot.selections);\n      var len = highlights.length;\n      if (fastDraw) {\n        var classesToRemove = [];\n        for (var i = 0; i < len; i++) {\n          var _highlights$i$setting = highlights[i].settings,\n            highlightHeaderClassName = _highlights$i$setting.highlightHeaderClassName,\n            highlightRowClassName = _highlights$i$setting.highlightRowClassName,\n            highlightColumnClassName = _highlights$i$setting.highlightColumnClassName;\n          var classNames = highlights[i].classNames;\n          var classNamesLength = classNames.length;\n          for (var j = 0; j < classNamesLength; j++) {\n            if (!classesToRemove.includes(classNames[j])) {\n              classesToRemove.push(classNames[j]);\n            }\n          }\n          if (highlightHeaderClassName && !classesToRemove.includes(highlightHeaderClassName)) {\n            classesToRemove.push(highlightHeaderClassName);\n          }\n          if (highlightRowClassName && !classesToRemove.includes(highlightRowClassName)) {\n            classesToRemove.push(highlightRowClassName);\n          }\n          if (highlightColumnClassName && !classesToRemove.includes(highlightColumnClassName)) {\n            classesToRemove.push(highlightColumnClassName);\n          }\n        }\n        var additionalClassesToRemove = wot.getSetting('onBeforeRemoveCellClassNames');\n        if (Array.isArray(additionalClassesToRemove)) {\n          for (var _i = 0; _i < additionalClassesToRemove.length; _i++) {\n            classesToRemove.push(additionalClassesToRemove[_i]);\n          }\n        }\n        var classesToRemoveLength = classesToRemove.length;\n        for (var _i2 = 0; _i2 < classesToRemoveLength; _i2++) {\n          // there was no rerender, so we need to remove classNames by ourselves\n          this.removeClassFromCells(classesToRemove[_i2]);\n        }\n      }\n      for (var _i3 = 0; _i3 < len; _i3++) {\n        highlights[_i3].draw(wot, fastDraw);\n      }\n    }\n    /**\n     * Get cell element at coords.\n     * Negative coords.row or coords.col are used to retrieve header cells. If there are multiple header levels, the\n     * negative value corresponds to the distance from the working area. For example, when there are 3 levels of column\n     * headers, coords.col=-1 corresponds to the most inner header element, while coords.col=-3 corresponds to the\n     * outmost header element.\n     *\n     * In case an element for the coords is not rendered, the method returns an error code.\n     * To produce the error code, the input parameters are validated in the order in which they\n     * are given. Thus, if both the row and the column coords are out of the rendered bounds,\n     * the method returns the error code for the row.\n     *\n     * @param {CellCoords} coords The cell coordinates.\n     * @returns {HTMLElement|number} HTMLElement on success or Number one of the exit codes on error:\n     *  -1 row before viewport\n     *  -2 row after viewport\n     *  -3 column before viewport\n     *  -4 column after viewport.\n     */\n  }, {\n    key: \"getCell\",\n    value: function getCell(coords) {\n      var row = coords.row;\n      var column = coords.col;\n      var hookResult = this.wot.getSetting('onModifyGetCellCoords', row, column);\n      if (hookResult && Array.isArray(hookResult)) {\n        var _hookResult = _slicedToArray(hookResult, 2);\n        row = _hookResult[0];\n        column = _hookResult[1];\n      }\n      if (this.isRowBeforeRenderedRows(row)) {\n        // row before rendered rows\n        return -1;\n      } else if (this.isRowAfterRenderedRows(row)) {\n        // row after rendered rows\n        return -2;\n      } else if (this.isColumnBeforeRenderedColumns(column)) {\n        // column before rendered columns\n        return -3;\n      } else if (this.isColumnAfterRenderedColumns(column)) {\n        // column after rendered columns\n        return -4;\n      }\n      var TR;\n      if (row < 0) {\n        TR = this.THEAD.childNodes[this.rowFilter.sourceRowToVisibleColHeadedRow(row)];\n      } else {\n        TR = this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];\n      }\n      if (!TR && row >= 0) {\n        throw new Error('TR was expected to be rendered but is not');\n      }\n      var TD = TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(column)];\n      if (!TD && column >= 0) {\n        throw new Error('TD or TH was expected to be rendered but is not');\n      }\n      return TD;\n    }\n    /**\n     * GetColumnHeader.\n     *\n     * @param {number} col Column index.\n     * @param {number} [level=0] Header level (0 = most distant to the table).\n     * @returns {object} HTMLElement on success or undefined on error.\n     */\n  }, {\n    key: \"getColumnHeader\",\n    value: function getColumnHeader(col) {\n      var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var TR = this.THEAD.childNodes[level];\n      return TR === null || TR === void 0 ? void 0 : TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(col)];\n    }\n    /**\n     * Gets all columns headers (TH elements) from the table.\n     *\n     * @param {number} column A source column index.\n     * @returns {HTMLTableCellElement[]}\n     */\n  }, {\n    key: \"getColumnHeaders\",\n    value: function getColumnHeaders(column) {\n      var THs = [];\n      var visibleColumn = this.columnFilter.sourceColumnToVisibleRowHeadedColumn(column);\n      this.THEAD.childNodes.forEach(function (TR) {\n        var TH = TR.childNodes[visibleColumn];\n        if (TH) {\n          THs.push(TH);\n        }\n      });\n      return THs;\n    }\n    /**\n     * GetRowHeader.\n     *\n     * @param {number} row Row index.\n     * @param {number} [level=0] Header level (0 = most distant to the table).\n     * @returns {HTMLElement} HTMLElement on success or Number one of the exit codes on error: `null table doesn't have row headers`.\n     */\n  }, {\n    key: \"getRowHeader\",\n    value: function getRowHeader(row) {\n      var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      if (this.columnFilter.sourceColumnToVisibleRowHeadedColumn(0) === 0) {\n        return;\n      }\n      var rowHeadersCount = this.wot.getSetting('rowHeaders').length;\n      if (level >= rowHeadersCount) {\n        return;\n      }\n      var TR = this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];\n      return TR === null || TR === void 0 ? void 0 : TR.childNodes[level];\n    }\n    /**\n     * Gets all rows headers (TH elements) from the table.\n     *\n     * @param {number} row A source row index.\n     * @returns {HTMLTableCellElement[]}\n     */\n  }, {\n    key: \"getRowHeaders\",\n    value: function getRowHeaders(row) {\n      if (this.columnFilter.sourceColumnToVisibleRowHeadedColumn(0) === 0) {\n        return [];\n      }\n      var THs = [];\n      var rowHeadersCount = this.wot.getSetting('rowHeaders').length;\n      for (var renderedRowIndex = 0; renderedRowIndex < rowHeadersCount; renderedRowIndex++) {\n        var TR = this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];\n        var TH = TR === null || TR === void 0 ? void 0 : TR.childNodes[renderedRowIndex];\n        if (TH) {\n          THs.push(TH);\n        }\n      }\n      return THs;\n    }\n    /**\n     * Returns cell coords object for a given TD (or a child element of a TD element).\n     *\n     * @param {HTMLTableCellElement} TD A cell DOM element (or a child of one).\n     * @returns {CellCoords|null} The coordinates of the provided TD element (or the closest TD element) or null, if the provided element is not applicable.\n     */\n  }, {\n    key: \"getCoords\",\n    value: function getCoords(TD) {\n      var cellElement = TD;\n      if (cellElement.nodeName !== 'TD' && cellElement.nodeName !== 'TH') {\n        cellElement = closest(cellElement, ['TD', 'TH']);\n      }\n      if (cellElement === null) {\n        return null;\n      }\n      var TR = cellElement.parentNode;\n      var CONTAINER = TR.parentNode;\n      var row = index(TR);\n      var col = cellElement.cellIndex;\n      if (overlayContainsElement(CLONE_TOP_LEFT_CORNER, cellElement, this.wtRootElement) || overlayContainsElement(CLONE_TOP, cellElement, this.wtRootElement)) {\n        if (CONTAINER.nodeName === 'THEAD') {\n          row -= CONTAINER.childNodes.length;\n        }\n      } else if (overlayContainsElement(CLONE_BOTTOM_LEFT_CORNER, cellElement, this.wtRootElement) || overlayContainsElement(CLONE_BOTTOM, cellElement, this.wtRootElement)) {\n        var totalRows = this.wot.getSetting('totalRows');\n        row = totalRows - CONTAINER.childNodes.length + row;\n      } else if (CONTAINER === this.THEAD) {\n        row = this.rowFilter.visibleColHeadedRowToSourceRow(row);\n      } else {\n        row = this.rowFilter.renderedToSource(row);\n      }\n      if (overlayContainsElement(CLONE_TOP_LEFT_CORNER, cellElement, this.wtRootElement) || overlayContainsElement(CLONE_LEFT, cellElement, this.wtRootElement) || overlayContainsElement(CLONE_BOTTOM_LEFT_CORNER, cellElement, this.wtRootElement)) {\n        col = this.columnFilter.offsettedTH(col);\n      } else {\n        col = this.columnFilter.visibleRowHeadedColumnToSourceColumn(col);\n      }\n      return new CellCoords(row, col);\n    }\n    /**\n     * Check if any of the rendered rows is higher than expected, and if so, cache them.\n     */\n  }, {\n    key: \"markOversizedRows\",\n    value: function markOversizedRows() {\n      if (this.wot.getSetting('externalRowCalculator')) {\n        return;\n      }\n      var rowCount = this.TBODY.childNodes.length;\n      var expectedTableHeight = rowCount * this.wot.wtSettings.settings.defaultRowHeight;\n      var actualTableHeight = innerHeight(this.TBODY) - 1;\n      var previousRowHeight;\n      var rowInnerHeight;\n      var sourceRowIndex;\n      var currentTr;\n      var rowHeader;\n      if (expectedTableHeight === actualTableHeight && !this.wot.getSetting('fixedRowsBottom')) {\n        // If the actual table height equals rowCount * default single row height, no row is oversized -> no need to iterate over them\n        return;\n      }\n      while (rowCount) {\n        rowCount -= 1;\n        sourceRowIndex = this.rowFilter.renderedToSource(rowCount);\n        previousRowHeight = this.getRowHeight(sourceRowIndex);\n        currentTr = this.getTrForRow(sourceRowIndex);\n        rowHeader = currentTr.querySelector('th');\n        if (rowHeader) {\n          rowInnerHeight = innerHeight(rowHeader);\n        } else {\n          rowInnerHeight = innerHeight(currentTr) - 1;\n        }\n        if (!previousRowHeight && this.wot.wtSettings.settings.defaultRowHeight < rowInnerHeight || previousRowHeight < rowInnerHeight) {\n          rowInnerHeight += 1;\n          this.wot.wtViewport.oversizedRows[sourceRowIndex] = rowInnerHeight;\n        }\n      }\n    }\n    /**\n     * @param {number} row The visual row index.\n     * @returns {HTMLTableElement}\n     */\n  }, {\n    key: \"getTrForRow\",\n    value: function getTrForRow(row) {\n      return this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];\n    }\n    /**\n     * Checks if the column index (negative value from -1 to N) is rendered.\n     *\n     * @param {number} column The column index (negative value from -1 to N).\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isColumnHeaderRendered\",\n    value: function isColumnHeaderRendered(column) {\n      if (column >= 0) {\n        return false;\n      }\n      var rowHeaders = this.wot.getSetting('rowHeaders');\n      var rowHeadersCount = rowHeaders.length;\n      return Math.abs(column) <= rowHeadersCount;\n    }\n    /**\n     * Checks if the row index (negative value from -1 to N) is rendered.\n     *\n     * @param {number} row The row index (negative value from -1 to N).\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isRowHeaderRendered\",\n    value: function isRowHeaderRendered(row) {\n      if (row >= 0) {\n        return false;\n      }\n      var columnHeaders = this.wot.getSetting('columnHeaders');\n      var columnHeadersCount = columnHeaders.length;\n      return Math.abs(row) <= columnHeadersCount;\n    }\n    /* eslint-disable jsdoc/require-description-complete-sentence */\n\n    /**\n     * Check if the given row index is lower than the index of the first row that\n     * is currently rendered and return TRUE in that case, or FALSE otherwise.\n     *\n     * Negative row index is used to check the columns' headers.\n     *\n     *  Headers\n     *           +--------------+                                     │\n     *       -3  │    │    │    │                                     │\n     *           +--------------+                                     │\n     *       -2  │    │    │    │                                     │ TRUE\n     *           +--------------+                                     │\n     *       -1  │    │    │    │                                     │\n     *  Cells  +==================+                                   │\n     *        0  ┇    ┇    ┇    ┇ <--- For fixedRowsTop: 1            │\n     *           +--------------+      the master overlay do       ---+ first rendered row (index 1)\n     *        1  │ A2 │ B2 │ C2 │      not render the first row.      │\n     *           +--------------+                                     │ FALSE\n     *        2  │ A3 │ B3 │ C3 │                                     │\n     *           +--------------+                                  ---+ last rendered row\n     *                                                                │\n     *                                                                │ FALSE\n     *\n     * @param {number} row The visual row index.\n     * @memberof Table#\n     * @function isRowBeforeRenderedRows\n     * @returns {boolean}\n     */\n\n    /* eslint-enable jsdoc/require-description-complete-sentence */\n  }, {\n    key: \"isRowBeforeRenderedRows\",\n    value: function isRowBeforeRenderedRows(row) {\n      var first = this.getFirstRenderedRow(); // Check the headers only in case when the first rendered row is -1 or 0.\n      // This is an indication that the overlay is placed on the most top position.\n\n      if (row < 0 && first <= 0) {\n        return !this.isRowHeaderRendered(row);\n      }\n      return row < first;\n    }\n    /* eslint-disable jsdoc/require-description-complete-sentence */\n\n    /**\n     * Check if the given column index is greater than the index of the last column that\n     * is currently rendered and return TRUE in that case, or FALSE otherwise.\n     *\n     * The negative row index is used to check the columns' headers. However,\n     * keep in mind that for negative indexes, the method always returns FALSE as\n     * it is not possible to render headers partially. The \"after\" index can not be\n     * lower than -1.\n     *\n     *  Headers\n     *           +--------------+                                     │\n     *       -3  │    │    │    │                                     │\n     *           +--------------+                                     │\n     *       -2  │    │    │    │                                     │ FALSE\n     *           +--------------+                                     │\n     *       -1  │    │    │    │                                     │\n     *  Cells  +==================+                                   │\n     *        0  ┇    ┇    ┇    ┇ <--- For fixedRowsTop: 1            │\n     *           +--------------+      the master overlay do       ---+ first rendered row (index 1)\n     *        1  │ A2 │ B2 │ C2 │      not render the first rows      │\n     *           +--------------+                                     │ FALSE\n     *        2  │ A3 │ B3 │ C3 │                                     │\n     *           +--------------+                                  ---+ last rendered row\n     *                                                                │\n     *                                                                │ TRUE\n     *\n     * @param {number} row The visual row index.\n     * @memberof Table#\n     * @function isRowAfterRenderedRows\n     * @returns {boolean}\n     */\n\n    /* eslint-enable jsdoc/require-description-complete-sentence */\n  }, {\n    key: \"isRowAfterRenderedRows\",\n    value: function isRowAfterRenderedRows(row) {\n      return row > this.getLastRenderedRow();\n    }\n    /* eslint-disable jsdoc/require-description-complete-sentence */\n\n    /**\n     * Check if the given column index is lower than the index of the first column that\n     * is currently rendered and return TRUE in that case, or FALSE otherwise.\n     *\n     * Negative column index is used to check the rows' headers.\n     *\n     *                            For fixedColumnsLeft: 1 the master overlay\n     *                            do not render this first columns.\n     *  Headers    -3   -2   -1    |\n     *           +----+----+----║┄ ┄ +------+------+\n     *           │    │    │    ║    │  B1  │  C1  │\n     *           +--------------║┄ ┄ --------------│\n     *           │    │    │    ║    │  B2  │  C2  │\n     *           +--------------║┄ ┄ --------------│\n     *           │    │    │    ║    │  B3  │  C3  │\n     *           +----+----+----║┄ ┄ +------+------+\n     *                               ╷             ╷\n     *      -------------------------+-------------+---------------->\n     *          TRUE             first    FALSE   last         FALSE\n     *                           rendered         rendered\n     *                           column           column\n     *\n     * @param {number} column The visual column index.\n     * @memberof Table#\n     * @function isColumnBeforeRenderedColumns\n     * @returns {boolean}\n     */\n\n    /* eslint-enable jsdoc/require-description-complete-sentence */\n  }, {\n    key: \"isColumnBeforeRenderedColumns\",\n    value: function isColumnBeforeRenderedColumns(column) {\n      var first = this.getFirstRenderedColumn(); // Check the headers only in case when the first rendered column is -1 or 0.\n      // This is an indication that the overlay is placed on the most left position.\n\n      if (column < 0 && first <= 0) {\n        return !this.isColumnHeaderRendered(column);\n      }\n      return column < first;\n    }\n    /* eslint-disable jsdoc/require-description-complete-sentence */\n\n    /**\n     * Check if the given column index is greater than the index of the last column that\n     * is currently rendered and return TRUE in that case, or FALSE otherwise.\n     *\n     * The negative column index is used to check the rows' headers. However,\n     * keep in mind that for negative indexes, the method always returns FALSE as\n     * it is not possible to render headers partially. The \"after\" index can not be\n     * lower than -1.\n     *\n     *                            For fixedColumnsLeft: 1 the master overlay\n     *                            do not render this first columns.\n     *  Headers    -3   -2   -1    |\n     *           +----+----+----║┄ ┄ +------+------+\n     *           │    │    │    ║    │  B1  │  C1  │\n     *           +--------------║┄ ┄ --------------│\n     *           │    │    │    ║    │  B2  │  C2  │\n     *           +--------------║┄ ┄ --------------│\n     *           │    │    │    ║    │  B3  │  C3  │\n     *           +----+----+----║┄ ┄ +------+------+\n     *                               ╷             ╷\n     *      -------------------------+-------------+---------------->\n     *          FALSE             first    FALSE   last         TRUE\n     *                           rendered         rendered\n     *                           column           column\n     *\n     * @param {number} column The visual column index.\n     * @memberof Table#\n     * @function isColumnAfterRenderedColumns\n     * @returns {boolean}\n     */\n\n    /* eslint-enable jsdoc/require-description-complete-sentence */\n  }, {\n    key: \"isColumnAfterRenderedColumns\",\n    value: function isColumnAfterRenderedColumns(column) {\n      return this.columnFilter && column > this.getLastRenderedColumn();\n    }\n  }, {\n    key: \"isColumnAfterViewport\",\n    value: function isColumnAfterViewport(column) {\n      return this.columnFilter && column > this.getLastVisibleColumn();\n    }\n  }, {\n    key: \"isRowAfterViewport\",\n    value: function isRowAfterViewport(row) {\n      return this.rowFilter && row > this.getLastVisibleRow();\n    }\n  }, {\n    key: \"isColumnBeforeViewport\",\n    value: function isColumnBeforeViewport(column) {\n      return this.columnFilter && this.columnFilter.sourceToRendered(column) < 0 && column >= 0;\n    }\n  }, {\n    key: \"isLastRowFullyVisible\",\n    value: function isLastRowFullyVisible() {\n      return this.getLastVisibleRow() === this.getLastRenderedRow();\n    }\n  }, {\n    key: \"isLastColumnFullyVisible\",\n    value: function isLastColumnFullyVisible() {\n      return this.getLastVisibleColumn() === this.getLastRenderedColumn();\n    }\n  }, {\n    key: \"allRowsInViewport\",\n    value: function allRowsInViewport() {\n      return this.wot.getSetting('totalRows') === this.getVisibleRowsCount();\n    }\n  }, {\n    key: \"allColumnsInViewport\",\n    value: function allColumnsInViewport() {\n      return this.wot.getSetting('totalColumns') === this.getVisibleColumnsCount();\n    }\n    /**\n     * Checks if any of the row's cells content exceeds its initial height, and if so, returns the oversized height.\n     *\n     * @param {number} sourceRow The physical row index.\n     * @returns {number}\n     */\n  }, {\n    key: \"getRowHeight\",\n    value: function getRowHeight(sourceRow) {\n      return this.rowUtils.getHeight(sourceRow);\n    }\n    /**\n     * @param {number} level The column level.\n     * @returns {number}\n     */\n  }, {\n    key: \"getColumnHeaderHeight\",\n    value: function getColumnHeaderHeight(level) {\n      return this.columnUtils.getHeaderHeight(level);\n    }\n    /**\n     * @param {number} sourceColumn The physical column index.\n     * @returns {number}\n     */\n  }, {\n    key: \"getColumnWidth\",\n    value: function getColumnWidth(sourceColumn) {\n      return this.columnUtils.getWidth(sourceColumn);\n    }\n    /**\n     * @param {number} sourceColumn The physical column index.\n     * @returns {number}\n     */\n  }, {\n    key: \"getStretchedColumnWidth\",\n    value: function getStretchedColumnWidth(sourceColumn) {\n      return this.columnUtils.getStretchedColumnWidth(sourceColumn);\n    }\n    /**\n     * Checks if the table has defined size. It returns `true` when the table has width and height\n     * set bigger than `0px`.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"hasDefinedSize\",\n    value: function hasDefinedSize() {\n      return this.hasTableHeight && this.hasTableWidth;\n    }\n    /**\n     * Checks if the table is visible. It returns `true` when the holder element (or its parents)\n     * has CSS 'display' property different than 'none'.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isVisible\",\n    value: function isVisible() {\n      return _isVisible(this.TABLE);\n    }\n    /**\n     * Modify row header widths provided by user in class contructor.\n     *\n     * @private\n     * @param {Function} rowHeaderWidthFactory The function which can provide default width values for rows..\n     * @returns {number}\n     */\n  }, {\n    key: \"_modifyRowHeaderWidth\",\n    value: function _modifyRowHeaderWidth(rowHeaderWidthFactory) {\n      var widths = isFunction(rowHeaderWidthFactory) ? rowHeaderWidthFactory() : null;\n      if (Array.isArray(widths)) {\n        widths = _toConsumableArray(widths);\n        widths[widths.length - 1] = this._correctRowHeaderWidth(widths[widths.length - 1]);\n      } else {\n        widths = this._correctRowHeaderWidth(widths);\n      }\n      return widths;\n    }\n    /**\n     * Correct row header width if necessary.\n     *\n     * @private\n     * @param {number} width The width to process.\n     * @returns {number}\n     */\n  }, {\n    key: \"_correctRowHeaderWidth\",\n    value: function _correctRowHeaderWidth(width) {\n      var rowHeaderWidth = width;\n      if (typeof width !== 'number') {\n        rowHeaderWidth = this.wot.getSetting('defaultColumnWidth');\n      }\n      if (this.correctHeaderWidth) {\n        rowHeaderWidth += 1;\n      }\n      return rowHeaderWidth;\n    }\n  }]);\n  return Table;\n}();\nexport default Table;","map":{"version":3,"names":["_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","TypeError","iter","Symbol","iterator","Array","from","isArray","_arrayLikeToArray","_slicedToArray","i","_arrayWithHoles","_iterableToArrayLimit","_nonIterableRest","o","minLen","n","Object","prototype","toString","call","slice","constructor","name","test","len","length","arr2","_i","_arr","_n","_d","_s","_e","next","done","push","value","err","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","hasClass","index","offset","removeClass","removeTextNodes","overlayContainsElement","closest","outerWidth","innerHeight","isVisible","_isVisible","isFunction","CellCoords","ColumnFilter","RowFilter","Renderer","ColumnUtils","RowUtils","isOverlayTypeOf","CLONE_TOP","CLONE_BOTTOM","CLONE_LEFT","CLONE_TOP_LEFT_CORNER","CLONE_BOTTOM_LEFT_CORNER","Table","wotInstance","table","_this","isMaster","cloneOverlay","wot","TABLE","TBODY","THEAD","COLGROUP","tableOffset","holderOffset","hasTableHeight","hasTableWidth","isTableVisible","spreader","createSpreader","hider","createHider","holder","createHolder","wtRootElement","parentNode","alignOverlaysWithTrimmingContainer","fixTableDomTree","rowFilter","columnFilter","correctHeaderWidth","origRowHeaderWidth","wtSettings","settings","rowHeaderWidth","_modifyRowHeaderWidth","rowUtils","columnUtils","tableRenderer","cellRenderer","is","overlayTypeName","rootDocument","querySelector","createElement","appendChild","insertBefore","getSetting","childNodes","parent","nodeType","Node","ELEMENT_NODE","className","style","position","draw","fastDraw","arguments","undefined","wtOverlays","wtViewport","totalRows","totalColumns","rowHeaders","rowHeadersCount","columnHeaders","columnHeadersCount","syncScroll","runFastDraw","createRenderCalculators","leftScrollPos","leftOverlay","getScrollPosition","previousState","prepareOverlays","createVisibleCalculators","refresh","cloneSource","wtTable","startRow","getFirstRenderedRow","startColumn","getFirstRenderedColumn","performRedraw","skipRender","setHeaderContentRenderers","resetOversizedRows","setViewportSize","getRenderedRowsCount","getRenderedColumnsCount","setFilters","render","workspaceWidth","getWorkspaceWidth","containerWidth","markOversizedColumnHeaders","adjustColumnHeaderHeights","markOversizedRows","applyToDOM","hiderWidth","tableWidth","calculateWidths","renderer","colGroup","adjustElementsSize","positionChanged","topOverlay","resetFixedPosition","bottomOverlay","clone","topLeftCornerOverlay","bottomLeftCornerOverlay","refreshAll","refreshSelections","syncScrollWithMaster","drawn","markIfOversizedColumnHeader","col","sourceColIndex","renderedToSource","level","defaultRowHeight","previousColHeaderHeight","currentHeader","currentHeaderHeight","columnHeaderHeightSetting","getColumnHeaderHeight","getColumnHeader","oversizedColumnHeaders","isNaN","children","height","concat","rowsToRender","visibleRowIndex","sourceRow","oversizedRows","removeClassFromCells","nodes","querySelectorAll","selections","highlights","classesToRemove","_highlights$i$setting","highlightHeaderClassName","highlightRowClassName","highlightColumnClassName","classNames","classNamesLength","j","includes","additionalClassesToRemove","classesToRemoveLength","_i2","_i3","getCell","coords","row","column","hookResult","_hookResult","isRowBeforeRenderedRows","isRowAfterRenderedRows","isColumnBeforeRenderedColumns","isColumnAfterRenderedColumns","TR","sourceRowToVisibleColHeadedRow","sourceToRendered","Error","TD","sourceColumnToVisibleRowHeadedColumn","getColumnHeaders","THs","visibleColumn","forEach","TH","getRowHeader","getRowHeaders","renderedRowIndex","getCoords","cellElement","nodeName","CONTAINER","cellIndex","visibleColHeadedRowToSourceRow","offsettedTH","visibleRowHeadedColumnToSourceColumn","rowCount","expectedTableHeight","actualTableHeight","previousRowHeight","rowInnerHeight","sourceRowIndex","currentTr","rowHeader","getRowHeight","getTrForRow","isColumnHeaderRendered","Math","abs","isRowHeaderRendered","first","getLastRenderedRow","getLastRenderedColumn","isColumnAfterViewport","getLastVisibleColumn","isRowAfterViewport","getLastVisibleRow","isColumnBeforeViewport","isLastRowFullyVisible","isLastColumnFullyVisible","allRowsInViewport","getVisibleRowsCount","allColumnsInViewport","getVisibleColumnsCount","getHeight","getHeaderHeight","getColumnWidth","sourceColumn","getWidth","getStretchedColumnWidth","hasDefinedSize","rowHeaderWidthFactory","widths","_correctRowHeaderWidth","width"],"sources":["/Users/priyadeliwala/Desktop/sales-dashboard/node_modules/handsontable/3rdparty/walkontable/src/table.mjs"],"sourcesContent":["function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nimport { hasClass, index, offset, removeClass, removeTextNodes, overlayContainsElement, closest, outerWidth, innerHeight, isVisible as _isVisible } from \"./../../../helpers/dom/element.mjs\";\nimport { isFunction } from \"./../../../helpers/function.mjs\";\nimport CellCoords from \"./cell/coords.mjs\";\nimport ColumnFilter from \"./filter/column.mjs\";\nimport RowFilter from \"./filter/row.mjs\";\nimport { Renderer } from \"./renderer/index.mjs\";\nimport ColumnUtils from \"./utils/column.mjs\";\nimport RowUtils from \"./utils/row.mjs\";\nimport { isOverlayTypeOf } from \"./overlay/registerer.mjs\";\nimport { CLONE_TOP, CLONE_BOTTOM, CLONE_LEFT, CLONE_TOP_LEFT_CORNER, CLONE_BOTTOM_LEFT_CORNER } from \"./overlay/constants.mjs\";\n/**\n *\n */\n\nvar Table = /*#__PURE__*/function () {\n  /**\n   * @param {Walkontable} wotInstance The Walkontable instance.\n   * @param {HTMLTableElement} table An element to the Walkontable generated table is injected.\n   */\n  function Table(wotInstance, table) {\n    var _this = this;\n\n    _classCallCheck(this, Table);\n\n    /**\n     * Indicates if this instance is of type `MasterTable` (i.e. It is NOT an overlay).\n     *\n     * @type {boolean}\n     */\n    this.isMaster = !wotInstance.cloneOverlay; // \"instanceof\" operator isn't used, because it caused a circular reference in Webpack\n\n    this.wot = wotInstance; // legacy support\n\n    this.instance = this.wot;\n    this.TABLE = table;\n    this.TBODY = null;\n    this.THEAD = null;\n    this.COLGROUP = null;\n    this.tableOffset = 0;\n    this.holderOffset = 0;\n    /**\n     * Indicates if the table has height bigger than 0px.\n     *\n     * @type {boolean}\n     */\n\n    this.hasTableHeight = true;\n    /**\n     * Indicates if the table has width bigger than 0px.\n     *\n     * @type {boolean}\n     */\n\n    this.hasTableWidth = true;\n    /**\n     * Indicates if the table is visible. By visible, it means that the holder\n     * element has CSS 'display' property different than 'none'.\n     *\n     * @type {boolean}\n     */\n\n    this.isTableVisible = false;\n    removeTextNodes(this.TABLE);\n    this.spreader = this.createSpreader(this.TABLE);\n    this.hider = this.createHider(this.spreader);\n    this.holder = this.createHolder(this.hider);\n    this.wtRootElement = this.holder.parentNode;\n\n    if (this.isMaster) {\n      this.alignOverlaysWithTrimmingContainer();\n    }\n\n    this.fixTableDomTree();\n    this.rowFilter = null;\n    this.columnFilter = null;\n    this.correctHeaderWidth = false;\n    var origRowHeaderWidth = this.wot.wtSettings.settings.rowHeaderWidth; // Fix for jumping row headers (https://github.com/handsontable/handsontable/issues/3850)\n\n    this.wot.wtSettings.settings.rowHeaderWidth = function () {\n      return _this._modifyRowHeaderWidth(origRowHeaderWidth);\n    };\n\n    this.rowUtils = new RowUtils(this.wot);\n    this.columnUtils = new ColumnUtils(this.wot);\n    this.tableRenderer = new Renderer({\n      TABLE: this.TABLE,\n      THEAD: this.THEAD,\n      COLGROUP: this.COLGROUP,\n      TBODY: this.TBODY,\n      rowUtils: this.rowUtils,\n      columnUtils: this.columnUtils,\n      cellRenderer: this.wot.wtSettings.settings.cellRenderer\n    });\n  }\n  /**\n   * Returns a boolean that is true if this intance of Table represents a specific overlay, identified by the overlay name.\n   * For MasterTable, it returns false.\n   *\n   * @param {string} overlayTypeName The overlay type.\n   * @returns {boolean}\n   */\n\n\n  _createClass(Table, [{\n    key: \"is\",\n    value: function is(overlayTypeName) {\n      return isOverlayTypeOf(this.wot.cloneOverlay, overlayTypeName);\n    }\n    /**\n     *\n     */\n\n  }, {\n    key: \"fixTableDomTree\",\n    value: function fixTableDomTree() {\n      var rootDocument = this.wot.rootDocument;\n      this.TBODY = this.TABLE.querySelector('tbody');\n\n      if (!this.TBODY) {\n        this.TBODY = rootDocument.createElement('tbody');\n        this.TABLE.appendChild(this.TBODY);\n      }\n\n      this.THEAD = this.TABLE.querySelector('thead');\n\n      if (!this.THEAD) {\n        this.THEAD = rootDocument.createElement('thead');\n        this.TABLE.insertBefore(this.THEAD, this.TBODY);\n      }\n\n      this.COLGROUP = this.TABLE.querySelector('colgroup');\n\n      if (!this.COLGROUP) {\n        this.COLGROUP = rootDocument.createElement('colgroup');\n        this.TABLE.insertBefore(this.COLGROUP, this.THEAD);\n      }\n\n      if (this.wot.getSetting('columnHeaders').length && !this.THEAD.childNodes.length) {\n        this.THEAD.appendChild(rootDocument.createElement('TR'));\n      }\n    }\n    /**\n     * @param {HTMLTableElement} table An element to process.\n     * @returns {HTMLElement}\n     */\n\n  }, {\n    key: \"createSpreader\",\n    value: function createSpreader(table) {\n      var parent = table.parentNode;\n      var spreader;\n\n      if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !hasClass(parent, 'wtHolder')) {\n        spreader = this.wot.rootDocument.createElement('div');\n        spreader.className = 'wtSpreader';\n\n        if (parent) {\n          // if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it\n          parent.insertBefore(spreader, table);\n        }\n\n        spreader.appendChild(table);\n      }\n\n      spreader.style.position = 'relative';\n      return spreader;\n    }\n    /**\n     * @param {HTMLElement} spreader An element to the hider element is injected.\n     * @returns {HTMLElement}\n     */\n\n  }, {\n    key: \"createHider\",\n    value: function createHider(spreader) {\n      var parent = spreader.parentNode;\n      var hider;\n\n      if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !hasClass(parent, 'wtHolder')) {\n        hider = this.wot.rootDocument.createElement('div');\n        hider.className = 'wtHider';\n\n        if (parent) {\n          // if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it\n          parent.insertBefore(hider, spreader);\n        }\n\n        hider.appendChild(spreader);\n      }\n\n      return hider;\n    }\n    /**\n     *\n     * @param {HTMLElement} hider An element to the holder element is injected.\n     * @returns {HTMLElement}\n     */\n\n  }, {\n    key: \"createHolder\",\n    value: function createHolder(hider) {\n      var parent = hider.parentNode;\n      var holder;\n\n      if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !hasClass(parent, 'wtHolder')) {\n        holder = this.wot.rootDocument.createElement('div');\n        holder.style.position = 'relative';\n        holder.className = 'wtHolder';\n\n        if (parent) {\n          // if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it\n          parent.insertBefore(holder, hider);\n        }\n\n        if (this.isMaster) {\n          holder.parentNode.className += 'ht_master handsontable';\n        }\n\n        holder.appendChild(hider);\n      }\n\n      return holder;\n    }\n    /**\n     * Redraws the table.\n     *\n     * @param {boolean} [fastDraw=false] If TRUE, will try to avoid full redraw and only update the border positions.\n     *                                   If FALSE or UNDEFINED, will perform a full redraw.\n     * @returns {Table}\n     */\n\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      var fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var wot = this.wot;\n      var wtOverlays = wot.wtOverlays,\n          wtViewport = wot.wtViewport;\n      var totalRows = wot.getSetting('totalRows');\n      var totalColumns = wot.getSetting('totalColumns');\n      var rowHeaders = wot.getSetting('rowHeaders');\n      var rowHeadersCount = rowHeaders.length;\n      var columnHeaders = wot.getSetting('columnHeaders');\n      var columnHeadersCount = columnHeaders.length;\n      var syncScroll = false;\n      var runFastDraw = fastDraw;\n\n      if (this.isMaster) {\n        this.holderOffset = offset(this.holder);\n        runFastDraw = wtViewport.createRenderCalculators(runFastDraw);\n\n        if (rowHeadersCount && !wot.getSetting('fixedColumnsLeft')) {\n          var leftScrollPos = wtOverlays.leftOverlay.getScrollPosition();\n          var previousState = this.correctHeaderWidth;\n          this.correctHeaderWidth = leftScrollPos > 0;\n\n          if (previousState !== this.correctHeaderWidth) {\n            runFastDraw = false;\n          }\n        }\n      }\n\n      if (this.isMaster) {\n        syncScroll = wtOverlays.prepareOverlays();\n      }\n\n      if (runFastDraw) {\n        if (this.isMaster) {\n          // in case we only scrolled without redraw, update visible rows information in oldRowsCalculator\n          wtViewport.createVisibleCalculators();\n        }\n\n        if (wtOverlays) {\n          wtOverlays.refresh(true);\n        }\n      } else {\n        if (this.isMaster) {\n          this.tableOffset = offset(this.TABLE);\n        } else {\n          this.tableOffset = this.wot.cloneSource.wtTable.tableOffset;\n        }\n\n        var startRow = totalRows > 0 ? this.getFirstRenderedRow() : 0;\n        var startColumn = totalColumns > 0 ? this.getFirstRenderedColumn() : 0;\n        this.rowFilter = new RowFilter(startRow, totalRows, columnHeadersCount);\n        this.columnFilter = new ColumnFilter(startColumn, totalColumns, rowHeadersCount);\n        var performRedraw = true; // Only master table rendering can be skipped\n\n        if (this.isMaster) {\n          this.alignOverlaysWithTrimmingContainer();\n          var skipRender = {};\n          this.wot.getSetting('beforeDraw', true, skipRender);\n          performRedraw = skipRender.skipRender !== true;\n        }\n\n        if (performRedraw) {\n          this.tableRenderer.setHeaderContentRenderers(rowHeaders, columnHeaders);\n\n          if (this.is(CLONE_BOTTOM) || this.is(CLONE_BOTTOM_LEFT_CORNER)) {\n            // do NOT render headers on the bottom or bottom-left corner overlay\n            this.tableRenderer.setHeaderContentRenderers(rowHeaders, []);\n          }\n\n          this.resetOversizedRows();\n          this.tableRenderer.setViewportSize(this.getRenderedRowsCount(), this.getRenderedColumnsCount()).setFilters(this.rowFilter, this.columnFilter).render();\n          var workspaceWidth;\n\n          if (this.isMaster) {\n            workspaceWidth = this.wot.wtViewport.getWorkspaceWidth();\n            this.wot.wtViewport.containerWidth = null;\n            this.markOversizedColumnHeaders();\n          }\n\n          this.adjustColumnHeaderHeights();\n\n          if (this.isMaster || this.is(CLONE_BOTTOM)) {\n            this.markOversizedRows();\n          }\n\n          if (this.isMaster) {\n            this.wot.wtViewport.createVisibleCalculators();\n            this.wot.wtOverlays.refresh(false);\n            this.wot.wtOverlays.applyToDOM();\n            var hiderWidth = outerWidth(this.hider);\n            var tableWidth = outerWidth(this.TABLE);\n\n            if (hiderWidth !== 0 && tableWidth !== hiderWidth) {\n              // Recalculate the column widths, if width changes made in the overlays removed the scrollbar, thus changing the viewport width.\n              this.columnUtils.calculateWidths();\n              this.tableRenderer.renderer.colGroup.render();\n            }\n\n            if (workspaceWidth !== this.wot.wtViewport.getWorkspaceWidth()) {\n              // workspace width changed though to shown/hidden vertical scrollbar. Let's reapply stretching\n              this.wot.wtViewport.containerWidth = null;\n              this.columnUtils.calculateWidths();\n              this.tableRenderer.renderer.colGroup.render();\n            }\n\n            this.wot.getSetting('onDraw', true);\n          } else if (this.is(CLONE_BOTTOM)) {\n            this.wot.cloneSource.wtOverlays.adjustElementsSize();\n          }\n        }\n      }\n\n      if (this.isMaster) {\n        var positionChanged = wtOverlays.topOverlay.resetFixedPosition();\n\n        if (wtOverlays.bottomOverlay.clone) {\n          positionChanged = wtOverlays.bottomOverlay.resetFixedPosition() || positionChanged;\n        }\n\n        positionChanged = wtOverlays.leftOverlay.resetFixedPosition() || positionChanged;\n\n        if (wtOverlays.topLeftCornerOverlay) {\n          wtOverlays.topLeftCornerOverlay.resetFixedPosition();\n        }\n\n        if (wtOverlays.bottomLeftCornerOverlay && wtOverlays.bottomLeftCornerOverlay.clone) {\n          wtOverlays.bottomLeftCornerOverlay.resetFixedPosition();\n        }\n\n        if (positionChanged) {\n          // It refreshes the cells borders caused by a 1px shift (introduced by overlays which add or\n          // remove `innerBorderTop` and `innerBorderLeft` CSS classes to the DOM element. This happens\n          // when there is a switch between rendering from 0 to N rows/columns and vice versa).\n          wtOverlays.refreshAll();\n          wtOverlays.adjustElementsSize();\n        }\n      }\n\n      this.refreshSelections(runFastDraw);\n\n      if (syncScroll) {\n        wtOverlays.syncScrollWithMaster();\n      }\n\n      wot.drawn = true;\n      return this;\n    }\n    /**\n     * @param {number} col The visual column index.\n     */\n\n  }, {\n    key: \"markIfOversizedColumnHeader\",\n    value: function markIfOversizedColumnHeader(col) {\n      var sourceColIndex = this.wot.wtTable.columnFilter.renderedToSource(col);\n      var level = this.wot.getSetting('columnHeaders').length;\n      var defaultRowHeight = this.wot.wtSettings.settings.defaultRowHeight;\n      var previousColHeaderHeight;\n      var currentHeader;\n      var currentHeaderHeight;\n      var columnHeaderHeightSetting = this.wot.getSetting('columnHeaderHeight') || [];\n\n      while (level) {\n        level -= 1;\n        previousColHeaderHeight = this.wot.wtTable.getColumnHeaderHeight(level);\n        currentHeader = this.wot.wtTable.getColumnHeader(sourceColIndex, level);\n\n        if (!currentHeader) {\n          /* eslint-disable no-continue */\n          continue;\n        }\n\n        currentHeaderHeight = innerHeight(currentHeader);\n\n        if (!previousColHeaderHeight && defaultRowHeight < currentHeaderHeight || previousColHeaderHeight < currentHeaderHeight) {\n          this.wot.wtViewport.oversizedColumnHeaders[level] = currentHeaderHeight;\n        }\n\n        if (Array.isArray(columnHeaderHeightSetting)) {\n          if (columnHeaderHeightSetting[level] !== null && columnHeaderHeightSetting[level] !== void 0) {\n            this.wot.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting[level];\n          }\n        } else if (!isNaN(columnHeaderHeightSetting)) {\n          this.wot.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting;\n        }\n\n        if (this.wot.wtViewport.oversizedColumnHeaders[level] < (columnHeaderHeightSetting[level] || columnHeaderHeightSetting)) {\n          this.wot.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting[level] || columnHeaderHeightSetting; // eslint-disable-line max-len\n        }\n      }\n    }\n    /**\n     *\n     */\n\n  }, {\n    key: \"adjustColumnHeaderHeights\",\n    value: function adjustColumnHeaderHeights() {\n      var wot = this.wot;\n      var children = wot.wtTable.THEAD.childNodes;\n      var oversizedColumnHeaders = wot.wtViewport.oversizedColumnHeaders;\n      var columnHeaders = wot.getSetting('columnHeaders');\n\n      for (var i = 0, len = columnHeaders.length; i < len; i++) {\n        if (oversizedColumnHeaders[i]) {\n          if (!children[i] || children[i].childNodes.length === 0) {\n            return;\n          }\n\n          children[i].childNodes[0].style.height = \"\".concat(oversizedColumnHeaders[i], \"px\");\n        }\n      }\n    }\n    /**\n     * Resets cache of row heights. The cache should be cached for each render cycle in a case\n     * when new cell values have content which increases/decreases cell height.\n     */\n\n  }, {\n    key: \"resetOversizedRows\",\n    value: function resetOversizedRows() {\n      var wot = this.wot;\n\n      if (!this.isMaster && !this.is(CLONE_BOTTOM)) {\n        return;\n      }\n\n      if (!wot.getSetting('externalRowCalculator')) {\n        var rowsToRender = this.getRenderedRowsCount(); // Reset the oversized row cache for rendered rows\n\n        for (var visibleRowIndex = 0; visibleRowIndex < rowsToRender; visibleRowIndex++) {\n          var sourceRow = this.rowFilter.renderedToSource(visibleRowIndex);\n\n          if (wot.wtViewport.oversizedRows && wot.wtViewport.oversizedRows[sourceRow]) {\n            wot.wtViewport.oversizedRows[sourceRow] = void 0;\n          }\n        }\n      }\n    }\n    /**\n     * @param {string} className The CSS class name to remove from the table cells.\n     */\n\n  }, {\n    key: \"removeClassFromCells\",\n    value: function removeClassFromCells(className) {\n      var nodes = this.TABLE.querySelectorAll(\".\".concat(className));\n\n      for (var i = 0, len = nodes.length; i < len; i++) {\n        removeClass(nodes[i], className);\n      }\n    }\n    /**\n     * Refresh the table selection by re-rendering Selection instances connected with that instance.\n     *\n     * @param {boolean} fastDraw If fast drawing is enabled than additionally className clearing is applied.\n     */\n\n  }, {\n    key: \"refreshSelections\",\n    value: function refreshSelections(fastDraw) {\n      var wot = this.wot;\n\n      if (!wot.selections) {\n        return;\n      }\n\n      var highlights = Array.from(wot.selections);\n      var len = highlights.length;\n\n      if (fastDraw) {\n        var classesToRemove = [];\n\n        for (var i = 0; i < len; i++) {\n          var _highlights$i$setting = highlights[i].settings,\n              highlightHeaderClassName = _highlights$i$setting.highlightHeaderClassName,\n              highlightRowClassName = _highlights$i$setting.highlightRowClassName,\n              highlightColumnClassName = _highlights$i$setting.highlightColumnClassName;\n          var classNames = highlights[i].classNames;\n          var classNamesLength = classNames.length;\n\n          for (var j = 0; j < classNamesLength; j++) {\n            if (!classesToRemove.includes(classNames[j])) {\n              classesToRemove.push(classNames[j]);\n            }\n          }\n\n          if (highlightHeaderClassName && !classesToRemove.includes(highlightHeaderClassName)) {\n            classesToRemove.push(highlightHeaderClassName);\n          }\n\n          if (highlightRowClassName && !classesToRemove.includes(highlightRowClassName)) {\n            classesToRemove.push(highlightRowClassName);\n          }\n\n          if (highlightColumnClassName && !classesToRemove.includes(highlightColumnClassName)) {\n            classesToRemove.push(highlightColumnClassName);\n          }\n        }\n\n        var additionalClassesToRemove = wot.getSetting('onBeforeRemoveCellClassNames');\n\n        if (Array.isArray(additionalClassesToRemove)) {\n          for (var _i = 0; _i < additionalClassesToRemove.length; _i++) {\n            classesToRemove.push(additionalClassesToRemove[_i]);\n          }\n        }\n\n        var classesToRemoveLength = classesToRemove.length;\n\n        for (var _i2 = 0; _i2 < classesToRemoveLength; _i2++) {\n          // there was no rerender, so we need to remove classNames by ourselves\n          this.removeClassFromCells(classesToRemove[_i2]);\n        }\n      }\n\n      for (var _i3 = 0; _i3 < len; _i3++) {\n        highlights[_i3].draw(wot, fastDraw);\n      }\n    }\n    /**\n     * Get cell element at coords.\n     * Negative coords.row or coords.col are used to retrieve header cells. If there are multiple header levels, the\n     * negative value corresponds to the distance from the working area. For example, when there are 3 levels of column\n     * headers, coords.col=-1 corresponds to the most inner header element, while coords.col=-3 corresponds to the\n     * outmost header element.\n     *\n     * In case an element for the coords is not rendered, the method returns an error code.\n     * To produce the error code, the input parameters are validated in the order in which they\n     * are given. Thus, if both the row and the column coords are out of the rendered bounds,\n     * the method returns the error code for the row.\n     *\n     * @param {CellCoords} coords The cell coordinates.\n     * @returns {HTMLElement|number} HTMLElement on success or Number one of the exit codes on error:\n     *  -1 row before viewport\n     *  -2 row after viewport\n     *  -3 column before viewport\n     *  -4 column after viewport.\n     */\n\n  }, {\n    key: \"getCell\",\n    value: function getCell(coords) {\n      var row = coords.row;\n      var column = coords.col;\n      var hookResult = this.wot.getSetting('onModifyGetCellCoords', row, column);\n\n      if (hookResult && Array.isArray(hookResult)) {\n        var _hookResult = _slicedToArray(hookResult, 2);\n\n        row = _hookResult[0];\n        column = _hookResult[1];\n      }\n\n      if (this.isRowBeforeRenderedRows(row)) {\n        // row before rendered rows\n        return -1;\n      } else if (this.isRowAfterRenderedRows(row)) {\n        // row after rendered rows\n        return -2;\n      } else if (this.isColumnBeforeRenderedColumns(column)) {\n        // column before rendered columns\n        return -3;\n      } else if (this.isColumnAfterRenderedColumns(column)) {\n        // column after rendered columns\n        return -4;\n      }\n\n      var TR;\n\n      if (row < 0) {\n        TR = this.THEAD.childNodes[this.rowFilter.sourceRowToVisibleColHeadedRow(row)];\n      } else {\n        TR = this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];\n      }\n\n      if (!TR && row >= 0) {\n        throw new Error('TR was expected to be rendered but is not');\n      }\n\n      var TD = TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(column)];\n\n      if (!TD && column >= 0) {\n        throw new Error('TD or TH was expected to be rendered but is not');\n      }\n\n      return TD;\n    }\n    /**\n     * GetColumnHeader.\n     *\n     * @param {number} col Column index.\n     * @param {number} [level=0] Header level (0 = most distant to the table).\n     * @returns {object} HTMLElement on success or undefined on error.\n     */\n\n  }, {\n    key: \"getColumnHeader\",\n    value: function getColumnHeader(col) {\n      var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var TR = this.THEAD.childNodes[level];\n      return TR === null || TR === void 0 ? void 0 : TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(col)];\n    }\n    /**\n     * Gets all columns headers (TH elements) from the table.\n     *\n     * @param {number} column A source column index.\n     * @returns {HTMLTableCellElement[]}\n     */\n\n  }, {\n    key: \"getColumnHeaders\",\n    value: function getColumnHeaders(column) {\n      var THs = [];\n      var visibleColumn = this.columnFilter.sourceColumnToVisibleRowHeadedColumn(column);\n      this.THEAD.childNodes.forEach(function (TR) {\n        var TH = TR.childNodes[visibleColumn];\n\n        if (TH) {\n          THs.push(TH);\n        }\n      });\n      return THs;\n    }\n    /**\n     * GetRowHeader.\n     *\n     * @param {number} row Row index.\n     * @param {number} [level=0] Header level (0 = most distant to the table).\n     * @returns {HTMLElement} HTMLElement on success or Number one of the exit codes on error: `null table doesn't have row headers`.\n     */\n\n  }, {\n    key: \"getRowHeader\",\n    value: function getRowHeader(row) {\n      var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n      if (this.columnFilter.sourceColumnToVisibleRowHeadedColumn(0) === 0) {\n        return;\n      }\n\n      var rowHeadersCount = this.wot.getSetting('rowHeaders').length;\n\n      if (level >= rowHeadersCount) {\n        return;\n      }\n\n      var TR = this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];\n      return TR === null || TR === void 0 ? void 0 : TR.childNodes[level];\n    }\n    /**\n     * Gets all rows headers (TH elements) from the table.\n     *\n     * @param {number} row A source row index.\n     * @returns {HTMLTableCellElement[]}\n     */\n\n  }, {\n    key: \"getRowHeaders\",\n    value: function getRowHeaders(row) {\n      if (this.columnFilter.sourceColumnToVisibleRowHeadedColumn(0) === 0) {\n        return [];\n      }\n\n      var THs = [];\n      var rowHeadersCount = this.wot.getSetting('rowHeaders').length;\n\n      for (var renderedRowIndex = 0; renderedRowIndex < rowHeadersCount; renderedRowIndex++) {\n        var TR = this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];\n        var TH = TR === null || TR === void 0 ? void 0 : TR.childNodes[renderedRowIndex];\n\n        if (TH) {\n          THs.push(TH);\n        }\n      }\n\n      return THs;\n    }\n    /**\n     * Returns cell coords object for a given TD (or a child element of a TD element).\n     *\n     * @param {HTMLTableCellElement} TD A cell DOM element (or a child of one).\n     * @returns {CellCoords|null} The coordinates of the provided TD element (or the closest TD element) or null, if the provided element is not applicable.\n     */\n\n  }, {\n    key: \"getCoords\",\n    value: function getCoords(TD) {\n      var cellElement = TD;\n\n      if (cellElement.nodeName !== 'TD' && cellElement.nodeName !== 'TH') {\n        cellElement = closest(cellElement, ['TD', 'TH']);\n      }\n\n      if (cellElement === null) {\n        return null;\n      }\n\n      var TR = cellElement.parentNode;\n      var CONTAINER = TR.parentNode;\n      var row = index(TR);\n      var col = cellElement.cellIndex;\n\n      if (overlayContainsElement(CLONE_TOP_LEFT_CORNER, cellElement, this.wtRootElement) || overlayContainsElement(CLONE_TOP, cellElement, this.wtRootElement)) {\n        if (CONTAINER.nodeName === 'THEAD') {\n          row -= CONTAINER.childNodes.length;\n        }\n      } else if (overlayContainsElement(CLONE_BOTTOM_LEFT_CORNER, cellElement, this.wtRootElement) || overlayContainsElement(CLONE_BOTTOM, cellElement, this.wtRootElement)) {\n        var totalRows = this.wot.getSetting('totalRows');\n        row = totalRows - CONTAINER.childNodes.length + row;\n      } else if (CONTAINER === this.THEAD) {\n        row = this.rowFilter.visibleColHeadedRowToSourceRow(row);\n      } else {\n        row = this.rowFilter.renderedToSource(row);\n      }\n\n      if (overlayContainsElement(CLONE_TOP_LEFT_CORNER, cellElement, this.wtRootElement) || overlayContainsElement(CLONE_LEFT, cellElement, this.wtRootElement) || overlayContainsElement(CLONE_BOTTOM_LEFT_CORNER, cellElement, this.wtRootElement)) {\n        col = this.columnFilter.offsettedTH(col);\n      } else {\n        col = this.columnFilter.visibleRowHeadedColumnToSourceColumn(col);\n      }\n\n      return new CellCoords(row, col);\n    }\n    /**\n     * Check if any of the rendered rows is higher than expected, and if so, cache them.\n     */\n\n  }, {\n    key: \"markOversizedRows\",\n    value: function markOversizedRows() {\n      if (this.wot.getSetting('externalRowCalculator')) {\n        return;\n      }\n\n      var rowCount = this.TBODY.childNodes.length;\n      var expectedTableHeight = rowCount * this.wot.wtSettings.settings.defaultRowHeight;\n      var actualTableHeight = innerHeight(this.TBODY) - 1;\n      var previousRowHeight;\n      var rowInnerHeight;\n      var sourceRowIndex;\n      var currentTr;\n      var rowHeader;\n\n      if (expectedTableHeight === actualTableHeight && !this.wot.getSetting('fixedRowsBottom')) {\n        // If the actual table height equals rowCount * default single row height, no row is oversized -> no need to iterate over them\n        return;\n      }\n\n      while (rowCount) {\n        rowCount -= 1;\n        sourceRowIndex = this.rowFilter.renderedToSource(rowCount);\n        previousRowHeight = this.getRowHeight(sourceRowIndex);\n        currentTr = this.getTrForRow(sourceRowIndex);\n        rowHeader = currentTr.querySelector('th');\n\n        if (rowHeader) {\n          rowInnerHeight = innerHeight(rowHeader);\n        } else {\n          rowInnerHeight = innerHeight(currentTr) - 1;\n        }\n\n        if (!previousRowHeight && this.wot.wtSettings.settings.defaultRowHeight < rowInnerHeight || previousRowHeight < rowInnerHeight) {\n          rowInnerHeight += 1;\n          this.wot.wtViewport.oversizedRows[sourceRowIndex] = rowInnerHeight;\n        }\n      }\n    }\n    /**\n     * @param {number} row The visual row index.\n     * @returns {HTMLTableElement}\n     */\n\n  }, {\n    key: \"getTrForRow\",\n    value: function getTrForRow(row) {\n      return this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];\n    }\n    /**\n     * Checks if the column index (negative value from -1 to N) is rendered.\n     *\n     * @param {number} column The column index (negative value from -1 to N).\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isColumnHeaderRendered\",\n    value: function isColumnHeaderRendered(column) {\n      if (column >= 0) {\n        return false;\n      }\n\n      var rowHeaders = this.wot.getSetting('rowHeaders');\n      var rowHeadersCount = rowHeaders.length;\n      return Math.abs(column) <= rowHeadersCount;\n    }\n    /**\n     * Checks if the row index (negative value from -1 to N) is rendered.\n     *\n     * @param {number} row The row index (negative value from -1 to N).\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isRowHeaderRendered\",\n    value: function isRowHeaderRendered(row) {\n      if (row >= 0) {\n        return false;\n      }\n\n      var columnHeaders = this.wot.getSetting('columnHeaders');\n      var columnHeadersCount = columnHeaders.length;\n      return Math.abs(row) <= columnHeadersCount;\n    }\n    /* eslint-disable jsdoc/require-description-complete-sentence */\n\n    /**\n     * Check if the given row index is lower than the index of the first row that\n     * is currently rendered and return TRUE in that case, or FALSE otherwise.\n     *\n     * Negative row index is used to check the columns' headers.\n     *\n     *  Headers\n     *           +--------------+                                     │\n     *       -3  │    │    │    │                                     │\n     *           +--------------+                                     │\n     *       -2  │    │    │    │                                     │ TRUE\n     *           +--------------+                                     │\n     *       -1  │    │    │    │                                     │\n     *  Cells  +==================+                                   │\n     *        0  ┇    ┇    ┇    ┇ <--- For fixedRowsTop: 1            │\n     *           +--------------+      the master overlay do       ---+ first rendered row (index 1)\n     *        1  │ A2 │ B2 │ C2 │      not render the first row.      │\n     *           +--------------+                                     │ FALSE\n     *        2  │ A3 │ B3 │ C3 │                                     │\n     *           +--------------+                                  ---+ last rendered row\n     *                                                                │\n     *                                                                │ FALSE\n     *\n     * @param {number} row The visual row index.\n     * @memberof Table#\n     * @function isRowBeforeRenderedRows\n     * @returns {boolean}\n     */\n\n    /* eslint-enable jsdoc/require-description-complete-sentence */\n\n  }, {\n    key: \"isRowBeforeRenderedRows\",\n    value: function isRowBeforeRenderedRows(row) {\n      var first = this.getFirstRenderedRow(); // Check the headers only in case when the first rendered row is -1 or 0.\n      // This is an indication that the overlay is placed on the most top position.\n\n      if (row < 0 && first <= 0) {\n        return !this.isRowHeaderRendered(row);\n      }\n\n      return row < first;\n    }\n    /* eslint-disable jsdoc/require-description-complete-sentence */\n\n    /**\n     * Check if the given column index is greater than the index of the last column that\n     * is currently rendered and return TRUE in that case, or FALSE otherwise.\n     *\n     * The negative row index is used to check the columns' headers. However,\n     * keep in mind that for negative indexes, the method always returns FALSE as\n     * it is not possible to render headers partially. The \"after\" index can not be\n     * lower than -1.\n     *\n     *  Headers\n     *           +--------------+                                     │\n     *       -3  │    │    │    │                                     │\n     *           +--------------+                                     │\n     *       -2  │    │    │    │                                     │ FALSE\n     *           +--------------+                                     │\n     *       -1  │    │    │    │                                     │\n     *  Cells  +==================+                                   │\n     *        0  ┇    ┇    ┇    ┇ <--- For fixedRowsTop: 1            │\n     *           +--------------+      the master overlay do       ---+ first rendered row (index 1)\n     *        1  │ A2 │ B2 │ C2 │      not render the first rows      │\n     *           +--------------+                                     │ FALSE\n     *        2  │ A3 │ B3 │ C3 │                                     │\n     *           +--------------+                                  ---+ last rendered row\n     *                                                                │\n     *                                                                │ TRUE\n     *\n     * @param {number} row The visual row index.\n     * @memberof Table#\n     * @function isRowAfterRenderedRows\n     * @returns {boolean}\n     */\n\n    /* eslint-enable jsdoc/require-description-complete-sentence */\n\n  }, {\n    key: \"isRowAfterRenderedRows\",\n    value: function isRowAfterRenderedRows(row) {\n      return row > this.getLastRenderedRow();\n    }\n    /* eslint-disable jsdoc/require-description-complete-sentence */\n\n    /**\n     * Check if the given column index is lower than the index of the first column that\n     * is currently rendered and return TRUE in that case, or FALSE otherwise.\n     *\n     * Negative column index is used to check the rows' headers.\n     *\n     *                            For fixedColumnsLeft: 1 the master overlay\n     *                            do not render this first columns.\n     *  Headers    -3   -2   -1    |\n     *           +----+----+----║┄ ┄ +------+------+\n     *           │    │    │    ║    │  B1  │  C1  │\n     *           +--------------║┄ ┄ --------------│\n     *           │    │    │    ║    │  B2  │  C2  │\n     *           +--------------║┄ ┄ --------------│\n     *           │    │    │    ║    │  B3  │  C3  │\n     *           +----+----+----║┄ ┄ +------+------+\n     *                               ╷             ╷\n     *      -------------------------+-------------+---------------->\n     *          TRUE             first    FALSE   last         FALSE\n     *                           rendered         rendered\n     *                           column           column\n     *\n     * @param {number} column The visual column index.\n     * @memberof Table#\n     * @function isColumnBeforeRenderedColumns\n     * @returns {boolean}\n     */\n\n    /* eslint-enable jsdoc/require-description-complete-sentence */\n\n  }, {\n    key: \"isColumnBeforeRenderedColumns\",\n    value: function isColumnBeforeRenderedColumns(column) {\n      var first = this.getFirstRenderedColumn(); // Check the headers only in case when the first rendered column is -1 or 0.\n      // This is an indication that the overlay is placed on the most left position.\n\n      if (column < 0 && first <= 0) {\n        return !this.isColumnHeaderRendered(column);\n      }\n\n      return column < first;\n    }\n    /* eslint-disable jsdoc/require-description-complete-sentence */\n\n    /**\n     * Check if the given column index is greater than the index of the last column that\n     * is currently rendered and return TRUE in that case, or FALSE otherwise.\n     *\n     * The negative column index is used to check the rows' headers. However,\n     * keep in mind that for negative indexes, the method always returns FALSE as\n     * it is not possible to render headers partially. The \"after\" index can not be\n     * lower than -1.\n     *\n     *                            For fixedColumnsLeft: 1 the master overlay\n     *                            do not render this first columns.\n     *  Headers    -3   -2   -1    |\n     *           +----+----+----║┄ ┄ +------+------+\n     *           │    │    │    ║    │  B1  │  C1  │\n     *           +--------------║┄ ┄ --------------│\n     *           │    │    │    ║    │  B2  │  C2  │\n     *           +--------------║┄ ┄ --------------│\n     *           │    │    │    ║    │  B3  │  C3  │\n     *           +----+----+----║┄ ┄ +------+------+\n     *                               ╷             ╷\n     *      -------------------------+-------------+---------------->\n     *          FALSE             first    FALSE   last         TRUE\n     *                           rendered         rendered\n     *                           column           column\n     *\n     * @param {number} column The visual column index.\n     * @memberof Table#\n     * @function isColumnAfterRenderedColumns\n     * @returns {boolean}\n     */\n\n    /* eslint-enable jsdoc/require-description-complete-sentence */\n\n  }, {\n    key: \"isColumnAfterRenderedColumns\",\n    value: function isColumnAfterRenderedColumns(column) {\n      return this.columnFilter && column > this.getLastRenderedColumn();\n    }\n  }, {\n    key: \"isColumnAfterViewport\",\n    value: function isColumnAfterViewport(column) {\n      return this.columnFilter && column > this.getLastVisibleColumn();\n    }\n  }, {\n    key: \"isRowAfterViewport\",\n    value: function isRowAfterViewport(row) {\n      return this.rowFilter && row > this.getLastVisibleRow();\n    }\n  }, {\n    key: \"isColumnBeforeViewport\",\n    value: function isColumnBeforeViewport(column) {\n      return this.columnFilter && this.columnFilter.sourceToRendered(column) < 0 && column >= 0;\n    }\n  }, {\n    key: \"isLastRowFullyVisible\",\n    value: function isLastRowFullyVisible() {\n      return this.getLastVisibleRow() === this.getLastRenderedRow();\n    }\n  }, {\n    key: \"isLastColumnFullyVisible\",\n    value: function isLastColumnFullyVisible() {\n      return this.getLastVisibleColumn() === this.getLastRenderedColumn();\n    }\n  }, {\n    key: \"allRowsInViewport\",\n    value: function allRowsInViewport() {\n      return this.wot.getSetting('totalRows') === this.getVisibleRowsCount();\n    }\n  }, {\n    key: \"allColumnsInViewport\",\n    value: function allColumnsInViewport() {\n      return this.wot.getSetting('totalColumns') === this.getVisibleColumnsCount();\n    }\n    /**\n     * Checks if any of the row's cells content exceeds its initial height, and if so, returns the oversized height.\n     *\n     * @param {number} sourceRow The physical row index.\n     * @returns {number}\n     */\n\n  }, {\n    key: \"getRowHeight\",\n    value: function getRowHeight(sourceRow) {\n      return this.rowUtils.getHeight(sourceRow);\n    }\n    /**\n     * @param {number} level The column level.\n     * @returns {number}\n     */\n\n  }, {\n    key: \"getColumnHeaderHeight\",\n    value: function getColumnHeaderHeight(level) {\n      return this.columnUtils.getHeaderHeight(level);\n    }\n    /**\n     * @param {number} sourceColumn The physical column index.\n     * @returns {number}\n     */\n\n  }, {\n    key: \"getColumnWidth\",\n    value: function getColumnWidth(sourceColumn) {\n      return this.columnUtils.getWidth(sourceColumn);\n    }\n    /**\n     * @param {number} sourceColumn The physical column index.\n     * @returns {number}\n     */\n\n  }, {\n    key: \"getStretchedColumnWidth\",\n    value: function getStretchedColumnWidth(sourceColumn) {\n      return this.columnUtils.getStretchedColumnWidth(sourceColumn);\n    }\n    /**\n     * Checks if the table has defined size. It returns `true` when the table has width and height\n     * set bigger than `0px`.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"hasDefinedSize\",\n    value: function hasDefinedSize() {\n      return this.hasTableHeight && this.hasTableWidth;\n    }\n    /**\n     * Checks if the table is visible. It returns `true` when the holder element (or its parents)\n     * has CSS 'display' property different than 'none'.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isVisible\",\n    value: function isVisible() {\n      return _isVisible(this.TABLE);\n    }\n    /**\n     * Modify row header widths provided by user in class contructor.\n     *\n     * @private\n     * @param {Function} rowHeaderWidthFactory The function which can provide default width values for rows..\n     * @returns {number}\n     */\n\n  }, {\n    key: \"_modifyRowHeaderWidth\",\n    value: function _modifyRowHeaderWidth(rowHeaderWidthFactory) {\n      var widths = isFunction(rowHeaderWidthFactory) ? rowHeaderWidthFactory() : null;\n\n      if (Array.isArray(widths)) {\n        widths = _toConsumableArray(widths);\n        widths[widths.length - 1] = this._correctRowHeaderWidth(widths[widths.length - 1]);\n      } else {\n        widths = this._correctRowHeaderWidth(widths);\n      }\n\n      return widths;\n    }\n    /**\n     * Correct row header width if necessary.\n     *\n     * @private\n     * @param {number} width The width to process.\n     * @returns {number}\n     */\n\n  }, {\n    key: \"_correctRowHeaderWidth\",\n    value: function _correctRowHeaderWidth(width) {\n      var rowHeaderWidth = width;\n\n      if (typeof width !== 'number') {\n        rowHeaderWidth = this.wot.getSetting('defaultColumnWidth');\n      }\n\n      if (this.correctHeaderWidth) {\n        rowHeaderWidth += 1;\n      }\n\n      return rowHeaderWidth;\n    }\n  }]);\n\n  return Table;\n}();\n\nexport default Table;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}