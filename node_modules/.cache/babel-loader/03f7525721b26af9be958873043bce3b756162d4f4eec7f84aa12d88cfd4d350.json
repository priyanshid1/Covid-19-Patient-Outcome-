{"ast":null,"code":"import { arrayEach } from \"../../../../helpers/array.mjs\";\nimport { collapseNode } from \"./collapse.mjs\";\nimport { getFirstChildProperty, isNodeReflectsFirstChildColspan, traverseHiddenNodeColumnIndexes } from \"./utils/tree.mjs\";\n/**\n * Expanding a node is a process where the processing node is expanded to\n * its original colspan width. To restore an original state of all node\n * children on the right, the modified nodes are replaced with the cloned\n * nodes (they were cloned while collapsing).\n *\n * @param {TreeNode} nodeToProcess A tree node to process.\n * @returns {object} Returns an object with properties:\n *                    - rollbackModification: The function that rollbacks\n *                      the tree to the previous state.\n *                    - affectedColumns: The list of the visual column\n *                      indexes which are affected. That list is passed\n *                      to the hiddens column logic.\n *                    - colspanCompensation: The number of colspan by\n *                      which the processed node colspan was increased.\n */\nexport function expandNode(nodeToProcess) {\n  var nodeData = nodeToProcess.data,\n    nodeChilds = nodeToProcess.childs;\n  if (!nodeData.isCollapsed || nodeData.isHidden || nodeData.origColspan <= 1) {\n    return {\n      rollbackModification: function rollbackModification() {},\n      affectedColumns: [],\n      colspanCompensation: 0\n    };\n  }\n  var isNodeReflected = isNodeReflectsFirstChildColspan(nodeToProcess);\n  if (isNodeReflected) {\n    return expandNode(nodeChilds[0]);\n  }\n  nodeData.isCollapsed = false;\n  var allLeavesExceptMostLeft = nodeChilds.slice(1);\n  var affectedColumns = new Set();\n  var colspanCompensation = 0;\n  if (allLeavesExceptMostLeft.length > 0) {\n    arrayEach(allLeavesExceptMostLeft, function (node) {\n      // Restore original state of the collapsed headers.\n      node.replaceTreeWith(node.data.clonedTree);\n      node.data.clonedTree = null;\n      var leafData = node.data;\n\n      // Calculate by how many colspan it needs to increase the headings to match them to\n      // the colspan width of all its children.\n      colspanCompensation += leafData.colspan;\n      traverseHiddenNodeColumnIndexes(node, function (gridColumnIndex) {\n        affectedColumns.add(gridColumnIndex);\n      });\n    });\n  } else {\n    var colspan = nodeData.colspan,\n      origColspan = nodeData.origColspan,\n      columnIndex = nodeData.columnIndex;\n\n    // In a case when the node doesn't have any children restore the colspan width to\n    // its original state.\n    colspanCompensation = origColspan - colspan;\n\n    // Add column to \"affected\" started from 1. The header without children can not be\n    // collapsed so the first column is already visible and we shouldn't touch it.\n    for (var i = 1; i < origColspan; i++) {\n      affectedColumns.add(columnIndex + i);\n    }\n  }\n  nodeToProcess.walkUp(function (node) {\n    var data = node.data;\n    data.colspan += colspanCompensation;\n    if (data.colspan >= data.origColspan) {\n      data.colspan = data.origColspan;\n      data.isCollapsed = false;\n    } else if (isNodeReflectsFirstChildColspan(node)) {\n      data.isCollapsed = getFirstChildProperty(node, 'isCollapsed');\n    }\n  });\n  return {\n    rollbackModification: function rollbackModification() {\n      return collapseNode(nodeToProcess);\n    },\n    affectedColumns: Array.from(affectedColumns),\n    colspanCompensation: colspanCompensation\n  };\n}","map":{"version":3,"names":["arrayEach","collapseNode","getFirstChildProperty","isNodeReflectsFirstChildColspan","traverseHiddenNodeColumnIndexes","expandNode","nodeToProcess","nodeData","data","nodeChilds","childs","isCollapsed","isHidden","origColspan","rollbackModification","affectedColumns","colspanCompensation","isNodeReflected","allLeavesExceptMostLeft","slice","Set","length","node","replaceTreeWith","clonedTree","leafData","colspan","gridColumnIndex","add","columnIndex","i","walkUp","Array","from"],"sources":["/Users/priyadeliwala/node_modules/handsontable/plugins/nestedHeaders/stateManager/nodeModifiers/expand.mjs"],"sourcesContent":["import \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nimport { arrayEach } from \"../../../../helpers/array.mjs\";\nimport { collapseNode } from \"./collapse.mjs\";\nimport { getFirstChildProperty, isNodeReflectsFirstChildColspan, traverseHiddenNodeColumnIndexes } from \"./utils/tree.mjs\";\n/**\n * Expanding a node is a process where the processing node is expanded to\n * its original colspan width. To restore an original state of all node\n * children on the right, the modified nodes are replaced with the cloned\n * nodes (they were cloned while collapsing).\n *\n * @param {TreeNode} nodeToProcess A tree node to process.\n * @returns {object} Returns an object with properties:\n *                    - rollbackModification: The function that rollbacks\n *                      the tree to the previous state.\n *                    - affectedColumns: The list of the visual column\n *                      indexes which are affected. That list is passed\n *                      to the hiddens column logic.\n *                    - colspanCompensation: The number of colspan by\n *                      which the processed node colspan was increased.\n */\nexport function expandNode(nodeToProcess) {\n  const {\n    data: nodeData,\n    childs: nodeChilds\n  } = nodeToProcess;\n  if (!nodeData.isCollapsed || nodeData.isHidden || nodeData.origColspan <= 1) {\n    return {\n      rollbackModification: () => {},\n      affectedColumns: [],\n      colspanCompensation: 0\n    };\n  }\n  const isNodeReflected = isNodeReflectsFirstChildColspan(nodeToProcess);\n  if (isNodeReflected) {\n    return expandNode(nodeChilds[0]);\n  }\n  nodeData.isCollapsed = false;\n  const allLeavesExceptMostLeft = nodeChilds.slice(1);\n  const affectedColumns = new Set();\n  let colspanCompensation = 0;\n  if (allLeavesExceptMostLeft.length > 0) {\n    arrayEach(allLeavesExceptMostLeft, node => {\n      // Restore original state of the collapsed headers.\n      node.replaceTreeWith(node.data.clonedTree);\n      node.data.clonedTree = null;\n      const leafData = node.data;\n\n      // Calculate by how many colspan it needs to increase the headings to match them to\n      // the colspan width of all its children.\n      colspanCompensation += leafData.colspan;\n      traverseHiddenNodeColumnIndexes(node, gridColumnIndex => {\n        affectedColumns.add(gridColumnIndex);\n      });\n    });\n  } else {\n    const {\n      colspan,\n      origColspan,\n      columnIndex\n    } = nodeData;\n\n    // In a case when the node doesn't have any children restore the colspan width to\n    // its original state.\n    colspanCompensation = origColspan - colspan;\n\n    // Add column to \"affected\" started from 1. The header without children can not be\n    // collapsed so the first column is already visible and we shouldn't touch it.\n    for (let i = 1; i < origColspan; i++) {\n      affectedColumns.add(columnIndex + i);\n    }\n  }\n  nodeToProcess.walkUp(node => {\n    const {\n      data\n    } = node;\n    data.colspan += colspanCompensation;\n    if (data.colspan >= data.origColspan) {\n      data.colspan = data.origColspan;\n      data.isCollapsed = false;\n    } else if (isNodeReflectsFirstChildColspan(node)) {\n      data.isCollapsed = getFirstChildProperty(node, 'isCollapsed');\n    }\n  });\n  return {\n    rollbackModification: () => collapseNode(nodeToProcess),\n    affectedColumns: Array.from(affectedColumns),\n    colspanCompensation\n  };\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}