{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nimport { arrayEach } from \"../../helpers/array.mjs\";\nimport { warn } from \"../../helpers/console.mjs\";\n/**\n * Class used to make all endpoint-related operations.\n *\n * @private\n * @class Endpoints\n */\n\nvar Endpoints = /*#__PURE__*/function () {\n  function Endpoints(plugin, settings) {\n    _classCallCheck(this, Endpoints);\n\n    /**\n     * The main plugin instance.\n     */\n    this.plugin = plugin;\n    /**\n     * Handsontable instance.\n     *\n     * @type {object}\n     */\n\n    this.hot = this.plugin.hot;\n    /**\n     * Array of declared plugin endpoints (calculation destination points).\n     *\n     * @type {Array}\n     * @default {Array} Empty array.\n     */\n\n    this.endpoints = [];\n    /**\n     * The plugin settings, taken from Handsontable configuration.\n     *\n     * @type {object|Function}\n     * @default null\n     */\n\n    this.settings = settings;\n    /**\n     * Settings type. Can be either 'array' or 'function.\n     *\n     * @type {string}\n     * @default {'array'}\n     */\n\n    this.settingsType = 'array';\n    /**\n     * The current endpoint (calculation destination point) in question.\n     *\n     * @type {object}\n     * @default null\n     */\n\n    this.currentEndpoint = null;\n    /**\n     * Array containing a list of changes to be applied.\n     *\n     * @private\n     * @type {Array}\n     * @default {[]}\n     */\n\n    this.cellsToSetCache = [];\n  }\n  /**\n   * Get a single endpoint object.\n   *\n   * @param {number} index Index of the endpoint.\n   * @returns {object}\n   */\n\n  _createClass(Endpoints, [{\n    key: \"getEndpoint\",\n    value: function getEndpoint(index) {\n      if (this.settingsType === 'function') {\n        return this.fillMissingEndpointData(this.settings)[index];\n      }\n      return this.endpoints[index];\n    }\n    /**\n     * Get an array with all the endpoints.\n     *\n     * @returns {Array}\n     */\n  }, {\n    key: \"getAllEndpoints\",\n    value: function getAllEndpoints() {\n      if (this.settingsType === 'function') {\n        return this.fillMissingEndpointData(this.settings);\n      }\n      return this.endpoints;\n    }\n    /**\n     * Used to fill the blanks in the endpoint data provided by a settings function.\n     *\n     * @private\n     * @param {Function} func Function provided in the HOT settings.\n     * @returns {Array} An array of endpoints.\n     */\n  }, {\n    key: \"fillMissingEndpointData\",\n    value: function fillMissingEndpointData(func) {\n      return this.parseSettings(func.call(this));\n    }\n    /**\n     * Parse plugin's settings.\n     *\n     * @param {Array} settings The settings array.\n     * @returns {object[]}\n     */\n  }, {\n    key: \"parseSettings\",\n    value: function parseSettings(settings) {\n      var _this = this;\n      var endpointsArray = [];\n      var settingsArray = settings;\n      if (!settingsArray && typeof this.settings === 'function') {\n        this.settingsType = 'function';\n        return;\n      }\n      if (!settingsArray) {\n        settingsArray = this.settings;\n      }\n      arrayEach(settingsArray, function (val) {\n        var newEndpoint = {};\n        _this.assignSetting(val, newEndpoint, 'ranges', [[0, _this.hot.countRows() - 1]]);\n        _this.assignSetting(val, newEndpoint, 'reversedRowCoords', false);\n        _this.assignSetting(val, newEndpoint, 'destinationRow', new Error(\"\\n        You must provide a destination row for the Column Summary plugin in order to work properly!\\n      \"));\n        _this.assignSetting(val, newEndpoint, 'destinationColumn', new Error(\"\\n        You must provide a destination column for the Column Summary plugin in order to work properly!\\n      \"));\n        _this.assignSetting(val, newEndpoint, 'sourceColumn', val.destinationColumn);\n        _this.assignSetting(val, newEndpoint, 'type', 'sum');\n        _this.assignSetting(val, newEndpoint, 'forceNumeric', false);\n        _this.assignSetting(val, newEndpoint, 'suppressDataTypeErrors', true);\n        _this.assignSetting(val, newEndpoint, 'suppressDataTypeErrors', true);\n        _this.assignSetting(val, newEndpoint, 'customFunction', null);\n        _this.assignSetting(val, newEndpoint, 'readOnly', true);\n        _this.assignSetting(val, newEndpoint, 'roundFloat', false);\n        endpointsArray.push(newEndpoint);\n      });\n      return endpointsArray;\n    }\n    /**\n     * Setter for the internal setting objects.\n     *\n     * @param {object} settings Object with the settings.\n     * @param {object} endpoint Contains information about the endpoint for the the calculation.\n     * @param {string} name Settings name.\n     * @param {object} defaultValue Default value for the settings.\n     */\n  }, {\n    key: \"assignSetting\",\n    value: function assignSetting(settings, endpoint, name, defaultValue) {\n      if (name === 'ranges' && settings[name] === void 0) {\n        endpoint[name] = defaultValue;\n        return;\n      } else if (name === 'ranges' && settings[name].length === 0) {\n        return;\n      }\n      if (settings[name] === void 0) {\n        if (defaultValue instanceof Error) {\n          throw defaultValue;\n        }\n        endpoint[name] = defaultValue;\n      } else {\n        /* eslint-disable no-lonely-if */\n        if (name === 'destinationRow' && endpoint.reversedRowCoords) {\n          endpoint[name] = this.hot.countRows() - settings[name] - 1;\n        } else {\n          endpoint[name] = settings[name];\n        }\n      }\n    }\n    /**\n     * Resets the endpoint setup before the structure alteration (like inserting or removing rows/columns). Used for settings provided as a function.\n     *\n     * @private\n     * @param {string} action Type of the action performed.\n     * @param {number} index Row/column index.\n     * @param {number} number Number of rows/columns added/removed.\n     */\n  }, {\n    key: \"resetSetupBeforeStructureAlteration\",\n    value: function resetSetupBeforeStructureAlteration(action, index, number) {\n      if (this.settingsType !== 'function') {\n        return;\n      }\n      var type = action.indexOf('row') > -1 ? 'row' : 'col';\n      var endpoints = this.getAllEndpoints();\n      arrayEach(endpoints, function (val) {\n        if (type === 'row' && val.destinationRow >= index) {\n          if (action === 'insert_row') {\n            val.alterRowOffset = number;\n          } else if (action === 'remove_row') {\n            val.alterRowOffset = -1 * number;\n          }\n        }\n        if (type === 'col' && val.destinationColumn >= index) {\n          if (action === 'insert_col') {\n            val.alterColumnOffset = number;\n          } else if (action === 'remove_col') {\n            val.alterColumnOffset = -1 * number;\n          }\n        }\n      });\n      this.resetAllEndpoints(endpoints, false);\n    }\n    /**\n     * AfterCreateRow/afterCreateRow/afterRemoveRow/afterRemoveCol hook callback. Reset and reenables the summary functionality\n     * after changing the table structure.\n     *\n     * @private\n     * @param {string} action Type of the action performed.\n     * @param {number} index Row/column index.\n     * @param {number} number Number of rows/columns added/removed.\n     * @param {Array} [logicRows] Array of the logical indexes.\n     * @param {string} [source] Source of change.\n     * @param {boolean} [forceRefresh] `true` of the endpoints should refresh after completing the function.\n     */\n  }, {\n    key: \"resetSetupAfterStructureAlteration\",\n    value: function resetSetupAfterStructureAlteration(action, index, number, logicRows, source) {\n      var _this2 = this;\n      var forceRefresh = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n      if (this.settingsType === 'function') {\n        // We need to run it on a next avaiable hook, because the TrimRows' `afterCreateRow` hook triggers after this one,\n        // and it needs to be run to properly calculate the endpoint value.\n        var beforeViewRenderCallback = function beforeViewRenderCallback() {\n          _this2.hot.removeHook('beforeViewRender', beforeViewRenderCallback);\n          return _this2.refreshAllEndpoints();\n        };\n        this.hot.addHookOnce('beforeViewRender', beforeViewRenderCallback);\n        return;\n      }\n      var type = action.indexOf('row') > -1 ? 'row' : 'col';\n      var multiplier = action.indexOf('remove') > -1 ? -1 : 1;\n      var endpoints = this.getAllEndpoints();\n      var rowMoving = action.indexOf('move_row') === 0;\n      var placeOfAlteration = index;\n      arrayEach(endpoints, function (val) {\n        if (type === 'row' && val.destinationRow >= placeOfAlteration) {\n          val.alterRowOffset = multiplier * number;\n        }\n        if (type === 'col' && val.destinationColumn >= placeOfAlteration) {\n          val.alterColumnOffset = multiplier * number;\n        }\n      });\n      this.resetAllEndpoints(endpoints, !rowMoving);\n      if (rowMoving) {\n        arrayEach(endpoints, function (endpoint) {\n          _this2.extendEndpointRanges(endpoint, placeOfAlteration, logicRows[0], logicRows.length);\n          _this2.recreatePhysicalRanges(endpoint);\n          _this2.clearOffsetInformation(endpoint);\n        });\n      } else {\n        arrayEach(endpoints, function (endpoint) {\n          _this2.shiftEndpointCoordinates(endpoint, placeOfAlteration);\n        });\n      }\n      if (forceRefresh) {\n        this.refreshAllEndpoints();\n      }\n    }\n    /**\n     * Clear the offset information from the endpoint object.\n     *\n     * @private\n     * @param {object} endpoint And endpoint object.\n     */\n  }, {\n    key: \"clearOffsetInformation\",\n    value: function clearOffsetInformation(endpoint) {\n      endpoint.alterRowOffset = void 0;\n      endpoint.alterColumnOffset = void 0;\n    }\n    /**\n     * Extend the row ranges for the provided endpoint.\n     *\n     * @private\n     * @param {object} endpoint The endpoint object.\n     * @param {number} placeOfAlteration Index of the row where the alteration takes place.\n     * @param {number} previousPosition Previous endpoint result position.\n     * @param {number} offset Offset generated by the alteration.\n     */\n  }, {\n    key: \"extendEndpointRanges\",\n    value: function extendEndpointRanges(endpoint, placeOfAlteration, previousPosition, offset) {\n      arrayEach(endpoint.ranges, function (range) {\n        // is a range, not a single row\n        if (range[1]) {\n          if (placeOfAlteration >= range[0] && placeOfAlteration <= range[1]) {\n            if (previousPosition > range[1]) {\n              range[1] += offset;\n            } else if (previousPosition < range[0]) {\n              range[0] -= offset;\n            }\n          } else if (previousPosition >= range[0] && previousPosition <= range[1]) {\n            range[1] -= offset;\n            if (placeOfAlteration <= range[0]) {\n              range[0] += 1;\n              range[1] += 1;\n            }\n          }\n        }\n      });\n    }\n    /**\n     * Recreate the physical ranges for the provided endpoint. Used (for example) when a row gets moved and extends an existing range.\n     *\n     * @private\n     * @param {object} endpoint An endpoint object.\n     */\n  }, {\n    key: \"recreatePhysicalRanges\",\n    value: function recreatePhysicalRanges(endpoint) {\n      var _this3 = this;\n      var ranges = endpoint.ranges;\n      var newRanges = [];\n      var allIndexes = [];\n      arrayEach(ranges, function (range) {\n        var newRange = [];\n        if (range[1]) {\n          for (var i = range[0]; i <= range[1]; i++) {\n            newRange.push(_this3.hot.toPhysicalRow(i));\n          }\n        } else {\n          newRange.push(_this3.hot.toPhysicalRow(range[0]));\n        }\n        allIndexes.push(newRange);\n      });\n      arrayEach(allIndexes, function (range) {\n        var newRange = [];\n        arrayEach(range, function (coord, index) {\n          if (index === 0) {\n            newRange.push(coord);\n          } else if (range[index] !== range[index - 1] + 1) {\n            newRange.push(range[index - 1]);\n            newRanges.push(newRange);\n            newRange = [];\n            newRange.push(coord);\n          }\n          if (index === range.length - 1) {\n            newRange.push(coord);\n            newRanges.push(newRange);\n          }\n        });\n      });\n      endpoint.ranges = newRanges;\n    }\n    /**\n     * Shifts the endpoint coordinates by the defined offset.\n     *\n     * @private\n     * @param {object} endpoint Endpoint object.\n     * @param {number} offsetStartIndex Index of the performed change (if the change is located after the endpoint, nothing about the endpoint has to be changed.\n     */\n  }, {\n    key: \"shiftEndpointCoordinates\",\n    value: function shiftEndpointCoordinates(endpoint, offsetStartIndex) {\n      if (endpoint.alterRowOffset && endpoint.alterRowOffset !== 0) {\n        endpoint.destinationRow += endpoint.alterRowOffset || 0;\n        arrayEach(endpoint.ranges, function (element) {\n          arrayEach(element, function (subElement, j) {\n            if (subElement >= offsetStartIndex) {\n              element[j] += endpoint.alterRowOffset || 0;\n            }\n          });\n        });\n      } else if (endpoint.alterColumnOffset && endpoint.alterColumnOffset !== 0) {\n        endpoint.destinationColumn += endpoint.alterColumnOffset || 0;\n        endpoint.sourceColumn += endpoint.alterColumnOffset || 0;\n      }\n    }\n    /**\n     * Resets (removes) the endpoints from the table.\n     *\n     * @param {Array} [endpoints] Array containing the endpoints.\n     * @param {boolean} [useOffset=true] Use the cell offset value.\n     */\n  }, {\n    key: \"resetAllEndpoints\",\n    value: function resetAllEndpoints() {\n      var _this4 = this;\n      var endpoints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAllEndpoints();\n      var useOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var anyEndpointOutOfRange = endpoints.some(function (endpoint) {\n        var alterRowOffset = endpoint.alterRowOffset || 0;\n        var alterColOffset = endpoint.alterColumnOffset || 0;\n        if (endpoint.destinationRow + alterRowOffset >= _this4.hot.countRows() || endpoint.destinationColumn + alterColOffset >= _this4.hot.countCols()) {\n          return true;\n        }\n        return false;\n      });\n      if (anyEndpointOutOfRange) {\n        return;\n      }\n      this.cellsToSetCache = [];\n      arrayEach(endpoints, function (endpoint) {\n        _this4.resetEndpointValue(endpoint, useOffset);\n      });\n      this.hot.setDataAtCell(this.cellsToSetCache, 'ColumnSummary.reset');\n      this.cellsToSetCache = [];\n    }\n    /**\n     * Calculate and refresh all defined endpoints.\n     */\n  }, {\n    key: \"refreshAllEndpoints\",\n    value: function refreshAllEndpoints() {\n      var _this5 = this;\n      this.cellsToSetCache = [];\n      arrayEach(this.getAllEndpoints(), function (value) {\n        _this5.currentEndpoint = value;\n        _this5.plugin.calculate(value);\n        _this5.setEndpointValue(value, 'init');\n      });\n      this.currentEndpoint = null;\n      this.hot.setDataAtCell(this.cellsToSetCache, 'ColumnSummary.reset');\n      this.cellsToSetCache = [];\n    }\n    /**\n     * Calculate and refresh endpoints only in the changed columns.\n     *\n     * @param {Array} changes Array of changes from the `afterChange` hook.\n     */\n  }, {\n    key: \"refreshChangedEndpoints\",\n    value: function refreshChangedEndpoints(changes) {\n      var _this6 = this;\n      var needToRefresh = [];\n      this.cellsToSetCache = [];\n      arrayEach(changes, function (value, key, changesObj) {\n        // if nothing changed, dont update anything\n        if (\"\".concat(value[2] || '') === \"\".concat(value[3])) {\n          return;\n        }\n        arrayEach(_this6.getAllEndpoints(), function (endpoint, j) {\n          if (_this6.hot.propToCol(changesObj[key][1]) === endpoint.sourceColumn && needToRefresh.indexOf(j) === -1) {\n            needToRefresh.push(j);\n          }\n        });\n      });\n      arrayEach(needToRefresh, function (value) {\n        _this6.refreshEndpoint(_this6.getEndpoint(value));\n      });\n      this.hot.setDataAtCell(this.cellsToSetCache, 'ColumnSummary.reset');\n      this.cellsToSetCache = [];\n    }\n    /**\n     * Calculate and refresh a single endpoint.\n     *\n     * @param {object} endpoint Contains the endpoint information.\n     */\n  }, {\n    key: \"refreshEndpoint\",\n    value: function refreshEndpoint(endpoint) {\n      this.currentEndpoint = endpoint;\n      this.plugin.calculate(endpoint);\n      this.setEndpointValue(endpoint);\n      this.currentEndpoint = null;\n    }\n    /**\n     * Reset the endpoint value.\n     *\n     * @param {object} endpoint Contains the endpoint information.\n     * @param {boolean} [useOffset=true] Use the cell offset value.\n     */\n  }, {\n    key: \"resetEndpointValue\",\n    value: function resetEndpointValue(endpoint) {\n      var useOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var alterRowOffset = endpoint.alterRowOffset || 0;\n      var alterColOffset = endpoint.alterColumnOffset || 0;\n      var _ref = [this.hot.toVisualRow(endpoint.destinationRow), this.hot.toVisualColumn(endpoint.destinationColumn)],\n        visualRowIndex = _ref[0],\n        visualColumnIndex = _ref[1];\n      if (visualColumnIndex !== null && visualRowIndex !== null) {\n        // Clear the meta on the \"old\" indexes\n        var cellMeta = this.hot.getCellMeta(visualRowIndex, visualColumnIndex);\n        cellMeta.readOnly = false;\n        cellMeta.className = '';\n      }\n      this.cellsToSetCache.push([this.hot.toVisualRow(endpoint.destinationRow + (useOffset ? alterRowOffset : 0)), this.hot.toVisualColumn(endpoint.destinationColumn + (useOffset ? alterColOffset : 0)), '']);\n    }\n    /**\n     * Set the endpoint value.\n     *\n     * @param {object} endpoint Contains the endpoint information.\n     * @param {string} [source] Source of the call information.\n     * @param {boolean} [render=false] `true` if it needs to render the table afterwards.\n     */\n  }, {\n    key: \"setEndpointValue\",\n    value: function setEndpointValue(endpoint, source) {\n      var render = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      // We'll need the reversed offset values, because cellMeta will be shifted AGAIN afterwards.\n      var reverseRowOffset = -1 * endpoint.alterRowOffset || 0;\n      var reverseColOffset = -1 * endpoint.alterColumnOffset || 0;\n      var visualEndpointRowIndex = this.hot.toVisualRow(endpoint.destinationRow);\n      if (endpoint.destinationRow >= this.hot.countRows() || endpoint.destinationColumn >= this.hot.countCols()) {\n        this.throwOutOfBoundsWarning();\n        return;\n      }\n      var destinationVisualRow = this.hot.toVisualRow(endpoint.destinationRow + reverseRowOffset);\n      if (destinationVisualRow !== null) {\n        var cellMeta = this.hot.getCellMeta(destinationVisualRow, endpoint.destinationColumn + reverseColOffset);\n        if (source === 'init' || cellMeta.readOnly !== endpoint.readOnly) {\n          cellMeta.readOnly = endpoint.readOnly;\n          cellMeta.className = 'columnSummaryResult';\n        }\n      }\n      if (endpoint.roundFloat && !isNaN(endpoint.result)) {\n        endpoint.result = endpoint.result.toFixed(endpoint.roundFloat);\n      }\n      if (render) {\n        this.hot.setDataAtCell(visualEndpointRowIndex, endpoint.destinationColumn, endpoint.result, 'ColumnSummary.set');\n      } else {\n        this.cellsToSetCache.push([visualEndpointRowIndex, endpoint.destinationColumn, endpoint.result]);\n      }\n      endpoint.alterRowOffset = void 0;\n      endpoint.alterColumnOffset = void 0;\n    }\n    /**\n     * Throw an error for the calculation range being out of boundaries.\n     *\n     * @private\n     */\n  }, {\n    key: \"throwOutOfBoundsWarning\",\n    value: function throwOutOfBoundsWarning() {\n      warn('One of the Column Summary plugins\\' destination points you provided is beyond the table boundaries!');\n    }\n  }]);\n  return Endpoints;\n}();\nexport default Endpoints;","map":{"version":3,"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","arrayEach","warn","Endpoints","plugin","settings","hot","endpoints","settingsType","currentEndpoint","cellsToSetCache","value","getEndpoint","index","fillMissingEndpointData","getAllEndpoints","func","parseSettings","call","_this","endpointsArray","settingsArray","val","newEndpoint","assignSetting","countRows","Error","destinationColumn","push","endpoint","name","defaultValue","reversedRowCoords","resetSetupBeforeStructureAlteration","action","number","type","indexOf","destinationRow","alterRowOffset","alterColumnOffset","resetAllEndpoints","resetSetupAfterStructureAlteration","logicRows","source","_this2","forceRefresh","arguments","undefined","beforeViewRenderCallback","removeHook","refreshAllEndpoints","addHookOnce","multiplier","rowMoving","placeOfAlteration","extendEndpointRanges","recreatePhysicalRanges","clearOffsetInformation","shiftEndpointCoordinates","previousPosition","offset","ranges","range","_this3","newRanges","allIndexes","newRange","toPhysicalRow","coord","offsetStartIndex","element","subElement","j","sourceColumn","_this4","useOffset","anyEndpointOutOfRange","some","alterColOffset","countCols","resetEndpointValue","setDataAtCell","_this5","calculate","setEndpointValue","refreshChangedEndpoints","changes","_this6","needToRefresh","changesObj","concat","propToCol","refreshEndpoint","_ref","toVisualRow","toVisualColumn","visualRowIndex","visualColumnIndex","cellMeta","getCellMeta","readOnly","className","render","reverseRowOffset","reverseColOffset","visualEndpointRowIndex","throwOutOfBoundsWarning","destinationVisualRow","roundFloat","isNaN","result","toFixed"],"sources":["/Users/priyadeliwala/Desktop/sales-dashboard/node_modules/handsontable/plugins/columnSummary/endpoints.mjs"],"sourcesContent":["import \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.number.to-fixed.js\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nimport { arrayEach } from \"../../helpers/array.mjs\";\nimport { warn } from \"../../helpers/console.mjs\";\n/**\n * Class used to make all endpoint-related operations.\n *\n * @private\n * @class Endpoints\n */\n\nvar Endpoints = /*#__PURE__*/function () {\n  function Endpoints(plugin, settings) {\n    _classCallCheck(this, Endpoints);\n\n    /**\n     * The main plugin instance.\n     */\n    this.plugin = plugin;\n    /**\n     * Handsontable instance.\n     *\n     * @type {object}\n     */\n\n    this.hot = this.plugin.hot;\n    /**\n     * Array of declared plugin endpoints (calculation destination points).\n     *\n     * @type {Array}\n     * @default {Array} Empty array.\n     */\n\n    this.endpoints = [];\n    /**\n     * The plugin settings, taken from Handsontable configuration.\n     *\n     * @type {object|Function}\n     * @default null\n     */\n\n    this.settings = settings;\n    /**\n     * Settings type. Can be either 'array' or 'function.\n     *\n     * @type {string}\n     * @default {'array'}\n     */\n\n    this.settingsType = 'array';\n    /**\n     * The current endpoint (calculation destination point) in question.\n     *\n     * @type {object}\n     * @default null\n     */\n\n    this.currentEndpoint = null;\n    /**\n     * Array containing a list of changes to be applied.\n     *\n     * @private\n     * @type {Array}\n     * @default {[]}\n     */\n\n    this.cellsToSetCache = [];\n  }\n  /**\n   * Get a single endpoint object.\n   *\n   * @param {number} index Index of the endpoint.\n   * @returns {object}\n   */\n\n\n  _createClass(Endpoints, [{\n    key: \"getEndpoint\",\n    value: function getEndpoint(index) {\n      if (this.settingsType === 'function') {\n        return this.fillMissingEndpointData(this.settings)[index];\n      }\n\n      return this.endpoints[index];\n    }\n    /**\n     * Get an array with all the endpoints.\n     *\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"getAllEndpoints\",\n    value: function getAllEndpoints() {\n      if (this.settingsType === 'function') {\n        return this.fillMissingEndpointData(this.settings);\n      }\n\n      return this.endpoints;\n    }\n    /**\n     * Used to fill the blanks in the endpoint data provided by a settings function.\n     *\n     * @private\n     * @param {Function} func Function provided in the HOT settings.\n     * @returns {Array} An array of endpoints.\n     */\n\n  }, {\n    key: \"fillMissingEndpointData\",\n    value: function fillMissingEndpointData(func) {\n      return this.parseSettings(func.call(this));\n    }\n    /**\n     * Parse plugin's settings.\n     *\n     * @param {Array} settings The settings array.\n     * @returns {object[]}\n     */\n\n  }, {\n    key: \"parseSettings\",\n    value: function parseSettings(settings) {\n      var _this = this;\n\n      var endpointsArray = [];\n      var settingsArray = settings;\n\n      if (!settingsArray && typeof this.settings === 'function') {\n        this.settingsType = 'function';\n        return;\n      }\n\n      if (!settingsArray) {\n        settingsArray = this.settings;\n      }\n\n      arrayEach(settingsArray, function (val) {\n        var newEndpoint = {};\n\n        _this.assignSetting(val, newEndpoint, 'ranges', [[0, _this.hot.countRows() - 1]]);\n\n        _this.assignSetting(val, newEndpoint, 'reversedRowCoords', false);\n\n        _this.assignSetting(val, newEndpoint, 'destinationRow', new Error(\"\\n        You must provide a destination row for the Column Summary plugin in order to work properly!\\n      \"));\n\n        _this.assignSetting(val, newEndpoint, 'destinationColumn', new Error(\"\\n        You must provide a destination column for the Column Summary plugin in order to work properly!\\n      \"));\n\n        _this.assignSetting(val, newEndpoint, 'sourceColumn', val.destinationColumn);\n\n        _this.assignSetting(val, newEndpoint, 'type', 'sum');\n\n        _this.assignSetting(val, newEndpoint, 'forceNumeric', false);\n\n        _this.assignSetting(val, newEndpoint, 'suppressDataTypeErrors', true);\n\n        _this.assignSetting(val, newEndpoint, 'suppressDataTypeErrors', true);\n\n        _this.assignSetting(val, newEndpoint, 'customFunction', null);\n\n        _this.assignSetting(val, newEndpoint, 'readOnly', true);\n\n        _this.assignSetting(val, newEndpoint, 'roundFloat', false);\n\n        endpointsArray.push(newEndpoint);\n      });\n      return endpointsArray;\n    }\n    /**\n     * Setter for the internal setting objects.\n     *\n     * @param {object} settings Object with the settings.\n     * @param {object} endpoint Contains information about the endpoint for the the calculation.\n     * @param {string} name Settings name.\n     * @param {object} defaultValue Default value for the settings.\n     */\n\n  }, {\n    key: \"assignSetting\",\n    value: function assignSetting(settings, endpoint, name, defaultValue) {\n      if (name === 'ranges' && settings[name] === void 0) {\n        endpoint[name] = defaultValue;\n        return;\n      } else if (name === 'ranges' && settings[name].length === 0) {\n        return;\n      }\n\n      if (settings[name] === void 0) {\n        if (defaultValue instanceof Error) {\n          throw defaultValue;\n        }\n\n        endpoint[name] = defaultValue;\n      } else {\n        /* eslint-disable no-lonely-if */\n        if (name === 'destinationRow' && endpoint.reversedRowCoords) {\n          endpoint[name] = this.hot.countRows() - settings[name] - 1;\n        } else {\n          endpoint[name] = settings[name];\n        }\n      }\n    }\n    /**\n     * Resets the endpoint setup before the structure alteration (like inserting or removing rows/columns). Used for settings provided as a function.\n     *\n     * @private\n     * @param {string} action Type of the action performed.\n     * @param {number} index Row/column index.\n     * @param {number} number Number of rows/columns added/removed.\n     */\n\n  }, {\n    key: \"resetSetupBeforeStructureAlteration\",\n    value: function resetSetupBeforeStructureAlteration(action, index, number) {\n      if (this.settingsType !== 'function') {\n        return;\n      }\n\n      var type = action.indexOf('row') > -1 ? 'row' : 'col';\n      var endpoints = this.getAllEndpoints();\n      arrayEach(endpoints, function (val) {\n        if (type === 'row' && val.destinationRow >= index) {\n          if (action === 'insert_row') {\n            val.alterRowOffset = number;\n          } else if (action === 'remove_row') {\n            val.alterRowOffset = -1 * number;\n          }\n        }\n\n        if (type === 'col' && val.destinationColumn >= index) {\n          if (action === 'insert_col') {\n            val.alterColumnOffset = number;\n          } else if (action === 'remove_col') {\n            val.alterColumnOffset = -1 * number;\n          }\n        }\n      });\n      this.resetAllEndpoints(endpoints, false);\n    }\n    /**\n     * AfterCreateRow/afterCreateRow/afterRemoveRow/afterRemoveCol hook callback. Reset and reenables the summary functionality\n     * after changing the table structure.\n     *\n     * @private\n     * @param {string} action Type of the action performed.\n     * @param {number} index Row/column index.\n     * @param {number} number Number of rows/columns added/removed.\n     * @param {Array} [logicRows] Array of the logical indexes.\n     * @param {string} [source] Source of change.\n     * @param {boolean} [forceRefresh] `true` of the endpoints should refresh after completing the function.\n     */\n\n  }, {\n    key: \"resetSetupAfterStructureAlteration\",\n    value: function resetSetupAfterStructureAlteration(action, index, number, logicRows, source) {\n      var _this2 = this;\n\n      var forceRefresh = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n\n      if (this.settingsType === 'function') {\n        // We need to run it on a next avaiable hook, because the TrimRows' `afterCreateRow` hook triggers after this one,\n        // and it needs to be run to properly calculate the endpoint value.\n        var beforeViewRenderCallback = function beforeViewRenderCallback() {\n          _this2.hot.removeHook('beforeViewRender', beforeViewRenderCallback);\n\n          return _this2.refreshAllEndpoints();\n        };\n\n        this.hot.addHookOnce('beforeViewRender', beforeViewRenderCallback);\n        return;\n      }\n\n      var type = action.indexOf('row') > -1 ? 'row' : 'col';\n      var multiplier = action.indexOf('remove') > -1 ? -1 : 1;\n      var endpoints = this.getAllEndpoints();\n      var rowMoving = action.indexOf('move_row') === 0;\n      var placeOfAlteration = index;\n      arrayEach(endpoints, function (val) {\n        if (type === 'row' && val.destinationRow >= placeOfAlteration) {\n          val.alterRowOffset = multiplier * number;\n        }\n\n        if (type === 'col' && val.destinationColumn >= placeOfAlteration) {\n          val.alterColumnOffset = multiplier * number;\n        }\n      });\n      this.resetAllEndpoints(endpoints, !rowMoving);\n\n      if (rowMoving) {\n        arrayEach(endpoints, function (endpoint) {\n          _this2.extendEndpointRanges(endpoint, placeOfAlteration, logicRows[0], logicRows.length);\n\n          _this2.recreatePhysicalRanges(endpoint);\n\n          _this2.clearOffsetInformation(endpoint);\n        });\n      } else {\n        arrayEach(endpoints, function (endpoint) {\n          _this2.shiftEndpointCoordinates(endpoint, placeOfAlteration);\n        });\n      }\n\n      if (forceRefresh) {\n        this.refreshAllEndpoints();\n      }\n    }\n    /**\n     * Clear the offset information from the endpoint object.\n     *\n     * @private\n     * @param {object} endpoint And endpoint object.\n     */\n\n  }, {\n    key: \"clearOffsetInformation\",\n    value: function clearOffsetInformation(endpoint) {\n      endpoint.alterRowOffset = void 0;\n      endpoint.alterColumnOffset = void 0;\n    }\n    /**\n     * Extend the row ranges for the provided endpoint.\n     *\n     * @private\n     * @param {object} endpoint The endpoint object.\n     * @param {number} placeOfAlteration Index of the row where the alteration takes place.\n     * @param {number} previousPosition Previous endpoint result position.\n     * @param {number} offset Offset generated by the alteration.\n     */\n\n  }, {\n    key: \"extendEndpointRanges\",\n    value: function extendEndpointRanges(endpoint, placeOfAlteration, previousPosition, offset) {\n      arrayEach(endpoint.ranges, function (range) {\n        // is a range, not a single row\n        if (range[1]) {\n          if (placeOfAlteration >= range[0] && placeOfAlteration <= range[1]) {\n            if (previousPosition > range[1]) {\n              range[1] += offset;\n            } else if (previousPosition < range[0]) {\n              range[0] -= offset;\n            }\n          } else if (previousPosition >= range[0] && previousPosition <= range[1]) {\n            range[1] -= offset;\n\n            if (placeOfAlteration <= range[0]) {\n              range[0] += 1;\n              range[1] += 1;\n            }\n          }\n        }\n      });\n    }\n    /**\n     * Recreate the physical ranges for the provided endpoint. Used (for example) when a row gets moved and extends an existing range.\n     *\n     * @private\n     * @param {object} endpoint An endpoint object.\n     */\n\n  }, {\n    key: \"recreatePhysicalRanges\",\n    value: function recreatePhysicalRanges(endpoint) {\n      var _this3 = this;\n\n      var ranges = endpoint.ranges;\n      var newRanges = [];\n      var allIndexes = [];\n      arrayEach(ranges, function (range) {\n        var newRange = [];\n\n        if (range[1]) {\n          for (var i = range[0]; i <= range[1]; i++) {\n            newRange.push(_this3.hot.toPhysicalRow(i));\n          }\n        } else {\n          newRange.push(_this3.hot.toPhysicalRow(range[0]));\n        }\n\n        allIndexes.push(newRange);\n      });\n      arrayEach(allIndexes, function (range) {\n        var newRange = [];\n        arrayEach(range, function (coord, index) {\n          if (index === 0) {\n            newRange.push(coord);\n          } else if (range[index] !== range[index - 1] + 1) {\n            newRange.push(range[index - 1]);\n            newRanges.push(newRange);\n            newRange = [];\n            newRange.push(coord);\n          }\n\n          if (index === range.length - 1) {\n            newRange.push(coord);\n            newRanges.push(newRange);\n          }\n        });\n      });\n      endpoint.ranges = newRanges;\n    }\n    /**\n     * Shifts the endpoint coordinates by the defined offset.\n     *\n     * @private\n     * @param {object} endpoint Endpoint object.\n     * @param {number} offsetStartIndex Index of the performed change (if the change is located after the endpoint, nothing about the endpoint has to be changed.\n     */\n\n  }, {\n    key: \"shiftEndpointCoordinates\",\n    value: function shiftEndpointCoordinates(endpoint, offsetStartIndex) {\n      if (endpoint.alterRowOffset && endpoint.alterRowOffset !== 0) {\n        endpoint.destinationRow += endpoint.alterRowOffset || 0;\n        arrayEach(endpoint.ranges, function (element) {\n          arrayEach(element, function (subElement, j) {\n            if (subElement >= offsetStartIndex) {\n              element[j] += endpoint.alterRowOffset || 0;\n            }\n          });\n        });\n      } else if (endpoint.alterColumnOffset && endpoint.alterColumnOffset !== 0) {\n        endpoint.destinationColumn += endpoint.alterColumnOffset || 0;\n        endpoint.sourceColumn += endpoint.alterColumnOffset || 0;\n      }\n    }\n    /**\n     * Resets (removes) the endpoints from the table.\n     *\n     * @param {Array} [endpoints] Array containing the endpoints.\n     * @param {boolean} [useOffset=true] Use the cell offset value.\n     */\n\n  }, {\n    key: \"resetAllEndpoints\",\n    value: function resetAllEndpoints() {\n      var _this4 = this;\n\n      var endpoints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAllEndpoints();\n      var useOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var anyEndpointOutOfRange = endpoints.some(function (endpoint) {\n        var alterRowOffset = endpoint.alterRowOffset || 0;\n        var alterColOffset = endpoint.alterColumnOffset || 0;\n\n        if (endpoint.destinationRow + alterRowOffset >= _this4.hot.countRows() || endpoint.destinationColumn + alterColOffset >= _this4.hot.countCols()) {\n          return true;\n        }\n\n        return false;\n      });\n\n      if (anyEndpointOutOfRange) {\n        return;\n      }\n\n      this.cellsToSetCache = [];\n      arrayEach(endpoints, function (endpoint) {\n        _this4.resetEndpointValue(endpoint, useOffset);\n      });\n      this.hot.setDataAtCell(this.cellsToSetCache, 'ColumnSummary.reset');\n      this.cellsToSetCache = [];\n    }\n    /**\n     * Calculate and refresh all defined endpoints.\n     */\n\n  }, {\n    key: \"refreshAllEndpoints\",\n    value: function refreshAllEndpoints() {\n      var _this5 = this;\n\n      this.cellsToSetCache = [];\n      arrayEach(this.getAllEndpoints(), function (value) {\n        _this5.currentEndpoint = value;\n\n        _this5.plugin.calculate(value);\n\n        _this5.setEndpointValue(value, 'init');\n      });\n      this.currentEndpoint = null;\n      this.hot.setDataAtCell(this.cellsToSetCache, 'ColumnSummary.reset');\n      this.cellsToSetCache = [];\n    }\n    /**\n     * Calculate and refresh endpoints only in the changed columns.\n     *\n     * @param {Array} changes Array of changes from the `afterChange` hook.\n     */\n\n  }, {\n    key: \"refreshChangedEndpoints\",\n    value: function refreshChangedEndpoints(changes) {\n      var _this6 = this;\n\n      var needToRefresh = [];\n      this.cellsToSetCache = [];\n      arrayEach(changes, function (value, key, changesObj) {\n        // if nothing changed, dont update anything\n        if (\"\".concat(value[2] || '') === \"\".concat(value[3])) {\n          return;\n        }\n\n        arrayEach(_this6.getAllEndpoints(), function (endpoint, j) {\n          if (_this6.hot.propToCol(changesObj[key][1]) === endpoint.sourceColumn && needToRefresh.indexOf(j) === -1) {\n            needToRefresh.push(j);\n          }\n        });\n      });\n      arrayEach(needToRefresh, function (value) {\n        _this6.refreshEndpoint(_this6.getEndpoint(value));\n      });\n      this.hot.setDataAtCell(this.cellsToSetCache, 'ColumnSummary.reset');\n      this.cellsToSetCache = [];\n    }\n    /**\n     * Calculate and refresh a single endpoint.\n     *\n     * @param {object} endpoint Contains the endpoint information.\n     */\n\n  }, {\n    key: \"refreshEndpoint\",\n    value: function refreshEndpoint(endpoint) {\n      this.currentEndpoint = endpoint;\n      this.plugin.calculate(endpoint);\n      this.setEndpointValue(endpoint);\n      this.currentEndpoint = null;\n    }\n    /**\n     * Reset the endpoint value.\n     *\n     * @param {object} endpoint Contains the endpoint information.\n     * @param {boolean} [useOffset=true] Use the cell offset value.\n     */\n\n  }, {\n    key: \"resetEndpointValue\",\n    value: function resetEndpointValue(endpoint) {\n      var useOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var alterRowOffset = endpoint.alterRowOffset || 0;\n      var alterColOffset = endpoint.alterColumnOffset || 0;\n      var _ref = [this.hot.toVisualRow(endpoint.destinationRow), this.hot.toVisualColumn(endpoint.destinationColumn)],\n          visualRowIndex = _ref[0],\n          visualColumnIndex = _ref[1];\n\n      if (visualColumnIndex !== null && visualRowIndex !== null) {\n        // Clear the meta on the \"old\" indexes\n        var cellMeta = this.hot.getCellMeta(visualRowIndex, visualColumnIndex);\n        cellMeta.readOnly = false;\n        cellMeta.className = '';\n      }\n\n      this.cellsToSetCache.push([this.hot.toVisualRow(endpoint.destinationRow + (useOffset ? alterRowOffset : 0)), this.hot.toVisualColumn(endpoint.destinationColumn + (useOffset ? alterColOffset : 0)), '']);\n    }\n    /**\n     * Set the endpoint value.\n     *\n     * @param {object} endpoint Contains the endpoint information.\n     * @param {string} [source] Source of the call information.\n     * @param {boolean} [render=false] `true` if it needs to render the table afterwards.\n     */\n\n  }, {\n    key: \"setEndpointValue\",\n    value: function setEndpointValue(endpoint, source) {\n      var render = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      // We'll need the reversed offset values, because cellMeta will be shifted AGAIN afterwards.\n      var reverseRowOffset = -1 * endpoint.alterRowOffset || 0;\n      var reverseColOffset = -1 * endpoint.alterColumnOffset || 0;\n      var visualEndpointRowIndex = this.hot.toVisualRow(endpoint.destinationRow);\n\n      if (endpoint.destinationRow >= this.hot.countRows() || endpoint.destinationColumn >= this.hot.countCols()) {\n        this.throwOutOfBoundsWarning();\n        return;\n      }\n\n      var destinationVisualRow = this.hot.toVisualRow(endpoint.destinationRow + reverseRowOffset);\n\n      if (destinationVisualRow !== null) {\n        var cellMeta = this.hot.getCellMeta(destinationVisualRow, endpoint.destinationColumn + reverseColOffset);\n\n        if (source === 'init' || cellMeta.readOnly !== endpoint.readOnly) {\n          cellMeta.readOnly = endpoint.readOnly;\n          cellMeta.className = 'columnSummaryResult';\n        }\n      }\n\n      if (endpoint.roundFloat && !isNaN(endpoint.result)) {\n        endpoint.result = endpoint.result.toFixed(endpoint.roundFloat);\n      }\n\n      if (render) {\n        this.hot.setDataAtCell(visualEndpointRowIndex, endpoint.destinationColumn, endpoint.result, 'ColumnSummary.set');\n      } else {\n        this.cellsToSetCache.push([visualEndpointRowIndex, endpoint.destinationColumn, endpoint.result]);\n      }\n\n      endpoint.alterRowOffset = void 0;\n      endpoint.alterColumnOffset = void 0;\n    }\n    /**\n     * Throw an error for the calculation range being out of boundaries.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"throwOutOfBoundsWarning\",\n    value: function throwOutOfBoundsWarning() {\n      warn('One of the Column Summary plugins\\' destination points you provided is beyond the table boundaries!');\n    }\n  }]);\n\n  return Endpoints;\n}();\n\nexport default Endpoints;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}