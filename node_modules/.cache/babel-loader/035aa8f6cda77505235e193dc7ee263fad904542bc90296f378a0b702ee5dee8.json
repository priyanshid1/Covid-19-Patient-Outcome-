{"ast":null,"code":"var _templateObject;\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _s, _e;\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n  return _arr;\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _taggedTemplateLiteral(strings, raw) {\n  if (!raw) {\n    raw = strings.slice(0);\n  }\n  return Object.freeze(Object.defineProperties(strings, {\n    raw: {\n      value: Object.freeze(raw)\n    }\n  }));\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nimport Highlight from \"./highlight/highlight.mjs\";\nimport { AREA_TYPE, HEADER_TYPE, CELL_TYPE } from \"./highlight/constants.mjs\";\nimport SelectionRange from \"./range.mjs\";\nimport { CellCoords } from \"./../3rdparty/walkontable/src/index.mjs\";\nimport { isPressedCtrlKey } from \"./../utils/keyStateObserver.mjs\";\nimport { createObjectPropListener, mixin } from \"./../helpers/object.mjs\";\nimport { isUndefined } from \"./../helpers/mixed.mjs\";\nimport { arrayEach } from \"./../helpers/array.mjs\";\nimport localHooks from \"./../mixins/localHooks.mjs\";\nimport Transformation from \"./transformation.mjs\";\nimport { detectSelectionType, isValidCoord, normalizeSelectionFactory, SELECTION_TYPE_EMPTY, SELECTION_TYPE_UNRECOGNIZED } from \"./utils.mjs\";\nimport { toSingleLine } from \"./../helpers/templateLiteralTag.mjs\";\n/**\n * @class Selection\n * @util\n */\n\nvar Selection = /*#__PURE__*/function () {\n  function Selection(settings, tableProps) {\n    var _this = this;\n    _classCallCheck(this, Selection);\n\n    /**\n     * Handsontable settings instance.\n     *\n     * @type {GridSettings}\n     */\n    this.settings = settings;\n    /**\n     * An additional object with dynamically defined properties which describes table state.\n     *\n     * @type {object}\n     */\n\n    this.tableProps = tableProps;\n    /**\n     * The flag which determines if the selection is in progress.\n     *\n     * @type {boolean}\n     */\n\n    this.inProgress = false;\n    /**\n     * The flag indicates that selection was performed by clicking the corner overlay.\n     *\n     * @type {boolean}\n     */\n\n    this.selectedByCorner = false;\n    /**\n     * The collection of the selection layer levels where the whole row was selected using the row header or\n     * the corner header.\n     *\n     * @type {Set.<number>}\n     */\n\n    this.selectedByRowHeader = new Set();\n    /**\n     * The collection of the selection layer levels where the whole column was selected using the column header or\n     * the corner header.\n     *\n     * @type {Set.<number>}\n     */\n\n    this.selectedByColumnHeader = new Set();\n    /**\n     * Selection data layer (handle visual coordinates).\n     *\n     * @type {SelectionRange}\n     */\n\n    this.selectedRange = new SelectionRange();\n    /**\n     * Visualization layer.\n     *\n     * @type {Highlight}\n     */\n\n    this.highlight = new Highlight({\n      headerClassName: settings.currentHeaderClassName,\n      activeHeaderClassName: settings.activeHeaderClassName,\n      rowClassName: settings.currentRowClassName,\n      columnClassName: settings.currentColClassName,\n      disabledCellSelection: function disabledCellSelection(row, column) {\n        return _this.tableProps.isDisabledCellSelection(row, column);\n      },\n      cellCornerVisible: function cellCornerVisible() {\n        return _this.isCellCornerVisible.apply(_this, arguments);\n      },\n      areaCornerVisible: function areaCornerVisible() {\n        return _this.isAreaCornerVisible.apply(_this, arguments);\n      },\n      visualToRenderableCoords: function visualToRenderableCoords(coords) {\n        return _this.tableProps.visualToRenderableCoords(coords);\n      },\n      renderableToVisualCoords: function renderableToVisualCoords(coords) {\n        return _this.tableProps.renderableToVisualCoords(coords);\n      }\n    });\n    /**\n     * The module for modifying coordinates.\n     *\n     * @type {Transformation}\n     */\n\n    this.transformation = new Transformation(this.selectedRange, {\n      countRows: function countRows() {\n        return _this.tableProps.countRowsTranslated();\n      },\n      countCols: function countCols() {\n        return _this.tableProps.countColsTranslated();\n      },\n      visualToRenderableCoords: function visualToRenderableCoords(coords) {\n        return _this.tableProps.visualToRenderableCoords(coords);\n      },\n      renderableToVisualCoords: function renderableToVisualCoords(coords) {\n        return _this.tableProps.renderableToVisualCoords(coords);\n      },\n      fixedRowsBottom: function fixedRowsBottom() {\n        return settings.fixedRowsBottom;\n      },\n      minSpareRows: function minSpareRows() {\n        return settings.minSpareRows;\n      },\n      minSpareCols: function minSpareCols() {\n        return settings.minSpareCols;\n      },\n      autoWrapRow: function autoWrapRow() {\n        return settings.autoWrapRow;\n      },\n      autoWrapCol: function autoWrapCol() {\n        return settings.autoWrapCol;\n      }\n    });\n    this.transformation.addLocalHook('beforeTransformStart', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return _this.runLocalHooks.apply(_this, ['beforeModifyTransformStart'].concat(args));\n    });\n    this.transformation.addLocalHook('afterTransformStart', function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return _this.runLocalHooks.apply(_this, ['afterModifyTransformStart'].concat(args));\n    });\n    this.transformation.addLocalHook('beforeTransformEnd', function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      return _this.runLocalHooks.apply(_this, ['beforeModifyTransformEnd'].concat(args));\n    });\n    this.transformation.addLocalHook('afterTransformEnd', function () {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n      return _this.runLocalHooks.apply(_this, ['afterModifyTransformEnd'].concat(args));\n    });\n    this.transformation.addLocalHook('insertRowRequire', function () {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n      return _this.runLocalHooks.apply(_this, ['insertRowRequire'].concat(args));\n    });\n    this.transformation.addLocalHook('insertColRequire', function () {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n      return _this.runLocalHooks.apply(_this, ['insertColRequire'].concat(args));\n    });\n  }\n  /**\n   * Get data layer for current selection.\n   *\n   * @returns {SelectionRange}\n   */\n\n  _createClass(Selection, [{\n    key: \"getSelectedRange\",\n    value: function getSelectedRange() {\n      return this.selectedRange;\n    }\n    /**\n     * Indicate that selection process began. It sets internaly `.inProgress` property to `true`.\n     */\n  }, {\n    key: \"begin\",\n    value: function begin() {\n      this.inProgress = true;\n    }\n    /**\n     * Indicate that selection process finished. It sets internaly `.inProgress` property to `false`.\n     */\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      this.runLocalHooks('afterSelectionFinished', Array.from(this.selectedRange));\n      this.inProgress = false;\n    }\n    /**\n     * Check if the process of selecting the cell/cells is in progress.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isInProgress\",\n    value: function isInProgress() {\n      return this.inProgress;\n    }\n    /**\n     * Starts selection range on given coordinate object.\n     *\n     * @param {CellCoords} coords Visual coords.\n     * @param {boolean} [multipleSelection] If `true`, selection will be worked in 'multiple' mode. This option works\n     *                                      only when 'selectionMode' is set as 'multiple'. If the argument is not defined\n     *                                      the default trigger will be used (isPressedCtrlKey() helper).\n     * @param {boolean} [fragment=false] If `true`, the selection will be treated as a partial selection where the\n     *                                   `setRangeEnd` method won't be called on every `setRangeStart` call.\n     */\n  }, {\n    key: \"setRangeStart\",\n    value: function setRangeStart(coords, multipleSelection) {\n      var fragment = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var isMultipleMode = this.settings.selectionMode === 'multiple';\n      var isMultipleSelection = isUndefined(multipleSelection) ? isPressedCtrlKey() : multipleSelection;\n      var isRowNegative = coords.row < 0;\n      var isColumnNegative = coords.col < 0;\n      var selectedByCorner = isRowNegative && isColumnNegative; // We are creating copy. We would like to modify just the start of the selection by below hook. Then original coords\n      // should be handled by next methods.\n\n      var coordsClone = coords.clone();\n      this.selectedByCorner = selectedByCorner;\n      this.runLocalHooks(\"beforeSetRangeStart\".concat(fragment ? 'Only' : ''), coordsClone);\n      if (!isMultipleMode || isMultipleMode && !isMultipleSelection && isUndefined(multipleSelection)) {\n        this.selectedRange.clear();\n      }\n      this.selectedRange.add(coordsClone);\n      if (this.getLayerLevel() === 0) {\n        this.selectedByRowHeader.clear();\n        this.selectedByColumnHeader.clear();\n      }\n      if (!selectedByCorner && isColumnNegative) {\n        this.selectedByRowHeader.add(this.getLayerLevel());\n      }\n      if (!selectedByCorner && isRowNegative) {\n        this.selectedByColumnHeader.add(this.getLayerLevel());\n      }\n      if (!fragment) {\n        this.setRangeEnd(coords);\n      }\n    }\n    /**\n     * Starts selection range on given coordinate object.\n     *\n     * @param {CellCoords} coords Visual coords.\n     * @param {boolean} [multipleSelection] If `true`, selection will be worked in 'multiple' mode. This option works\n     *                                      only when 'selectionMode' is set as 'multiple'. If the argument is not defined\n     *                                      the default trigger will be used (isPressedCtrlKey() helper).\n     */\n  }, {\n    key: \"setRangeStartOnly\",\n    value: function setRangeStartOnly(coords, multipleSelection) {\n      this.setRangeStart(coords, multipleSelection, true);\n    }\n    /**\n     * Ends selection range on given coordinate object.\n     *\n     * @param {CellCoords} coords Visual coords.\n     */\n  }, {\n    key: \"setRangeEnd\",\n    value: function setRangeEnd(coords) {\n      if (this.selectedRange.isEmpty()) {\n        return;\n      } // We are creating copy. We would like to modify just the end of the selection by below hook. Then original coords\n      // should be handled by next methods.\n\n      var coordsClone = coords.clone();\n      this.runLocalHooks('beforeSetRangeEnd', coordsClone);\n      this.begin();\n      var cellRange = this.selectedRange.current();\n      if (this.settings.selectionMode !== 'single') {\n        cellRange.setTo(new CellCoords(coordsClone.row, coordsClone.col));\n      } // Set up current selection.\n\n      this.highlight.getCell().clear();\n      if (this.highlight.isEnabledFor(CELL_TYPE, cellRange.highlight)) {\n        this.highlight.getCell().add(this.selectedRange.current().highlight).commit().adjustCoordinates(cellRange);\n      }\n      var layerLevel = this.getLayerLevel(); // If the next layer level is lower than previous then clear all area and header highlights. This is the\n      // indication that the new selection is performing.\n\n      if (layerLevel < this.highlight.layerLevel) {\n        arrayEach(this.highlight.getAreas(), function (highlight) {\n          return void highlight.clear();\n        });\n        arrayEach(this.highlight.getHeaders(), function (highlight) {\n          return void highlight.clear();\n        });\n        arrayEach(this.highlight.getActiveHeaders(), function (highlight) {\n          return void highlight.clear();\n        });\n      }\n      this.highlight.useLayerLevel(layerLevel);\n      var areaHighlight = this.highlight.createOrGetArea();\n      var headerHighlight = this.highlight.createOrGetHeader();\n      var activeHeaderHighlight = this.highlight.createOrGetActiveHeader();\n      areaHighlight.clear();\n      headerHighlight.clear();\n      activeHeaderHighlight.clear();\n      if (this.highlight.isEnabledFor(AREA_TYPE, cellRange.highlight) && (this.isMultiple() || layerLevel >= 1)) {\n        areaHighlight.add(cellRange.from).add(cellRange.to).commit();\n        if (layerLevel === 1) {\n          // For single cell selection in the same layer, we do not create area selection to prevent blue background.\n          // When non-consecutive selection is performed we have to add that missing area selection to the previous layer\n          // based on previous coordinates. It only occurs when the previous selection wasn't select multiple cells.\n          var previousRange = this.selectedRange.previous();\n          this.highlight.useLayerLevel(layerLevel - 1).createOrGetArea().add(previousRange.from).commit() // Range may start with hidden indexes. Commit would not found start point (as we add just the `from` coords).\n          .adjustCoordinates(previousRange);\n          this.highlight.useLayerLevel(layerLevel);\n        }\n      }\n      if (this.highlight.isEnabledFor(HEADER_TYPE, cellRange.highlight)) {\n        // The header selection generally contains cell selection. In a case when all rows (or columns)\n        // are hidden that visual coordinates are translated to renderable coordinates that do not exist.\n        // Hence no header highlight is generated. In that case, to make a column (or a row) header\n        // highlight, the row and column index has to point to the header (the negative value). See #7052.\n        var areAnyRowsRendered = this.tableProps.countRowsTranslated() === 0;\n        var areAnyColumnsRendered = this.tableProps.countColsTranslated() === 0;\n        var headerCellRange = cellRange;\n        if (areAnyRowsRendered || areAnyColumnsRendered) {\n          headerCellRange = cellRange.clone();\n        }\n        if (areAnyRowsRendered) {\n          headerCellRange.from.row = -1;\n        }\n        if (areAnyColumnsRendered) {\n          headerCellRange.from.col = -1;\n        }\n        if (this.settings.selectionMode === 'single') {\n          if (this.isSelectedByAnyHeader()) {\n            headerCellRange.from.normalize();\n          }\n          headerHighlight.add(headerCellRange.from).commit();\n        } else {\n          headerHighlight.add(headerCellRange.from).add(headerCellRange.to).commit();\n        }\n        if (this.isEntireRowSelected()) {\n          var isRowSelected = this.tableProps.countCols() === cellRange.getWidth(); // Make sure that the whole row is selected (in case where selectionMode is set to 'single')\n\n          if (isRowSelected) {\n            activeHeaderHighlight.add(new CellCoords(cellRange.from.row, -1)).add(new CellCoords(cellRange.to.row, -1)).commit();\n          }\n        }\n        if (this.isEntireColumnSelected()) {\n          var isColumnSelected = this.tableProps.countRows() === cellRange.getHeight(); // Make sure that the whole column is selected (in case where selectionMode is set to 'single')\n\n          if (isColumnSelected) {\n            activeHeaderHighlight.add(new CellCoords(-1, cellRange.from.col)).add(new CellCoords(-1, cellRange.to.col)).commit();\n          }\n        }\n      }\n      this.runLocalHooks('afterSetRangeEnd', coords);\n    }\n    /**\n     * Returns information if we have a multiselection. This method check multiselection only on the latest layer of\n     * the selection.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isMultiple\",\n    value: function isMultiple() {\n      var isMultipleListener = createObjectPropListener(!this.selectedRange.current().isSingle());\n      this.runLocalHooks('afterIsMultipleSelection', isMultipleListener);\n      return isMultipleListener.value;\n    }\n    /**\n     * Selects cell relative to the current cell (if possible).\n     *\n     * @param {number} rowDelta Rows number to move, value can be passed as negative number.\n     * @param {number} colDelta Columns number to move, value can be passed as negative number.\n     * @param {boolean} [force=false] If `true` the new rows/columns will be created if necessary. Otherwise, row/column will\n     *                        be created according to `minSpareRows/minSpareCols` settings of Handsontable.\n     */\n  }, {\n    key: \"transformStart\",\n    value: function transformStart(rowDelta, colDelta) {\n      var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      this.setRangeStart(this.transformation.transformStart(rowDelta, colDelta, force));\n    }\n    /**\n     * Sets selection end cell relative to the current selection end cell (if possible).\n     *\n     * @param {number} rowDelta Rows number to move, value can be passed as negative number.\n     * @param {number} colDelta Columns number to move, value can be passed as negative number.\n     */\n  }, {\n    key: \"transformEnd\",\n    value: function transformEnd(rowDelta, colDelta) {\n      this.setRangeEnd(this.transformation.transformEnd(rowDelta, colDelta));\n    }\n    /**\n     * Returns currently used layer level.\n     *\n     * @returns {number} Returns layer level starting from 0. If no selection was added to the table -1 is returned.\n     */\n  }, {\n    key: \"getLayerLevel\",\n    value: function getLayerLevel() {\n      return this.selectedRange.size() - 1;\n    }\n    /**\n     * Returns `true` if currently there is a selection on the screen, `false` otherwise.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isSelected\",\n    value: function isSelected() {\n      return !this.selectedRange.isEmpty();\n    }\n    /**\n     * Returns `true` if the selection was applied by clicking to the row header. If the `layerLevel`\n     * argument is passed then only that layer will be checked. Otherwise, it checks if any row header\n     * was clicked on any selection layer level.\n     *\n     * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isSelectedByRowHeader\",\n    value: function isSelectedByRowHeader() {\n      var layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n      return !this.isSelectedByCorner(layerLevel) && this.isEntireRowSelected(layerLevel);\n    }\n    /**\n     * Returns `true` if the selection consists of entire rows (including their headers). If the `layerLevel`\n     * argument is passed then only that layer will be checked. Otherwise, it checks the selection for all layers.\n     *\n     * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isEntireRowSelected\",\n    value: function isEntireRowSelected() {\n      var layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n      return layerLevel === -1 ? this.selectedByRowHeader.size > 0 : this.selectedByRowHeader.has(layerLevel);\n    }\n    /**\n     * Returns `true` if the selection was applied by clicking to the column header. If the `layerLevel`\n     * argument is passed then only that layer will be checked. Otherwise, it checks if any column header\n     * was clicked on any selection layer level.\n     *\n     * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isSelectedByColumnHeader\",\n    value: function isSelectedByColumnHeader() {\n      var layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n      return !this.isSelectedByCorner() && this.isEntireColumnSelected(layerLevel);\n    }\n    /**\n     * Returns `true` if the selection consists of entire columns (including their headers). If the `layerLevel`\n     * argument is passed then only that layer will be checked. Otherwise, it checks the selection for all layers.\n     *\n     * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isEntireColumnSelected\",\n    value: function isEntireColumnSelected() {\n      var layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n      return layerLevel === -1 ? this.selectedByColumnHeader.size > 0 : this.selectedByColumnHeader.has(layerLevel);\n    }\n    /**\n     * Returns `true` if the selection was applied by clicking on the row or column header on any layer level.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isSelectedByAnyHeader\",\n    value: function isSelectedByAnyHeader() {\n      return this.isSelectedByRowHeader(-1) || this.isSelectedByColumnHeader(-1) || this.isSelectedByCorner();\n    }\n    /**\n     * Returns `true` if the selection was applied by clicking on the left-top corner overlay.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isSelectedByCorner\",\n    value: function isSelectedByCorner() {\n      return this.selectedByCorner;\n    }\n    /**\n     * Returns `true` if coords is within selection coords. This method iterates through all selection layers to check if\n     * the coords object is within selection range.\n     *\n     * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"inInSelection\",\n    value: function inInSelection(coords) {\n      return this.selectedRange.includes(coords);\n    }\n    /**\n     * Returns `true` if the cell corner should be visible.\n     *\n     * @private\n     * @returns {boolean} `true` if the corner element has to be visible, `false` otherwise.\n     */\n  }, {\n    key: \"isCellCornerVisible\",\n    value: function isCellCornerVisible() {\n      return this.settings.fillHandle && !this.tableProps.isEditorOpened() && !this.isMultiple();\n    }\n    /**\n     * Returns `true` if the area corner should be visible.\n     *\n     * @param {number} layerLevel The layer level.\n     * @returns {boolean} `true` if the corner element has to be visible, `false` otherwise.\n     */\n  }, {\n    key: \"isAreaCornerVisible\",\n    value: function isAreaCornerVisible(layerLevel) {\n      if (Number.isInteger(layerLevel) && layerLevel !== this.getLayerLevel()) {\n        return false;\n      }\n      return this.settings.fillHandle && !this.tableProps.isEditorOpened() && this.isMultiple();\n    }\n    /**\n     * Clear the selection by resetting the collected ranges and highlights.\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      // TODO: collections selectedByColumnHeader and selectedByRowHeader should be clear too.\n      this.selectedRange.clear();\n      this.highlight.clear();\n    }\n    /**\n     * Deselects all selected cells.\n     */\n  }, {\n    key: \"deselect\",\n    value: function deselect() {\n      if (!this.isSelected()) {\n        return;\n      }\n      this.inProgress = false;\n      this.clear();\n      this.runLocalHooks('afterDeselect');\n    }\n    /**\n     * Select all cells.\n     *\n     * @param {boolean} [includeRowHeaders=false] `true` If the selection should include the row headers, `false`\n     * otherwise.\n     * @param {boolean} [includeColumnHeaders=false] `true` If the selection should include the column headers, `false`\n     * otherwise.\n     */\n  }, {\n    key: \"selectAll\",\n    value: function selectAll() {\n      var includeRowHeaders = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var includeColumnHeaders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var nrOfRows = this.tableProps.countRows();\n      var nrOfColumns = this.tableProps.countCols(); // We can't select cells when there is no data.\n\n      if (!includeRowHeaders && !includeColumnHeaders && (nrOfRows === 0 || nrOfColumns === 0)) {\n        return;\n      }\n      var startCoords = new CellCoords(includeColumnHeaders ? -1 : 0, includeRowHeaders ? -1 : 0);\n      this.clear();\n      this.setRangeStartOnly(startCoords);\n      this.selectedByRowHeader.add(this.getLayerLevel());\n      this.selectedByColumnHeader.add(this.getLayerLevel());\n      this.setRangeEnd(new CellCoords(nrOfRows - 1, nrOfColumns - 1));\n      this.finish();\n    }\n    /**\n     * Make multiple, non-contiguous selection specified by `row` and `column` values or a range of cells\n     * finishing at `endRow`, `endColumn`. The method supports two input formats, first as an array of arrays such\n     * as `[[rowStart, columnStart, rowEnd, columnEnd]]` and second format as an array of CellRange objects.\n     * If the passed ranges have another format the exception will be thrown.\n     *\n     * @param {Array[]|CellRange[]} selectionRanges The coordinates which define what the cells should be selected.\n     * @returns {boolean} Returns `true` if selection was successful, `false` otherwise.\n     */\n  }, {\n    key: \"selectCells\",\n    value: function selectCells(selectionRanges) {\n      var _this2 = this;\n      var selectionType = detectSelectionType(selectionRanges);\n      if (selectionType === SELECTION_TYPE_EMPTY) {\n        return false;\n      } else if (selectionType === SELECTION_TYPE_UNRECOGNIZED) {\n        throw new Error(toSingleLine(_templateObject || (_templateObject = _taggedTemplateLiteral([\"Unsupported format of the selection ranges was passed. To select cells pass \\n        the coordinates as an array of arrays ([[rowStart, columnStart/columnPropStart, rowEnd, \\n        columnEnd/columnPropEnd]]) or as an array of CellRange objects.\"], [\"Unsupported format of the selection ranges was passed. To select cells pass\\\\x20\\n        the coordinates as an array of arrays ([[rowStart, columnStart/columnPropStart, rowEnd,\\\\x20\\n        columnEnd/columnPropEnd]]) or as an array of CellRange objects.\"]))));\n      }\n      var selectionSchemaNormalizer = normalizeSelectionFactory(selectionType, {\n        propToCol: function propToCol(prop) {\n          return _this2.tableProps.propToCol(prop);\n        },\n        keepDirection: true\n      });\n      var nrOfRows = this.tableProps.countRows();\n      var nrOfColumns = this.tableProps.countCols(); // Check if every layer of the coordinates are valid.\n\n      var isValid = !selectionRanges.some(function (selection) {\n        var _selectionSchemaNorma = selectionSchemaNormalizer(selection),\n          _selectionSchemaNorma2 = _slicedToArray(_selectionSchemaNorma, 4),\n          rowStart = _selectionSchemaNorma2[0],\n          columnStart = _selectionSchemaNorma2[1],\n          rowEnd = _selectionSchemaNorma2[2],\n          columnEnd = _selectionSchemaNorma2[3];\n        var _isValid = isValidCoord(rowStart, nrOfRows) && isValidCoord(columnStart, nrOfColumns) && isValidCoord(rowEnd, nrOfRows) && isValidCoord(columnEnd, nrOfColumns);\n        return !_isValid;\n      });\n      if (isValid) {\n        this.clear();\n        arrayEach(selectionRanges, function (selection) {\n          var _selectionSchemaNorma3 = selectionSchemaNormalizer(selection),\n            _selectionSchemaNorma4 = _slicedToArray(_selectionSchemaNorma3, 4),\n            rowStart = _selectionSchemaNorma4[0],\n            columnStart = _selectionSchemaNorma4[1],\n            rowEnd = _selectionSchemaNorma4[2],\n            columnEnd = _selectionSchemaNorma4[3];\n          _this2.setRangeStartOnly(new CellCoords(rowStart, columnStart), false);\n          _this2.setRangeEnd(new CellCoords(rowEnd, columnEnd));\n          _this2.finish();\n        });\n      }\n      return isValid;\n    }\n    /**\n     * Select column specified by `startColumn` visual index or column property or a range of columns finishing at\n     * `endColumn`.\n     *\n     * @param {number|string} startColumn Visual column index or column property from which the selection starts.\n     * @param {number|string} [endColumn] Visual column index or column property from to the selection finishes.\n     * @param {number} [headerLevel=-1] A row header index that triggers the column selection. The value can\n     *                                  take -1 to -N, where -1 means the header closest to the cells.\n     *\n     * @returns {boolean} Returns `true` if selection was successful, `false` otherwise.\n     */\n  }, {\n    key: \"selectColumns\",\n    value: function selectColumns(startColumn) {\n      var endColumn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startColumn;\n      var headerLevel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n      var start = typeof startColumn === 'string' ? this.tableProps.propToCol(startColumn) : startColumn;\n      var end = typeof endColumn === 'string' ? this.tableProps.propToCol(endColumn) : endColumn;\n      var nrOfColumns = this.tableProps.countCols();\n      var nrOfRows = this.tableProps.countRows();\n      var isValid = isValidCoord(start, nrOfColumns) && isValidCoord(end, nrOfColumns);\n      if (isValid) {\n        this.setRangeStartOnly(new CellCoords(headerLevel, start));\n        this.setRangeEnd(new CellCoords(nrOfRows - 1, end));\n        this.finish();\n      }\n      return isValid;\n    }\n    /**\n     * Select row specified by `startRow` visual index or a range of rows finishing at `endRow`.\n     *\n     * @param {number} startRow Visual row index from which the selection starts.\n     * @param {number} [endRow] Visual row index from to the selection finishes.\n     * @param {number} [headerLevel=-1] A column header index that triggers the row selection.\n     *                                  The value can take -1 to -N, where -1 means the header\n     *                                  closest to the cells.\n     * @returns {boolean} Returns `true` if selection was successful, `false` otherwise.\n     */\n  }, {\n    key: \"selectRows\",\n    value: function selectRows(startRow) {\n      var endRow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startRow;\n      var headerLevel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n      var nrOfRows = this.tableProps.countRows();\n      var nrOfColumns = this.tableProps.countCols();\n      var isValid = isValidCoord(startRow, nrOfRows) && isValidCoord(endRow, nrOfRows);\n      if (isValid) {\n        this.setRangeStartOnly(new CellCoords(startRow, headerLevel));\n        this.setRangeEnd(new CellCoords(endRow, nrOfColumns - 1));\n        this.finish();\n      }\n      return isValid;\n    }\n    /**\n     * Rewrite the rendered state of the selection as visual selection may have a new representation in the DOM.\n     */\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      var customSelections = this.highlight.getCustomSelections();\n      customSelections.forEach(function (customSelection) {\n        customSelection.commit();\n      });\n      if (!this.isSelected()) {\n        return;\n      }\n      var cellHighlight = this.highlight.getCell();\n      var currentLayer = this.getLayerLevel();\n      cellHighlight.commit().adjustCoordinates(this.selectedRange.current()); // Rewriting rendered ranges going through all layers.\n\n      for (var layerLevel = 0; layerLevel < this.selectedRange.size(); layerLevel += 1) {\n        this.highlight.useLayerLevel(layerLevel);\n        var areaHighlight = this.highlight.createOrGetArea();\n        var headerHighlight = this.highlight.createOrGetHeader();\n        var activeHeaderHighlight = this.highlight.createOrGetActiveHeader();\n        areaHighlight.commit();\n        headerHighlight.commit();\n        activeHeaderHighlight.commit();\n      } // Reverting starting layer for the Highlight.\n\n      this.highlight.useLayerLevel(currentLayer);\n    }\n  }]);\n  return Selection;\n}();\nmixin(Selection, localHooks);\nexport default Selection;","map":{"version":3,"names":["_templateObject","_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","TypeError","o","minLen","_arrayLikeToArray","n","Object","prototype","toString","call","slice","constructor","name","Array","from","test","len","length","arr2","_i","Symbol","iterator","_arr","_n","_d","_s","_e","next","done","push","value","err","isArray","_taggedTemplateLiteral","strings","raw","freeze","defineProperties","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","Highlight","AREA_TYPE","HEADER_TYPE","CELL_TYPE","SelectionRange","CellCoords","isPressedCtrlKey","createObjectPropListener","mixin","isUndefined","arrayEach","localHooks","Transformation","detectSelectionType","isValidCoord","normalizeSelectionFactory","SELECTION_TYPE_EMPTY","SELECTION_TYPE_UNRECOGNIZED","toSingleLine","Selection","settings","tableProps","_this","inProgress","selectedByCorner","selectedByRowHeader","Set","selectedByColumnHeader","selectedRange","highlight","headerClassName","currentHeaderClassName","activeHeaderClassName","rowClassName","currentRowClassName","columnClassName","currentColClassName","disabledCellSelection","row","column","isDisabledCellSelection","cellCornerVisible","isCellCornerVisible","apply","arguments","areaCornerVisible","isAreaCornerVisible","visualToRenderableCoords","coords","renderableToVisualCoords","transformation","countRows","countRowsTranslated","countCols","countColsTranslated","fixedRowsBottom","minSpareRows","minSpareCols","autoWrapRow","autoWrapCol","addLocalHook","_len","args","_key","runLocalHooks","concat","_len2","_key2","_len3","_key3","_len4","_key4","_len5","_key5","_len6","_key6","getSelectedRange","begin","finish","isInProgress","setRangeStart","multipleSelection","fragment","undefined","isMultipleMode","selectionMode","isMultipleSelection","isRowNegative","isColumnNegative","col","coordsClone","clone","clear","add","getLayerLevel","setRangeEnd","setRangeStartOnly","isEmpty","cellRange","current","setTo","getCell","isEnabledFor","commit","adjustCoordinates","layerLevel","getAreas","getHeaders","getActiveHeaders","useLayerLevel","areaHighlight","createOrGetArea","headerHighlight","createOrGetHeader","activeHeaderHighlight","createOrGetActiveHeader","isMultiple","to","previousRange","previous","areAnyRowsRendered","areAnyColumnsRendered","headerCellRange","isSelectedByAnyHeader","normalize","isEntireRowSelected","isRowSelected","getWidth","isEntireColumnSelected","isColumnSelected","getHeight","isMultipleListener","isSingle","transformStart","rowDelta","colDelta","force","transformEnd","size","isSelected","isSelectedByRowHeader","isSelectedByCorner","has","isSelectedByColumnHeader","inInSelection","includes","fillHandle","isEditorOpened","Number","isInteger","deselect","selectAll","includeRowHeaders","includeColumnHeaders","nrOfRows","nrOfColumns","startCoords","selectCells","selectionRanges","_this2","selectionType","Error","selectionSchemaNormalizer","propToCol","prop","keepDirection","isValid","some","selection","_selectionSchemaNorma","_selectionSchemaNorma2","rowStart","columnStart","rowEnd","columnEnd","_isValid","_selectionSchemaNorma3","_selectionSchemaNorma4","selectColumns","startColumn","endColumn","headerLevel","start","end","selectRows","startRow","endRow","refresh","customSelections","getCustomSelections","forEach","customSelection","cellHighlight","currentLayer"],"sources":["/Users/priyadeliwala/Desktop/sales-dashboard/node_modules/handsontable/selection/selection.mjs"],"sourcesContent":["import \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.object.freeze.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\n\nvar _templateObject;\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/es.number.is-integer.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nimport Highlight from \"./highlight/highlight.mjs\";\nimport { AREA_TYPE, HEADER_TYPE, CELL_TYPE } from \"./highlight/constants.mjs\";\nimport SelectionRange from \"./range.mjs\";\nimport { CellCoords } from \"./../3rdparty/walkontable/src/index.mjs\";\nimport { isPressedCtrlKey } from \"./../utils/keyStateObserver.mjs\";\nimport { createObjectPropListener, mixin } from \"./../helpers/object.mjs\";\nimport { isUndefined } from \"./../helpers/mixed.mjs\";\nimport { arrayEach } from \"./../helpers/array.mjs\";\nimport localHooks from \"./../mixins/localHooks.mjs\";\nimport Transformation from \"./transformation.mjs\";\nimport { detectSelectionType, isValidCoord, normalizeSelectionFactory, SELECTION_TYPE_EMPTY, SELECTION_TYPE_UNRECOGNIZED } from \"./utils.mjs\";\nimport { toSingleLine } from \"./../helpers/templateLiteralTag.mjs\";\n/**\n * @class Selection\n * @util\n */\n\nvar Selection = /*#__PURE__*/function () {\n  function Selection(settings, tableProps) {\n    var _this = this;\n\n    _classCallCheck(this, Selection);\n\n    /**\n     * Handsontable settings instance.\n     *\n     * @type {GridSettings}\n     */\n    this.settings = settings;\n    /**\n     * An additional object with dynamically defined properties which describes table state.\n     *\n     * @type {object}\n     */\n\n    this.tableProps = tableProps;\n    /**\n     * The flag which determines if the selection is in progress.\n     *\n     * @type {boolean}\n     */\n\n    this.inProgress = false;\n    /**\n     * The flag indicates that selection was performed by clicking the corner overlay.\n     *\n     * @type {boolean}\n     */\n\n    this.selectedByCorner = false;\n    /**\n     * The collection of the selection layer levels where the whole row was selected using the row header or\n     * the corner header.\n     *\n     * @type {Set.<number>}\n     */\n\n    this.selectedByRowHeader = new Set();\n    /**\n     * The collection of the selection layer levels where the whole column was selected using the column header or\n     * the corner header.\n     *\n     * @type {Set.<number>}\n     */\n\n    this.selectedByColumnHeader = new Set();\n    /**\n     * Selection data layer (handle visual coordinates).\n     *\n     * @type {SelectionRange}\n     */\n\n    this.selectedRange = new SelectionRange();\n    /**\n     * Visualization layer.\n     *\n     * @type {Highlight}\n     */\n\n    this.highlight = new Highlight({\n      headerClassName: settings.currentHeaderClassName,\n      activeHeaderClassName: settings.activeHeaderClassName,\n      rowClassName: settings.currentRowClassName,\n      columnClassName: settings.currentColClassName,\n      disabledCellSelection: function disabledCellSelection(row, column) {\n        return _this.tableProps.isDisabledCellSelection(row, column);\n      },\n      cellCornerVisible: function cellCornerVisible() {\n        return _this.isCellCornerVisible.apply(_this, arguments);\n      },\n      areaCornerVisible: function areaCornerVisible() {\n        return _this.isAreaCornerVisible.apply(_this, arguments);\n      },\n      visualToRenderableCoords: function visualToRenderableCoords(coords) {\n        return _this.tableProps.visualToRenderableCoords(coords);\n      },\n      renderableToVisualCoords: function renderableToVisualCoords(coords) {\n        return _this.tableProps.renderableToVisualCoords(coords);\n      }\n    });\n    /**\n     * The module for modifying coordinates.\n     *\n     * @type {Transformation}\n     */\n\n    this.transformation = new Transformation(this.selectedRange, {\n      countRows: function countRows() {\n        return _this.tableProps.countRowsTranslated();\n      },\n      countCols: function countCols() {\n        return _this.tableProps.countColsTranslated();\n      },\n      visualToRenderableCoords: function visualToRenderableCoords(coords) {\n        return _this.tableProps.visualToRenderableCoords(coords);\n      },\n      renderableToVisualCoords: function renderableToVisualCoords(coords) {\n        return _this.tableProps.renderableToVisualCoords(coords);\n      },\n      fixedRowsBottom: function fixedRowsBottom() {\n        return settings.fixedRowsBottom;\n      },\n      minSpareRows: function minSpareRows() {\n        return settings.minSpareRows;\n      },\n      minSpareCols: function minSpareCols() {\n        return settings.minSpareCols;\n      },\n      autoWrapRow: function autoWrapRow() {\n        return settings.autoWrapRow;\n      },\n      autoWrapCol: function autoWrapCol() {\n        return settings.autoWrapCol;\n      }\n    });\n    this.transformation.addLocalHook('beforeTransformStart', function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return _this.runLocalHooks.apply(_this, ['beforeModifyTransformStart'].concat(args));\n    });\n    this.transformation.addLocalHook('afterTransformStart', function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return _this.runLocalHooks.apply(_this, ['afterModifyTransformStart'].concat(args));\n    });\n    this.transformation.addLocalHook('beforeTransformEnd', function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      return _this.runLocalHooks.apply(_this, ['beforeModifyTransformEnd'].concat(args));\n    });\n    this.transformation.addLocalHook('afterTransformEnd', function () {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n\n      return _this.runLocalHooks.apply(_this, ['afterModifyTransformEnd'].concat(args));\n    });\n    this.transformation.addLocalHook('insertRowRequire', function () {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n\n      return _this.runLocalHooks.apply(_this, ['insertRowRequire'].concat(args));\n    });\n    this.transformation.addLocalHook('insertColRequire', function () {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n\n      return _this.runLocalHooks.apply(_this, ['insertColRequire'].concat(args));\n    });\n  }\n  /**\n   * Get data layer for current selection.\n   *\n   * @returns {SelectionRange}\n   */\n\n\n  _createClass(Selection, [{\n    key: \"getSelectedRange\",\n    value: function getSelectedRange() {\n      return this.selectedRange;\n    }\n    /**\n     * Indicate that selection process began. It sets internaly `.inProgress` property to `true`.\n     */\n\n  }, {\n    key: \"begin\",\n    value: function begin() {\n      this.inProgress = true;\n    }\n    /**\n     * Indicate that selection process finished. It sets internaly `.inProgress` property to `false`.\n     */\n\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      this.runLocalHooks('afterSelectionFinished', Array.from(this.selectedRange));\n      this.inProgress = false;\n    }\n    /**\n     * Check if the process of selecting the cell/cells is in progress.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isInProgress\",\n    value: function isInProgress() {\n      return this.inProgress;\n    }\n    /**\n     * Starts selection range on given coordinate object.\n     *\n     * @param {CellCoords} coords Visual coords.\n     * @param {boolean} [multipleSelection] If `true`, selection will be worked in 'multiple' mode. This option works\n     *                                      only when 'selectionMode' is set as 'multiple'. If the argument is not defined\n     *                                      the default trigger will be used (isPressedCtrlKey() helper).\n     * @param {boolean} [fragment=false] If `true`, the selection will be treated as a partial selection where the\n     *                                   `setRangeEnd` method won't be called on every `setRangeStart` call.\n     */\n\n  }, {\n    key: \"setRangeStart\",\n    value: function setRangeStart(coords, multipleSelection) {\n      var fragment = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var isMultipleMode = this.settings.selectionMode === 'multiple';\n      var isMultipleSelection = isUndefined(multipleSelection) ? isPressedCtrlKey() : multipleSelection;\n      var isRowNegative = coords.row < 0;\n      var isColumnNegative = coords.col < 0;\n      var selectedByCorner = isRowNegative && isColumnNegative; // We are creating copy. We would like to modify just the start of the selection by below hook. Then original coords\n      // should be handled by next methods.\n\n      var coordsClone = coords.clone();\n      this.selectedByCorner = selectedByCorner;\n      this.runLocalHooks(\"beforeSetRangeStart\".concat(fragment ? 'Only' : ''), coordsClone);\n\n      if (!isMultipleMode || isMultipleMode && !isMultipleSelection && isUndefined(multipleSelection)) {\n        this.selectedRange.clear();\n      }\n\n      this.selectedRange.add(coordsClone);\n\n      if (this.getLayerLevel() === 0) {\n        this.selectedByRowHeader.clear();\n        this.selectedByColumnHeader.clear();\n      }\n\n      if (!selectedByCorner && isColumnNegative) {\n        this.selectedByRowHeader.add(this.getLayerLevel());\n      }\n\n      if (!selectedByCorner && isRowNegative) {\n        this.selectedByColumnHeader.add(this.getLayerLevel());\n      }\n\n      if (!fragment) {\n        this.setRangeEnd(coords);\n      }\n    }\n    /**\n     * Starts selection range on given coordinate object.\n     *\n     * @param {CellCoords} coords Visual coords.\n     * @param {boolean} [multipleSelection] If `true`, selection will be worked in 'multiple' mode. This option works\n     *                                      only when 'selectionMode' is set as 'multiple'. If the argument is not defined\n     *                                      the default trigger will be used (isPressedCtrlKey() helper).\n     */\n\n  }, {\n    key: \"setRangeStartOnly\",\n    value: function setRangeStartOnly(coords, multipleSelection) {\n      this.setRangeStart(coords, multipleSelection, true);\n    }\n    /**\n     * Ends selection range on given coordinate object.\n     *\n     * @param {CellCoords} coords Visual coords.\n     */\n\n  }, {\n    key: \"setRangeEnd\",\n    value: function setRangeEnd(coords) {\n      if (this.selectedRange.isEmpty()) {\n        return;\n      } // We are creating copy. We would like to modify just the end of the selection by below hook. Then original coords\n      // should be handled by next methods.\n\n\n      var coordsClone = coords.clone();\n      this.runLocalHooks('beforeSetRangeEnd', coordsClone);\n      this.begin();\n      var cellRange = this.selectedRange.current();\n\n      if (this.settings.selectionMode !== 'single') {\n        cellRange.setTo(new CellCoords(coordsClone.row, coordsClone.col));\n      } // Set up current selection.\n\n\n      this.highlight.getCell().clear();\n\n      if (this.highlight.isEnabledFor(CELL_TYPE, cellRange.highlight)) {\n        this.highlight.getCell().add(this.selectedRange.current().highlight).commit().adjustCoordinates(cellRange);\n      }\n\n      var layerLevel = this.getLayerLevel(); // If the next layer level is lower than previous then clear all area and header highlights. This is the\n      // indication that the new selection is performing.\n\n      if (layerLevel < this.highlight.layerLevel) {\n        arrayEach(this.highlight.getAreas(), function (highlight) {\n          return void highlight.clear();\n        });\n        arrayEach(this.highlight.getHeaders(), function (highlight) {\n          return void highlight.clear();\n        });\n        arrayEach(this.highlight.getActiveHeaders(), function (highlight) {\n          return void highlight.clear();\n        });\n      }\n\n      this.highlight.useLayerLevel(layerLevel);\n      var areaHighlight = this.highlight.createOrGetArea();\n      var headerHighlight = this.highlight.createOrGetHeader();\n      var activeHeaderHighlight = this.highlight.createOrGetActiveHeader();\n      areaHighlight.clear();\n      headerHighlight.clear();\n      activeHeaderHighlight.clear();\n\n      if (this.highlight.isEnabledFor(AREA_TYPE, cellRange.highlight) && (this.isMultiple() || layerLevel >= 1)) {\n        areaHighlight.add(cellRange.from).add(cellRange.to).commit();\n\n        if (layerLevel === 1) {\n          // For single cell selection in the same layer, we do not create area selection to prevent blue background.\n          // When non-consecutive selection is performed we have to add that missing area selection to the previous layer\n          // based on previous coordinates. It only occurs when the previous selection wasn't select multiple cells.\n          var previousRange = this.selectedRange.previous();\n          this.highlight.useLayerLevel(layerLevel - 1).createOrGetArea().add(previousRange.from).commit() // Range may start with hidden indexes. Commit would not found start point (as we add just the `from` coords).\n          .adjustCoordinates(previousRange);\n          this.highlight.useLayerLevel(layerLevel);\n        }\n      }\n\n      if (this.highlight.isEnabledFor(HEADER_TYPE, cellRange.highlight)) {\n        // The header selection generally contains cell selection. In a case when all rows (or columns)\n        // are hidden that visual coordinates are translated to renderable coordinates that do not exist.\n        // Hence no header highlight is generated. In that case, to make a column (or a row) header\n        // highlight, the row and column index has to point to the header (the negative value). See #7052.\n        var areAnyRowsRendered = this.tableProps.countRowsTranslated() === 0;\n        var areAnyColumnsRendered = this.tableProps.countColsTranslated() === 0;\n        var headerCellRange = cellRange;\n\n        if (areAnyRowsRendered || areAnyColumnsRendered) {\n          headerCellRange = cellRange.clone();\n        }\n\n        if (areAnyRowsRendered) {\n          headerCellRange.from.row = -1;\n        }\n\n        if (areAnyColumnsRendered) {\n          headerCellRange.from.col = -1;\n        }\n\n        if (this.settings.selectionMode === 'single') {\n          if (this.isSelectedByAnyHeader()) {\n            headerCellRange.from.normalize();\n          }\n\n          headerHighlight.add(headerCellRange.from).commit();\n        } else {\n          headerHighlight.add(headerCellRange.from).add(headerCellRange.to).commit();\n        }\n\n        if (this.isEntireRowSelected()) {\n          var isRowSelected = this.tableProps.countCols() === cellRange.getWidth(); // Make sure that the whole row is selected (in case where selectionMode is set to 'single')\n\n          if (isRowSelected) {\n            activeHeaderHighlight.add(new CellCoords(cellRange.from.row, -1)).add(new CellCoords(cellRange.to.row, -1)).commit();\n          }\n        }\n\n        if (this.isEntireColumnSelected()) {\n          var isColumnSelected = this.tableProps.countRows() === cellRange.getHeight(); // Make sure that the whole column is selected (in case where selectionMode is set to 'single')\n\n          if (isColumnSelected) {\n            activeHeaderHighlight.add(new CellCoords(-1, cellRange.from.col)).add(new CellCoords(-1, cellRange.to.col)).commit();\n          }\n        }\n      }\n\n      this.runLocalHooks('afterSetRangeEnd', coords);\n    }\n    /**\n     * Returns information if we have a multiselection. This method check multiselection only on the latest layer of\n     * the selection.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isMultiple\",\n    value: function isMultiple() {\n      var isMultipleListener = createObjectPropListener(!this.selectedRange.current().isSingle());\n      this.runLocalHooks('afterIsMultipleSelection', isMultipleListener);\n      return isMultipleListener.value;\n    }\n    /**\n     * Selects cell relative to the current cell (if possible).\n     *\n     * @param {number} rowDelta Rows number to move, value can be passed as negative number.\n     * @param {number} colDelta Columns number to move, value can be passed as negative number.\n     * @param {boolean} [force=false] If `true` the new rows/columns will be created if necessary. Otherwise, row/column will\n     *                        be created according to `minSpareRows/minSpareCols` settings of Handsontable.\n     */\n\n  }, {\n    key: \"transformStart\",\n    value: function transformStart(rowDelta, colDelta) {\n      var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      this.setRangeStart(this.transformation.transformStart(rowDelta, colDelta, force));\n    }\n    /**\n     * Sets selection end cell relative to the current selection end cell (if possible).\n     *\n     * @param {number} rowDelta Rows number to move, value can be passed as negative number.\n     * @param {number} colDelta Columns number to move, value can be passed as negative number.\n     */\n\n  }, {\n    key: \"transformEnd\",\n    value: function transformEnd(rowDelta, colDelta) {\n      this.setRangeEnd(this.transformation.transformEnd(rowDelta, colDelta));\n    }\n    /**\n     * Returns currently used layer level.\n     *\n     * @returns {number} Returns layer level starting from 0. If no selection was added to the table -1 is returned.\n     */\n\n  }, {\n    key: \"getLayerLevel\",\n    value: function getLayerLevel() {\n      return this.selectedRange.size() - 1;\n    }\n    /**\n     * Returns `true` if currently there is a selection on the screen, `false` otherwise.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isSelected\",\n    value: function isSelected() {\n      return !this.selectedRange.isEmpty();\n    }\n    /**\n     * Returns `true` if the selection was applied by clicking to the row header. If the `layerLevel`\n     * argument is passed then only that layer will be checked. Otherwise, it checks if any row header\n     * was clicked on any selection layer level.\n     *\n     * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isSelectedByRowHeader\",\n    value: function isSelectedByRowHeader() {\n      var layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n      return !this.isSelectedByCorner(layerLevel) && this.isEntireRowSelected(layerLevel);\n    }\n    /**\n     * Returns `true` if the selection consists of entire rows (including their headers). If the `layerLevel`\n     * argument is passed then only that layer will be checked. Otherwise, it checks the selection for all layers.\n     *\n     * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isEntireRowSelected\",\n    value: function isEntireRowSelected() {\n      var layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n      return layerLevel === -1 ? this.selectedByRowHeader.size > 0 : this.selectedByRowHeader.has(layerLevel);\n    }\n    /**\n     * Returns `true` if the selection was applied by clicking to the column header. If the `layerLevel`\n     * argument is passed then only that layer will be checked. Otherwise, it checks if any column header\n     * was clicked on any selection layer level.\n     *\n     * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isSelectedByColumnHeader\",\n    value: function isSelectedByColumnHeader() {\n      var layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n      return !this.isSelectedByCorner() && this.isEntireColumnSelected(layerLevel);\n    }\n    /**\n     * Returns `true` if the selection consists of entire columns (including their headers). If the `layerLevel`\n     * argument is passed then only that layer will be checked. Otherwise, it checks the selection for all layers.\n     *\n     * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isEntireColumnSelected\",\n    value: function isEntireColumnSelected() {\n      var layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();\n      return layerLevel === -1 ? this.selectedByColumnHeader.size > 0 : this.selectedByColumnHeader.has(layerLevel);\n    }\n    /**\n     * Returns `true` if the selection was applied by clicking on the row or column header on any layer level.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isSelectedByAnyHeader\",\n    value: function isSelectedByAnyHeader() {\n      return this.isSelectedByRowHeader(-1) || this.isSelectedByColumnHeader(-1) || this.isSelectedByCorner();\n    }\n    /**\n     * Returns `true` if the selection was applied by clicking on the left-top corner overlay.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isSelectedByCorner\",\n    value: function isSelectedByCorner() {\n      return this.selectedByCorner;\n    }\n    /**\n     * Returns `true` if coords is within selection coords. This method iterates through all selection layers to check if\n     * the coords object is within selection range.\n     *\n     * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"inInSelection\",\n    value: function inInSelection(coords) {\n      return this.selectedRange.includes(coords);\n    }\n    /**\n     * Returns `true` if the cell corner should be visible.\n     *\n     * @private\n     * @returns {boolean} `true` if the corner element has to be visible, `false` otherwise.\n     */\n\n  }, {\n    key: \"isCellCornerVisible\",\n    value: function isCellCornerVisible() {\n      return this.settings.fillHandle && !this.tableProps.isEditorOpened() && !this.isMultiple();\n    }\n    /**\n     * Returns `true` if the area corner should be visible.\n     *\n     * @param {number} layerLevel The layer level.\n     * @returns {boolean} `true` if the corner element has to be visible, `false` otherwise.\n     */\n\n  }, {\n    key: \"isAreaCornerVisible\",\n    value: function isAreaCornerVisible(layerLevel) {\n      if (Number.isInteger(layerLevel) && layerLevel !== this.getLayerLevel()) {\n        return false;\n      }\n\n      return this.settings.fillHandle && !this.tableProps.isEditorOpened() && this.isMultiple();\n    }\n    /**\n     * Clear the selection by resetting the collected ranges and highlights.\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      // TODO: collections selectedByColumnHeader and selectedByRowHeader should be clear too.\n      this.selectedRange.clear();\n      this.highlight.clear();\n    }\n    /**\n     * Deselects all selected cells.\n     */\n\n  }, {\n    key: \"deselect\",\n    value: function deselect() {\n      if (!this.isSelected()) {\n        return;\n      }\n\n      this.inProgress = false;\n      this.clear();\n      this.runLocalHooks('afterDeselect');\n    }\n    /**\n     * Select all cells.\n     *\n     * @param {boolean} [includeRowHeaders=false] `true` If the selection should include the row headers, `false`\n     * otherwise.\n     * @param {boolean} [includeColumnHeaders=false] `true` If the selection should include the column headers, `false`\n     * otherwise.\n     */\n\n  }, {\n    key: \"selectAll\",\n    value: function selectAll() {\n      var includeRowHeaders = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var includeColumnHeaders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var nrOfRows = this.tableProps.countRows();\n      var nrOfColumns = this.tableProps.countCols(); // We can't select cells when there is no data.\n\n      if (!includeRowHeaders && !includeColumnHeaders && (nrOfRows === 0 || nrOfColumns === 0)) {\n        return;\n      }\n\n      var startCoords = new CellCoords(includeColumnHeaders ? -1 : 0, includeRowHeaders ? -1 : 0);\n      this.clear();\n      this.setRangeStartOnly(startCoords);\n      this.selectedByRowHeader.add(this.getLayerLevel());\n      this.selectedByColumnHeader.add(this.getLayerLevel());\n      this.setRangeEnd(new CellCoords(nrOfRows - 1, nrOfColumns - 1));\n      this.finish();\n    }\n    /**\n     * Make multiple, non-contiguous selection specified by `row` and `column` values or a range of cells\n     * finishing at `endRow`, `endColumn`. The method supports two input formats, first as an array of arrays such\n     * as `[[rowStart, columnStart, rowEnd, columnEnd]]` and second format as an array of CellRange objects.\n     * If the passed ranges have another format the exception will be thrown.\n     *\n     * @param {Array[]|CellRange[]} selectionRanges The coordinates which define what the cells should be selected.\n     * @returns {boolean} Returns `true` if selection was successful, `false` otherwise.\n     */\n\n  }, {\n    key: \"selectCells\",\n    value: function selectCells(selectionRanges) {\n      var _this2 = this;\n\n      var selectionType = detectSelectionType(selectionRanges);\n\n      if (selectionType === SELECTION_TYPE_EMPTY) {\n        return false;\n      } else if (selectionType === SELECTION_TYPE_UNRECOGNIZED) {\n        throw new Error(toSingleLine(_templateObject || (_templateObject = _taggedTemplateLiteral([\"Unsupported format of the selection ranges was passed. To select cells pass \\n        the coordinates as an array of arrays ([[rowStart, columnStart/columnPropStart, rowEnd, \\n        columnEnd/columnPropEnd]]) or as an array of CellRange objects.\"], [\"Unsupported format of the selection ranges was passed. To select cells pass\\\\x20\\n        the coordinates as an array of arrays ([[rowStart, columnStart/columnPropStart, rowEnd,\\\\x20\\n        columnEnd/columnPropEnd]]) or as an array of CellRange objects.\"]))));\n      }\n\n      var selectionSchemaNormalizer = normalizeSelectionFactory(selectionType, {\n        propToCol: function propToCol(prop) {\n          return _this2.tableProps.propToCol(prop);\n        },\n        keepDirection: true\n      });\n      var nrOfRows = this.tableProps.countRows();\n      var nrOfColumns = this.tableProps.countCols(); // Check if every layer of the coordinates are valid.\n\n      var isValid = !selectionRanges.some(function (selection) {\n        var _selectionSchemaNorma = selectionSchemaNormalizer(selection),\n            _selectionSchemaNorma2 = _slicedToArray(_selectionSchemaNorma, 4),\n            rowStart = _selectionSchemaNorma2[0],\n            columnStart = _selectionSchemaNorma2[1],\n            rowEnd = _selectionSchemaNorma2[2],\n            columnEnd = _selectionSchemaNorma2[3];\n\n        var _isValid = isValidCoord(rowStart, nrOfRows) && isValidCoord(columnStart, nrOfColumns) && isValidCoord(rowEnd, nrOfRows) && isValidCoord(columnEnd, nrOfColumns);\n\n        return !_isValid;\n      });\n\n      if (isValid) {\n        this.clear();\n        arrayEach(selectionRanges, function (selection) {\n          var _selectionSchemaNorma3 = selectionSchemaNormalizer(selection),\n              _selectionSchemaNorma4 = _slicedToArray(_selectionSchemaNorma3, 4),\n              rowStart = _selectionSchemaNorma4[0],\n              columnStart = _selectionSchemaNorma4[1],\n              rowEnd = _selectionSchemaNorma4[2],\n              columnEnd = _selectionSchemaNorma4[3];\n\n          _this2.setRangeStartOnly(new CellCoords(rowStart, columnStart), false);\n\n          _this2.setRangeEnd(new CellCoords(rowEnd, columnEnd));\n\n          _this2.finish();\n        });\n      }\n\n      return isValid;\n    }\n    /**\n     * Select column specified by `startColumn` visual index or column property or a range of columns finishing at\n     * `endColumn`.\n     *\n     * @param {number|string} startColumn Visual column index or column property from which the selection starts.\n     * @param {number|string} [endColumn] Visual column index or column property from to the selection finishes.\n     * @param {number} [headerLevel=-1] A row header index that triggers the column selection. The value can\n     *                                  take -1 to -N, where -1 means the header closest to the cells.\n     *\n     * @returns {boolean} Returns `true` if selection was successful, `false` otherwise.\n     */\n\n  }, {\n    key: \"selectColumns\",\n    value: function selectColumns(startColumn) {\n      var endColumn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startColumn;\n      var headerLevel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n      var start = typeof startColumn === 'string' ? this.tableProps.propToCol(startColumn) : startColumn;\n      var end = typeof endColumn === 'string' ? this.tableProps.propToCol(endColumn) : endColumn;\n      var nrOfColumns = this.tableProps.countCols();\n      var nrOfRows = this.tableProps.countRows();\n      var isValid = isValidCoord(start, nrOfColumns) && isValidCoord(end, nrOfColumns);\n\n      if (isValid) {\n        this.setRangeStartOnly(new CellCoords(headerLevel, start));\n        this.setRangeEnd(new CellCoords(nrOfRows - 1, end));\n        this.finish();\n      }\n\n      return isValid;\n    }\n    /**\n     * Select row specified by `startRow` visual index or a range of rows finishing at `endRow`.\n     *\n     * @param {number} startRow Visual row index from which the selection starts.\n     * @param {number} [endRow] Visual row index from to the selection finishes.\n     * @param {number} [headerLevel=-1] A column header index that triggers the row selection.\n     *                                  The value can take -1 to -N, where -1 means the header\n     *                                  closest to the cells.\n     * @returns {boolean} Returns `true` if selection was successful, `false` otherwise.\n     */\n\n  }, {\n    key: \"selectRows\",\n    value: function selectRows(startRow) {\n      var endRow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startRow;\n      var headerLevel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n      var nrOfRows = this.tableProps.countRows();\n      var nrOfColumns = this.tableProps.countCols();\n      var isValid = isValidCoord(startRow, nrOfRows) && isValidCoord(endRow, nrOfRows);\n\n      if (isValid) {\n        this.setRangeStartOnly(new CellCoords(startRow, headerLevel));\n        this.setRangeEnd(new CellCoords(endRow, nrOfColumns - 1));\n        this.finish();\n      }\n\n      return isValid;\n    }\n    /**\n     * Rewrite the rendered state of the selection as visual selection may have a new representation in the DOM.\n     */\n\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      var customSelections = this.highlight.getCustomSelections();\n      customSelections.forEach(function (customSelection) {\n        customSelection.commit();\n      });\n\n      if (!this.isSelected()) {\n        return;\n      }\n\n      var cellHighlight = this.highlight.getCell();\n      var currentLayer = this.getLayerLevel();\n      cellHighlight.commit().adjustCoordinates(this.selectedRange.current()); // Rewriting rendered ranges going through all layers.\n\n      for (var layerLevel = 0; layerLevel < this.selectedRange.size(); layerLevel += 1) {\n        this.highlight.useLayerLevel(layerLevel);\n        var areaHighlight = this.highlight.createOrGetArea();\n        var headerHighlight = this.highlight.createOrGetHeader();\n        var activeHeaderHighlight = this.highlight.createOrGetActiveHeader();\n        areaHighlight.commit();\n        headerHighlight.commit();\n        activeHeaderHighlight.commit();\n      } // Reverting starting layer for the Highlight.\n\n\n      this.highlight.useLayerLevel(currentLayer);\n    }\n  }]);\n\n  return Selection;\n}();\n\nmixin(Selection, localHooks);\nexport default Selection;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}