{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nimport { getScrollableElement, getTrimmingContainer } from \"./../../../../helpers/dom/element.mjs\";\nimport { defineGetter } from \"./../../../../helpers/object.mjs\";\nimport { arrayEach } from \"./../../../../helpers/array.mjs\";\nimport { warn } from \"./../../../../helpers/console.mjs\";\nimport EventManager from \"./../../../../eventManager.mjs\";\nimport { CLONE_TYPES, CLONE_TOP, CLONE_LEFT } from \"./constants.mjs\";\n/**\n * Creates an overlay over the original Walkontable instance. The overlay renders the clone of the original Walkontable\n * and (optionally) implements behavior needed for native horizontal and vertical scrolling.\n *\n * @class Overlay\n */\n\nexport var Overlay = /*#__PURE__*/function () {\n  /**\n   * @param {Walkontable} wotInstance The Walkontable instance.\n   */\n  function Overlay(wotInstance) {\n    _classCallCheck(this, Overlay);\n    defineGetter(this, 'wot', wotInstance, {\n      writable: false\n    });\n    var _this$wot$wtTable = this.wot.wtTable,\n      TABLE = _this$wot$wtTable.TABLE,\n      hider = _this$wot$wtTable.hider,\n      spreader = _this$wot$wtTable.spreader,\n      holder = _this$wot$wtTable.holder,\n      wtRootElement = _this$wot$wtTable.wtRootElement; // legacy support, deprecated in the future\n\n    this.instance = this.wot;\n    this.type = '';\n    this.mainTableScrollableElement = null;\n    this.TABLE = TABLE;\n    this.hider = hider;\n    this.spreader = spreader;\n    this.holder = holder;\n    this.wtRootElement = wtRootElement;\n    this.trimmingContainer = getTrimmingContainer(this.hider.parentNode.parentNode);\n    this.updateStateOfRendering();\n  }\n  /**\n   * Update internal state of object with an information about the need of full rendering of the overlay.\n   *\n   * @returns {boolean} Returns `true` if the state has changed since the last check.\n   */\n\n  _createClass(Overlay, [{\n    key: \"updateStateOfRendering\",\n    value: function updateStateOfRendering() {\n      var previousState = this.needFullRender;\n      this.needFullRender = this.shouldBeRendered();\n      var changed = previousState !== this.needFullRender;\n      if (changed && !this.needFullRender) {\n        this.reset();\n      }\n      return changed;\n    }\n    /**\n     * Checks if overlay should be fully rendered.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"shouldBeRendered\",\n    value: function shouldBeRendered() {\n      return true;\n    }\n    /**\n     * Update the trimming container.\n     */\n  }, {\n    key: \"updateTrimmingContainer\",\n    value: function updateTrimmingContainer() {\n      this.trimmingContainer = getTrimmingContainer(this.hider.parentNode.parentNode);\n    }\n    /**\n     * Update the main scrollable element.\n     */\n  }, {\n    key: \"updateMainScrollableElement\",\n    value: function updateMainScrollableElement() {\n      var _this$wot = this.wot,\n        wtTable = _this$wot.wtTable,\n        rootWindow = _this$wot.rootWindow;\n      if (rootWindow.getComputedStyle(wtTable.wtRootElement.parentNode).getPropertyValue('overflow') === 'hidden') {\n        this.mainTableScrollableElement = this.wot.wtTable.holder;\n      } else {\n        this.mainTableScrollableElement = getScrollableElement(wtTable.TABLE);\n      }\n    }\n    /**\n     * Calculates coordinates of the provided element, relative to the root Handsontable element.\n     * NOTE: The element needs to be a child of the overlay in order for the method to work correctly.\n     *\n     * @param {HTMLElement} element The cell element to calculate the position for.\n     * @param {number} rowIndex Visual row index.\n     * @param {number} columnIndex Visual column index.\n     * @returns {{top: number, left: number}|undefined}\n     */\n  }, {\n    key: \"getRelativeCellPosition\",\n    value: function getRelativeCellPosition(element, rowIndex, columnIndex) {\n      if (this.clone.wtTable.holder.contains(element) === false) {\n        warn(\"The provided element is not a child of the \".concat(this.type, \" overlay\"));\n        return;\n      }\n      var windowScroll = this.mainTableScrollableElement === this.wot.rootWindow;\n      var fixedColumn = columnIndex < this.wot.getSetting('fixedColumnsLeft');\n      var fixedRowTop = rowIndex < this.wot.getSetting('fixedRowsTop');\n      var fixedRowBottom = rowIndex >= this.wot.getSetting('totalRows') - this.wot.getSetting('fixedRowsBottom');\n      var spreaderOffset = {\n        left: this.clone.wtTable.spreader.offsetLeft,\n        top: this.clone.wtTable.spreader.offsetTop\n      };\n      var elementOffset = {\n        left: element.offsetLeft,\n        top: element.offsetTop\n      };\n      var offsetObject = null;\n      if (windowScroll) {\n        offsetObject = this.getRelativeCellPositionWithinWindow(fixedRowTop, fixedColumn, elementOffset, spreaderOffset);\n      } else {\n        offsetObject = this.getRelativeCellPositionWithinHolder(fixedRowTop, fixedRowBottom, fixedColumn, elementOffset, spreaderOffset);\n      }\n      return offsetObject;\n    }\n    /**\n     * Calculates coordinates of the provided element, relative to the root Handsontable element within a table with window\n     * as a scrollable element.\n     *\n     * @private\n     * @param {boolean} onFixedRowTop `true` if the coordinates point to a place within the top fixed rows.\n     * @param {boolean} onFixedColumn `true` if the coordinates point to a place within the fixed columns.\n     * @param {number} elementOffset Offset position of the cell element.\n     * @param {number} spreaderOffset Offset position of the spreader element.\n     * @returns {{top: number, left: number}}\n     */\n  }, {\n    key: \"getRelativeCellPositionWithinWindow\",\n    value: function getRelativeCellPositionWithinWindow(onFixedRowTop, onFixedColumn, elementOffset, spreaderOffset) {\n      var absoluteRootElementPosition = this.wot.wtTable.wtRootElement.getBoundingClientRect();\n      var horizontalOffset = 0;\n      var verticalOffset = 0;\n      if (!onFixedColumn) {\n        horizontalOffset = spreaderOffset.left;\n      } else {\n        horizontalOffset = absoluteRootElementPosition.left <= 0 ? -1 * absoluteRootElementPosition.left : 0;\n      }\n      if (onFixedRowTop) {\n        var absoluteOverlayPosition = this.clone.wtTable.TABLE.getBoundingClientRect();\n        verticalOffset = absoluteOverlayPosition.top - absoluteRootElementPosition.top;\n      } else {\n        verticalOffset = spreaderOffset.top;\n      }\n      return {\n        left: elementOffset.left + horizontalOffset,\n        top: elementOffset.top + verticalOffset\n      };\n    }\n    /**\n     * Calculates coordinates of the provided element, relative to the root Handsontable element within a table with window\n     * as a scrollable element.\n     *\n     * @private\n     * @param {boolean} onFixedRowTop `true` if the coordinates point to a place within the top fixed rows.\n     * @param {boolean} onFixedRowBottom `true` if the coordinates point to a place within the bottom fixed rows.\n     * @param {boolean} onFixedColumn `true` if the coordinates point to a place within the fixed columns.\n     * @param {number} elementOffset Offset position of the cell element.\n     * @param {number} spreaderOffset Offset position of the spreader element.\n     * @returns {{top: number, left: number}}\n     */\n  }, {\n    key: \"getRelativeCellPositionWithinHolder\",\n    value: function getRelativeCellPositionWithinHolder(onFixedRowTop, onFixedRowBottom, onFixedColumn, elementOffset, spreaderOffset) {\n      var tableScrollPosition = {\n        horizontal: this.clone.cloneSource.wtOverlays.leftOverlay.getScrollPosition(),\n        vertical: this.clone.cloneSource.wtOverlays.topOverlay.getScrollPosition()\n      };\n      var horizontalOffset = 0;\n      var verticalOffset = 0;\n      if (!onFixedColumn) {\n        horizontalOffset = tableScrollPosition.horizontal - spreaderOffset.left;\n      }\n      if (onFixedRowBottom) {\n        var absoluteRootElementPosition = this.wot.wtTable.wtRootElement.getBoundingClientRect();\n        var absoluteOverlayPosition = this.clone.wtTable.TABLE.getBoundingClientRect();\n        verticalOffset = absoluteOverlayPosition.top * -1 + absoluteRootElementPosition.top;\n      } else if (!onFixedRowTop) {\n        verticalOffset = tableScrollPosition.vertical - spreaderOffset.top;\n      }\n      return {\n        left: elementOffset.left - horizontalOffset,\n        top: elementOffset.top - verticalOffset\n      };\n    }\n    /**\n     * Make a clone of table for overlay.\n     *\n     * @param {string} direction Can be `Overlay.CLONE_TOP`, `Overlay.CLONE_LEFT`,\n     *                           `Overlay.CLONE_TOP_LEFT_CORNER`.\n     * @returns {Walkontable}\n     */\n  }, {\n    key: \"makeClone\",\n    value: function makeClone(direction) {\n      if (CLONE_TYPES.indexOf(direction) === -1) {\n        throw new Error(\"Clone type \\\"\".concat(direction, \"\\\" is not supported.\"));\n      }\n      var _this$wot2 = this.wot,\n        wtTable = _this$wot2.wtTable,\n        rootDocument = _this$wot2.rootDocument,\n        rootWindow = _this$wot2.rootWindow;\n      var clone = rootDocument.createElement('DIV');\n      var clonedTable = rootDocument.createElement('TABLE');\n      var tableParent = wtTable.wtRootElement.parentNode;\n      clone.className = \"ht_clone_\".concat(direction, \" handsontable\");\n      clone.style.position = 'absolute';\n      clone.style.top = 0;\n      clone.style.left = 0;\n      clone.style.overflow = 'visible';\n      clonedTable.className = wtTable.TABLE.className;\n      clone.appendChild(clonedTable);\n      this.type = direction;\n      tableParent.appendChild(clone);\n      var preventOverflow = this.wot.getSetting('preventOverflow');\n      if (preventOverflow === true || preventOverflow === 'horizontal' && this.type === CLONE_TOP || preventOverflow === 'vertical' && this.type === CLONE_LEFT) {\n        this.mainTableScrollableElement = rootWindow;\n      } else if (rootWindow.getComputedStyle(tableParent).getPropertyValue('overflow') === 'hidden') {\n        this.mainTableScrollableElement = wtTable.holder;\n      } else {\n        this.mainTableScrollableElement = getScrollableElement(wtTable.TABLE);\n      } // Create a new instance of the Walkontable class\n\n      return new this.wot.constructor({\n        cloneSource: this.wot,\n        cloneOverlay: this,\n        table: clonedTable\n      });\n    }\n    /**\n     * Refresh/Redraw overlay.\n     *\n     * @param {boolean} [fastDraw=false] When `true`, try to refresh only the positions of borders without rerendering\n     *                                   the data. It will only work if Table.draw() does not force\n     *                                   rendering anyway.\n     */\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      var fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      // When hot settings are changed we allow to refresh overlay once before blocking\n      var nextCycleRenderFlag = this.shouldBeRendered();\n      if (this.clone && (this.needFullRender || nextCycleRenderFlag)) {\n        this.clone.draw(fastDraw);\n      }\n      this.needFullRender = nextCycleRenderFlag;\n    }\n    /**\n     * Reset overlay styles to initial values.\n     */\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      if (!this.clone) {\n        return;\n      }\n      var holder = this.clone.wtTable.holder;\n      var hider = this.clone.wtTable.hider;\n      var holderStyle = holder.style;\n      var hidderStyle = hider.style;\n      var rootStyle = holder.parentNode.style;\n      arrayEach([holderStyle, hidderStyle, rootStyle], function (style) {\n        style.width = '';\n        style.height = '';\n      });\n    }\n    /**\n     * Destroy overlay instance.\n     */\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      new EventManager(this.clone).destroy();\n    }\n  }]);\n  return Overlay;\n}();","map":{"version":3,"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","getScrollableElement","getTrimmingContainer","defineGetter","arrayEach","warn","EventManager","CLONE_TYPES","CLONE_TOP","CLONE_LEFT","Overlay","wotInstance","_this$wot$wtTable","wot","wtTable","TABLE","hider","spreader","holder","wtRootElement","type","mainTableScrollableElement","trimmingContainer","parentNode","updateStateOfRendering","value","previousState","needFullRender","shouldBeRendered","changed","reset","updateTrimmingContainer","updateMainScrollableElement","_this$wot","rootWindow","getComputedStyle","getPropertyValue","getRelativeCellPosition","element","rowIndex","columnIndex","clone","contains","concat","windowScroll","fixedColumn","getSetting","fixedRowTop","fixedRowBottom","spreaderOffset","left","offsetLeft","top","offsetTop","elementOffset","offsetObject","getRelativeCellPositionWithinWindow","getRelativeCellPositionWithinHolder","onFixedRowTop","onFixedColumn","absoluteRootElementPosition","getBoundingClientRect","horizontalOffset","verticalOffset","absoluteOverlayPosition","onFixedRowBottom","tableScrollPosition","horizontal","cloneSource","wtOverlays","leftOverlay","getScrollPosition","vertical","topOverlay","makeClone","direction","indexOf","Error","_this$wot2","rootDocument","createElement","clonedTable","tableParent","className","style","position","overflow","appendChild","preventOverflow","constructor","cloneOverlay","table","refresh","fastDraw","arguments","undefined","nextCycleRenderFlag","draw","holderStyle","hidderStyle","rootStyle","width","height","destroy"],"sources":["/Users/priyadeliwala/Desktop/sales-dashboard/node_modules/handsontable/3rdparty/walkontable/src/overlay/_base.mjs"],"sourcesContent":["import \"core-js/modules/es.array.index-of.js\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nimport { getScrollableElement, getTrimmingContainer } from \"./../../../../helpers/dom/element.mjs\";\nimport { defineGetter } from \"./../../../../helpers/object.mjs\";\nimport { arrayEach } from \"./../../../../helpers/array.mjs\";\nimport { warn } from \"./../../../../helpers/console.mjs\";\nimport EventManager from \"./../../../../eventManager.mjs\";\nimport { CLONE_TYPES, CLONE_TOP, CLONE_LEFT } from \"./constants.mjs\";\n/**\n * Creates an overlay over the original Walkontable instance. The overlay renders the clone of the original Walkontable\n * and (optionally) implements behavior needed for native horizontal and vertical scrolling.\n *\n * @class Overlay\n */\n\nexport var Overlay = /*#__PURE__*/function () {\n  /**\n   * @param {Walkontable} wotInstance The Walkontable instance.\n   */\n  function Overlay(wotInstance) {\n    _classCallCheck(this, Overlay);\n\n    defineGetter(this, 'wot', wotInstance, {\n      writable: false\n    });\n    var _this$wot$wtTable = this.wot.wtTable,\n        TABLE = _this$wot$wtTable.TABLE,\n        hider = _this$wot$wtTable.hider,\n        spreader = _this$wot$wtTable.spreader,\n        holder = _this$wot$wtTable.holder,\n        wtRootElement = _this$wot$wtTable.wtRootElement; // legacy support, deprecated in the future\n\n    this.instance = this.wot;\n    this.type = '';\n    this.mainTableScrollableElement = null;\n    this.TABLE = TABLE;\n    this.hider = hider;\n    this.spreader = spreader;\n    this.holder = holder;\n    this.wtRootElement = wtRootElement;\n    this.trimmingContainer = getTrimmingContainer(this.hider.parentNode.parentNode);\n    this.updateStateOfRendering();\n  }\n  /**\n   * Update internal state of object with an information about the need of full rendering of the overlay.\n   *\n   * @returns {boolean} Returns `true` if the state has changed since the last check.\n   */\n\n\n  _createClass(Overlay, [{\n    key: \"updateStateOfRendering\",\n    value: function updateStateOfRendering() {\n      var previousState = this.needFullRender;\n      this.needFullRender = this.shouldBeRendered();\n      var changed = previousState !== this.needFullRender;\n\n      if (changed && !this.needFullRender) {\n        this.reset();\n      }\n\n      return changed;\n    }\n    /**\n     * Checks if overlay should be fully rendered.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"shouldBeRendered\",\n    value: function shouldBeRendered() {\n      return true;\n    }\n    /**\n     * Update the trimming container.\n     */\n\n  }, {\n    key: \"updateTrimmingContainer\",\n    value: function updateTrimmingContainer() {\n      this.trimmingContainer = getTrimmingContainer(this.hider.parentNode.parentNode);\n    }\n    /**\n     * Update the main scrollable element.\n     */\n\n  }, {\n    key: \"updateMainScrollableElement\",\n    value: function updateMainScrollableElement() {\n      var _this$wot = this.wot,\n          wtTable = _this$wot.wtTable,\n          rootWindow = _this$wot.rootWindow;\n\n      if (rootWindow.getComputedStyle(wtTable.wtRootElement.parentNode).getPropertyValue('overflow') === 'hidden') {\n        this.mainTableScrollableElement = this.wot.wtTable.holder;\n      } else {\n        this.mainTableScrollableElement = getScrollableElement(wtTable.TABLE);\n      }\n    }\n    /**\n     * Calculates coordinates of the provided element, relative to the root Handsontable element.\n     * NOTE: The element needs to be a child of the overlay in order for the method to work correctly.\n     *\n     * @param {HTMLElement} element The cell element to calculate the position for.\n     * @param {number} rowIndex Visual row index.\n     * @param {number} columnIndex Visual column index.\n     * @returns {{top: number, left: number}|undefined}\n     */\n\n  }, {\n    key: \"getRelativeCellPosition\",\n    value: function getRelativeCellPosition(element, rowIndex, columnIndex) {\n      if (this.clone.wtTable.holder.contains(element) === false) {\n        warn(\"The provided element is not a child of the \".concat(this.type, \" overlay\"));\n        return;\n      }\n\n      var windowScroll = this.mainTableScrollableElement === this.wot.rootWindow;\n      var fixedColumn = columnIndex < this.wot.getSetting('fixedColumnsLeft');\n      var fixedRowTop = rowIndex < this.wot.getSetting('fixedRowsTop');\n      var fixedRowBottom = rowIndex >= this.wot.getSetting('totalRows') - this.wot.getSetting('fixedRowsBottom');\n      var spreaderOffset = {\n        left: this.clone.wtTable.spreader.offsetLeft,\n        top: this.clone.wtTable.spreader.offsetTop\n      };\n      var elementOffset = {\n        left: element.offsetLeft,\n        top: element.offsetTop\n      };\n      var offsetObject = null;\n\n      if (windowScroll) {\n        offsetObject = this.getRelativeCellPositionWithinWindow(fixedRowTop, fixedColumn, elementOffset, spreaderOffset);\n      } else {\n        offsetObject = this.getRelativeCellPositionWithinHolder(fixedRowTop, fixedRowBottom, fixedColumn, elementOffset, spreaderOffset);\n      }\n\n      return offsetObject;\n    }\n    /**\n     * Calculates coordinates of the provided element, relative to the root Handsontable element within a table with window\n     * as a scrollable element.\n     *\n     * @private\n     * @param {boolean} onFixedRowTop `true` if the coordinates point to a place within the top fixed rows.\n     * @param {boolean} onFixedColumn `true` if the coordinates point to a place within the fixed columns.\n     * @param {number} elementOffset Offset position of the cell element.\n     * @param {number} spreaderOffset Offset position of the spreader element.\n     * @returns {{top: number, left: number}}\n     */\n\n  }, {\n    key: \"getRelativeCellPositionWithinWindow\",\n    value: function getRelativeCellPositionWithinWindow(onFixedRowTop, onFixedColumn, elementOffset, spreaderOffset) {\n      var absoluteRootElementPosition = this.wot.wtTable.wtRootElement.getBoundingClientRect();\n      var horizontalOffset = 0;\n      var verticalOffset = 0;\n\n      if (!onFixedColumn) {\n        horizontalOffset = spreaderOffset.left;\n      } else {\n        horizontalOffset = absoluteRootElementPosition.left <= 0 ? -1 * absoluteRootElementPosition.left : 0;\n      }\n\n      if (onFixedRowTop) {\n        var absoluteOverlayPosition = this.clone.wtTable.TABLE.getBoundingClientRect();\n        verticalOffset = absoluteOverlayPosition.top - absoluteRootElementPosition.top;\n      } else {\n        verticalOffset = spreaderOffset.top;\n      }\n\n      return {\n        left: elementOffset.left + horizontalOffset,\n        top: elementOffset.top + verticalOffset\n      };\n    }\n    /**\n     * Calculates coordinates of the provided element, relative to the root Handsontable element within a table with window\n     * as a scrollable element.\n     *\n     * @private\n     * @param {boolean} onFixedRowTop `true` if the coordinates point to a place within the top fixed rows.\n     * @param {boolean} onFixedRowBottom `true` if the coordinates point to a place within the bottom fixed rows.\n     * @param {boolean} onFixedColumn `true` if the coordinates point to a place within the fixed columns.\n     * @param {number} elementOffset Offset position of the cell element.\n     * @param {number} spreaderOffset Offset position of the spreader element.\n     * @returns {{top: number, left: number}}\n     */\n\n  }, {\n    key: \"getRelativeCellPositionWithinHolder\",\n    value: function getRelativeCellPositionWithinHolder(onFixedRowTop, onFixedRowBottom, onFixedColumn, elementOffset, spreaderOffset) {\n      var tableScrollPosition = {\n        horizontal: this.clone.cloneSource.wtOverlays.leftOverlay.getScrollPosition(),\n        vertical: this.clone.cloneSource.wtOverlays.topOverlay.getScrollPosition()\n      };\n      var horizontalOffset = 0;\n      var verticalOffset = 0;\n\n      if (!onFixedColumn) {\n        horizontalOffset = tableScrollPosition.horizontal - spreaderOffset.left;\n      }\n\n      if (onFixedRowBottom) {\n        var absoluteRootElementPosition = this.wot.wtTable.wtRootElement.getBoundingClientRect();\n        var absoluteOverlayPosition = this.clone.wtTable.TABLE.getBoundingClientRect();\n        verticalOffset = absoluteOverlayPosition.top * -1 + absoluteRootElementPosition.top;\n      } else if (!onFixedRowTop) {\n        verticalOffset = tableScrollPosition.vertical - spreaderOffset.top;\n      }\n\n      return {\n        left: elementOffset.left - horizontalOffset,\n        top: elementOffset.top - verticalOffset\n      };\n    }\n    /**\n     * Make a clone of table for overlay.\n     *\n     * @param {string} direction Can be `Overlay.CLONE_TOP`, `Overlay.CLONE_LEFT`,\n     *                           `Overlay.CLONE_TOP_LEFT_CORNER`.\n     * @returns {Walkontable}\n     */\n\n  }, {\n    key: \"makeClone\",\n    value: function makeClone(direction) {\n      if (CLONE_TYPES.indexOf(direction) === -1) {\n        throw new Error(\"Clone type \\\"\".concat(direction, \"\\\" is not supported.\"));\n      }\n\n      var _this$wot2 = this.wot,\n          wtTable = _this$wot2.wtTable,\n          rootDocument = _this$wot2.rootDocument,\n          rootWindow = _this$wot2.rootWindow;\n      var clone = rootDocument.createElement('DIV');\n      var clonedTable = rootDocument.createElement('TABLE');\n      var tableParent = wtTable.wtRootElement.parentNode;\n      clone.className = \"ht_clone_\".concat(direction, \" handsontable\");\n      clone.style.position = 'absolute';\n      clone.style.top = 0;\n      clone.style.left = 0;\n      clone.style.overflow = 'visible';\n      clonedTable.className = wtTable.TABLE.className;\n      clone.appendChild(clonedTable);\n      this.type = direction;\n      tableParent.appendChild(clone);\n      var preventOverflow = this.wot.getSetting('preventOverflow');\n\n      if (preventOverflow === true || preventOverflow === 'horizontal' && this.type === CLONE_TOP || preventOverflow === 'vertical' && this.type === CLONE_LEFT) {\n        this.mainTableScrollableElement = rootWindow;\n      } else if (rootWindow.getComputedStyle(tableParent).getPropertyValue('overflow') === 'hidden') {\n        this.mainTableScrollableElement = wtTable.holder;\n      } else {\n        this.mainTableScrollableElement = getScrollableElement(wtTable.TABLE);\n      } // Create a new instance of the Walkontable class\n\n\n      return new this.wot.constructor({\n        cloneSource: this.wot,\n        cloneOverlay: this,\n        table: clonedTable\n      });\n    }\n    /**\n     * Refresh/Redraw overlay.\n     *\n     * @param {boolean} [fastDraw=false] When `true`, try to refresh only the positions of borders without rerendering\n     *                                   the data. It will only work if Table.draw() does not force\n     *                                   rendering anyway.\n     */\n\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      var fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      // When hot settings are changed we allow to refresh overlay once before blocking\n      var nextCycleRenderFlag = this.shouldBeRendered();\n\n      if (this.clone && (this.needFullRender || nextCycleRenderFlag)) {\n        this.clone.draw(fastDraw);\n      }\n\n      this.needFullRender = nextCycleRenderFlag;\n    }\n    /**\n     * Reset overlay styles to initial values.\n     */\n\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      if (!this.clone) {\n        return;\n      }\n\n      var holder = this.clone.wtTable.holder;\n      var hider = this.clone.wtTable.hider;\n      var holderStyle = holder.style;\n      var hidderStyle = hider.style;\n      var rootStyle = holder.parentNode.style;\n      arrayEach([holderStyle, hidderStyle, rootStyle], function (style) {\n        style.width = '';\n        style.height = '';\n      });\n    }\n    /**\n     * Destroy overlay instance.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      new EventManager(this.clone).destroy();\n    }\n  }]);\n\n  return Overlay;\n}();"],"mappings":"AAEA,SAASA,eAAeA,CAACC,QAAQ,EAAEC,WAAW,EAAE;EAAE,IAAI,EAAED,QAAQ,YAAYC,WAAW,CAAC,EAAE;IAAE,MAAM,IAAIC,SAAS,CAAC,mCAAmC,CAAC;EAAE;AAAE;AAExJ,SAASC,iBAAiBA,CAACC,MAAM,EAAEC,KAAK,EAAE;EAAE,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,KAAK,CAACE,MAAM,EAAED,CAAC,EAAE,EAAE;IAAE,IAAIE,UAAU,GAAGH,KAAK,CAACC,CAAC,CAAC;IAAEE,UAAU,CAACC,UAAU,GAAGD,UAAU,CAACC,UAAU,IAAI,KAAK;IAAED,UAAU,CAACE,YAAY,GAAG,IAAI;IAAE,IAAI,OAAO,IAAIF,UAAU,EAAEA,UAAU,CAACG,QAAQ,GAAG,IAAI;IAAEC,MAAM,CAACC,cAAc,CAACT,MAAM,EAAEI,UAAU,CAACM,GAAG,EAAEN,UAAU,CAAC;EAAE;AAAE;AAE5T,SAASO,YAAYA,CAACd,WAAW,EAAEe,UAAU,EAAEC,WAAW,EAAE;EAAE,IAAID,UAAU,EAAEb,iBAAiB,CAACF,WAAW,CAACiB,SAAS,EAAEF,UAAU,CAAC;EAAE,IAAIC,WAAW,EAAEd,iBAAiB,CAACF,WAAW,EAAEgB,WAAW,CAAC;EAAEL,MAAM,CAACC,cAAc,CAACZ,WAAW,EAAE,WAAW,EAAE;IAAEU,QAAQ,EAAE;EAAM,CAAC,CAAC;EAAE,OAAOV,WAAW;AAAE;AAE5R,SAASkB,oBAAoB,EAAEC,oBAAoB,QAAQ,uCAAuC;AAClG,SAASC,YAAY,QAAQ,kCAAkC;AAC/D,SAASC,SAAS,QAAQ,iCAAiC;AAC3D,SAASC,IAAI,QAAQ,mCAAmC;AACxD,OAAOC,YAAY,MAAM,gCAAgC;AACzD,SAASC,WAAW,EAAEC,SAAS,EAAEC,UAAU,QAAQ,iBAAiB;AACpE;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,IAAIC,OAAO,GAAG,aAAa,YAAY;EAC5C;AACF;AACA;EACE,SAASA,OAAOA,CAACC,WAAW,EAAE;IAC5B9B,eAAe,CAAC,IAAI,EAAE6B,OAAO,CAAC;IAE9BP,YAAY,CAAC,IAAI,EAAE,KAAK,EAAEQ,WAAW,EAAE;MACrClB,QAAQ,EAAE;IACZ,CAAC,CAAC;IACF,IAAImB,iBAAiB,GAAG,IAAI,CAACC,GAAG,CAACC,OAAO;MACpCC,KAAK,GAAGH,iBAAiB,CAACG,KAAK;MAC/BC,KAAK,GAAGJ,iBAAiB,CAACI,KAAK;MAC/BC,QAAQ,GAAGL,iBAAiB,CAACK,QAAQ;MACrCC,MAAM,GAAGN,iBAAiB,CAACM,MAAM;MACjCC,aAAa,GAAGP,iBAAiB,CAACO,aAAa,CAAC,CAAC;;IAErD,IAAI,CAACrC,QAAQ,GAAG,IAAI,CAAC+B,GAAG;IACxB,IAAI,CAACO,IAAI,GAAG,EAAE;IACd,IAAI,CAACC,0BAA0B,GAAG,IAAI;IACtC,IAAI,CAACN,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACC,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACC,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACC,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACG,iBAAiB,GAAGpB,oBAAoB,CAAC,IAAI,CAACc,KAAK,CAACO,UAAU,CAACA,UAAU,CAAC;IAC/E,IAAI,CAACC,sBAAsB,CAAC,CAAC;EAC/B;EACA;AACF;AACA;AACA;AACA;;EAGE3B,YAAY,CAACa,OAAO,EAAE,CAAC;IACrBd,GAAG,EAAE,wBAAwB;IAC7B6B,KAAK,EAAE,SAASD,sBAAsBA,CAAA,EAAG;MACvC,IAAIE,aAAa,GAAG,IAAI,CAACC,cAAc;MACvC,IAAI,CAACA,cAAc,GAAG,IAAI,CAACC,gBAAgB,CAAC,CAAC;MAC7C,IAAIC,OAAO,GAAGH,aAAa,KAAK,IAAI,CAACC,cAAc;MAEnD,IAAIE,OAAO,IAAI,CAAC,IAAI,CAACF,cAAc,EAAE;QACnC,IAAI,CAACG,KAAK,CAAC,CAAC;MACd;MAEA,OAAOD,OAAO;IAChB;IACA;AACJ;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACDjC,GAAG,EAAE,kBAAkB;IACvB6B,KAAK,EAAE,SAASG,gBAAgBA,CAAA,EAAG;MACjC,OAAO,IAAI;IACb;IACA;AACJ;AACA;EAEE,CAAC,EAAE;IACDhC,GAAG,EAAE,yBAAyB;IAC9B6B,KAAK,EAAE,SAASM,uBAAuBA,CAAA,EAAG;MACxC,IAAI,CAACT,iBAAiB,GAAGpB,oBAAoB,CAAC,IAAI,CAACc,KAAK,CAACO,UAAU,CAACA,UAAU,CAAC;IACjF;IACA;AACJ;AACA;EAEE,CAAC,EAAE;IACD3B,GAAG,EAAE,6BAA6B;IAClC6B,KAAK,EAAE,SAASO,2BAA2BA,CAAA,EAAG;MAC5C,IAAIC,SAAS,GAAG,IAAI,CAACpB,GAAG;QACpBC,OAAO,GAAGmB,SAAS,CAACnB,OAAO;QAC3BoB,UAAU,GAAGD,SAAS,CAACC,UAAU;MAErC,IAAIA,UAAU,CAACC,gBAAgB,CAACrB,OAAO,CAACK,aAAa,CAACI,UAAU,CAAC,CAACa,gBAAgB,CAAC,UAAU,CAAC,KAAK,QAAQ,EAAE;QAC3G,IAAI,CAACf,0BAA0B,GAAG,IAAI,CAACR,GAAG,CAACC,OAAO,CAACI,MAAM;MAC3D,CAAC,MAAM;QACL,IAAI,CAACG,0BAA0B,GAAGpB,oBAAoB,CAACa,OAAO,CAACC,KAAK,CAAC;MACvE;IACF;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACDnB,GAAG,EAAE,yBAAyB;IAC9B6B,KAAK,EAAE,SAASY,uBAAuBA,CAACC,OAAO,EAAEC,QAAQ,EAAEC,WAAW,EAAE;MACtE,IAAI,IAAI,CAACC,KAAK,CAAC3B,OAAO,CAACI,MAAM,CAACwB,QAAQ,CAACJ,OAAO,CAAC,KAAK,KAAK,EAAE;QACzDjC,IAAI,CAAC,6CAA6C,CAACsC,MAAM,CAAC,IAAI,CAACvB,IAAI,EAAE,UAAU,CAAC,CAAC;QACjF;MACF;MAEA,IAAIwB,YAAY,GAAG,IAAI,CAACvB,0BAA0B,KAAK,IAAI,CAACR,GAAG,CAACqB,UAAU;MAC1E,IAAIW,WAAW,GAAGL,WAAW,GAAG,IAAI,CAAC3B,GAAG,CAACiC,UAAU,CAAC,kBAAkB,CAAC;MACvE,IAAIC,WAAW,GAAGR,QAAQ,GAAG,IAAI,CAAC1B,GAAG,CAACiC,UAAU,CAAC,cAAc,CAAC;MAChE,IAAIE,cAAc,GAAGT,QAAQ,IAAI,IAAI,CAAC1B,GAAG,CAACiC,UAAU,CAAC,WAAW,CAAC,GAAG,IAAI,CAACjC,GAAG,CAACiC,UAAU,CAAC,iBAAiB,CAAC;MAC1G,IAAIG,cAAc,GAAG;QACnBC,IAAI,EAAE,IAAI,CAACT,KAAK,CAAC3B,OAAO,CAACG,QAAQ,CAACkC,UAAU;QAC5CC,GAAG,EAAE,IAAI,CAACX,KAAK,CAAC3B,OAAO,CAACG,QAAQ,CAACoC;MACnC,CAAC;MACD,IAAIC,aAAa,GAAG;QAClBJ,IAAI,EAAEZ,OAAO,CAACa,UAAU;QACxBC,GAAG,EAAEd,OAAO,CAACe;MACf,CAAC;MACD,IAAIE,YAAY,GAAG,IAAI;MAEvB,IAAIX,YAAY,EAAE;QAChBW,YAAY,GAAG,IAAI,CAACC,mCAAmC,CAACT,WAAW,EAAEF,WAAW,EAAES,aAAa,EAAEL,cAAc,CAAC;MAClH,CAAC,MAAM;QACLM,YAAY,GAAG,IAAI,CAACE,mCAAmC,CAACV,WAAW,EAAEC,cAAc,EAAEH,WAAW,EAAES,aAAa,EAAEL,cAAc,CAAC;MAClI;MAEA,OAAOM,YAAY;IACrB;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACD3D,GAAG,EAAE,qCAAqC;IAC1C6B,KAAK,EAAE,SAAS+B,mCAAmCA,CAACE,aAAa,EAAEC,aAAa,EAAEL,aAAa,EAAEL,cAAc,EAAE;MAC/G,IAAIW,2BAA2B,GAAG,IAAI,CAAC/C,GAAG,CAACC,OAAO,CAACK,aAAa,CAAC0C,qBAAqB,CAAC,CAAC;MACxF,IAAIC,gBAAgB,GAAG,CAAC;MACxB,IAAIC,cAAc,GAAG,CAAC;MAEtB,IAAI,CAACJ,aAAa,EAAE;QAClBG,gBAAgB,GAAGb,cAAc,CAACC,IAAI;MACxC,CAAC,MAAM;QACLY,gBAAgB,GAAGF,2BAA2B,CAACV,IAAI,IAAI,CAAC,GAAG,CAAC,CAAC,GAAGU,2BAA2B,CAACV,IAAI,GAAG,CAAC;MACtG;MAEA,IAAIQ,aAAa,EAAE;QACjB,IAAIM,uBAAuB,GAAG,IAAI,CAACvB,KAAK,CAAC3B,OAAO,CAACC,KAAK,CAAC8C,qBAAqB,CAAC,CAAC;QAC9EE,cAAc,GAAGC,uBAAuB,CAACZ,GAAG,GAAGQ,2BAA2B,CAACR,GAAG;MAChF,CAAC,MAAM;QACLW,cAAc,GAAGd,cAAc,CAACG,GAAG;MACrC;MAEA,OAAO;QACLF,IAAI,EAAEI,aAAa,CAACJ,IAAI,GAAGY,gBAAgB;QAC3CV,GAAG,EAAEE,aAAa,CAACF,GAAG,GAAGW;MAC3B,CAAC;IACH;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACDnE,GAAG,EAAE,qCAAqC;IAC1C6B,KAAK,EAAE,SAASgC,mCAAmCA,CAACC,aAAa,EAAEO,gBAAgB,EAAEN,aAAa,EAAEL,aAAa,EAAEL,cAAc,EAAE;MACjI,IAAIiB,mBAAmB,GAAG;QACxBC,UAAU,EAAE,IAAI,CAAC1B,KAAK,CAAC2B,WAAW,CAACC,UAAU,CAACC,WAAW,CAACC,iBAAiB,CAAC,CAAC;QAC7EC,QAAQ,EAAE,IAAI,CAAC/B,KAAK,CAAC2B,WAAW,CAACC,UAAU,CAACI,UAAU,CAACF,iBAAiB,CAAC;MAC3E,CAAC;MACD,IAAIT,gBAAgB,GAAG,CAAC;MACxB,IAAIC,cAAc,GAAG,CAAC;MAEtB,IAAI,CAACJ,aAAa,EAAE;QAClBG,gBAAgB,GAAGI,mBAAmB,CAACC,UAAU,GAAGlB,cAAc,CAACC,IAAI;MACzE;MAEA,IAAIe,gBAAgB,EAAE;QACpB,IAAIL,2BAA2B,GAAG,IAAI,CAAC/C,GAAG,CAACC,OAAO,CAACK,aAAa,CAAC0C,qBAAqB,CAAC,CAAC;QACxF,IAAIG,uBAAuB,GAAG,IAAI,CAACvB,KAAK,CAAC3B,OAAO,CAACC,KAAK,CAAC8C,qBAAqB,CAAC,CAAC;QAC9EE,cAAc,GAAGC,uBAAuB,CAACZ,GAAG,GAAG,CAAC,CAAC,GAAGQ,2BAA2B,CAACR,GAAG;MACrF,CAAC,MAAM,IAAI,CAACM,aAAa,EAAE;QACzBK,cAAc,GAAGG,mBAAmB,CAACM,QAAQ,GAAGvB,cAAc,CAACG,GAAG;MACpE;MAEA,OAAO;QACLF,IAAI,EAAEI,aAAa,CAACJ,IAAI,GAAGY,gBAAgB;QAC3CV,GAAG,EAAEE,aAAa,CAACF,GAAG,GAAGW;MAC3B,CAAC;IACH;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACDnE,GAAG,EAAE,WAAW;IAChB6B,KAAK,EAAE,SAASiD,SAASA,CAACC,SAAS,EAAE;MACnC,IAAIpE,WAAW,CAACqE,OAAO,CAACD,SAAS,CAAC,KAAK,CAAC,CAAC,EAAE;QACzC,MAAM,IAAIE,KAAK,CAAC,eAAe,CAAClC,MAAM,CAACgC,SAAS,EAAE,sBAAsB,CAAC,CAAC;MAC5E;MAEA,IAAIG,UAAU,GAAG,IAAI,CAACjE,GAAG;QACrBC,OAAO,GAAGgE,UAAU,CAAChE,OAAO;QAC5BiE,YAAY,GAAGD,UAAU,CAACC,YAAY;QACtC7C,UAAU,GAAG4C,UAAU,CAAC5C,UAAU;MACtC,IAAIO,KAAK,GAAGsC,YAAY,CAACC,aAAa,CAAC,KAAK,CAAC;MAC7C,IAAIC,WAAW,GAAGF,YAAY,CAACC,aAAa,CAAC,OAAO,CAAC;MACrD,IAAIE,WAAW,GAAGpE,OAAO,CAACK,aAAa,CAACI,UAAU;MAClDkB,KAAK,CAAC0C,SAAS,GAAG,WAAW,CAACxC,MAAM,CAACgC,SAAS,EAAE,eAAe,CAAC;MAChElC,KAAK,CAAC2C,KAAK,CAACC,QAAQ,GAAG,UAAU;MACjC5C,KAAK,CAAC2C,KAAK,CAAChC,GAAG,GAAG,CAAC;MACnBX,KAAK,CAAC2C,KAAK,CAAClC,IAAI,GAAG,CAAC;MACpBT,KAAK,CAAC2C,KAAK,CAACE,QAAQ,GAAG,SAAS;MAChCL,WAAW,CAACE,SAAS,GAAGrE,OAAO,CAACC,KAAK,CAACoE,SAAS;MAC/C1C,KAAK,CAAC8C,WAAW,CAACN,WAAW,CAAC;MAC9B,IAAI,CAAC7D,IAAI,GAAGuD,SAAS;MACrBO,WAAW,CAACK,WAAW,CAAC9C,KAAK,CAAC;MAC9B,IAAI+C,eAAe,GAAG,IAAI,CAAC3E,GAAG,CAACiC,UAAU,CAAC,iBAAiB,CAAC;MAE5D,IAAI0C,eAAe,KAAK,IAAI,IAAIA,eAAe,KAAK,YAAY,IAAI,IAAI,CAACpE,IAAI,KAAKZ,SAAS,IAAIgF,eAAe,KAAK,UAAU,IAAI,IAAI,CAACpE,IAAI,KAAKX,UAAU,EAAE;QACzJ,IAAI,CAACY,0BAA0B,GAAGa,UAAU;MAC9C,CAAC,MAAM,IAAIA,UAAU,CAACC,gBAAgB,CAAC+C,WAAW,CAAC,CAAC9C,gBAAgB,CAAC,UAAU,CAAC,KAAK,QAAQ,EAAE;QAC7F,IAAI,CAACf,0BAA0B,GAAGP,OAAO,CAACI,MAAM;MAClD,CAAC,MAAM;QACL,IAAI,CAACG,0BAA0B,GAAGpB,oBAAoB,CAACa,OAAO,CAACC,KAAK,CAAC;MACvE,CAAC,CAAC;;MAGF,OAAO,IAAI,IAAI,CAACF,GAAG,CAAC4E,WAAW,CAAC;QAC9BrB,WAAW,EAAE,IAAI,CAACvD,GAAG;QACrB6E,YAAY,EAAE,IAAI;QAClBC,KAAK,EAAEV;MACT,CAAC,CAAC;IACJ;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;EAEE,CAAC,EAAE;IACDrF,GAAG,EAAE,SAAS;IACd6B,KAAK,EAAE,SAASmE,OAAOA,CAAA,EAAG;MACxB,IAAIC,QAAQ,GAAGC,SAAS,CAACzG,MAAM,GAAG,CAAC,IAAIyG,SAAS,CAAC,CAAC,CAAC,KAAKC,SAAS,GAAGD,SAAS,CAAC,CAAC,CAAC,GAAG,KAAK;MACxF;MACA,IAAIE,mBAAmB,GAAG,IAAI,CAACpE,gBAAgB,CAAC,CAAC;MAEjD,IAAI,IAAI,CAACa,KAAK,KAAK,IAAI,CAACd,cAAc,IAAIqE,mBAAmB,CAAC,EAAE;QAC9D,IAAI,CAACvD,KAAK,CAACwD,IAAI,CAACJ,QAAQ,CAAC;MAC3B;MAEA,IAAI,CAAClE,cAAc,GAAGqE,mBAAmB;IAC3C;IACA;AACJ;AACA;EAEE,CAAC,EAAE;IACDpG,GAAG,EAAE,OAAO;IACZ6B,KAAK,EAAE,SAASK,KAAKA,CAAA,EAAG;MACtB,IAAI,CAAC,IAAI,CAACW,KAAK,EAAE;QACf;MACF;MAEA,IAAIvB,MAAM,GAAG,IAAI,CAACuB,KAAK,CAAC3B,OAAO,CAACI,MAAM;MACtC,IAAIF,KAAK,GAAG,IAAI,CAACyB,KAAK,CAAC3B,OAAO,CAACE,KAAK;MACpC,IAAIkF,WAAW,GAAGhF,MAAM,CAACkE,KAAK;MAC9B,IAAIe,WAAW,GAAGnF,KAAK,CAACoE,KAAK;MAC7B,IAAIgB,SAAS,GAAGlF,MAAM,CAACK,UAAU,CAAC6D,KAAK;MACvChF,SAAS,CAAC,CAAC8F,WAAW,EAAEC,WAAW,EAAEC,SAAS,CAAC,EAAE,UAAUhB,KAAK,EAAE;QAChEA,KAAK,CAACiB,KAAK,GAAG,EAAE;QAChBjB,KAAK,CAACkB,MAAM,GAAG,EAAE;MACnB,CAAC,CAAC;IACJ;IACA;AACJ;AACA;EAEE,CAAC,EAAE;IACD1G,GAAG,EAAE,SAAS;IACd6B,KAAK,EAAE,SAAS8E,OAAOA,CAAA,EAAG;MACxB,IAAIjG,YAAY,CAAC,IAAI,CAACmC,KAAK,CAAC,CAAC8D,OAAO,CAAC,CAAC;IACxC;EACF,CAAC,CAAC,CAAC;EAEH,OAAO7F,OAAO;AAChB,CAAC,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}