{"ast":null,"code":"import { arrayEach } from \"../../../../helpers/array.mjs\";\nimport { expandNode } from \"./expand.mjs\";\nimport { getFirstChildProperty, isNodeReflectsFirstChildColspan, traverseHiddenNodeColumnIndexes } from \"./utils/tree.mjs\";\n/**\n * Collapsing a node is a process where the processing node is collapsed\n * to the colspan width of the first child. All node children, except the\n * first one, are hidden. To prevent losing a current state of node children\n * on the right, all nodes are cloned (and restored while expanding), and\n * only then original nodes are modified (hidden in this case).\n *\n * @param {TreeNode} nodeToProcess A tree node to process.\n * @returns {object} Returns an object with properties:\n *                    - rollbackModification: The function that rollbacks\n *                      the tree to the previous state.\n *                    - affectedColumns: The list of the visual column\n *                      indexes which are affected. That list is passed\n *                      to the hiddens column logic.\n *                    - colspanCompensation: The number of colspan by\n *                      which the processed node colspan was reduced.\n */\n\nexport function collapseNode(nodeToProcess) {\n  var _getFirstChildPropert;\n  var nodeData = nodeToProcess.data,\n    nodeChilds = nodeToProcess.childs;\n  if (nodeData.isCollapsed || nodeData.isHidden || nodeData.origColspan <= 1) {\n    return {\n      rollbackModification: function rollbackModification() {},\n      affectedColumns: [],\n      colspanCompensation: 0\n    };\n  }\n  var isNodeReflected = isNodeReflectsFirstChildColspan(nodeToProcess);\n  if (isNodeReflected) {\n    return collapseNode(nodeChilds[0]);\n  }\n  nodeData.isCollapsed = true;\n  var allLeavesExceptMostLeft = nodeChilds.slice(1);\n  var affectedColumns = new Set();\n  if (allLeavesExceptMostLeft.length > 0) {\n    arrayEach(allLeavesExceptMostLeft, function (node) {\n      traverseHiddenNodeColumnIndexes(node, function (gridColumnIndex) {\n        affectedColumns.add(gridColumnIndex);\n      }); // Clone the tree to preserve original tree state after header expanding.\n\n      node.data.clonedTree = node.cloneTree(); // Hide all leaves except the first leaf on the left (on headers context hide all\n      // headers on the right).\n\n      node.walkDown(function (_ref) {\n        var data = _ref.data;\n        data.isHidden = true;\n      });\n    });\n  } else {\n    var origColspan = nodeData.origColspan,\n      columnIndex = nodeData.columnIndex; // Add column to \"affected\" started from 1. The header without children can not be\n    // collapsed so the first have to be visible (untouched).\n\n    for (var i = 1; i < origColspan; i++) {\n      var gridColumnIndex = columnIndex + i;\n      affectedColumns.add(gridColumnIndex);\n    }\n  } // Calculate by how many colspan it needs to reduce the headings to match them to\n  // the first child colspan width.\n\n  var colspanCompensation = nodeData.colspan - ((_getFirstChildPropert = getFirstChildProperty(nodeToProcess, 'colspan')) !== null && _getFirstChildPropert !== void 0 ? _getFirstChildPropert : 1);\n  nodeToProcess.walkUp(function (node) {\n    var data = node.data;\n    data.colspan -= colspanCompensation;\n    if (data.colspan <= 1) {\n      data.colspan = 1;\n      data.isCollapsed = true;\n    } else if (isNodeReflectsFirstChildColspan(node)) {\n      data.isCollapsed = getFirstChildProperty(node, 'isCollapsed');\n    }\n  });\n  return {\n    rollbackModification: function rollbackModification() {\n      return expandNode(nodeToProcess);\n    },\n    affectedColumns: Array.from(affectedColumns),\n    colspanCompensation: colspanCompensation\n  };\n}","map":{"version":3,"names":["arrayEach","expandNode","getFirstChildProperty","isNodeReflectsFirstChildColspan","traverseHiddenNodeColumnIndexes","collapseNode","nodeToProcess","_getFirstChildPropert","nodeData","data","nodeChilds","childs","isCollapsed","isHidden","origColspan","rollbackModification","affectedColumns","colspanCompensation","isNodeReflected","allLeavesExceptMostLeft","slice","Set","length","node","gridColumnIndex","add","clonedTree","cloneTree","walkDown","_ref","columnIndex","i","colspan","walkUp","Array","from"],"sources":["/Users/priyadeliwala/Desktop/sales-dashboard/node_modules/handsontable/plugins/nestedHeaders/stateManager/nodeModifiers/collapse.mjs"],"sourcesContent":["import \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport { arrayEach } from \"../../../../helpers/array.mjs\";\nimport { expandNode } from \"./expand.mjs\";\nimport { getFirstChildProperty, isNodeReflectsFirstChildColspan, traverseHiddenNodeColumnIndexes } from \"./utils/tree.mjs\";\n/**\n * Collapsing a node is a process where the processing node is collapsed\n * to the colspan width of the first child. All node children, except the\n * first one, are hidden. To prevent losing a current state of node children\n * on the right, all nodes are cloned (and restored while expanding), and\n * only then original nodes are modified (hidden in this case).\n *\n * @param {TreeNode} nodeToProcess A tree node to process.\n * @returns {object} Returns an object with properties:\n *                    - rollbackModification: The function that rollbacks\n *                      the tree to the previous state.\n *                    - affectedColumns: The list of the visual column\n *                      indexes which are affected. That list is passed\n *                      to the hiddens column logic.\n *                    - colspanCompensation: The number of colspan by\n *                      which the processed node colspan was reduced.\n */\n\nexport function collapseNode(nodeToProcess) {\n  var _getFirstChildPropert;\n\n  var nodeData = nodeToProcess.data,\n      nodeChilds = nodeToProcess.childs;\n\n  if (nodeData.isCollapsed || nodeData.isHidden || nodeData.origColspan <= 1) {\n    return {\n      rollbackModification: function rollbackModification() {},\n      affectedColumns: [],\n      colspanCompensation: 0\n    };\n  }\n\n  var isNodeReflected = isNodeReflectsFirstChildColspan(nodeToProcess);\n\n  if (isNodeReflected) {\n    return collapseNode(nodeChilds[0]);\n  }\n\n  nodeData.isCollapsed = true;\n  var allLeavesExceptMostLeft = nodeChilds.slice(1);\n  var affectedColumns = new Set();\n\n  if (allLeavesExceptMostLeft.length > 0) {\n    arrayEach(allLeavesExceptMostLeft, function (node) {\n      traverseHiddenNodeColumnIndexes(node, function (gridColumnIndex) {\n        affectedColumns.add(gridColumnIndex);\n      }); // Clone the tree to preserve original tree state after header expanding.\n\n      node.data.clonedTree = node.cloneTree(); // Hide all leaves except the first leaf on the left (on headers context hide all\n      // headers on the right).\n\n      node.walkDown(function (_ref) {\n        var data = _ref.data;\n        data.isHidden = true;\n      });\n    });\n  } else {\n    var origColspan = nodeData.origColspan,\n        columnIndex = nodeData.columnIndex; // Add column to \"affected\" started from 1. The header without children can not be\n    // collapsed so the first have to be visible (untouched).\n\n    for (var i = 1; i < origColspan; i++) {\n      var gridColumnIndex = columnIndex + i;\n      affectedColumns.add(gridColumnIndex);\n    }\n  } // Calculate by how many colspan it needs to reduce the headings to match them to\n  // the first child colspan width.\n\n\n  var colspanCompensation = nodeData.colspan - ((_getFirstChildPropert = getFirstChildProperty(nodeToProcess, 'colspan')) !== null && _getFirstChildPropert !== void 0 ? _getFirstChildPropert : 1);\n  nodeToProcess.walkUp(function (node) {\n    var data = node.data;\n    data.colspan -= colspanCompensation;\n\n    if (data.colspan <= 1) {\n      data.colspan = 1;\n      data.isCollapsed = true;\n    } else if (isNodeReflectsFirstChildColspan(node)) {\n      data.isCollapsed = getFirstChildProperty(node, 'isCollapsed');\n    }\n  });\n  return {\n    rollbackModification: function rollbackModification() {\n      return expandNode(nodeToProcess);\n    },\n    affectedColumns: Array.from(affectedColumns),\n    colspanCompensation: colspanCompensation\n  };\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}