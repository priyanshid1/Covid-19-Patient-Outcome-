{"ast":null,"code":"function _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _s, _e;\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n  return _arr;\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _get() {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n      if (desc.get) {\n        return desc.get.call(arguments.length < 3 ? target : receiver);\n      }\n      return desc.value;\n    };\n  }\n  return _get.apply(this, arguments);\n}\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n  return object;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn(this, result);\n  };\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n  return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) {\n  _checkPrivateRedeclaration(obj, privateMap);\n  privateMap.set(obj, value);\n}\nfunction _checkPrivateRedeclaration(obj, privateCollection) {\n  if (privateCollection.has(obj)) {\n    throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n  }\n}\nfunction _classPrivateFieldSet(receiver, privateMap, value) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\");\n  _classApplyDescriptorSet(receiver, descriptor, value);\n  return value;\n}\nfunction _classApplyDescriptorSet(receiver, descriptor, value) {\n  if (descriptor.set) {\n    descriptor.set.call(receiver, value);\n  } else {\n    if (!descriptor.writable) {\n      throw new TypeError(\"attempted to set read only private field\");\n    }\n    descriptor.value = value;\n  }\n}\nfunction _classPrivateFieldGet(receiver, privateMap) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\");\n  return _classApplyDescriptorGet(receiver, descriptor);\n}\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to \" + action + \" private field on non-instance\");\n  }\n  return privateMap.get(receiver);\n}\nfunction _classApplyDescriptorGet(receiver, descriptor) {\n  if (descriptor.get) {\n    return descriptor.get.call(receiver);\n  }\n  return descriptor.value;\n}\nimport { BasePlugin } from \"../base/index.mjs\";\nimport staticRegister from \"../../utils/staticRegister.mjs\";\nimport { error, warn } from \"../../helpers/console.mjs\";\nimport { isNumeric } from \"../../helpers/number.mjs\";\nimport { isDefined, isUndefined } from \"../../helpers/mixed.mjs\";\nimport { setupEngine, setupSheet, unregisterEngine, getRegisteredHotInstances } from \"./engine/register.mjs\";\nimport { isEscapedFormulaExpression, unescapeFormulaExpression } from \"./utils.mjs\";\nimport { getEngineSettingsWithOverrides } from \"./engine/settings.mjs\";\nimport { isArrayOfArrays } from \"../../helpers/data.mjs\";\nimport { toUpperCaseFirst } from \"../../helpers/string.mjs\";\nimport Hooks from \"../../pluginHooks.mjs\";\nexport var PLUGIN_KEY = 'formulas';\nexport var PLUGIN_PRIORITY = 260;\nvar ROW_MOVE_UNDO_REDO_NAME = 'row_move';\nHooks.getSingleton().register('afterNamedExpressionAdded');\nHooks.getSingleton().register('afterNamedExpressionRemoved');\nHooks.getSingleton().register('afterSheetAdded');\nHooks.getSingleton().register('afterSheetRemoved');\nHooks.getSingleton().register('afterSheetRenamed');\nHooks.getSingleton().register('afterFormulasValuesUpdate'); // This function will be used for detecting changes coming from the `UndoRedo` plugin. This kind of change won't be\n// handled by whole body of listeners and therefore won't change undo/redo stack inside engine provided by HyperFormula.\n// HyperFormula's `undo` and `redo` methods will do it instead. Please keep in mind that undo/redo stacks inside\n// instances of Handsontable and HyperFormula should be synced (number of actions should be the same).\n\nvar isBlockedSource = function isBlockedSource(source) {\n  return source === 'UndoRedo.undo' || source === 'UndoRedo.redo' || source === 'auto';\n};\n/**\n * This plugin allows you to perform Excel-like calculations in your business applications. It does it by an\n * integration with our other product, [HyperFormula](https://github.com/handsontable/hyperformula/), which is a\n * powerful calculation engine with an extensive number of features.\n *\n * To test out HyperFormula, see [this guide](@/guides/formulas/formula-calculation.md#available-functions).\n *\n * @plugin Formulas\n * @class Formulas\n */\n\nvar _internalOperationPending = /*#__PURE__*/new WeakMap();\nvar _hotWasInitializedWithEmptyData = /*#__PURE__*/new WeakMap();\nvar _engineListeners = /*#__PURE__*/new WeakMap();\nexport var Formulas = /*#__PURE__*/function (_BasePlugin) {\n  _inherits(Formulas, _BasePlugin);\n  var _super = _createSuper(Formulas);\n  function Formulas() {\n    var _this;\n    _classCallCheck(this, Formulas);\n    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {\n      _args[_key] = arguments[_key];\n    }\n    _this = _super.call.apply(_super, [this].concat(_args));\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _internalOperationPending, {\n      writable: true,\n      value: false\n    });\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _hotWasInitializedWithEmptyData, {\n      writable: true,\n      value: false\n    });\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _engineListeners, {\n      writable: true,\n      value: [['valuesUpdated', function () {\n        var _this2;\n        return (_this2 = _this).onEngineValuesUpdated.apply(_this2, arguments);\n      }], ['namedExpressionAdded', function () {\n        var _this3;\n        return (_this3 = _this).onEngineNamedExpressionsAdded.apply(_this3, arguments);\n      }], ['namedExpressionRemoved', function () {\n        var _this4;\n        return (_this4 = _this).onEngineNamedExpressionsRemoved.apply(_this4, arguments);\n      }], ['sheetAdded', function () {\n        var _this5;\n        return (_this5 = _this).onEngineSheetAdded.apply(_this5, arguments);\n      }], ['sheetRenamed', function () {\n        var _this6;\n        return (_this6 = _this).onEngineSheetRenamed.apply(_this6, arguments);\n      }], ['sheetRemoved', function () {\n        var _this7;\n        return (_this7 = _this).onEngineSheetRemoved.apply(_this7, arguments);\n      }]]\n    });\n    _defineProperty(_assertThisInitialized(_this), \"staticRegister\", staticRegister('formulas'));\n    _defineProperty(_assertThisInitialized(_this), \"engine\", null);\n    _defineProperty(_assertThisInitialized(_this), \"sheetName\", null);\n    return _this;\n  }\n  _createClass(Formulas, [{\n    key: \"sheetId\",\n    get:\n    /**\n     * HyperFormula's sheet id.\n     *\n     * @type {number|null}\n     */\n    function get() {\n      return this.sheetName === null ? null : this.engine.getSheetId(this.sheetName);\n    }\n    /**\n     * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}\n     * hook and if it returns `true` than the {@link Formulas#enablePlugin} method is called.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isEnabled\",\n    value: function isEnabled() {\n      /* eslint-disable no-unneeded-ternary */\n      return this.hot.getSettings()[PLUGIN_KEY] ? true : false;\n    }\n    /**\n     * Enables the plugin functionality for this Handsontable instance.\n     */\n  }, {\n    key: \"enablePlugin\",\n    value: function enablePlugin() {\n      var _setupEngine,\n        _this8 = this;\n      if (this.enabled) {\n        return;\n      }\n      this.engine = (_setupEngine = setupEngine(this.hot)) !== null && _setupEngine !== void 0 ? _setupEngine : this.engine;\n      if (!this.engine) {\n        warn('Missing the required `engine` key in the Formulas settings. Please fill it with either an' + ' engine class or an engine instance.');\n        return;\n      } // Useful for disabling -> enabling the plugin using `updateSettings` or the API.\n\n      if (this.sheetName !== null && !this.engine.doesSheetExist(this.sheetName)) {\n        var newSheetName = this.addSheet(this.sheetName, this.hot.getSourceDataArray());\n        if (newSheetName !== false) {\n          this.sheetName = newSheetName;\n        }\n      }\n      this.addHook('beforeLoadData', function () {\n        return _this8.onBeforeLoadData.apply(_this8, arguments);\n      });\n      this.addHook('afterLoadData', function () {\n        return _this8.onAfterLoadData.apply(_this8, arguments);\n      });\n      this.addHook('modifyData', function () {\n        return _this8.onModifyData.apply(_this8, arguments);\n      });\n      this.addHook('modifySourceData', function () {\n        return _this8.onModifySourceData.apply(_this8, arguments);\n      });\n      this.addHook('beforeValidate', function () {\n        return _this8.onBeforeValidate.apply(_this8, arguments);\n      });\n      this.addHook('afterSetSourceDataAtCell', function () {\n        return _this8.onAfterSetSourceDataAtCell.apply(_this8, arguments);\n      });\n      this.addHook('afterSetDataAtCell', function () {\n        return _this8.onAfterSetDataAtCell.apply(_this8, arguments);\n      });\n      this.addHook('afterSetDataAtRowProp', function () {\n        return _this8.onAfterSetDataAtCell.apply(_this8, arguments);\n      });\n      this.addHook('beforeCreateRow', function () {\n        return _this8.onBeforeCreateRow.apply(_this8, arguments);\n      });\n      this.addHook('beforeCreateCol', function () {\n        return _this8.onBeforeCreateCol.apply(_this8, arguments);\n      });\n      this.addHook('afterCreateRow', function () {\n        return _this8.onAfterCreateRow.apply(_this8, arguments);\n      });\n      this.addHook('afterCreateCol', function () {\n        return _this8.onAfterCreateCol.apply(_this8, arguments);\n      });\n      this.addHook('beforeRemoveRow', function () {\n        return _this8.onBeforeRemoveRow.apply(_this8, arguments);\n      });\n      this.addHook('beforeRemoveCol', function () {\n        return _this8.onBeforeRemoveCol.apply(_this8, arguments);\n      });\n      this.addHook('afterRemoveRow', function () {\n        return _this8.onAfterRemoveRow.apply(_this8, arguments);\n      });\n      this.addHook('afterRemoveCol', function () {\n        return _this8.onAfterRemoveCol.apply(_this8, arguments);\n      }); // Handling undo actions on data just using HyperFormula's UndoRedo mechanism\n\n      this.addHook('beforeUndo', function (action) {\n        // TODO: Move action isn't handled by HyperFormula.\n        if ((action === null || action === void 0 ? void 0 : action.actionType) === ROW_MOVE_UNDO_REDO_NAME) {\n          return;\n        }\n        _this8.engine.undo();\n      }); // Handling redo actions on data just using HyperFormula's UndoRedo mechanism\n\n      this.addHook('beforeRedo', function (action) {\n        // TODO: Move action isn't handled by HyperFormula.\n        if ((action === null || action === void 0 ? void 0 : action.actionType) === ROW_MOVE_UNDO_REDO_NAME) {\n          return;\n        }\n        _this8.engine.redo();\n      });\n      this.addHook('afterDetachChild', function () {\n        return _this8.onAfterDetachChild.apply(_this8, arguments);\n      });\n      this.addHook('beforeAutofill', function () {\n        return _this8.onBeforeAutofill.apply(_this8, arguments);\n      });\n      _classPrivateFieldGet(this, _engineListeners).forEach(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n          eventName = _ref2[0],\n          listener = _ref2[1];\n        return _this8.engine.on(eventName, listener);\n      });\n      _get(_getPrototypeOf(Formulas.prototype), \"enablePlugin\", this).call(this);\n    }\n    /**\n     * Disables the plugin functionality for this Handsontable instance.\n     */\n  }, {\n    key: \"disablePlugin\",\n    value: function disablePlugin() {\n      var _this9 = this;\n      _classPrivateFieldGet(this, _engineListeners).forEach(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n          eventName = _ref4[0],\n          listener = _ref4[1];\n        return _this9.engine.off(eventName, listener);\n      });\n      unregisterEngine(this.engine, this.hot);\n      this.engine = null;\n      _get(_getPrototypeOf(Formulas.prototype), \"disablePlugin\", this).call(this);\n    }\n    /**\n     * Triggered on `updateSettings`.\n     *\n     * @private\n     * @param {object} newSettings New set of settings passed to the `updateSettings` method.\n     */\n  }, {\n    key: \"updatePlugin\",\n    value: function updatePlugin(newSettings) {\n      this.engine.updateConfig(getEngineSettingsWithOverrides(this.hot.getSettings()));\n      var pluginSettings = this.hot.getSettings()[PLUGIN_KEY];\n      if (isDefined(pluginSettings) && isDefined(pluginSettings.sheetName) && pluginSettings.sheetName !== this.sheetName) {\n        this.switchSheet(pluginSettings.sheetName);\n      } // If no data was passed to the `updateSettings` method and no sheet is connected to the instance -> create a\n      // new sheet using the currently used data. Otherwise, it will be handled by the `afterLoadData` call.\n\n      if (!newSettings.data && this.sheetName === null) {\n        var sheetName = this.hot.getSettings()[PLUGIN_KEY].sheetName;\n        if (sheetName && this.engine.doesSheetExist(sheetName)) {\n          this.switchSheet(this.sheetName);\n        } else {\n          this.sheetName = this.addSheet(sheetName !== null && sheetName !== void 0 ? sheetName : void 0, this.hot.getSourceDataArray());\n        }\n      }\n      _get(_getPrototypeOf(Formulas.prototype), \"updatePlugin\", this).call(this, newSettings);\n    }\n    /**\n     * Destroys the plugin instance.\n     */\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var _this10 = this;\n      _classPrivateFieldGet(this, _engineListeners).forEach(function (_ref5) {\n        var _this10$engine;\n        var _ref6 = _slicedToArray(_ref5, 2),\n          eventName = _ref6[0],\n          listener = _ref6[1];\n        return (_this10$engine = _this10.engine) === null || _this10$engine === void 0 ? void 0 : _this10$engine.off(eventName, listener);\n      });\n      _classPrivateFieldSet(this, _engineListeners, null);\n      unregisterEngine(this.engine, this.hot);\n      this.engine = null;\n      _get(_getPrototypeOf(Formulas.prototype), \"destroy\", this).call(this);\n    }\n    /**\n     * Helper function for `toPhysicalRowPosition` and `toPhysicalColumnPosition`.\n     *\n     * @private\n     * @param {number} visualIndex Visual entry index.\n     * @param {number} physicalIndex Physical entry index.\n     * @param {number} entriesCount Visual entries count.\n     * @param {number} sourceEntriesCount Source entries count.\n     * @param {boolean} contained `true` if it should return only indexes within boundaries of the table (basically\n     * `toPhysical` alias.\n     * @returns {*}\n     */\n  }, {\n    key: \"getPhysicalIndexPosition\",\n    value: function getPhysicalIndexPosition(visualIndex, physicalIndex, entriesCount, sourceEntriesCount, contained) {\n      if (!contained) {\n        if (visualIndex >= entriesCount) {\n          return sourceEntriesCount + (visualIndex - entriesCount);\n        }\n      }\n      return physicalIndex;\n    }\n    /**\n     * Returns the physical row index. The difference between this and Core's `toPhysical` is that it doesn't return\n     * `null` on rows with indexes higher than the number of rows.\n     *\n     * @private\n     * @param {number} row Visual row index.\n     * @param {boolean} [contained] `true` if it should return only indexes within boundaries of the table (basically\n     * `toPhysical` alias.\n     * @returns {number} The physical row index.\n     */\n  }, {\n    key: \"toPhysicalRowPosition\",\n    value: function toPhysicalRowPosition(row) {\n      var contained = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return this.getPhysicalIndexPosition(row, this.hot.toPhysicalRow(row), this.hot.countRows(), this.hot.countSourceRows(), contained);\n    }\n    /**\n     * Returns the physical column index. The difference between this and Core's `toPhysical` is that it doesn't return\n     * `null` on columns with indexes higher than the number of columns.\n     *\n     * @private\n     * @param {number} column Visual column index.\n     * @param {boolean} [contained] `true` if it should return only indexes within boundaries of the table (basically\n     * `toPhysical` alias.\n     * @returns {number} The physical column index.\n     */\n  }, {\n    key: \"toPhysicalColumnPosition\",\n    value: function toPhysicalColumnPosition(column) {\n      var contained = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return this.getPhysicalIndexPosition(column, this.hot.toPhysicalColumn(column), this.hot.countCols(), this.hot.countSourceCols(), contained);\n    }\n    /**\n     * Add a sheet to the shared HyperFormula instance.\n     *\n     * @param {string|null} [sheetName] The new sheet name. If not provided (or a null is passed), will be\n     * auto-generated by HyperFormula.\n     * @param {Array} [sheetData] Data passed to the shared HyperFormula instance. Has to be declared as an array of\n     * arrays - array of objects is not supported in this scenario.\n     * @returns {boolean|string} `false` if the data format is unusable or it is impossible to add a new sheet to the\n     * engine, the created sheet name otherwise.\n     */\n  }, {\n    key: \"addSheet\",\n    value: function addSheet(sheetName, sheetData) {\n      if (isDefined(sheetData) && !isArrayOfArrays(sheetData)) {\n        warn('The provided data should be an array of arrays.');\n        return false;\n      }\n      if (sheetName !== void 0 && sheetName !== null && this.engine.doesSheetExist(sheetName)) {\n        warn('Sheet with the provided name already exists.');\n        return false;\n      }\n      try {\n        var actualSheetName = this.engine.addSheet(sheetName !== null && sheetName !== void 0 ? sheetName : void 0);\n        if (sheetData) {\n          this.engine.setSheetContent(this.engine.getSheetId(actualSheetName), sheetData);\n        }\n        return actualSheetName;\n      } catch (e) {\n        warn(e.message);\n        return false;\n      }\n    }\n    /**\n     * Switch the sheet used as data in the Handsontable instance (it loads the data from the shared HyperFormula\n     * instance).\n     *\n     * @param {string} sheetName Sheet name used in the shared HyperFormula instance.\n     */\n  }, {\n    key: \"switchSheet\",\n    value: function switchSheet(sheetName) {\n      if (!this.engine.doesSheetExist(sheetName)) {\n        error(\"The sheet named `\".concat(sheetName, \"` does not exist, switch aborted.\"));\n        return;\n      }\n      this.sheetName = sheetName;\n      var serialized = this.engine.getSheetSerialized(this.sheetId);\n      if (serialized.length > 0) {\n        this.hot.loadData(serialized, \"\".concat(toUpperCaseFirst(PLUGIN_KEY), \".switchSheet\"));\n      }\n    }\n    /**\n     * Get the cell type under specified visual coordinates.\n     *\n     * @param {number} row Visual row index.\n     * @param {number} column Visual column index.\n     * @param {number} [sheet] The target sheet id, defaults to the current sheet.\n     * @returns {string} Possible values: 'FORMULA' | 'VALUE' | 'ARRAYFORMULA' | 'EMPTY'.\n     */\n  }, {\n    key: \"getCellType\",\n    value: function getCellType(row, column) {\n      var sheet = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.sheetId;\n      var physicalRow = this.hot.toPhysicalRow(row);\n      var physicalColumn = this.hot.toPhysicalColumn(column);\n      if (physicalRow !== null && physicalColumn !== null) {\n        return this.engine.getCellType({\n          sheet: sheet,\n          row: physicalRow,\n          col: physicalColumn\n        });\n      } else {\n        // Should return `EMPTY` when out of bounds (according to the test cases).\n        return 'EMPTY';\n      }\n    }\n    /**\n     * Returns `true` if under specified visual coordinates is formula.\n     *\n     * @param {number} row Visual row index.\n     * @param {number} column Visual column index.\n     * @param {number} [sheet] The target sheet id, defaults to the current sheet.\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isFormulaCellType\",\n    value: function isFormulaCellType(row, column) {\n      var sheet = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.sheetId;\n      var physicalRow = this.hot.toPhysicalRow(row);\n      var physicalColumn = this.hot.toPhysicalColumn(column);\n      if (physicalRow === null || physicalColumn === null) {\n        return false;\n      }\n      return this.engine.doesCellHaveFormula({\n        sheet: sheet,\n        row: physicalRow,\n        col: physicalColumn\n      });\n    }\n    /**\n     * Renders dependent sheets (handsontable instances) based on the changes - list of the\n     * recalculated dependent cells.\n     *\n     * @private\n     * @param {object[]} dependentCells The values and location of applied changes within HF engine.\n     * @param {boolean} [renderSelf] `true` if it's supposed to render itself, `false` otherwise.\n     */\n  }, {\n    key: \"renderDependentSheets\",\n    value: function renderDependentSheets(dependentCells) {\n      var _this11 = this;\n      var renderSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var affectedSheetIds = new Set();\n      dependentCells.forEach(function (change) {\n        var _change$address;\n\n        // For the Named expression the address is empty, hence the `sheetId` is undefined.\n        var sheetId = change === null || change === void 0 ? void 0 : (_change$address = change.address) === null || _change$address === void 0 ? void 0 : _change$address.sheet;\n        if (sheetId !== void 0) {\n          if (!affectedSheetIds.has(sheetId)) {\n            affectedSheetIds.add(sheetId);\n          }\n        }\n      });\n      getRegisteredHotInstances(this.engine).forEach(function (relatedHot, sheetId) {\n        if ((renderSelf || sheetId !== _this11.sheetId) && affectedSheetIds.has(sheetId)) {\n          var _relatedHot$view;\n          relatedHot.render();\n          (_relatedHot$view = relatedHot.view) === null || _relatedHot$view === void 0 ? void 0 : _relatedHot$view.adjustElementsSize();\n        }\n      });\n    }\n    /**\n     * Validates dependent cells based on the cells that are modified by the change.\n     *\n     * @private\n     * @param {object[]} dependentCells The values and location of applied changes within HF engine.\n     * @param {object[]} [changedCells] The values and location of applied changes by developer (through API or UI).\n     */\n  }, {\n    key: \"validateDependentCells\",\n    value: function validateDependentCells(dependentCells) {\n      var _this12 = this;\n      var changedCells = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var stringifyAddress = function stringifyAddress(change) {\n        var _change$address2;\n        var _ref7 = (_change$address2 = change === null || change === void 0 ? void 0 : change.address) !== null && _change$address2 !== void 0 ? _change$address2 : {},\n          row = _ref7.row,\n          col = _ref7.col,\n          sheet = _ref7.sheet;\n        return isDefined(sheet) ? \"\".concat(sheet, \":\").concat(row, \"x\").concat(col) : '';\n      };\n      var changedCellsSet = new Set(changedCells.map(function (change) {\n        return stringifyAddress(change);\n      }));\n      dependentCells.forEach(function (change) {\n        var _change$address3, _change$address4;\n        var _ref8 = (_change$address3 = change.address) !== null && _change$address3 !== void 0 ? _change$address3 : {},\n          row = _ref8.row,\n          col = _ref8.col;\n        var visualRow = isDefined(row) ? _this12.hot.toVisualRow(row) : null;\n        var visualColumn = isDefined(col) ? _this12.hot.toVisualColumn(col) : null; // Don't try to validate cells outside of the visual part of the table.\n\n        if (visualRow === null || visualColumn === null) {\n          return;\n        } // For the Named expression the address is empty, hence the `sheetId` is undefined.\n\n        var sheetId = change === null || change === void 0 ? void 0 : (_change$address4 = change.address) === null || _change$address4 === void 0 ? void 0 : _change$address4.sheet;\n        var addressId = stringifyAddress(change); // Validate the cells that depend on the calculated formulas. Skip that cells\n        // where the user directly changes the values - the Core triggers those validators.\n\n        if (sheetId !== void 0 && !changedCellsSet.has(addressId)) {\n          var hot = getRegisteredHotInstances(_this12.engine).get(sheetId); // It will just re-render certain cell when necessary.\n\n          hot.validateCell(hot.getDataAtCell(visualRow, visualColumn), hot.getCellMeta(visualRow, visualColumn), function () {});\n        }\n      });\n    }\n    /**\n     * Sync a change from the change-related hooks with the engine.\n     *\n     * @private\n     * @param {number} row Visual row index.\n     * @param {number} column Visual column index.\n     * @param {Handsontable.CellValue} newValue New value.\n     * @returns {Array} Array of changes exported from the engine.\n     */\n  }, {\n    key: \"syncChangeWithEngine\",\n    value: function syncChangeWithEngine(row, column, newValue) {\n      var address = {\n        row: this.toPhysicalRowPosition(row),\n        col: this.toPhysicalColumnPosition(column),\n        sheet: this.sheetId\n      };\n      if (!this.engine.isItPossibleToSetCellContents(address)) {\n        warn(\"Not possible to set cell data at \".concat(JSON.stringify(address)));\n        return;\n      }\n      return this.engine.setCellContents(address, newValue);\n    }\n    /**\n     * The hook allows to translate the formula value to calculated value before it goes to the\n     * validator function.\n     *\n     * @private\n     * @param {*} value The cell value to validate.\n     * @param {number} visualRow The visual row index.\n     * @param {number|string} prop The visual column index or property name of the column.\n     * @returns {*} Returns value to validate.\n     */\n  }, {\n    key: \"onBeforeValidate\",\n    value: function onBeforeValidate(value, visualRow, prop) {\n      var visualColumn = this.hot.propToCol(prop);\n      if (this.isFormulaCellType(visualRow, visualColumn)) {\n        var address = {\n          row: this.hot.toPhysicalRow(visualRow),\n          col: this.hot.toPhysicalColumn(visualColumn),\n          sheet: this.sheetId\n        };\n        var cellValue = this.engine.getCellValue(address); // If `cellValue` is an object it is expected to be an error\n\n        return _typeof(cellValue) === 'object' && cellValue !== null ? cellValue.value : cellValue;\n      }\n      return value;\n    }\n    /**\n     * `onBeforeAutofill` hook callback.\n     *\n     * @private\n     * @param {Array[]} fillData The data that was used to fill the `targetRange`. If `beforeAutofill` was used\n     * and returned `[[]]`, this will be the same object that was returned from `beforeAutofill`.\n     * @param {CellRange} sourceRange The range values will be filled from.\n     * @param {CellRange} targetRange The range new values will be filled into.\n     * @returns {boolean|*}\n     */\n  }, {\n    key: \"onBeforeAutofill\",\n    value: function onBeforeAutofill(fillData, sourceRange, targetRange) {\n      var _this13 = this;\n      var withSheetId = function withSheetId(range) {\n        return _objectSpread(_objectSpread({}, range), {}, {\n          sheet: _this13.sheetId\n        });\n      };\n      var engineSourceRange = {\n        start: withSheetId(sourceRange.getTopLeftCorner()),\n        end: withSheetId(sourceRange.getBottomRightCorner())\n      };\n      var engineTargetRange = {\n        start: withSheetId(targetRange.getTopLeftCorner()),\n        end: withSheetId(targetRange.getBottomRightCorner())\n      }; // Blocks the autofill operation if HyperFormula says that at least one of\n      // the underlying cell's contents cannot be set.\n\n      if (this.engine.isItPossibleToSetCellContents(engineTargetRange) === false) {\n        return false;\n      }\n      return this.engine.getFillRangeData(engineSourceRange, engineTargetRange);\n    }\n    /**\n     * `beforeLoadData` hook callback.\n     *\n     * @param {Array} sourceData Array of arrays or array of objects containing data.\n     * @param {boolean} initialLoad Flag that determines whether the data has been loaded during the initialization.\n     * @param {string} [source] Source of the call.\n     * @private\n     */\n  }, {\n    key: \"onBeforeLoadData\",\n    value: function onBeforeLoadData(sourceData, initialLoad) {\n      var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      if (source.includes(toUpperCaseFirst(PLUGIN_KEY))) {\n        return;\n      } // This flag needs to be defined, because not passing data to HOT results in HOT auto-generating a `null`-filled\n      // initial dataset.\n\n      _classPrivateFieldSet(this, _hotWasInitializedWithEmptyData, isUndefined(this.hot.getSettings().data));\n    }\n    /**\n     * `afterLoadData` hook callback.\n     *\n     * @param {Array} sourceData Array of arrays or array of objects containing data.\n     * @param {boolean} initialLoad Flag that determines whether the data has been loaded during the initialization.\n     * @param {string} [source] Source of the call.\n     * @private\n     */\n  }, {\n    key: \"onAfterLoadData\",\n    value: function onAfterLoadData(sourceData, initialLoad) {\n      var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      if (source.includes(toUpperCaseFirst(PLUGIN_KEY))) {\n        return;\n      }\n      this.sheetName = setupSheet(this.engine, this.hot.getSettings()[PLUGIN_KEY].sheetName);\n      if (!_classPrivateFieldGet(this, _hotWasInitializedWithEmptyData)) {\n        var sourceDataArray = this.hot.getSourceDataArray();\n        if (this.engine.isItPossibleToReplaceSheetContent(this.sheetId, sourceDataArray)) {\n          _classPrivateFieldSet(this, _internalOperationPending, true);\n          var dependentCells = this.engine.setSheetContent(this.sheetId, this.hot.getSourceDataArray());\n          this.renderDependentSheets(dependentCells);\n          _classPrivateFieldSet(this, _internalOperationPending, false);\n        }\n      } else {\n        this.switchSheet(this.sheetName);\n      }\n    }\n    /**\n     * `modifyData` hook callback.\n     *\n     * @private\n     * @param {number} row Physical row height.\n     * @param {number} column Physical column index.\n     * @param {object} valueHolder Object which contains original value which can be modified by overwriting `.value`\n     *   property.\n     * @param {string} ioMode String which indicates for what operation hook is fired (`get` or `set`).\n     */\n  }, {\n    key: \"onModifyData\",\n    value: function onModifyData(row, column, valueHolder, ioMode) {\n      if (ioMode !== 'get' || _classPrivateFieldGet(this, _internalOperationPending) || this.sheetName === null || !this.engine.doesSheetExist(this.sheetName)) {\n        return;\n      }\n      var visualRow = this.hot.toVisualRow(row); // `column` is here as visual index because of inconsistencies related to hook execution in `src/dataMap`.\n\n      var isFormulaCellType = this.isFormulaCellType(visualRow, column);\n      if (!isFormulaCellType) {\n        var cellType = this.getCellType(visualRow, column);\n        if (cellType !== 'ARRAY') {\n          if (isEscapedFormulaExpression(valueHolder.value)) {\n            valueHolder.value = unescapeFormulaExpression(valueHolder.value);\n          }\n          return;\n        }\n      } // `toPhysicalColumn` is here because of inconsistencies related to hook execution in `DataMap`.\n\n      var address = {\n        row: row,\n        col: this.toPhysicalColumnPosition(column),\n        sheet: this.sheetId\n      };\n      var cellValue = this.engine.getCellValue(address); // If `cellValue` is an object it is expected to be an error\n\n      var value = _typeof(cellValue) === 'object' && cellValue !== null ? cellValue.value : cellValue;\n      valueHolder.value = value;\n    }\n    /**\n     * `modifySourceData` hook callback.\n     *\n     * @private\n     * @param {number} row Physical row index.\n     * @param {number|string} columnOrProp Physical column index or prop.\n     * @param {object} valueHolder Object which contains original value which can be modified by overwriting `.value`\n     *   property.\n     * @param {string} ioMode String which indicates for what operation hook is fired (`get` or `set`).\n     */\n  }, {\n    key: \"onModifySourceData\",\n    value: function onModifySourceData(row, columnOrProp, valueHolder, ioMode) {\n      if (ioMode !== 'get' || _classPrivateFieldGet(this, _internalOperationPending) || this.sheetName === null || !this.engine.doesSheetExist(this.sheetName)) {\n        return;\n      }\n      var visualRow = this.hot.toVisualRow(row);\n      var visualColumn = this.hot.propToCol(columnOrProp); // `column` is here as visual index because of inconsistencies related to hook execution in `src/dataMap`.\n\n      var isFormulaCellType = this.isFormulaCellType(visualRow, visualColumn);\n      if (!isFormulaCellType) {\n        var cellType = this.getCellType(visualRow, visualColumn);\n        if (cellType !== 'ARRAY') {\n          return;\n        }\n      }\n      var dimensions = this.engine.getSheetDimensions(this.engine.getSheetId(this.sheetName)); // Don't actually change the source data if HyperFormula is not\n      // initialized yet. This is done to allow the `afterLoadData` hook to\n      // load the existing source data with `Handsontable#getSourceDataArray`\n      // properly.\n\n      if (dimensions.width === 0 && dimensions.height === 0) {\n        return;\n      }\n      var address = {\n        row: row,\n        // Workaround for inconsistencies in `src/dataSource.js`\n        col: this.toPhysicalColumnPosition(visualColumn),\n        sheet: this.sheetId\n      };\n      valueHolder.value = this.engine.getCellSerialized(address);\n    }\n    /**\n     * `onAfterSetDataAtCell` hook callback.\n     *\n     * @private\n     * @param {Array[]} changes An array of changes in format [[row, prop, oldValue, value], ...].\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link http://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).\n     */\n  }, {\n    key: \"onAfterSetDataAtCell\",\n    value: function onAfterSetDataAtCell(changes, source) {\n      var _this14 = this;\n      if (isBlockedSource(source)) {\n        return;\n      }\n      var outOfBoundsChanges = [];\n      var changedCells = [];\n      var dependentCells = this.engine.batch(function () {\n        changes.forEach(function (_ref9) {\n          var _ref10 = _slicedToArray(_ref9, 4),\n            row = _ref10[0],\n            prop = _ref10[1],\n            newValue = _ref10[3];\n          var column = _this14.hot.propToCol(prop);\n          var physicalRow = _this14.hot.toPhysicalRow(row);\n          var physicalColumn = _this14.hot.toPhysicalColumn(column);\n          var address = {\n            row: physicalRow,\n            col: physicalColumn,\n            sheet: _this14.sheetId\n          };\n          if (physicalRow !== null && physicalColumn !== null) {\n            _this14.syncChangeWithEngine(row, column, newValue);\n          } else {\n            outOfBoundsChanges.push([row, column, newValue]);\n          }\n          changedCells.push({\n            address: address\n          });\n        });\n      });\n      if (outOfBoundsChanges.length) {\n        // Workaround for rows/columns being created two times (by HOT and the engine).\n        // (unfortunately, this requires an extra re-render)\n        this.hot.addHookOnce('afterChange', function () {\n          var outOfBoundsDependentCells = _this14.engine.batch(function () {\n            outOfBoundsChanges.forEach(function (_ref11) {\n              var _ref12 = _slicedToArray(_ref11, 3),\n                row = _ref12[0],\n                column = _ref12[1],\n                newValue = _ref12[2];\n              _this14.syncChangeWithEngine(row, column, newValue);\n            });\n          });\n          _this14.renderDependentSheets(outOfBoundsDependentCells, true);\n        });\n      }\n      this.renderDependentSheets(dependentCells);\n      this.validateDependentCells(dependentCells, changedCells);\n    }\n    /**\n     * `onAfterSetSourceDataAtCell` hook callback.\n     *\n     * @private\n     * @param {Array[]} changes An array of changes in format [[row, column, oldValue, value], ...].\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link http://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).\n     */\n  }, {\n    key: \"onAfterSetSourceDataAtCell\",\n    value: function onAfterSetSourceDataAtCell(changes, source) {\n      var _this15 = this;\n      if (isBlockedSource(source)) {\n        return;\n      }\n      var dependentCells = [];\n      var changedCells = [];\n      changes.forEach(function (_ref13) {\n        var _ref14 = _slicedToArray(_ref13, 4),\n          row = _ref14[0],\n          prop = _ref14[1],\n          newValue = _ref14[3];\n        var column = _this15.hot.propToCol(prop);\n        if (!isNumeric(column)) {\n          return;\n        }\n        var address = {\n          row: row,\n          col: _this15.toPhysicalColumnPosition(column),\n          sheet: _this15.sheetId\n        };\n        if (!_this15.engine.isItPossibleToSetCellContents(address)) {\n          warn(\"Not possible to set source cell data at \".concat(JSON.stringify(address)));\n          return;\n        }\n        changedCells.push({\n          address: address\n        });\n        dependentCells.push.apply(dependentCells, _toConsumableArray(_this15.engine.setCellContents(address, newValue)));\n      });\n      this.renderDependentSheets(dependentCells);\n      this.validateDependentCells(dependentCells, changedCells);\n    }\n    /**\n     * `beforeCreateRow` hook callback.\n     *\n     * @private\n     * @param {number} row Represents the visual index of first newly created row in the data source array.\n     * @param {number} amount Number of newly created rows in the data source array.\n     * @returns {*|boolean} If false is returned the action is canceled.\n     */\n  }, {\n    key: \"onBeforeCreateRow\",\n    value: function onBeforeCreateRow(row, amount) {\n      if (this.sheetId === null || !this.engine.doesSheetExist(this.sheetName) || !this.engine.isItPossibleToAddRows(this.sheetId, [this.toPhysicalRowPosition(row), amount])) {\n        return false;\n      }\n    }\n    /**\n     * `beforeCreateCol` hook callback.\n     *\n     * @private\n     * @param {number} col Represents the visual index of first newly created column in the data source.\n     * @param {number} amount Number of newly created columns in the data source.\n     * @returns {*|boolean} If false is returned the action is canceled.\n     */\n  }, {\n    key: \"onBeforeCreateCol\",\n    value: function onBeforeCreateCol(col, amount) {\n      if (this.sheetId === null || !this.engine.doesSheetExist(this.sheetName) || !this.engine.isItPossibleToAddColumns(this.sheetId, [this.toPhysicalColumnPosition(col), amount])) {\n        return false;\n      }\n    }\n    /**\n     * `beforeRemoveRow` hook callback.\n     *\n     * @private\n     * @param {number} row Visual index of starter row.\n     * @param {number} amount Amount of rows to be removed.\n     * @param {number[]} physicalRows An array of physical rows removed from the data source.\n     * @returns {*|boolean} If false is returned the action is canceled.\n     */\n  }, {\n    key: \"onBeforeRemoveRow\",\n    value: function onBeforeRemoveRow(row, amount, physicalRows) {\n      var _this16 = this;\n      var possible = physicalRows.every(function (physicalRow) {\n        return _this16.engine.isItPossibleToRemoveRows(_this16.sheetId, [physicalRow, 1]);\n      });\n      return possible === false ? false : void 0;\n    }\n    /**\n     * `beforeRemoveCol` hook callback.\n     *\n     * @private\n     * @param {number} col Visual index of starter column.\n     * @param {number} amount Amount of columns to be removed.\n     * @param {number[]} physicalColumns An array of physical columns removed from the data source.\n     * @returns {*|boolean} If false is returned the action is canceled.\n     */\n  }, {\n    key: \"onBeforeRemoveCol\",\n    value: function onBeforeRemoveCol(col, amount, physicalColumns) {\n      var _this17 = this;\n      var possible = physicalColumns.every(function (physicalColumn) {\n        return _this17.engine.isItPossibleToRemoveColumns(_this17.sheetId, [physicalColumn, 1]);\n      });\n      return possible === false ? false : void 0;\n    }\n    /**\n     * `afterCreateRow` hook callback.\n     *\n     * @private\n     * @param {number} row Represents the visual index of first newly created row in the data source array.\n     * @param {number} amount Number of newly created rows in the data source array.\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link http://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).\n     */\n  }, {\n    key: \"onAfterCreateRow\",\n    value: function onAfterCreateRow(row, amount, source) {\n      if (isBlockedSource(source)) {\n        return;\n      }\n      var changes = this.engine.addRows(this.sheetId, [this.toPhysicalRowPosition(row), amount]);\n      this.renderDependentSheets(changes);\n    }\n    /**\n     * `afterCreateCol` hook callback.\n     *\n     * @private\n     * @param {number} col Represents the visual index of first newly created column in the data source.\n     * @param {number} amount Number of newly created columns in the data source.\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link http://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).\n     */\n  }, {\n    key: \"onAfterCreateCol\",\n    value: function onAfterCreateCol(col, amount, source) {\n      if (isBlockedSource(source)) {\n        return;\n      }\n      var changes = this.engine.addColumns(this.sheetId, [this.toPhysicalColumnPosition(col), amount]);\n      this.renderDependentSheets(changes);\n    }\n    /**\n     * `afterRemoveRow` hook callback.\n     *\n     * @private\n     * @param {number} row Visual index of starter row.\n     * @param {number} amount An amount of removed rows.\n     * @param {number[]} physicalRows An array of physical rows removed from the data source.\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link http://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).\n     */\n  }, {\n    key: \"onAfterRemoveRow\",\n    value: function onAfterRemoveRow(row, amount, physicalRows, source) {\n      var _this18 = this;\n      if (isBlockedSource(source)) {\n        return;\n      }\n      var descendingPhysicalRows = physicalRows.sort().reverse();\n      var changes = this.engine.batch(function () {\n        descendingPhysicalRows.forEach(function (physicalRow) {\n          _this18.engine.removeRows(_this18.sheetId, [physicalRow, 1]);\n        });\n      });\n      this.renderDependentSheets(changes);\n    }\n    /**\n     * `afterRemoveCol` hook callback.\n     *\n     * @private\n     * @param {number} col Visual index of starter column.\n     * @param {number} amount An amount of removed columns.\n     * @param {number[]} physicalColumns An array of physical columns removed from the data source.\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link http://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).\n     */\n  }, {\n    key: \"onAfterRemoveCol\",\n    value: function onAfterRemoveCol(col, amount, physicalColumns, source) {\n      var _this19 = this;\n      if (isBlockedSource(source)) {\n        return;\n      }\n      var descendingPhysicalColumns = physicalColumns.sort().reverse();\n      var changes = this.engine.batch(function () {\n        descendingPhysicalColumns.forEach(function (physicalColumn) {\n          _this19.engine.removeColumns(_this19.sheetId, [physicalColumn, 1]);\n        });\n      });\n      this.renderDependentSheets(changes);\n    }\n    /**\n     * `afterDetachChild` hook callback.\n     * Used to sync the data of the rows detached in the Nested Rows plugin with the engine's dataset.\n     *\n     * @private\n     * @param {object} parent An object representing the parent from which the element was detached.\n     * @param {object} element The detached element.\n     * @param {number} finalElementRowIndex The final row index of the detached element.\n     */\n  }, {\n    key: \"onAfterDetachChild\",\n    value: function onAfterDetachChild(parent, element, finalElementRowIndex) {\n      var _element$__children,\n        _this20 = this;\n      _classPrivateFieldSet(this, _internalOperationPending, true);\n      var rowsData = this.hot.getSourceDataArray(finalElementRowIndex, 0, finalElementRowIndex + (((_element$__children = element.__children) === null || _element$__children === void 0 ? void 0 : _element$__children.length) || 0), this.hot.countSourceCols());\n      _classPrivateFieldSet(this, _internalOperationPending, false);\n      rowsData.forEach(function (row, relativeRowIndex) {\n        row.forEach(function (value, colIndex) {\n          _this20.engine.setCellContents({\n            col: colIndex,\n            row: finalElementRowIndex + relativeRowIndex,\n            sheet: _this20.sheetId\n          }, [[value]]);\n        });\n      });\n    }\n    /**\n     * Called when a value is updated in the engine.\n     *\n     * @private\n     * @fires Hooks#afterFormulasValuesUpdate\n     * @param {Array} changes The values and location of applied changes.\n     */\n  }, {\n    key: \"onEngineValuesUpdated\",\n    value: function onEngineValuesUpdated(changes) {\n      this.hot.runHooks('afterFormulasValuesUpdate', changes);\n    }\n    /**\n     * Called when a named expression is added to the engine instance.\n     *\n     * @private\n     * @fires Hooks#afterNamedExpressionAdded\n     * @param {string} namedExpressionName The name of the added expression.\n     * @param {Array} changes The values and location of applied changes.\n     */\n  }, {\n    key: \"onEngineNamedExpressionsAdded\",\n    value: function onEngineNamedExpressionsAdded(namedExpressionName, changes) {\n      this.hot.runHooks('afterNamedExpressionAdded', namedExpressionName, changes);\n    }\n    /**\n     * Called when a named expression is removed from the engine instance.\n     *\n     * @private\n     * @fires Hooks#afterNamedExpressionRemoved\n     * @param {string} namedExpressionName The name of the removed expression.\n     * @param {Array} changes The values and location of applied changes.\n     */\n  }, {\n    key: \"onEngineNamedExpressionsRemoved\",\n    value: function onEngineNamedExpressionsRemoved(namedExpressionName, changes) {\n      this.hot.runHooks('afterNamedExpressionRemoved', namedExpressionName, changes);\n    }\n    /**\n     * Called when a new sheet is added to the engine instance.\n     *\n     * @private\n     * @fires Hooks#afterSheetAdded\n     * @param {string} addedSheetDisplayName The name of the added sheet.\n     */\n  }, {\n    key: \"onEngineSheetAdded\",\n    value: function onEngineSheetAdded(addedSheetDisplayName) {\n      this.hot.runHooks('afterSheetAdded', addedSheetDisplayName);\n    }\n    /**\n     * Called when a sheet in the engine instance is renamed.\n     *\n     * @private\n     * @fires Hooks#afterSheetRenamed\n     * @param {string} oldDisplayName The old name of the sheet.\n     * @param {string} newDisplayName The new name of the sheet.\n     */\n  }, {\n    key: \"onEngineSheetRenamed\",\n    value: function onEngineSheetRenamed(oldDisplayName, newDisplayName) {\n      this.hot.runHooks('afterSheetRenamed', oldDisplayName, newDisplayName);\n    }\n    /**\n     * Called when a sheet is removed from the engine instance.\n     *\n     * @private\n     * @fires Hooks#afterSheetRemoved\n     * @param {string} removedSheetDisplayName The removed sheet name.\n     * @param {Array} changes The values and location of applied changes.\n     */\n  }, {\n    key: \"onEngineSheetRemoved\",\n    value: function onEngineSheetRemoved(removedSheetDisplayName, changes) {\n      this.hot.runHooks('afterSheetRemoved', removedSheetDisplayName, changes);\n    }\n  }], [{\n    key: \"PLUGIN_KEY\",\n    get: function get() {\n      return PLUGIN_KEY;\n    }\n  }, {\n    key: \"PLUGIN_PRIORITY\",\n    get: function get() {\n      return PLUGIN_PRIORITY;\n    }\n    /**\n     * Flag used to bypass hooks in internal operations.\n     *\n     * @private\n     * @type {boolean}\n     */\n  }]);\n  return Formulas;\n}(BasePlugin);","map":{"version":3,"names":["_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","TypeError","iter","Symbol","iterator","Array","from","isArray","_arrayLikeToArray","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","_typeof","obj","constructor","prototype","_slicedToArray","_arrayWithHoles","_iterableToArrayLimit","_nonIterableRest","o","minLen","n","toString","call","slice","name","test","len","arr2","_i","_arr","_n","_d","_s","_e","next","done","value","err","_classCallCheck","instance","Constructor","_defineProperties","props","descriptor","configurable","writable","_createClass","protoProps","staticProps","_get","Reflect","get","property","receiver","base","_superPropBase","desc","hasOwnProperty","_getPrototypeOf","_inherits","subClass","superClass","create","_setPrototypeOf","p","setPrototypeOf","__proto__","_createSuper","Derived","hasNativeReflectConstruct","_isNativeReflectConstruct","_createSuperInternal","Super","result","NewTarget","construct","_possibleConstructorReturn","self","_assertThisInitialized","ReferenceError","sham","Proxy","Boolean","valueOf","e","getPrototypeOf","_classPrivateFieldInitSpec","privateMap","_checkPrivateRedeclaration","set","privateCollection","has","_classPrivateFieldSet","_classExtractFieldDescriptor","_classApplyDescriptorSet","_classPrivateFieldGet","_classApplyDescriptorGet","action","BasePlugin","staticRegister","error","warn","isNumeric","isDefined","isUndefined","setupEngine","setupSheet","unregisterEngine","getRegisteredHotInstances","isEscapedFormulaExpression","unescapeFormulaExpression","getEngineSettingsWithOverrides","isArrayOfArrays","toUpperCaseFirst","Hooks","PLUGIN_KEY","PLUGIN_PRIORITY","ROW_MOVE_UNDO_REDO_NAME","getSingleton","register","isBlockedSource","_internalOperationPending","WeakMap","_hotWasInitializedWithEmptyData","_engineListeners","Formulas","_BasePlugin","_super","_this","_len","_args","_key","concat","_this2","onEngineValuesUpdated","_this3","onEngineNamedExpressionsAdded","_this4","onEngineNamedExpressionsRemoved","_this5","onEngineSheetAdded","_this6","onEngineSheetRenamed","_this7","onEngineSheetRemoved","sheetName","engine","getSheetId","isEnabled","hot","getSettings","enablePlugin","_setupEngine","_this8","enabled","doesSheetExist","newSheetName","addSheet","getSourceDataArray","addHook","onBeforeLoadData","onAfterLoadData","onModifyData","onModifySourceData","onBeforeValidate","onAfterSetSourceDataAtCell","onAfterSetDataAtCell","onBeforeCreateRow","onBeforeCreateCol","onAfterCreateRow","onAfterCreateCol","onBeforeRemoveRow","onBeforeRemoveCol","onAfterRemoveRow","onAfterRemoveCol","actionType","undo","redo","onAfterDetachChild","onBeforeAutofill","_ref","_ref2","eventName","listener","on","disablePlugin","_this9","_ref3","_ref4","off","updatePlugin","newSettings","updateConfig","pluginSettings","switchSheet","data","destroy","_this10","_ref5","_this10$engine","_ref6","getPhysicalIndexPosition","visualIndex","physicalIndex","entriesCount","sourceEntriesCount","contained","toPhysicalRowPosition","row","undefined","toPhysicalRow","countRows","countSourceRows","toPhysicalColumnPosition","column","toPhysicalColumn","countCols","countSourceCols","sheetData","actualSheetName","setSheetContent","message","serialized","getSheetSerialized","sheetId","loadData","getCellType","sheet","physicalRow","physicalColumn","col","isFormulaCellType","doesCellHaveFormula","renderDependentSheets","dependentCells","_this11","renderSelf","affectedSheetIds","Set","change","_change$address","address","add","relatedHot","_relatedHot$view","render","view","adjustElementsSize","validateDependentCells","_this12","changedCells","stringifyAddress","_change$address2","_ref7","changedCellsSet","map","_change$address3","_change$address4","_ref8","visualRow","toVisualRow","visualColumn","toVisualColumn","addressId","validateCell","getDataAtCell","getCellMeta","syncChangeWithEngine","newValue","isItPossibleToSetCellContents","JSON","stringify","setCellContents","prop","propToCol","cellValue","getCellValue","fillData","sourceRange","targetRange","_this13","withSheetId","range","engineSourceRange","start","getTopLeftCorner","end","getBottomRightCorner","engineTargetRange","getFillRangeData","sourceData","initialLoad","includes","sourceDataArray","isItPossibleToReplaceSheetContent","valueHolder","ioMode","cellType","columnOrProp","dimensions","getSheetDimensions","width","height","getCellSerialized","changes","_this14","outOfBoundsChanges","batch","_ref9","_ref10","addHookOnce","outOfBoundsDependentCells","_ref11","_ref12","_this15","_ref13","_ref14","amount","isItPossibleToAddRows","isItPossibleToAddColumns","physicalRows","_this16","possible","every","isItPossibleToRemoveRows","physicalColumns","_this17","isItPossibleToRemoveColumns","addRows","addColumns","_this18","descendingPhysicalRows","sort","reverse","removeRows","_this19","descendingPhysicalColumns","removeColumns","parent","element","finalElementRowIndex","_element$__children","_this20","rowsData","__children","relativeRowIndex","colIndex","runHooks","namedExpressionName","addedSheetDisplayName","oldDisplayName","newDisplayName","removedSheetDisplayName"],"sources":["/Users/priyadeliwala/Desktop/sales-dashboard/node_modules/handsontable/plugins/formulas/formulas.mjs"],"sourcesContent":["function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.set.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/es.array.reverse.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.weak-map.js\";\nimport \"core-js/modules/es.object.set-prototype-of.js\";\nimport \"core-js/modules/es.object.get-prototype-of.js\";\nimport \"core-js/modules/es.reflect.construct.js\";\nimport \"core-js/modules/es.reflect.get.js\";\nimport \"core-js/modules/es.object.get-own-property-descriptor.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.object.get-own-property-descriptors.js\";\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _get() { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }\n\nfunction _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); } }\n\nfunction _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }\n\nfunction _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } }\n\nfunction _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\"); return _classApplyDescriptorGet(receiver, descriptor); }\n\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to \" + action + \" private field on non-instance\"); } return privateMap.get(receiver); }\n\nfunction _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\n\nimport { BasePlugin } from \"../base/index.mjs\";\nimport staticRegister from \"../../utils/staticRegister.mjs\";\nimport { error, warn } from \"../../helpers/console.mjs\";\nimport { isNumeric } from \"../../helpers/number.mjs\";\nimport { isDefined, isUndefined } from \"../../helpers/mixed.mjs\";\nimport { setupEngine, setupSheet, unregisterEngine, getRegisteredHotInstances } from \"./engine/register.mjs\";\nimport { isEscapedFormulaExpression, unescapeFormulaExpression } from \"./utils.mjs\";\nimport { getEngineSettingsWithOverrides } from \"./engine/settings.mjs\";\nimport { isArrayOfArrays } from \"../../helpers/data.mjs\";\nimport { toUpperCaseFirst } from \"../../helpers/string.mjs\";\nimport Hooks from \"../../pluginHooks.mjs\";\nexport var PLUGIN_KEY = 'formulas';\nexport var PLUGIN_PRIORITY = 260;\nvar ROW_MOVE_UNDO_REDO_NAME = 'row_move';\nHooks.getSingleton().register('afterNamedExpressionAdded');\nHooks.getSingleton().register('afterNamedExpressionRemoved');\nHooks.getSingleton().register('afterSheetAdded');\nHooks.getSingleton().register('afterSheetRemoved');\nHooks.getSingleton().register('afterSheetRenamed');\nHooks.getSingleton().register('afterFormulasValuesUpdate'); // This function will be used for detecting changes coming from the `UndoRedo` plugin. This kind of change won't be\n// handled by whole body of listeners and therefore won't change undo/redo stack inside engine provided by HyperFormula.\n// HyperFormula's `undo` and `redo` methods will do it instead. Please keep in mind that undo/redo stacks inside\n// instances of Handsontable and HyperFormula should be synced (number of actions should be the same).\n\nvar isBlockedSource = function isBlockedSource(source) {\n  return source === 'UndoRedo.undo' || source === 'UndoRedo.redo' || source === 'auto';\n};\n/**\n * This plugin allows you to perform Excel-like calculations in your business applications. It does it by an\n * integration with our other product, [HyperFormula](https://github.com/handsontable/hyperformula/), which is a\n * powerful calculation engine with an extensive number of features.\n *\n * To test out HyperFormula, see [this guide](@/guides/formulas/formula-calculation.md#available-functions).\n *\n * @plugin Formulas\n * @class Formulas\n */\n\n\nvar _internalOperationPending = /*#__PURE__*/new WeakMap();\n\nvar _hotWasInitializedWithEmptyData = /*#__PURE__*/new WeakMap();\n\nvar _engineListeners = /*#__PURE__*/new WeakMap();\n\nexport var Formulas = /*#__PURE__*/function (_BasePlugin) {\n  _inherits(Formulas, _BasePlugin);\n\n  var _super = _createSuper(Formulas);\n\n  function Formulas() {\n    var _this;\n\n    _classCallCheck(this, Formulas);\n\n    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {\n      _args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(_args));\n\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _internalOperationPending, {\n      writable: true,\n      value: false\n    });\n\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _hotWasInitializedWithEmptyData, {\n      writable: true,\n      value: false\n    });\n\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _engineListeners, {\n      writable: true,\n      value: [['valuesUpdated', function () {\n        var _this2;\n\n        return (_this2 = _this).onEngineValuesUpdated.apply(_this2, arguments);\n      }], ['namedExpressionAdded', function () {\n        var _this3;\n\n        return (_this3 = _this).onEngineNamedExpressionsAdded.apply(_this3, arguments);\n      }], ['namedExpressionRemoved', function () {\n        var _this4;\n\n        return (_this4 = _this).onEngineNamedExpressionsRemoved.apply(_this4, arguments);\n      }], ['sheetAdded', function () {\n        var _this5;\n\n        return (_this5 = _this).onEngineSheetAdded.apply(_this5, arguments);\n      }], ['sheetRenamed', function () {\n        var _this6;\n\n        return (_this6 = _this).onEngineSheetRenamed.apply(_this6, arguments);\n      }], ['sheetRemoved', function () {\n        var _this7;\n\n        return (_this7 = _this).onEngineSheetRemoved.apply(_this7, arguments);\n      }]]\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"staticRegister\", staticRegister('formulas'));\n\n    _defineProperty(_assertThisInitialized(_this), \"engine\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"sheetName\", null);\n\n    return _this;\n  }\n\n  _createClass(Formulas, [{\n    key: \"sheetId\",\n    get:\n    /**\n     * HyperFormula's sheet id.\n     *\n     * @type {number|null}\n     */\n    function get() {\n      return this.sheetName === null ? null : this.engine.getSheetId(this.sheetName);\n    }\n    /**\n     * Checks if the plugin is enabled in the handsontable settings. This method is executed in {@link Hooks#beforeInit}\n     * hook and if it returns `true` than the {@link Formulas#enablePlugin} method is called.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isEnabled\",\n    value: function isEnabled() {\n      /* eslint-disable no-unneeded-ternary */\n      return this.hot.getSettings()[PLUGIN_KEY] ? true : false;\n    }\n    /**\n     * Enables the plugin functionality for this Handsontable instance.\n     */\n\n  }, {\n    key: \"enablePlugin\",\n    value: function enablePlugin() {\n      var _setupEngine,\n          _this8 = this;\n\n      if (this.enabled) {\n        return;\n      }\n\n      this.engine = (_setupEngine = setupEngine(this.hot)) !== null && _setupEngine !== void 0 ? _setupEngine : this.engine;\n\n      if (!this.engine) {\n        warn('Missing the required `engine` key in the Formulas settings. Please fill it with either an' + ' engine class or an engine instance.');\n        return;\n      } // Useful for disabling -> enabling the plugin using `updateSettings` or the API.\n\n\n      if (this.sheetName !== null && !this.engine.doesSheetExist(this.sheetName)) {\n        var newSheetName = this.addSheet(this.sheetName, this.hot.getSourceDataArray());\n\n        if (newSheetName !== false) {\n          this.sheetName = newSheetName;\n        }\n      }\n\n      this.addHook('beforeLoadData', function () {\n        return _this8.onBeforeLoadData.apply(_this8, arguments);\n      });\n      this.addHook('afterLoadData', function () {\n        return _this8.onAfterLoadData.apply(_this8, arguments);\n      });\n      this.addHook('modifyData', function () {\n        return _this8.onModifyData.apply(_this8, arguments);\n      });\n      this.addHook('modifySourceData', function () {\n        return _this8.onModifySourceData.apply(_this8, arguments);\n      });\n      this.addHook('beforeValidate', function () {\n        return _this8.onBeforeValidate.apply(_this8, arguments);\n      });\n      this.addHook('afterSetSourceDataAtCell', function () {\n        return _this8.onAfterSetSourceDataAtCell.apply(_this8, arguments);\n      });\n      this.addHook('afterSetDataAtCell', function () {\n        return _this8.onAfterSetDataAtCell.apply(_this8, arguments);\n      });\n      this.addHook('afterSetDataAtRowProp', function () {\n        return _this8.onAfterSetDataAtCell.apply(_this8, arguments);\n      });\n      this.addHook('beforeCreateRow', function () {\n        return _this8.onBeforeCreateRow.apply(_this8, arguments);\n      });\n      this.addHook('beforeCreateCol', function () {\n        return _this8.onBeforeCreateCol.apply(_this8, arguments);\n      });\n      this.addHook('afterCreateRow', function () {\n        return _this8.onAfterCreateRow.apply(_this8, arguments);\n      });\n      this.addHook('afterCreateCol', function () {\n        return _this8.onAfterCreateCol.apply(_this8, arguments);\n      });\n      this.addHook('beforeRemoveRow', function () {\n        return _this8.onBeforeRemoveRow.apply(_this8, arguments);\n      });\n      this.addHook('beforeRemoveCol', function () {\n        return _this8.onBeforeRemoveCol.apply(_this8, arguments);\n      });\n      this.addHook('afterRemoveRow', function () {\n        return _this8.onAfterRemoveRow.apply(_this8, arguments);\n      });\n      this.addHook('afterRemoveCol', function () {\n        return _this8.onAfterRemoveCol.apply(_this8, arguments);\n      }); // Handling undo actions on data just using HyperFormula's UndoRedo mechanism\n\n      this.addHook('beforeUndo', function (action) {\n        // TODO: Move action isn't handled by HyperFormula.\n        if ((action === null || action === void 0 ? void 0 : action.actionType) === ROW_MOVE_UNDO_REDO_NAME) {\n          return;\n        }\n\n        _this8.engine.undo();\n      }); // Handling redo actions on data just using HyperFormula's UndoRedo mechanism\n\n      this.addHook('beforeRedo', function (action) {\n        // TODO: Move action isn't handled by HyperFormula.\n        if ((action === null || action === void 0 ? void 0 : action.actionType) === ROW_MOVE_UNDO_REDO_NAME) {\n          return;\n        }\n\n        _this8.engine.redo();\n      });\n      this.addHook('afterDetachChild', function () {\n        return _this8.onAfterDetachChild.apply(_this8, arguments);\n      });\n      this.addHook('beforeAutofill', function () {\n        return _this8.onBeforeAutofill.apply(_this8, arguments);\n      });\n\n      _classPrivateFieldGet(this, _engineListeners).forEach(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            eventName = _ref2[0],\n            listener = _ref2[1];\n\n        return _this8.engine.on(eventName, listener);\n      });\n\n      _get(_getPrototypeOf(Formulas.prototype), \"enablePlugin\", this).call(this);\n    }\n    /**\n     * Disables the plugin functionality for this Handsontable instance.\n     */\n\n  }, {\n    key: \"disablePlugin\",\n    value: function disablePlugin() {\n      var _this9 = this;\n\n      _classPrivateFieldGet(this, _engineListeners).forEach(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n            eventName = _ref4[0],\n            listener = _ref4[1];\n\n        return _this9.engine.off(eventName, listener);\n      });\n\n      unregisterEngine(this.engine, this.hot);\n      this.engine = null;\n\n      _get(_getPrototypeOf(Formulas.prototype), \"disablePlugin\", this).call(this);\n    }\n    /**\n     * Triggered on `updateSettings`.\n     *\n     * @private\n     * @param {object} newSettings New set of settings passed to the `updateSettings` method.\n     */\n\n  }, {\n    key: \"updatePlugin\",\n    value: function updatePlugin(newSettings) {\n      this.engine.updateConfig(getEngineSettingsWithOverrides(this.hot.getSettings()));\n      var pluginSettings = this.hot.getSettings()[PLUGIN_KEY];\n\n      if (isDefined(pluginSettings) && isDefined(pluginSettings.sheetName) && pluginSettings.sheetName !== this.sheetName) {\n        this.switchSheet(pluginSettings.sheetName);\n      } // If no data was passed to the `updateSettings` method and no sheet is connected to the instance -> create a\n      // new sheet using the currently used data. Otherwise, it will be handled by the `afterLoadData` call.\n\n\n      if (!newSettings.data && this.sheetName === null) {\n        var sheetName = this.hot.getSettings()[PLUGIN_KEY].sheetName;\n\n        if (sheetName && this.engine.doesSheetExist(sheetName)) {\n          this.switchSheet(this.sheetName);\n        } else {\n          this.sheetName = this.addSheet(sheetName !== null && sheetName !== void 0 ? sheetName : void 0, this.hot.getSourceDataArray());\n        }\n      }\n\n      _get(_getPrototypeOf(Formulas.prototype), \"updatePlugin\", this).call(this, newSettings);\n    }\n    /**\n     * Destroys the plugin instance.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var _this10 = this;\n\n      _classPrivateFieldGet(this, _engineListeners).forEach(function (_ref5) {\n        var _this10$engine;\n\n        var _ref6 = _slicedToArray(_ref5, 2),\n            eventName = _ref6[0],\n            listener = _ref6[1];\n\n        return (_this10$engine = _this10.engine) === null || _this10$engine === void 0 ? void 0 : _this10$engine.off(eventName, listener);\n      });\n\n      _classPrivateFieldSet(this, _engineListeners, null);\n\n      unregisterEngine(this.engine, this.hot);\n      this.engine = null;\n\n      _get(_getPrototypeOf(Formulas.prototype), \"destroy\", this).call(this);\n    }\n    /**\n     * Helper function for `toPhysicalRowPosition` and `toPhysicalColumnPosition`.\n     *\n     * @private\n     * @param {number} visualIndex Visual entry index.\n     * @param {number} physicalIndex Physical entry index.\n     * @param {number} entriesCount Visual entries count.\n     * @param {number} sourceEntriesCount Source entries count.\n     * @param {boolean} contained `true` if it should return only indexes within boundaries of the table (basically\n     * `toPhysical` alias.\n     * @returns {*}\n     */\n\n  }, {\n    key: \"getPhysicalIndexPosition\",\n    value: function getPhysicalIndexPosition(visualIndex, physicalIndex, entriesCount, sourceEntriesCount, contained) {\n      if (!contained) {\n        if (visualIndex >= entriesCount) {\n          return sourceEntriesCount + (visualIndex - entriesCount);\n        }\n      }\n\n      return physicalIndex;\n    }\n    /**\n     * Returns the physical row index. The difference between this and Core's `toPhysical` is that it doesn't return\n     * `null` on rows with indexes higher than the number of rows.\n     *\n     * @private\n     * @param {number} row Visual row index.\n     * @param {boolean} [contained] `true` if it should return only indexes within boundaries of the table (basically\n     * `toPhysical` alias.\n     * @returns {number} The physical row index.\n     */\n\n  }, {\n    key: \"toPhysicalRowPosition\",\n    value: function toPhysicalRowPosition(row) {\n      var contained = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return this.getPhysicalIndexPosition(row, this.hot.toPhysicalRow(row), this.hot.countRows(), this.hot.countSourceRows(), contained);\n    }\n    /**\n     * Returns the physical column index. The difference between this and Core's `toPhysical` is that it doesn't return\n     * `null` on columns with indexes higher than the number of columns.\n     *\n     * @private\n     * @param {number} column Visual column index.\n     * @param {boolean} [contained] `true` if it should return only indexes within boundaries of the table (basically\n     * `toPhysical` alias.\n     * @returns {number} The physical column index.\n     */\n\n  }, {\n    key: \"toPhysicalColumnPosition\",\n    value: function toPhysicalColumnPosition(column) {\n      var contained = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return this.getPhysicalIndexPosition(column, this.hot.toPhysicalColumn(column), this.hot.countCols(), this.hot.countSourceCols(), contained);\n    }\n    /**\n     * Add a sheet to the shared HyperFormula instance.\n     *\n     * @param {string|null} [sheetName] The new sheet name. If not provided (or a null is passed), will be\n     * auto-generated by HyperFormula.\n     * @param {Array} [sheetData] Data passed to the shared HyperFormula instance. Has to be declared as an array of\n     * arrays - array of objects is not supported in this scenario.\n     * @returns {boolean|string} `false` if the data format is unusable or it is impossible to add a new sheet to the\n     * engine, the created sheet name otherwise.\n     */\n\n  }, {\n    key: \"addSheet\",\n    value: function addSheet(sheetName, sheetData) {\n      if (isDefined(sheetData) && !isArrayOfArrays(sheetData)) {\n        warn('The provided data should be an array of arrays.');\n        return false;\n      }\n\n      if (sheetName !== void 0 && sheetName !== null && this.engine.doesSheetExist(sheetName)) {\n        warn('Sheet with the provided name already exists.');\n        return false;\n      }\n\n      try {\n        var actualSheetName = this.engine.addSheet(sheetName !== null && sheetName !== void 0 ? sheetName : void 0);\n\n        if (sheetData) {\n          this.engine.setSheetContent(this.engine.getSheetId(actualSheetName), sheetData);\n        }\n\n        return actualSheetName;\n      } catch (e) {\n        warn(e.message);\n        return false;\n      }\n    }\n    /**\n     * Switch the sheet used as data in the Handsontable instance (it loads the data from the shared HyperFormula\n     * instance).\n     *\n     * @param {string} sheetName Sheet name used in the shared HyperFormula instance.\n     */\n\n  }, {\n    key: \"switchSheet\",\n    value: function switchSheet(sheetName) {\n      if (!this.engine.doesSheetExist(sheetName)) {\n        error(\"The sheet named `\".concat(sheetName, \"` does not exist, switch aborted.\"));\n        return;\n      }\n\n      this.sheetName = sheetName;\n      var serialized = this.engine.getSheetSerialized(this.sheetId);\n\n      if (serialized.length > 0) {\n        this.hot.loadData(serialized, \"\".concat(toUpperCaseFirst(PLUGIN_KEY), \".switchSheet\"));\n      }\n    }\n    /**\n     * Get the cell type under specified visual coordinates.\n     *\n     * @param {number} row Visual row index.\n     * @param {number} column Visual column index.\n     * @param {number} [sheet] The target sheet id, defaults to the current sheet.\n     * @returns {string} Possible values: 'FORMULA' | 'VALUE' | 'ARRAYFORMULA' | 'EMPTY'.\n     */\n\n  }, {\n    key: \"getCellType\",\n    value: function getCellType(row, column) {\n      var sheet = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.sheetId;\n      var physicalRow = this.hot.toPhysicalRow(row);\n      var physicalColumn = this.hot.toPhysicalColumn(column);\n\n      if (physicalRow !== null && physicalColumn !== null) {\n        return this.engine.getCellType({\n          sheet: sheet,\n          row: physicalRow,\n          col: physicalColumn\n        });\n      } else {\n        // Should return `EMPTY` when out of bounds (according to the test cases).\n        return 'EMPTY';\n      }\n    }\n    /**\n     * Returns `true` if under specified visual coordinates is formula.\n     *\n     * @param {number} row Visual row index.\n     * @param {number} column Visual column index.\n     * @param {number} [sheet] The target sheet id, defaults to the current sheet.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isFormulaCellType\",\n    value: function isFormulaCellType(row, column) {\n      var sheet = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.sheetId;\n      var physicalRow = this.hot.toPhysicalRow(row);\n      var physicalColumn = this.hot.toPhysicalColumn(column);\n\n      if (physicalRow === null || physicalColumn === null) {\n        return false;\n      }\n\n      return this.engine.doesCellHaveFormula({\n        sheet: sheet,\n        row: physicalRow,\n        col: physicalColumn\n      });\n    }\n    /**\n     * Renders dependent sheets (handsontable instances) based on the changes - list of the\n     * recalculated dependent cells.\n     *\n     * @private\n     * @param {object[]} dependentCells The values and location of applied changes within HF engine.\n     * @param {boolean} [renderSelf] `true` if it's supposed to render itself, `false` otherwise.\n     */\n\n  }, {\n    key: \"renderDependentSheets\",\n    value: function renderDependentSheets(dependentCells) {\n      var _this11 = this;\n\n      var renderSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var affectedSheetIds = new Set();\n      dependentCells.forEach(function (change) {\n        var _change$address;\n\n        // For the Named expression the address is empty, hence the `sheetId` is undefined.\n        var sheetId = change === null || change === void 0 ? void 0 : (_change$address = change.address) === null || _change$address === void 0 ? void 0 : _change$address.sheet;\n\n        if (sheetId !== void 0) {\n          if (!affectedSheetIds.has(sheetId)) {\n            affectedSheetIds.add(sheetId);\n          }\n        }\n      });\n      getRegisteredHotInstances(this.engine).forEach(function (relatedHot, sheetId) {\n        if ((renderSelf || sheetId !== _this11.sheetId) && affectedSheetIds.has(sheetId)) {\n          var _relatedHot$view;\n\n          relatedHot.render();\n          (_relatedHot$view = relatedHot.view) === null || _relatedHot$view === void 0 ? void 0 : _relatedHot$view.adjustElementsSize();\n        }\n      });\n    }\n    /**\n     * Validates dependent cells based on the cells that are modified by the change.\n     *\n     * @private\n     * @param {object[]} dependentCells The values and location of applied changes within HF engine.\n     * @param {object[]} [changedCells] The values and location of applied changes by developer (through API or UI).\n     */\n\n  }, {\n    key: \"validateDependentCells\",\n    value: function validateDependentCells(dependentCells) {\n      var _this12 = this;\n\n      var changedCells = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n      var stringifyAddress = function stringifyAddress(change) {\n        var _change$address2;\n\n        var _ref7 = (_change$address2 = change === null || change === void 0 ? void 0 : change.address) !== null && _change$address2 !== void 0 ? _change$address2 : {},\n            row = _ref7.row,\n            col = _ref7.col,\n            sheet = _ref7.sheet;\n\n        return isDefined(sheet) ? \"\".concat(sheet, \":\").concat(row, \"x\").concat(col) : '';\n      };\n\n      var changedCellsSet = new Set(changedCells.map(function (change) {\n        return stringifyAddress(change);\n      }));\n      dependentCells.forEach(function (change) {\n        var _change$address3, _change$address4;\n\n        var _ref8 = (_change$address3 = change.address) !== null && _change$address3 !== void 0 ? _change$address3 : {},\n            row = _ref8.row,\n            col = _ref8.col;\n\n        var visualRow = isDefined(row) ? _this12.hot.toVisualRow(row) : null;\n        var visualColumn = isDefined(col) ? _this12.hot.toVisualColumn(col) : null; // Don't try to validate cells outside of the visual part of the table.\n\n        if (visualRow === null || visualColumn === null) {\n          return;\n        } // For the Named expression the address is empty, hence the `sheetId` is undefined.\n\n\n        var sheetId = change === null || change === void 0 ? void 0 : (_change$address4 = change.address) === null || _change$address4 === void 0 ? void 0 : _change$address4.sheet;\n        var addressId = stringifyAddress(change); // Validate the cells that depend on the calculated formulas. Skip that cells\n        // where the user directly changes the values - the Core triggers those validators.\n\n        if (sheetId !== void 0 && !changedCellsSet.has(addressId)) {\n          var hot = getRegisteredHotInstances(_this12.engine).get(sheetId); // It will just re-render certain cell when necessary.\n\n          hot.validateCell(hot.getDataAtCell(visualRow, visualColumn), hot.getCellMeta(visualRow, visualColumn), function () {});\n        }\n      });\n    }\n    /**\n     * Sync a change from the change-related hooks with the engine.\n     *\n     * @private\n     * @param {number} row Visual row index.\n     * @param {number} column Visual column index.\n     * @param {Handsontable.CellValue} newValue New value.\n     * @returns {Array} Array of changes exported from the engine.\n     */\n\n  }, {\n    key: \"syncChangeWithEngine\",\n    value: function syncChangeWithEngine(row, column, newValue) {\n      var address = {\n        row: this.toPhysicalRowPosition(row),\n        col: this.toPhysicalColumnPosition(column),\n        sheet: this.sheetId\n      };\n\n      if (!this.engine.isItPossibleToSetCellContents(address)) {\n        warn(\"Not possible to set cell data at \".concat(JSON.stringify(address)));\n        return;\n      }\n\n      return this.engine.setCellContents(address, newValue);\n    }\n    /**\n     * The hook allows to translate the formula value to calculated value before it goes to the\n     * validator function.\n     *\n     * @private\n     * @param {*} value The cell value to validate.\n     * @param {number} visualRow The visual row index.\n     * @param {number|string} prop The visual column index or property name of the column.\n     * @returns {*} Returns value to validate.\n     */\n\n  }, {\n    key: \"onBeforeValidate\",\n    value: function onBeforeValidate(value, visualRow, prop) {\n      var visualColumn = this.hot.propToCol(prop);\n\n      if (this.isFormulaCellType(visualRow, visualColumn)) {\n        var address = {\n          row: this.hot.toPhysicalRow(visualRow),\n          col: this.hot.toPhysicalColumn(visualColumn),\n          sheet: this.sheetId\n        };\n        var cellValue = this.engine.getCellValue(address); // If `cellValue` is an object it is expected to be an error\n\n        return _typeof(cellValue) === 'object' && cellValue !== null ? cellValue.value : cellValue;\n      }\n\n      return value;\n    }\n    /**\n     * `onBeforeAutofill` hook callback.\n     *\n     * @private\n     * @param {Array[]} fillData The data that was used to fill the `targetRange`. If `beforeAutofill` was used\n     * and returned `[[]]`, this will be the same object that was returned from `beforeAutofill`.\n     * @param {CellRange} sourceRange The range values will be filled from.\n     * @param {CellRange} targetRange The range new values will be filled into.\n     * @returns {boolean|*}\n     */\n\n  }, {\n    key: \"onBeforeAutofill\",\n    value: function onBeforeAutofill(fillData, sourceRange, targetRange) {\n      var _this13 = this;\n\n      var withSheetId = function withSheetId(range) {\n        return _objectSpread(_objectSpread({}, range), {}, {\n          sheet: _this13.sheetId\n        });\n      };\n\n      var engineSourceRange = {\n        start: withSheetId(sourceRange.getTopLeftCorner()),\n        end: withSheetId(sourceRange.getBottomRightCorner())\n      };\n      var engineTargetRange = {\n        start: withSheetId(targetRange.getTopLeftCorner()),\n        end: withSheetId(targetRange.getBottomRightCorner())\n      }; // Blocks the autofill operation if HyperFormula says that at least one of\n      // the underlying cell's contents cannot be set.\n\n      if (this.engine.isItPossibleToSetCellContents(engineTargetRange) === false) {\n        return false;\n      }\n\n      return this.engine.getFillRangeData(engineSourceRange, engineTargetRange);\n    }\n    /**\n     * `beforeLoadData` hook callback.\n     *\n     * @param {Array} sourceData Array of arrays or array of objects containing data.\n     * @param {boolean} initialLoad Flag that determines whether the data has been loaded during the initialization.\n     * @param {string} [source] Source of the call.\n     * @private\n     */\n\n  }, {\n    key: \"onBeforeLoadData\",\n    value: function onBeforeLoadData(sourceData, initialLoad) {\n      var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n\n      if (source.includes(toUpperCaseFirst(PLUGIN_KEY))) {\n        return;\n      } // This flag needs to be defined, because not passing data to HOT results in HOT auto-generating a `null`-filled\n      // initial dataset.\n\n\n      _classPrivateFieldSet(this, _hotWasInitializedWithEmptyData, isUndefined(this.hot.getSettings().data));\n    }\n    /**\n     * `afterLoadData` hook callback.\n     *\n     * @param {Array} sourceData Array of arrays or array of objects containing data.\n     * @param {boolean} initialLoad Flag that determines whether the data has been loaded during the initialization.\n     * @param {string} [source] Source of the call.\n     * @private\n     */\n\n  }, {\n    key: \"onAfterLoadData\",\n    value: function onAfterLoadData(sourceData, initialLoad) {\n      var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n\n      if (source.includes(toUpperCaseFirst(PLUGIN_KEY))) {\n        return;\n      }\n\n      this.sheetName = setupSheet(this.engine, this.hot.getSettings()[PLUGIN_KEY].sheetName);\n\n      if (!_classPrivateFieldGet(this, _hotWasInitializedWithEmptyData)) {\n        var sourceDataArray = this.hot.getSourceDataArray();\n\n        if (this.engine.isItPossibleToReplaceSheetContent(this.sheetId, sourceDataArray)) {\n          _classPrivateFieldSet(this, _internalOperationPending, true);\n\n          var dependentCells = this.engine.setSheetContent(this.sheetId, this.hot.getSourceDataArray());\n          this.renderDependentSheets(dependentCells);\n\n          _classPrivateFieldSet(this, _internalOperationPending, false);\n        }\n      } else {\n        this.switchSheet(this.sheetName);\n      }\n    }\n    /**\n     * `modifyData` hook callback.\n     *\n     * @private\n     * @param {number} row Physical row height.\n     * @param {number} column Physical column index.\n     * @param {object} valueHolder Object which contains original value which can be modified by overwriting `.value`\n     *   property.\n     * @param {string} ioMode String which indicates for what operation hook is fired (`get` or `set`).\n     */\n\n  }, {\n    key: \"onModifyData\",\n    value: function onModifyData(row, column, valueHolder, ioMode) {\n      if (ioMode !== 'get' || _classPrivateFieldGet(this, _internalOperationPending) || this.sheetName === null || !this.engine.doesSheetExist(this.sheetName)) {\n        return;\n      }\n\n      var visualRow = this.hot.toVisualRow(row); // `column` is here as visual index because of inconsistencies related to hook execution in `src/dataMap`.\n\n      var isFormulaCellType = this.isFormulaCellType(visualRow, column);\n\n      if (!isFormulaCellType) {\n        var cellType = this.getCellType(visualRow, column);\n\n        if (cellType !== 'ARRAY') {\n          if (isEscapedFormulaExpression(valueHolder.value)) {\n            valueHolder.value = unescapeFormulaExpression(valueHolder.value);\n          }\n\n          return;\n        }\n      } // `toPhysicalColumn` is here because of inconsistencies related to hook execution in `DataMap`.\n\n\n      var address = {\n        row: row,\n        col: this.toPhysicalColumnPosition(column),\n        sheet: this.sheetId\n      };\n      var cellValue = this.engine.getCellValue(address); // If `cellValue` is an object it is expected to be an error\n\n      var value = _typeof(cellValue) === 'object' && cellValue !== null ? cellValue.value : cellValue;\n      valueHolder.value = value;\n    }\n    /**\n     * `modifySourceData` hook callback.\n     *\n     * @private\n     * @param {number} row Physical row index.\n     * @param {number|string} columnOrProp Physical column index or prop.\n     * @param {object} valueHolder Object which contains original value which can be modified by overwriting `.value`\n     *   property.\n     * @param {string} ioMode String which indicates for what operation hook is fired (`get` or `set`).\n     */\n\n  }, {\n    key: \"onModifySourceData\",\n    value: function onModifySourceData(row, columnOrProp, valueHolder, ioMode) {\n      if (ioMode !== 'get' || _classPrivateFieldGet(this, _internalOperationPending) || this.sheetName === null || !this.engine.doesSheetExist(this.sheetName)) {\n        return;\n      }\n\n      var visualRow = this.hot.toVisualRow(row);\n      var visualColumn = this.hot.propToCol(columnOrProp); // `column` is here as visual index because of inconsistencies related to hook execution in `src/dataMap`.\n\n      var isFormulaCellType = this.isFormulaCellType(visualRow, visualColumn);\n\n      if (!isFormulaCellType) {\n        var cellType = this.getCellType(visualRow, visualColumn);\n\n        if (cellType !== 'ARRAY') {\n          return;\n        }\n      }\n\n      var dimensions = this.engine.getSheetDimensions(this.engine.getSheetId(this.sheetName)); // Don't actually change the source data if HyperFormula is not\n      // initialized yet. This is done to allow the `afterLoadData` hook to\n      // load the existing source data with `Handsontable#getSourceDataArray`\n      // properly.\n\n      if (dimensions.width === 0 && dimensions.height === 0) {\n        return;\n      }\n\n      var address = {\n        row: row,\n        // Workaround for inconsistencies in `src/dataSource.js`\n        col: this.toPhysicalColumnPosition(visualColumn),\n        sheet: this.sheetId\n      };\n      valueHolder.value = this.engine.getCellSerialized(address);\n    }\n    /**\n     * `onAfterSetDataAtCell` hook callback.\n     *\n     * @private\n     * @param {Array[]} changes An array of changes in format [[row, prop, oldValue, value], ...].\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link http://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).\n     */\n\n  }, {\n    key: \"onAfterSetDataAtCell\",\n    value: function onAfterSetDataAtCell(changes, source) {\n      var _this14 = this;\n\n      if (isBlockedSource(source)) {\n        return;\n      }\n\n      var outOfBoundsChanges = [];\n      var changedCells = [];\n      var dependentCells = this.engine.batch(function () {\n        changes.forEach(function (_ref9) {\n          var _ref10 = _slicedToArray(_ref9, 4),\n              row = _ref10[0],\n              prop = _ref10[1],\n              newValue = _ref10[3];\n\n          var column = _this14.hot.propToCol(prop);\n\n          var physicalRow = _this14.hot.toPhysicalRow(row);\n\n          var physicalColumn = _this14.hot.toPhysicalColumn(column);\n\n          var address = {\n            row: physicalRow,\n            col: physicalColumn,\n            sheet: _this14.sheetId\n          };\n\n          if (physicalRow !== null && physicalColumn !== null) {\n            _this14.syncChangeWithEngine(row, column, newValue);\n          } else {\n            outOfBoundsChanges.push([row, column, newValue]);\n          }\n\n          changedCells.push({\n            address: address\n          });\n        });\n      });\n\n      if (outOfBoundsChanges.length) {\n        // Workaround for rows/columns being created two times (by HOT and the engine).\n        // (unfortunately, this requires an extra re-render)\n        this.hot.addHookOnce('afterChange', function () {\n          var outOfBoundsDependentCells = _this14.engine.batch(function () {\n            outOfBoundsChanges.forEach(function (_ref11) {\n              var _ref12 = _slicedToArray(_ref11, 3),\n                  row = _ref12[0],\n                  column = _ref12[1],\n                  newValue = _ref12[2];\n\n              _this14.syncChangeWithEngine(row, column, newValue);\n            });\n          });\n\n          _this14.renderDependentSheets(outOfBoundsDependentCells, true);\n        });\n      }\n\n      this.renderDependentSheets(dependentCells);\n      this.validateDependentCells(dependentCells, changedCells);\n    }\n    /**\n     * `onAfterSetSourceDataAtCell` hook callback.\n     *\n     * @private\n     * @param {Array[]} changes An array of changes in format [[row, column, oldValue, value], ...].\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link http://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).\n     */\n\n  }, {\n    key: \"onAfterSetSourceDataAtCell\",\n    value: function onAfterSetSourceDataAtCell(changes, source) {\n      var _this15 = this;\n\n      if (isBlockedSource(source)) {\n        return;\n      }\n\n      var dependentCells = [];\n      var changedCells = [];\n      changes.forEach(function (_ref13) {\n        var _ref14 = _slicedToArray(_ref13, 4),\n            row = _ref14[0],\n            prop = _ref14[1],\n            newValue = _ref14[3];\n\n        var column = _this15.hot.propToCol(prop);\n\n        if (!isNumeric(column)) {\n          return;\n        }\n\n        var address = {\n          row: row,\n          col: _this15.toPhysicalColumnPosition(column),\n          sheet: _this15.sheetId\n        };\n\n        if (!_this15.engine.isItPossibleToSetCellContents(address)) {\n          warn(\"Not possible to set source cell data at \".concat(JSON.stringify(address)));\n          return;\n        }\n\n        changedCells.push({\n          address: address\n        });\n        dependentCells.push.apply(dependentCells, _toConsumableArray(_this15.engine.setCellContents(address, newValue)));\n      });\n      this.renderDependentSheets(dependentCells);\n      this.validateDependentCells(dependentCells, changedCells);\n    }\n    /**\n     * `beforeCreateRow` hook callback.\n     *\n     * @private\n     * @param {number} row Represents the visual index of first newly created row in the data source array.\n     * @param {number} amount Number of newly created rows in the data source array.\n     * @returns {*|boolean} If false is returned the action is canceled.\n     */\n\n  }, {\n    key: \"onBeforeCreateRow\",\n    value: function onBeforeCreateRow(row, amount) {\n      if (this.sheetId === null || !this.engine.doesSheetExist(this.sheetName) || !this.engine.isItPossibleToAddRows(this.sheetId, [this.toPhysicalRowPosition(row), amount])) {\n        return false;\n      }\n    }\n    /**\n     * `beforeCreateCol` hook callback.\n     *\n     * @private\n     * @param {number} col Represents the visual index of first newly created column in the data source.\n     * @param {number} amount Number of newly created columns in the data source.\n     * @returns {*|boolean} If false is returned the action is canceled.\n     */\n\n  }, {\n    key: \"onBeforeCreateCol\",\n    value: function onBeforeCreateCol(col, amount) {\n      if (this.sheetId === null || !this.engine.doesSheetExist(this.sheetName) || !this.engine.isItPossibleToAddColumns(this.sheetId, [this.toPhysicalColumnPosition(col), amount])) {\n        return false;\n      }\n    }\n    /**\n     * `beforeRemoveRow` hook callback.\n     *\n     * @private\n     * @param {number} row Visual index of starter row.\n     * @param {number} amount Amount of rows to be removed.\n     * @param {number[]} physicalRows An array of physical rows removed from the data source.\n     * @returns {*|boolean} If false is returned the action is canceled.\n     */\n\n  }, {\n    key: \"onBeforeRemoveRow\",\n    value: function onBeforeRemoveRow(row, amount, physicalRows) {\n      var _this16 = this;\n\n      var possible = physicalRows.every(function (physicalRow) {\n        return _this16.engine.isItPossibleToRemoveRows(_this16.sheetId, [physicalRow, 1]);\n      });\n      return possible === false ? false : void 0;\n    }\n    /**\n     * `beforeRemoveCol` hook callback.\n     *\n     * @private\n     * @param {number} col Visual index of starter column.\n     * @param {number} amount Amount of columns to be removed.\n     * @param {number[]} physicalColumns An array of physical columns removed from the data source.\n     * @returns {*|boolean} If false is returned the action is canceled.\n     */\n\n  }, {\n    key: \"onBeforeRemoveCol\",\n    value: function onBeforeRemoveCol(col, amount, physicalColumns) {\n      var _this17 = this;\n\n      var possible = physicalColumns.every(function (physicalColumn) {\n        return _this17.engine.isItPossibleToRemoveColumns(_this17.sheetId, [physicalColumn, 1]);\n      });\n      return possible === false ? false : void 0;\n    }\n    /**\n     * `afterCreateRow` hook callback.\n     *\n     * @private\n     * @param {number} row Represents the visual index of first newly created row in the data source array.\n     * @param {number} amount Number of newly created rows in the data source array.\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link http://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).\n     */\n\n  }, {\n    key: \"onAfterCreateRow\",\n    value: function onAfterCreateRow(row, amount, source) {\n      if (isBlockedSource(source)) {\n        return;\n      }\n\n      var changes = this.engine.addRows(this.sheetId, [this.toPhysicalRowPosition(row), amount]);\n      this.renderDependentSheets(changes);\n    }\n    /**\n     * `afterCreateCol` hook callback.\n     *\n     * @private\n     * @param {number} col Represents the visual index of first newly created column in the data source.\n     * @param {number} amount Number of newly created columns in the data source.\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link http://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).\n     */\n\n  }, {\n    key: \"onAfterCreateCol\",\n    value: function onAfterCreateCol(col, amount, source) {\n      if (isBlockedSource(source)) {\n        return;\n      }\n\n      var changes = this.engine.addColumns(this.sheetId, [this.toPhysicalColumnPosition(col), amount]);\n      this.renderDependentSheets(changes);\n    }\n    /**\n     * `afterRemoveRow` hook callback.\n     *\n     * @private\n     * @param {number} row Visual index of starter row.\n     * @param {number} amount An amount of removed rows.\n     * @param {number[]} physicalRows An array of physical rows removed from the data source.\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link http://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).\n     */\n\n  }, {\n    key: \"onAfterRemoveRow\",\n    value: function onAfterRemoveRow(row, amount, physicalRows, source) {\n      var _this18 = this;\n\n      if (isBlockedSource(source)) {\n        return;\n      }\n\n      var descendingPhysicalRows = physicalRows.sort().reverse();\n      var changes = this.engine.batch(function () {\n        descendingPhysicalRows.forEach(function (physicalRow) {\n          _this18.engine.removeRows(_this18.sheetId, [physicalRow, 1]);\n        });\n      });\n      this.renderDependentSheets(changes);\n    }\n    /**\n     * `afterRemoveCol` hook callback.\n     *\n     * @private\n     * @param {number} col Visual index of starter column.\n     * @param {number} amount An amount of removed columns.\n     * @param {number[]} physicalColumns An array of physical columns removed from the data source.\n     * @param {string} [source] String that identifies source of hook call\n     *                          ([list of all available sources]{@link http://docs.handsontable.com/tutorial-using-callbacks.html#page-source-definition}).\n     */\n\n  }, {\n    key: \"onAfterRemoveCol\",\n    value: function onAfterRemoveCol(col, amount, physicalColumns, source) {\n      var _this19 = this;\n\n      if (isBlockedSource(source)) {\n        return;\n      }\n\n      var descendingPhysicalColumns = physicalColumns.sort().reverse();\n      var changes = this.engine.batch(function () {\n        descendingPhysicalColumns.forEach(function (physicalColumn) {\n          _this19.engine.removeColumns(_this19.sheetId, [physicalColumn, 1]);\n        });\n      });\n      this.renderDependentSheets(changes);\n    }\n    /**\n     * `afterDetachChild` hook callback.\n     * Used to sync the data of the rows detached in the Nested Rows plugin with the engine's dataset.\n     *\n     * @private\n     * @param {object} parent An object representing the parent from which the element was detached.\n     * @param {object} element The detached element.\n     * @param {number} finalElementRowIndex The final row index of the detached element.\n     */\n\n  }, {\n    key: \"onAfterDetachChild\",\n    value: function onAfterDetachChild(parent, element, finalElementRowIndex) {\n      var _element$__children,\n          _this20 = this;\n\n      _classPrivateFieldSet(this, _internalOperationPending, true);\n\n      var rowsData = this.hot.getSourceDataArray(finalElementRowIndex, 0, finalElementRowIndex + (((_element$__children = element.__children) === null || _element$__children === void 0 ? void 0 : _element$__children.length) || 0), this.hot.countSourceCols());\n\n      _classPrivateFieldSet(this, _internalOperationPending, false);\n\n      rowsData.forEach(function (row, relativeRowIndex) {\n        row.forEach(function (value, colIndex) {\n          _this20.engine.setCellContents({\n            col: colIndex,\n            row: finalElementRowIndex + relativeRowIndex,\n            sheet: _this20.sheetId\n          }, [[value]]);\n        });\n      });\n    }\n    /**\n     * Called when a value is updated in the engine.\n     *\n     * @private\n     * @fires Hooks#afterFormulasValuesUpdate\n     * @param {Array} changes The values and location of applied changes.\n     */\n\n  }, {\n    key: \"onEngineValuesUpdated\",\n    value: function onEngineValuesUpdated(changes) {\n      this.hot.runHooks('afterFormulasValuesUpdate', changes);\n    }\n    /**\n     * Called when a named expression is added to the engine instance.\n     *\n     * @private\n     * @fires Hooks#afterNamedExpressionAdded\n     * @param {string} namedExpressionName The name of the added expression.\n     * @param {Array} changes The values and location of applied changes.\n     */\n\n  }, {\n    key: \"onEngineNamedExpressionsAdded\",\n    value: function onEngineNamedExpressionsAdded(namedExpressionName, changes) {\n      this.hot.runHooks('afterNamedExpressionAdded', namedExpressionName, changes);\n    }\n    /**\n     * Called when a named expression is removed from the engine instance.\n     *\n     * @private\n     * @fires Hooks#afterNamedExpressionRemoved\n     * @param {string} namedExpressionName The name of the removed expression.\n     * @param {Array} changes The values and location of applied changes.\n     */\n\n  }, {\n    key: \"onEngineNamedExpressionsRemoved\",\n    value: function onEngineNamedExpressionsRemoved(namedExpressionName, changes) {\n      this.hot.runHooks('afterNamedExpressionRemoved', namedExpressionName, changes);\n    }\n    /**\n     * Called when a new sheet is added to the engine instance.\n     *\n     * @private\n     * @fires Hooks#afterSheetAdded\n     * @param {string} addedSheetDisplayName The name of the added sheet.\n     */\n\n  }, {\n    key: \"onEngineSheetAdded\",\n    value: function onEngineSheetAdded(addedSheetDisplayName) {\n      this.hot.runHooks('afterSheetAdded', addedSheetDisplayName);\n    }\n    /**\n     * Called when a sheet in the engine instance is renamed.\n     *\n     * @private\n     * @fires Hooks#afterSheetRenamed\n     * @param {string} oldDisplayName The old name of the sheet.\n     * @param {string} newDisplayName The new name of the sheet.\n     */\n\n  }, {\n    key: \"onEngineSheetRenamed\",\n    value: function onEngineSheetRenamed(oldDisplayName, newDisplayName) {\n      this.hot.runHooks('afterSheetRenamed', oldDisplayName, newDisplayName);\n    }\n    /**\n     * Called when a sheet is removed from the engine instance.\n     *\n     * @private\n     * @fires Hooks#afterSheetRemoved\n     * @param {string} removedSheetDisplayName The removed sheet name.\n     * @param {Array} changes The values and location of applied changes.\n     */\n\n  }, {\n    key: \"onEngineSheetRemoved\",\n    value: function onEngineSheetRemoved(removedSheetDisplayName, changes) {\n      this.hot.runHooks('afterSheetRemoved', removedSheetDisplayName, changes);\n    }\n  }], [{\n    key: \"PLUGIN_KEY\",\n    get: function get() {\n      return PLUGIN_KEY;\n    }\n  }, {\n    key: \"PLUGIN_PRIORITY\",\n    get: function get() {\n      return PLUGIN_PRIORITY;\n    }\n    /**\n     * Flag used to bypass hooks in internal operations.\n     *\n     * @private\n     * @type {boolean}\n     */\n\n  }]);\n\n  return Formulas;\n}(BasePlugin);"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}