{"ast":null,"code":"import _toConsumableArray from \"/Users/priyadeliwala/Desktop/sales-dashboard/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"/Users/priyadeliwala/Desktop/sales-dashboard/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"/Users/priyadeliwala/Desktop/sales-dashboard/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/priyadeliwala/Desktop/sales-dashboard/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nimport { hasClass, index, offset, removeTextNodes, overlayContainsElement, closest, outerHeight, outerWidth, innerHeight, isVisible as _isVisible, setAttribute } from \"../../../helpers/dom/element.mjs\";\nimport { isFunction } from \"../../../helpers/function.mjs\";\nimport ColumnFilter from \"./filter/column.mjs\";\nimport RowFilter from \"./filter/row.mjs\";\nimport { Renderer } from \"./renderer/index.mjs\";\nimport ColumnUtils from \"./utils/column.mjs\";\nimport RowUtils from \"./utils/row.mjs\";\nimport { CLONE_TOP, CLONE_BOTTOM, CLONE_INLINE_START, CLONE_TOP_INLINE_START_CORNER, CLONE_BOTTOM_INLINE_START_CORNER } from \"./overlay/index.mjs\";\nimport { A11Y_PRESENTATION } from \"../../../helpers/a11y.mjs\";\n/**\n * @todo These mixes are never added to the class Table, however their members are used here.\n * @todo Continue: Potentially it works only, because some of these mixes are added to every inherited class.\n * @todo Refactoring, move code from `if(this.isMaster)` into MasterTable, and others like that.\n * @mixes stickyColumnsStart\n * @mixes stickyRowsBottom\n * @mixes stickyRowsTop\n * @mixes calculatedRows\n * @mixes calculatedColumns\n * @abstract\n */\nvar Table = /*#__PURE__*/function () {\n  /**\n   *\n   * @abstract\n   * @param {TableDao} dataAccessObject The data access object.\n   * @param {FacadeGetter} facadeGetter Function which return proper facade.\n   * @param {DomBindings} domBindings Bindings into DOM.\n   * @param {Settings} wtSettings The Walkontable settings.\n   * @param {'master'|CLONE_TYPES_ENUM} name Overlay name.\n   */\n  function Table(dataAccessObject, facadeGetter, domBindings, wtSettings, name) {\n    var _this = this;\n    _classCallCheck(this, Table);\n    /**\n     * The walkontable settings.\n     *\n     * @protected\n     * @type {Settings}\n     */\n    _defineProperty(this, \"wtSettings\", null);\n    _defineProperty(this, \"domBindings\", void 0);\n    _defineProperty(this, \"TBODY\", null);\n    _defineProperty(this, \"THEAD\", null);\n    _defineProperty(this, \"COLGROUP\", null);\n    /**\n     * Indicates if the table has height bigger than 0px.\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"hasTableHeight\", true);\n    /**\n     * Indicates if the table has width bigger than 0px.\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"hasTableWidth\", true);\n    /**\n     * Indicates if the table is visible. By visible, it means that the holder\n     * element has CSS 'display' property different than 'none'.\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"isTableVisible\", false);\n    _defineProperty(this, \"tableOffset\", 0);\n    _defineProperty(this, \"holderOffset\", 0);\n    this.domBindings = domBindings;\n    /**\n     * Indicates if this instance is of type `MasterTable` (i.e. It is NOT an overlay).\n     *\n     * @type {boolean}\n     */\n    this.isMaster = name === 'master';\n    this.name = name;\n    this.dataAccessObject = dataAccessObject;\n    this.facadeGetter = facadeGetter;\n    this.wtSettings = wtSettings;\n\n    // legacy support\n    this.instance = this.dataAccessObject.wot; // TODO refactoring: it might be removed here, and provides legacy support through facade.\n    this.wot = this.dataAccessObject.wot;\n    this.TABLE = domBindings.rootTable;\n    removeTextNodes(this.TABLE);\n\n    // TODO refactoring, to recognize the legitimacy of moving them into domBidings\n    this.spreader = this.createSpreader(this.TABLE);\n    this.hider = this.createHider(this.spreader);\n    this.holder = this.createHolder(this.hider);\n    this.wtRootElement = this.holder.parentNode;\n    if (this.isMaster) {\n      this.alignOverlaysWithTrimmingContainer(); // todo wow, It calls method from child class (MasterTable).\n    }\n    this.fixTableDomTree();\n    this.rowFilter = null; // TODO refactoring, eliminate all (re)creations of this object, then updates state when needed.\n    this.columnFilter = null; // TODO refactoring, eliminate all (re)creations of this object, then updates state when needed.\n    this.correctHeaderWidth = false;\n    var origRowHeaderWidth = this.wtSettings.getSettingPure('rowHeaderWidth');\n\n    // Fix for jumping row headers (https://github.com/handsontable/handsontable/issues/3850)\n    this.wtSettings.update('rowHeaderWidth', function () {\n      return _this._modifyRowHeaderWidth(origRowHeaderWidth);\n    });\n    this.rowUtils = new RowUtils(this.dataAccessObject, this.wtSettings); // TODO refactoring, It can be passed through IOC.\n    this.columnUtils = new ColumnUtils(this.dataAccessObject, this.wtSettings); // TODO refactoring, It can be passed through IOC.\n\n    this.tableRenderer = new Renderer({\n      // TODO refactoring, It can be passed through IOC.\n      TABLE: this.TABLE,\n      THEAD: this.THEAD,\n      COLGROUP: this.COLGROUP,\n      TBODY: this.TBODY,\n      rowUtils: this.rowUtils,\n      columnUtils: this.columnUtils,\n      cellRenderer: this.wtSettings.getSettingPure('cellRenderer')\n    });\n  }\n\n  /**\n   * Returns a boolean that is true if this Table represents a specific overlay, identified by the overlay name.\n   * For MasterTable, it returns false.\n   *\n   * @param {string} overlayTypeName The overlay type.\n   * @returns {boolean}\n   */\n  return _createClass(Table, [{\n    key: \"is\",\n    value: function is(overlayTypeName) {\n      // todo refactoring: eliminate all protected and private usages\n      return this.name === overlayTypeName;\n    }\n\n    /**\n     *\n     */\n  }, {\n    key: \"fixTableDomTree\",\n    value: function fixTableDomTree() {\n      var rootDocument = this.domBindings.rootDocument;\n      this.TBODY = this.TABLE.querySelector('tbody');\n      if (!this.TBODY) {\n        this.TBODY = rootDocument.createElement('tbody');\n        this.TABLE.appendChild(this.TBODY);\n      }\n      this.THEAD = this.TABLE.querySelector('thead');\n      if (!this.THEAD) {\n        this.THEAD = rootDocument.createElement('thead');\n        this.TABLE.insertBefore(this.THEAD, this.TBODY);\n      }\n      this.COLGROUP = this.TABLE.querySelector('colgroup');\n      if (!this.COLGROUP) {\n        this.COLGROUP = rootDocument.createElement('colgroup');\n        this.TABLE.insertBefore(this.COLGROUP, this.THEAD);\n      }\n    }\n\n    /**\n     * @param {HTMLTableElement} table An element to process.\n     * @returns {HTMLElement}\n     */\n  }, {\n    key: \"createSpreader\",\n    value: function createSpreader(table) {\n      var parent = table.parentNode;\n      var spreader;\n      if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !hasClass(parent, 'wtHolder')) {\n        spreader = this.domBindings.rootDocument.createElement('div');\n        spreader.className = 'wtSpreader';\n        if (parent) {\n          // if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it\n          parent.insertBefore(spreader, table);\n        }\n        spreader.appendChild(table);\n      }\n      spreader.style.position = 'relative';\n      if (this.wtSettings.getSetting('ariaTags')) {\n        setAttribute(spreader, [A11Y_PRESENTATION()]);\n      }\n      return spreader;\n    }\n\n    /**\n     * @param {HTMLElement} spreader An element to the hider element is injected.\n     * @returns {HTMLElement}\n     */\n  }, {\n    key: \"createHider\",\n    value: function createHider(spreader) {\n      var parent = spreader.parentNode;\n      var hider;\n      if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !hasClass(parent, 'wtHolder')) {\n        hider = this.domBindings.rootDocument.createElement('div');\n        hider.className = 'wtHider';\n        if (parent) {\n          // if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it\n          parent.insertBefore(hider, spreader);\n        }\n        hider.appendChild(spreader);\n      }\n      if (this.wtSettings.getSetting('ariaTags')) {\n        setAttribute(hider, [A11Y_PRESENTATION()]);\n      }\n      return hider;\n    }\n\n    /**\n     *\n     * @param {HTMLElement} hider An element to the holder element is injected.\n     * @returns {HTMLElement}\n     */\n  }, {\n    key: \"createHolder\",\n    value: function createHolder(hider) {\n      var parent = hider.parentNode;\n      var holder;\n      if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !hasClass(parent, 'wtHolder')) {\n        holder = this.domBindings.rootDocument.createElement('div');\n        holder.style.position = 'relative';\n        holder.className = 'wtHolder';\n        if (parent) {\n          // if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it\n          parent.insertBefore(holder, hider);\n        }\n        if (this.isMaster) {\n          holder.parentNode.className += 'ht_master handsontable';\n          holder.parentNode.setAttribute('dir', this.wtSettings.getSettingPure('rtlMode') ? 'rtl' : 'ltr');\n          if (this.wtSettings.getSetting('ariaTags')) {\n            setAttribute(holder.parentNode, [A11Y_PRESENTATION()]);\n          }\n        }\n        holder.appendChild(hider);\n      }\n      if (this.wtSettings.getSetting('ariaTags')) {\n        setAttribute(holder, [A11Y_PRESENTATION()]);\n      }\n      return holder;\n    }\n\n    /**\n     * Redraws the table.\n     *\n     * @param {boolean} [fastDraw=false] If TRUE, will try to avoid full redraw and only update the border positions.\n     *                                   If FALSE or UNDEFINED, will perform a full redraw.\n     * @returns {Table}\n     */\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      var fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var wtSettings = this.wtSettings;\n      var _this$dataAccessObjec = this.dataAccessObject,\n        wtOverlays = _this$dataAccessObjec.wtOverlays,\n        wtViewport = _this$dataAccessObjec.wtViewport;\n      var totalRows = wtSettings.getSetting('totalRows');\n      var totalColumns = wtSettings.getSetting('totalColumns');\n      var rowHeaders = wtSettings.getSetting('rowHeaders');\n      var rowHeadersCount = rowHeaders.length;\n      var columnHeaders = wtSettings.getSetting('columnHeaders');\n      var columnHeadersCount = columnHeaders.length;\n      var runFastDraw = fastDraw;\n      if (this.isMaster) {\n        wtOverlays.beforeDraw();\n        this.holderOffset = offset(this.holder);\n        runFastDraw = wtViewport.createCalculators(runFastDraw);\n        if (rowHeadersCount && !wtSettings.getSetting('fixedColumnsStart')) {\n          var leftScrollPos = wtOverlays.inlineStartOverlay.getScrollPosition();\n          var previousState = this.correctHeaderWidth;\n          this.correctHeaderWidth = leftScrollPos !== 0;\n          if (previousState !== this.correctHeaderWidth) {\n            runFastDraw = false;\n          }\n        }\n      }\n      if (runFastDraw) {\n        if (this.isMaster) {\n          wtOverlays.refresh(true);\n        }\n      } else {\n        if (this.isMaster) {\n          this.tableOffset = offset(this.TABLE);\n        } else {\n          this.tableOffset = this.dataAccessObject.parentTableOffset;\n        }\n        var startRow = totalRows > 0 ? this.getFirstRenderedRow() : 0;\n        var startColumn = totalColumns > 0 ? this.getFirstRenderedColumn() : 0;\n        this.rowFilter = new RowFilter(startRow, totalRows, columnHeadersCount);\n        this.columnFilter = new ColumnFilter(startColumn, totalColumns, rowHeadersCount);\n        var performRedraw = true;\n\n        // Only master table rendering can be skipped\n        if (this.isMaster) {\n          this.alignOverlaysWithTrimmingContainer(); // todo It calls method from child class (MasterTable).\n          var skipRender = {};\n          this.wtSettings.getSetting('beforeDraw', true, skipRender);\n          performRedraw = skipRender.skipRender !== true;\n        }\n        if (performRedraw) {\n          this.tableRenderer.setHeaderContentRenderers(rowHeaders, columnHeaders);\n          if (this.is(CLONE_BOTTOM) || this.is(CLONE_BOTTOM_INLINE_START_CORNER)) {\n            // do NOT render headers on the bottom or bottom-left corner overlay\n            this.tableRenderer.setHeaderContentRenderers(rowHeaders, []);\n          }\n          this.resetOversizedRows();\n          this.tableRenderer.setActiveOverlayName(this.name).setViewportSize(this.getRenderedRowsCount(), this.getRenderedColumnsCount()).setFilters(this.rowFilter, this.columnFilter).render();\n          var workspaceWidth;\n          if (this.isMaster) {\n            workspaceWidth = this.dataAccessObject.workspaceWidth;\n            wtViewport.containerWidth = null;\n            this.markOversizedColumnHeaders();\n          }\n          this.adjustColumnHeaderHeights();\n          if (this.isMaster || this.is(CLONE_BOTTOM)) {\n            this.markOversizedRows();\n          }\n          if (this.isMaster) {\n            if (!this.wtSettings.getSetting('externalRowCalculator')) {\n              wtViewport.createVisibleCalculators();\n            }\n            wtOverlays.refresh(false);\n            wtOverlays.applyToDOM();\n            var hiderWidth = outerWidth(this.hider);\n            var tableWidth = outerWidth(this.TABLE);\n            if (hiderWidth !== 0 && tableWidth !== hiderWidth) {\n              // Recalculate the column widths, if width changes made in the overlays removed the scrollbar, thus changing the viewport width.\n              this.columnUtils.calculateWidths();\n              this.tableRenderer.renderer.colGroup.render();\n            }\n            if (workspaceWidth !== wtViewport.getWorkspaceWidth()) {\n              // workspace width changed though to shown/hidden vertical scrollbar. Let's reapply stretching\n              wtViewport.containerWidth = null;\n              this.columnUtils.calculateWidths();\n              this.tableRenderer.renderer.colGroup.render();\n            }\n            this.wtSettings.getSetting('onDraw', true);\n          } else if (this.is(CLONE_BOTTOM)) {\n            this.dataAccessObject.cloneSource.wtOverlays.adjustElementsSize();\n          }\n        }\n      }\n      var positionChanged = false;\n      if (this.isMaster) {\n        positionChanged = wtOverlays.topOverlay.resetFixedPosition();\n        if (wtOverlays.bottomOverlay.clone) {\n          positionChanged = wtOverlays.bottomOverlay.resetFixedPosition() || positionChanged;\n        }\n        positionChanged = wtOverlays.inlineStartOverlay.resetFixedPosition() || positionChanged;\n        if (wtOverlays.topInlineStartCornerOverlay) {\n          wtOverlays.topInlineStartCornerOverlay.resetFixedPosition();\n        }\n        if (wtOverlays.bottomInlineStartCornerOverlay && wtOverlays.bottomInlineStartCornerOverlay.clone) {\n          wtOverlays.bottomInlineStartCornerOverlay.resetFixedPosition();\n        }\n      }\n      if (positionChanged) {\n        // It refreshes the cells borders caused by a 1px shift (introduced by overlays which add or\n        // remove `innerBorderTop` and `innerBorderInlineStart` CSS classes to the DOM element. This happens\n        // when there is a switch between rendering from 0 to N rows/columns and vice versa).\n        wtOverlays.refreshAll(); // `refreshAll()` internally already calls `refreshSelections()` method\n        wtOverlays.adjustElementsSize();\n      } else {\n        this.dataAccessObject.selectionManager.setActiveOverlay(this.facadeGetter()).render(runFastDraw);\n      }\n      if (this.isMaster) {\n        wtOverlays.afterDraw();\n      }\n      this.dataAccessObject.drawn = true;\n      return this;\n    }\n\n    /**\n     * @param {number} col The visual column index.\n     */\n  }, {\n    key: \"markIfOversizedColumnHeader\",\n    value: function markIfOversizedColumnHeader(col) {\n      var sourceColIndex = this.columnFilter.renderedToSource(col);\n      var level = this.wtSettings.getSetting('columnHeaders').length;\n      var defaultRowHeight = this.wtSettings.getSetting('defaultRowHeight');\n      var previousColHeaderHeight;\n      var currentHeader;\n      var currentHeaderHeight;\n      var columnHeaderHeightSetting = this.wtSettings.getSetting('columnHeaderHeight') || [];\n      while (level) {\n        level -= 1;\n        previousColHeaderHeight = this.getColumnHeaderHeight(level);\n        currentHeader = this.getColumnHeader(sourceColIndex, level);\n        if (!currentHeader) {\n          /* eslint-disable no-continue */\n          continue;\n        }\n        currentHeaderHeight = innerHeight(currentHeader);\n        if (!previousColHeaderHeight && defaultRowHeight < currentHeaderHeight || previousColHeaderHeight < currentHeaderHeight) {\n          this.dataAccessObject.wtViewport.oversizedColumnHeaders[level] = currentHeaderHeight;\n        }\n        if (Array.isArray(columnHeaderHeightSetting)) {\n          if (columnHeaderHeightSetting[level] !== null && columnHeaderHeightSetting[level] !== undefined) {\n            this.dataAccessObject.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting[level];\n          }\n        } else if (!isNaN(columnHeaderHeightSetting)) {\n          this.dataAccessObject.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting;\n        }\n        if (this.dataAccessObject.wtViewport.oversizedColumnHeaders[level] < (columnHeaderHeightSetting[level] || columnHeaderHeightSetting)) {\n          this.dataAccessObject.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting[level] || columnHeaderHeightSetting; // eslint-disable-line max-len\n        }\n      }\n    }\n\n    /**\n     *\n     */\n  }, {\n    key: \"adjustColumnHeaderHeights\",\n    value: function adjustColumnHeaderHeights() {\n      var wtSettings = this.wtSettings;\n      var children = this.THEAD.childNodes;\n      var oversizedColumnHeaders = this.dataAccessObject.wtViewport.oversizedColumnHeaders;\n      var columnHeaders = wtSettings.getSetting('columnHeaders');\n      for (var i = 0, len = columnHeaders.length; i < len; i++) {\n        if (oversizedColumnHeaders[i]) {\n          if (!children[i] || children[i].childNodes.length === 0) {\n            return;\n          }\n          children[i].childNodes[0].style.height = \"\".concat(oversizedColumnHeaders[i], \"px\");\n        }\n      }\n    }\n\n    /**\n     * Resets cache of row heights. The cache should be cached for each render cycle in a case\n     * when new cell values have content which increases/decreases cell height.\n     */\n  }, {\n    key: \"resetOversizedRows\",\n    value: function resetOversizedRows() {\n      var wtSettings = this.wtSettings;\n      var wtViewport = this.dataAccessObject.wtViewport;\n      if (!this.isMaster && !this.is(CLONE_BOTTOM)) {\n        return;\n      }\n      if (!wtSettings.getSetting('externalRowCalculator')) {\n        var rowsToRender = this.getRenderedRowsCount();\n\n        // Reset the oversized row cache for rendered rows\n        for (var visibleRowIndex = 0; visibleRowIndex < rowsToRender; visibleRowIndex++) {\n          var sourceRow = this.rowFilter.renderedToSource(visibleRowIndex);\n          if (wtViewport.oversizedRows && wtViewport.oversizedRows[sourceRow]) {\n            wtViewport.oversizedRows[sourceRow] = undefined;\n          }\n        }\n      }\n    }\n\n    /**\n     * Get cell element at coords.\n     * Negative coords.row or coords.col are used to retrieve header cells. If there are multiple header levels, the\n     * negative value corresponds to the distance from the working area. For example, when there are 3 levels of column\n     * headers, coords.col=-1 corresponds to the most inner header element, while coords.col=-3 corresponds to the\n     * outmost header element.\n     *\n     * In case an element for the coords is not rendered, the method returns an error code.\n     * To produce the error code, the input parameters are validated in the order in which they\n     * are given. Thus, if both the row and the column coords are out of the rendered bounds,\n     * the method returns the error code for the row.\n     *\n     * @param {CellCoords} coords The cell coordinates.\n     * @returns {HTMLElement|number} HTMLElement on success or Number one of the exit codes on error:\n     *  -1 row before viewport\n     *  -2 row after viewport\n     *  -3 column before viewport\n     *  -4 column after viewport.\n     */\n  }, {\n    key: \"getCell\",\n    value: function getCell(coords) {\n      var row = coords.row;\n      var column = coords.col;\n      var hookResult = this.wtSettings.getSetting('onModifyGetCellCoords', row, column);\n      if (hookResult && Array.isArray(hookResult)) {\n        var _hookResult = _slicedToArray(hookResult, 2);\n        row = _hookResult[0];\n        column = _hookResult[1];\n      }\n      if (this.isRowBeforeRenderedRows(row)) {\n        // row before rendered rows\n        return -1;\n      } else if (this.isRowAfterRenderedRows(row)) {\n        // row after rendered rows\n        return -2;\n      } else if (this.isColumnBeforeRenderedColumns(column)) {\n        // column before rendered columns\n        return -3;\n      } else if (this.isColumnAfterRenderedColumns(column)) {\n        // column after rendered columns\n        return -4;\n      }\n      var TR = this.getRow(row);\n      if (!TR && row >= 0) {\n        throw new Error('TR was expected to be rendered but is not');\n      }\n      var TD = TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(column)];\n      if (!TD && column >= 0) {\n        throw new Error('TD or TH was expected to be rendered but is not');\n      }\n      return TD;\n    }\n\n    /**\n     * Get the DOM element of the row with the provided index.\n     *\n     * @param {number} rowIndex Row index.\n     * @returns {HTMLTableRowElement|boolean} Return the row's DOM element or `false` if the row with the provided\n     * index doesn't exist.\n     */\n  }, {\n    key: \"getRow\",\n    value: function getRow(rowIndex) {\n      var renderedRowIndex = null;\n      var parentElement = null;\n      if (rowIndex < 0) {\n        var _this$rowFilter;\n        renderedRowIndex = (_this$rowFilter = this.rowFilter) === null || _this$rowFilter === void 0 ? void 0 : _this$rowFilter.sourceRowToVisibleColHeadedRow(rowIndex);\n        parentElement = this.THEAD;\n      } else {\n        var _this$rowFilter2;\n        renderedRowIndex = (_this$rowFilter2 = this.rowFilter) === null || _this$rowFilter2 === void 0 ? void 0 : _this$rowFilter2.sourceToRendered(rowIndex);\n        parentElement = this.TBODY;\n      }\n      if (renderedRowIndex !== undefined && parentElement !== undefined) {\n        if (parentElement.childNodes.length < renderedRowIndex + 1) {\n          return false;\n        } else {\n          return parentElement.childNodes[renderedRowIndex];\n        }\n      } else {\n        return false;\n      }\n    }\n\n    /**\n     * GetColumnHeader.\n     *\n     * @param {number} col Column index.\n     * @param {number} [level=0] Header level (0 = most distant to the table).\n     * @returns {object} HTMLElement on success or undefined on error.\n     */\n  }, {\n    key: \"getColumnHeader\",\n    value: function getColumnHeader(col) {\n      var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var TR = this.THEAD.childNodes[level];\n      return TR === null || TR === void 0 ? void 0 : TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(col)];\n    }\n\n    /**\n     * Gets all columns headers (TH elements) from the table.\n     *\n     * @param {number} column A source column index.\n     * @returns {HTMLTableCellElement[]}\n     */\n  }, {\n    key: \"getColumnHeaders\",\n    value: function getColumnHeaders(column) {\n      var THs = [];\n      var visibleColumn = this.columnFilter.sourceColumnToVisibleRowHeadedColumn(column);\n      this.THEAD.childNodes.forEach(function (TR) {\n        var TH = TR.childNodes[visibleColumn];\n        if (TH) {\n          THs.push(TH);\n        }\n      });\n      return THs;\n    }\n\n    /**\n     * GetRowHeader.\n     *\n     * @param {number} row Row index.\n     * @param {number} [level=0] Header level (0 = most distant to the table).\n     * @returns {HTMLElement} HTMLElement on success or Number one of the exit codes on error: `null table doesn't have\n     *   row headers`.\n     */\n  }, {\n    key: \"getRowHeader\",\n    value: function getRowHeader(row) {\n      var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var rowHeadersCount = this.wtSettings.getSetting('rowHeaders').length;\n      if (level >= rowHeadersCount) {\n        return;\n      }\n      var renderedRow = this.rowFilter.sourceToRendered(row);\n      var visibleRow = renderedRow < 0 ? this.rowFilter.sourceRowToVisibleColHeadedRow(row) : renderedRow;\n      var parentElement = renderedRow < 0 ? this.THEAD : this.TBODY;\n      var TR = parentElement.childNodes[visibleRow];\n      return TR === null || TR === void 0 ? void 0 : TR.childNodes[level];\n    }\n\n    /**\n     * Gets all rows headers (TH elements) from the table.\n     *\n     * @param {number} row A source row index.\n     * @returns {HTMLTableCellElement[]}\n     */\n  }, {\n    key: \"getRowHeaders\",\n    value: function getRowHeaders(row) {\n      var THs = [];\n      var rowHeadersCount = this.wtSettings.getSetting('rowHeaders').length;\n      for (var renderedRowIndex = 0; renderedRowIndex < rowHeadersCount; renderedRowIndex++) {\n        var TR = this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];\n        var TH = TR === null || TR === void 0 ? void 0 : TR.childNodes[renderedRowIndex];\n        if (TH) {\n          THs.push(TH);\n        }\n      }\n      return THs;\n    }\n\n    /**\n     * Returns cell coords object for a given TD (or a child element of a TD element).\n     *\n     * @param {HTMLTableCellElement} TD A cell DOM element (or a child of one).\n     * @returns {CellCoords|null} The coordinates of the provided TD element (or the closest TD element) or null, if the\n     *   provided element is not applicable.\n     */\n  }, {\n    key: \"getCoords\",\n    value: function getCoords(TD) {\n      var cellElement = TD;\n      if (cellElement.nodeName !== 'TD' && cellElement.nodeName !== 'TH') {\n        cellElement = closest(cellElement, ['TD', 'TH']);\n      }\n      if (cellElement === null) {\n        return null;\n      }\n      var TR = cellElement.parentNode;\n      var CONTAINER = TR.parentNode;\n      var row = index(TR);\n      var col = cellElement.cellIndex;\n      if (overlayContainsElement(CLONE_TOP_INLINE_START_CORNER, cellElement, this.wtRootElement) || overlayContainsElement(CLONE_TOP, cellElement, this.wtRootElement)) {\n        if (CONTAINER.nodeName === 'THEAD') {\n          row -= CONTAINER.childNodes.length;\n        }\n      } else if (overlayContainsElement(CLONE_BOTTOM_INLINE_START_CORNER, cellElement, this.wtRootElement) || overlayContainsElement(CLONE_BOTTOM, cellElement, this.wtRootElement)) {\n        var totalRows = this.wtSettings.getSetting('totalRows');\n        row = totalRows - CONTAINER.childNodes.length + row;\n      } else if (CONTAINER === this.THEAD) {\n        row = this.rowFilter.visibleColHeadedRowToSourceRow(row);\n      } else {\n        row = this.rowFilter.renderedToSource(row);\n      }\n      if (overlayContainsElement(CLONE_TOP_INLINE_START_CORNER, cellElement, this.wtRootElement) || overlayContainsElement(CLONE_INLINE_START, cellElement, this.wtRootElement) || overlayContainsElement(CLONE_BOTTOM_INLINE_START_CORNER, cellElement, this.wtRootElement)) {\n        col = this.columnFilter.offsettedTH(col);\n      } else {\n        col = this.columnFilter.visibleRowHeadedColumnToSourceColumn(col);\n      }\n      return this.wot.createCellCoords(row, col);\n    }\n\n    /**\n     * Check if any of the rendered rows is higher than expected, and if so, cache them.\n     */\n  }, {\n    key: \"markOversizedRows\",\n    value: function markOversizedRows() {\n      if (this.wtSettings.getSetting('externalRowCalculator')) {\n        return;\n      }\n      var rowCount = this.TBODY.childNodes.length;\n      var expectedTableHeight = rowCount * this.wtSettings.getSetting('defaultRowHeight');\n      var actualTableHeight = innerHeight(this.TBODY) - 1;\n      var previousRowHeight;\n      var rowInnerHeight;\n      var sourceRowIndex;\n      var currentTr;\n      var rowHeader;\n      if (expectedTableHeight === actualTableHeight && !this.wtSettings.getSetting('fixedRowsBottom')) {\n        // If the actual table height equals rowCount * default single row height, no row is oversized -> no need to iterate over them\n        return;\n      }\n      while (rowCount) {\n        rowCount -= 1;\n        sourceRowIndex = this.rowFilter.renderedToSource(rowCount);\n        previousRowHeight = this.getRowHeight(sourceRowIndex);\n        currentTr = this.getTrForRow(sourceRowIndex);\n        rowHeader = currentTr.querySelector('th');\n        if (rowHeader) {\n          rowInnerHeight = innerHeight(rowHeader);\n        } else {\n          rowInnerHeight = innerHeight(currentTr) - 1;\n        }\n        if (!previousRowHeight && this.wtSettings.getSetting('defaultRowHeight') < rowInnerHeight || previousRowHeight < rowInnerHeight) {\n          rowInnerHeight += 1;\n          this.dataAccessObject.wtViewport.oversizedRows[sourceRowIndex] = rowInnerHeight;\n        }\n      }\n    }\n\n    /**\n     * @param {number} row The visual row index.\n     * @returns {HTMLTableElement}\n     */\n  }, {\n    key: \"getTrForRow\",\n    value: function getTrForRow(row) {\n      return this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];\n    }\n\n    /**\n     * Checks if the column index (negative value from -1 to N) is rendered.\n     *\n     * @param {number} column The column index (negative value from -1 to N).\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isColumnHeaderRendered\",\n    value: function isColumnHeaderRendered(column) {\n      if (column >= 0) {\n        return false;\n      }\n      var rowHeaders = this.wtSettings.getSetting('rowHeaders');\n      var rowHeadersCount = rowHeaders.length;\n      return Math.abs(column) <= rowHeadersCount;\n    }\n\n    /**\n     * Checks if the row index (negative value from -1 to N) is rendered.\n     *\n     * @param {number} row The row index (negative value from -1 to N).\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isRowHeaderRendered\",\n    value: function isRowHeaderRendered(row) {\n      if (row >= 0) {\n        return false;\n      }\n      var columnHeaders = this.wtSettings.getSetting('columnHeaders');\n      var columnHeadersCount = columnHeaders.length;\n      return Math.abs(row) <= columnHeadersCount;\n    }\n\n    /* eslint-disable jsdoc/require-description-complete-sentence */\n    /**\n     * Check if the given row index is lower than the index of the first row that\n     * is currently rendered and return TRUE in that case, or FALSE otherwise.\n     *\n     * Negative row index is used to check the columns' headers.\n     *\n     *  Headers\n     *           +--------------+                                     │\n     *       -3  │    │    │    │                                     │\n     *           +--------------+                                     │\n     *       -2  │    │    │    │                                     │ TRUE\n     *           +--------------+                                     │\n     *       -1  │    │    │    │                                     │\n     *  Cells  +==================+                                   │\n     *        0  ┇    ┇    ┇    ┇ <--- For fixedRowsTop: 1            │\n     *           +--------------+      the master overlay do       ---+ first rendered row (index 1)\n     *        1  │ A2 │ B2 │ C2 │      not render the first row.      │\n     *           +--------------+                                     │ FALSE\n     *        2  │ A3 │ B3 │ C3 │                                     │\n     *           +--------------+                                  ---+ last rendered row\n     *                                                                │\n     *                                                                │ FALSE\n     *\n     * @param {number} row The visual row index.\n     * @memberof Table#\n     * @function isRowBeforeRenderedRows\n     * @returns {boolean}\n     */\n    /* eslint-enable jsdoc/require-description-complete-sentence */\n  }, {\n    key: \"isRowBeforeRenderedRows\",\n    value: function isRowBeforeRenderedRows(row) {\n      var first = this.getFirstRenderedRow();\n\n      // Check the headers only in case when the first rendered row is -1 or 0.\n      // This is an indication that the overlay is placed on the most top position.\n      if (row < 0 && first <= 0) {\n        return !this.isRowHeaderRendered(row);\n      }\n      return row < first;\n    }\n\n    /* eslint-disable jsdoc/require-description-complete-sentence */\n    /**\n     * Check if the given column index is greater than the index of the last column that\n     * is currently rendered and return TRUE in that case, or FALSE otherwise.\n     *\n     * The negative row index is used to check the columns' headers. However,\n     * keep in mind that for negative indexes, the method always returns FALSE as\n     * it is not possible to render headers partially. The \"after\" index can not be\n     * lower than -1.\n     *\n     *  Headers\n     *           +--------------+                                     │\n     *       -3  │    │    │    │                                     │\n     *           +--------------+                                     │\n     *       -2  │    │    │    │                                     │ FALSE\n     *           +--------------+                                     │\n     *       -1  │    │    │    │                                     │\n     *  Cells  +==================+                                   │\n     *        0  ┇    ┇    ┇    ┇ <--- For fixedRowsTop: 1            │\n     *           +--------------+      the master overlay do       ---+ first rendered row (index 1)\n     *        1  │ A2 │ B2 │ C2 │      not render the first rows      │\n     *           +--------------+                                     │ FALSE\n     *        2  │ A3 │ B3 │ C3 │                                     │\n     *           +--------------+                                  ---+ last rendered row\n     *                                                                │\n     *                                                                │ TRUE\n     *\n     * @param {number} row The visual row index.\n     * @memberof Table#\n     * @function isRowAfterRenderedRows\n     * @returns {boolean}\n     */\n    /* eslint-enable jsdoc/require-description-complete-sentence */\n  }, {\n    key: \"isRowAfterRenderedRows\",\n    value: function isRowAfterRenderedRows(row) {\n      return row > this.getLastRenderedRow();\n    }\n\n    /* eslint-disable jsdoc/require-description-complete-sentence */\n    /**\n     * Check if the given column index is lower than the index of the first column that\n     * is currently rendered and return TRUE in that case, or FALSE otherwise.\n     *\n     * Negative column index is used to check the rows' headers.\n     *\n     *                            For fixedColumnsStart: 1 the master overlay\n     *                            do not render this first columns.\n     *  Headers    -3   -2   -1    |\n     *           +----+----+----║┄ ┄ +------+------+\n     *           │    │    │    ║    │  B1  │  C1  │\n     *           +--------------║┄ ┄ --------------│\n     *           │    │    │    ║    │  B2  │  C2  │\n     *           +--------------║┄ ┄ --------------│\n     *           │    │    │    ║    │  B3  │  C3  │\n     *           +----+----+----║┄ ┄ +------+------+\n     *                               ╷             ╷\n     *      -------------------------+-------------+---------------->\n     *          TRUE             first    FALSE   last         FALSE\n     *                           rendered         rendered\n     *                           column           column\n     *\n     * @param {number} column The visual column index.\n     * @memberof Table#\n     * @function isColumnBeforeRenderedColumns\n     * @returns {boolean}\n     */\n    /* eslint-enable jsdoc/require-description-complete-sentence */\n  }, {\n    key: \"isColumnBeforeRenderedColumns\",\n    value: function isColumnBeforeRenderedColumns(column) {\n      var first = this.getFirstRenderedColumn();\n\n      // Check the headers only in case when the first rendered column is -1 or 0.\n      // This is an indication that the overlay is placed on the most left position.\n      if (column < 0 && first <= 0) {\n        return !this.isColumnHeaderRendered(column);\n      }\n      return column < first;\n    }\n\n    /* eslint-disable jsdoc/require-description-complete-sentence */\n    /**\n     * Check if the given column index is greater than the index of the last column that\n     * is currently rendered and return TRUE in that case, or FALSE otherwise.\n     *\n     * The negative column index is used to check the rows' headers. However,\n     * keep in mind that for negative indexes, the method always returns FALSE as\n     * it is not possible to render headers partially. The \"after\" index can not be\n     * lower than -1.\n     *\n     *                            For fixedColumnsStart: 1 the master overlay\n     *                            do not render this first columns.\n     *  Headers    -3   -2   -1    |\n     *           +----+----+----║┄ ┄ +------+------+\n     *           │    │    │    ║    │  B1  │  C1  │\n     *           +--------------║┄ ┄ --------------│\n     *           │    │    │    ║    │  B2  │  C2  │\n     *           +--------------║┄ ┄ --------------│\n     *           │    │    │    ║    │  B3  │  C3  │\n     *           +----+----+----║┄ ┄ +------+------+\n     *                               ╷             ╷\n     *      -------------------------+-------------+---------------->\n     *          FALSE             first    FALSE   last         TRUE\n     *                           rendered         rendered\n     *                           column           column\n     *\n     * @param {number} column The visual column index.\n     * @memberof Table#\n     * @function isColumnAfterRenderedColumns\n     * @returns {boolean}\n     */\n    /* eslint-enable jsdoc/require-description-complete-sentence */\n  }, {\n    key: \"isColumnAfterRenderedColumns\",\n    value: function isColumnAfterRenderedColumns(column) {\n      return this.columnFilter && column > this.getLastRenderedColumn();\n    }\n  }, {\n    key: \"isColumnAfterViewport\",\n    value: function isColumnAfterViewport(column) {\n      return this.columnFilter && column > this.getLastVisibleColumn();\n    }\n  }, {\n    key: \"isRowAfterViewport\",\n    value: function isRowAfterViewport(row) {\n      return this.rowFilter && row > this.getLastVisibleRow();\n    }\n  }, {\n    key: \"isColumnBeforeViewport\",\n    value: function isColumnBeforeViewport(column) {\n      return this.columnFilter && this.columnFilter.sourceToRendered(column) < 0 && column >= 0;\n    }\n  }, {\n    key: \"isLastRowFullyVisible\",\n    value: function isLastRowFullyVisible() {\n      return this.getLastVisibleRow() === this.getLastRenderedRow();\n    }\n  }, {\n    key: \"isLastColumnFullyVisible\",\n    value: function isLastColumnFullyVisible() {\n      return this.getLastVisibleColumn() === this.getLastRenderedColumn();\n    }\n  }, {\n    key: \"allRowsInViewport\",\n    value: function allRowsInViewport() {\n      return this.wtSettings.getSetting('totalRows') === this.getVisibleRowsCount();\n    }\n  }, {\n    key: \"allColumnsInViewport\",\n    value: function allColumnsInViewport() {\n      return this.wtSettings.getSetting('totalColumns') === this.getVisibleColumnsCount();\n    }\n\n    /**\n     * Checks if any of the row's cells content exceeds its initial height, and if so, returns the oversized height.\n     *\n     * @param {number} sourceRow The physical row index.\n     * @returns {number}\n     */\n  }, {\n    key: \"getRowHeight\",\n    value: function getRowHeight(sourceRow) {\n      return this.rowUtils.getHeight(sourceRow);\n    }\n\n    /**\n     * @param {number} level The column level.\n     * @returns {number}\n     */\n  }, {\n    key: \"getColumnHeaderHeight\",\n    value: function getColumnHeaderHeight(level) {\n      return this.columnUtils.getHeaderHeight(level);\n    }\n\n    /**\n     * @param {number} sourceColumn The physical column index.\n     * @returns {number}\n     */\n  }, {\n    key: \"getColumnWidth\",\n    value: function getColumnWidth(sourceColumn) {\n      return this.columnUtils.getWidth(sourceColumn);\n    }\n\n    /**\n     * @param {number} sourceColumn The physical column index.\n     * @returns {number}\n     */\n  }, {\n    key: \"getStretchedColumnWidth\",\n    value: function getStretchedColumnWidth(sourceColumn) {\n      return this.columnUtils.getStretchedColumnWidth(sourceColumn);\n    }\n\n    /**\n     * Checks if the table has defined size. It returns `true` when the table has width and height\n     * set bigger than `0px`.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"hasDefinedSize\",\n    value: function hasDefinedSize() {\n      return this.hasTableHeight && this.hasTableWidth;\n    }\n\n    /**\n     * Gets table's width. The returned width is the width of the rendered cells that fit in the\n     * current viewport. The value may change depends on the viewport position (scroll position).\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"getWidth\",\n    value: function getWidth() {\n      return outerWidth(this.TABLE);\n    }\n\n    /**\n     * Gets table's height. The returned height is the height of the rendered cells that fit in the\n     * current viewport. The value may change depends on the viewport position (scroll position).\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"getHeight\",\n    value: function getHeight() {\n      return outerHeight(this.TABLE);\n    }\n\n    /**\n     * Gets table's total width. The returned width is the width of all rendered cells (including headers)\n     * that can be displayed in the table.\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"getTotalWidth\",\n    value: function getTotalWidth() {\n      var width = outerWidth(this.hider);\n\n      // when the overlay's table does not have any cells the hider returns 0, get then width from the table element\n      return width !== 0 ? width : this.getWidth();\n    }\n\n    /**\n     * Gets table's total height. The returned height is the height of all rendered cells (including headers)\n     * that can be displayed in the table.\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"getTotalHeight\",\n    value: function getTotalHeight() {\n      var height = outerHeight(this.hider);\n\n      // when the overlay's table does not have any cells the hider returns 0, get then height from the table element\n      return height !== 0 ? height : this.getHeight();\n    }\n\n    /**\n     * Checks if the table is visible. It returns `true` when the holder element (or its parents)\n     * has CSS 'display' property different than 'none'.\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isVisible\",\n    value: function isVisible() {\n      return _isVisible(this.TABLE);\n    }\n\n    /**\n     * Modify row header widths provided by user in class contructor.\n     *\n     * @private\n     * @param {Function} rowHeaderWidthFactory The function which can provide default width values for rows..\n     * @returns {number}\n     */\n  }, {\n    key: \"_modifyRowHeaderWidth\",\n    value: function _modifyRowHeaderWidth(rowHeaderWidthFactory) {\n      var widths = isFunction(rowHeaderWidthFactory) ? rowHeaderWidthFactory() : null;\n      if (Array.isArray(widths)) {\n        widths = _toConsumableArray(widths);\n        widths[widths.length - 1] = this._correctRowHeaderWidth(widths[widths.length - 1]);\n      } else {\n        widths = this._correctRowHeaderWidth(widths);\n      }\n      return widths;\n    }\n\n    /**\n     * Correct row header width if necessary.\n     *\n     * @private\n     * @param {number} width The width to process.\n     * @returns {number}\n     */\n  }, {\n    key: \"_correctRowHeaderWidth\",\n    value: function _correctRowHeaderWidth(width) {\n      var rowHeaderWidth = width;\n      if (typeof width !== 'number') {\n        rowHeaderWidth = this.wtSettings.getSetting('defaultColumnWidth');\n      }\n      if (this.correctHeaderWidth) {\n        rowHeaderWidth += 1;\n      }\n      return rowHeaderWidth;\n    }\n  }]);\n}();\nexport default Table;","map":{"version":3,"names":["_defineProperty","e","r","t","_toPropertyKey","Object","defineProperty","value","enumerable","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","TypeError","String","Number","hasClass","index","offset","removeTextNodes","overlayContainsElement","closest","outerHeight","outerWidth","innerHeight","isVisible","setAttribute","isFunction","ColumnFilter","RowFilter","Renderer","ColumnUtils","RowUtils","CLONE_TOP","CLONE_BOTTOM","CLONE_INLINE_START","CLONE_TOP_INLINE_START_CORNER","CLONE_BOTTOM_INLINE_START_CORNER","A11Y_PRESENTATION","Table","dataAccessObject","facadeGetter","domBindings","wtSettings","name","_this","_classCallCheck","isMaster","instance","wot","TABLE","rootTable","spreader","createSpreader","hider","createHider","holder","createHolder","wtRootElement","parentNode","alignOverlaysWithTrimmingContainer","fixTableDomTree","rowFilter","columnFilter","correctHeaderWidth","origRowHeaderWidth","getSettingPure","update","_modifyRowHeaderWidth","rowUtils","columnUtils","tableRenderer","THEAD","COLGROUP","TBODY","cellRenderer","_createClass","key","is","overlayTypeName","rootDocument","querySelector","createElement","appendChild","insertBefore","table","parent","nodeType","Node","ELEMENT_NODE","className","style","position","getSetting","draw","fastDraw","arguments","length","undefined","_this$dataAccessObjec","wtOverlays","wtViewport","totalRows","totalColumns","rowHeaders","rowHeadersCount","columnHeaders","columnHeadersCount","runFastDraw","beforeDraw","holderOffset","createCalculators","leftScrollPos","inlineStartOverlay","getScrollPosition","previousState","refresh","tableOffset","parentTableOffset","startRow","getFirstRenderedRow","startColumn","getFirstRenderedColumn","performRedraw","skipRender","setHeaderContentRenderers","resetOversizedRows","setActiveOverlayName","setViewportSize","getRenderedRowsCount","getRenderedColumnsCount","setFilters","render","workspaceWidth","containerWidth","markOversizedColumnHeaders","adjustColumnHeaderHeights","markOversizedRows","createVisibleCalculators","applyToDOM","hiderWidth","tableWidth","calculateWidths","renderer","colGroup","getWorkspaceWidth","cloneSource","adjustElementsSize","positionChanged","topOverlay","resetFixedPosition","bottomOverlay","clone","topInlineStartCornerOverlay","bottomInlineStartCornerOverlay","refreshAll","selectionManager","setActiveOverlay","afterDraw","drawn","markIfOversizedColumnHeader","col","sourceColIndex","renderedToSource","level","defaultRowHeight","previousColHeaderHeight","currentHeader","currentHeaderHeight","columnHeaderHeightSetting","getColumnHeaderHeight","getColumnHeader","oversizedColumnHeaders","Array","isArray","isNaN","children","childNodes","len","height","concat","rowsToRender","visibleRowIndex","sourceRow","oversizedRows","getCell","coords","row","column","hookResult","_hookResult","_slicedToArray","isRowBeforeRenderedRows","isRowAfterRenderedRows","isColumnBeforeRenderedColumns","isColumnAfterRenderedColumns","TR","getRow","Error","TD","sourceColumnToVisibleRowHeadedColumn","rowIndex","renderedRowIndex","parentElement","_this$rowFilter","sourceRowToVisibleColHeadedRow","_this$rowFilter2","sourceToRendered","getColumnHeaders","THs","visibleColumn","forEach","TH","push","getRowHeader","renderedRow","visibleRow","getRowHeaders","getCoords","cellElement","nodeName","CONTAINER","cellIndex","visibleColHeadedRowToSourceRow","offsettedTH","visibleRowHeadedColumnToSourceColumn","createCellCoords","rowCount","expectedTableHeight","actualTableHeight","previousRowHeight","rowInnerHeight","sourceRowIndex","currentTr","rowHeader","getRowHeight","getTrForRow","isColumnHeaderRendered","Math","abs","isRowHeaderRendered","first","getLastRenderedRow","getLastRenderedColumn","isColumnAfterViewport","getLastVisibleColumn","isRowAfterViewport","getLastVisibleRow","isColumnBeforeViewport","isLastRowFullyVisible","isLastColumnFullyVisible","allRowsInViewport","getVisibleRowsCount","allColumnsInViewport","getVisibleColumnsCount","getHeight","getHeaderHeight","getColumnWidth","sourceColumn","getWidth","getStretchedColumnWidth","hasDefinedSize","hasTableHeight","hasTableWidth","getTotalWidth","width","getTotalHeight","rowHeaderWidthFactory","widths","_toConsumableArray","_correctRowHeaderWidth","rowHeaderWidth"],"sources":["/Users/priyadeliwala/node_modules/handsontable/3rdparty/walkontable/src/table.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.push.js\";\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport { hasClass, index, offset, removeTextNodes, overlayContainsElement, closest, outerHeight, outerWidth, innerHeight, isVisible, setAttribute } from \"../../../helpers/dom/element.mjs\";\nimport { isFunction } from \"../../../helpers/function.mjs\";\nimport ColumnFilter from \"./filter/column.mjs\";\nimport RowFilter from \"./filter/row.mjs\";\nimport { Renderer } from \"./renderer/index.mjs\";\nimport ColumnUtils from \"./utils/column.mjs\";\nimport RowUtils from \"./utils/row.mjs\";\nimport { CLONE_TOP, CLONE_BOTTOM, CLONE_INLINE_START, CLONE_TOP_INLINE_START_CORNER, CLONE_BOTTOM_INLINE_START_CORNER } from \"./overlay/index.mjs\";\nimport { A11Y_PRESENTATION } from \"../../../helpers/a11y.mjs\";\n/**\n * @todo These mixes are never added to the class Table, however their members are used here.\n * @todo Continue: Potentially it works only, because some of these mixes are added to every inherited class.\n * @todo Refactoring, move code from `if(this.isMaster)` into MasterTable, and others like that.\n * @mixes stickyColumnsStart\n * @mixes stickyRowsBottom\n * @mixes stickyRowsTop\n * @mixes calculatedRows\n * @mixes calculatedColumns\n * @abstract\n */\nclass Table {\n  /**\n   *\n   * @abstract\n   * @param {TableDao} dataAccessObject The data access object.\n   * @param {FacadeGetter} facadeGetter Function which return proper facade.\n   * @param {DomBindings} domBindings Bindings into DOM.\n   * @param {Settings} wtSettings The Walkontable settings.\n   * @param {'master'|CLONE_TYPES_ENUM} name Overlay name.\n   */\n  constructor(dataAccessObject, facadeGetter, domBindings, wtSettings, name) {\n    /**\n     * The walkontable settings.\n     *\n     * @protected\n     * @type {Settings}\n     */\n    _defineProperty(this, \"wtSettings\", null);\n    _defineProperty(this, \"domBindings\", void 0);\n    _defineProperty(this, \"TBODY\", null);\n    _defineProperty(this, \"THEAD\", null);\n    _defineProperty(this, \"COLGROUP\", null);\n    /**\n     * Indicates if the table has height bigger than 0px.\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"hasTableHeight\", true);\n    /**\n     * Indicates if the table has width bigger than 0px.\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"hasTableWidth\", true);\n    /**\n     * Indicates if the table is visible. By visible, it means that the holder\n     * element has CSS 'display' property different than 'none'.\n     *\n     * @type {boolean}\n     */\n    _defineProperty(this, \"isTableVisible\", false);\n    _defineProperty(this, \"tableOffset\", 0);\n    _defineProperty(this, \"holderOffset\", 0);\n    this.domBindings = domBindings;\n    /**\n     * Indicates if this instance is of type `MasterTable` (i.e. It is NOT an overlay).\n     *\n     * @type {boolean}\n     */\n    this.isMaster = name === 'master';\n    this.name = name;\n    this.dataAccessObject = dataAccessObject;\n    this.facadeGetter = facadeGetter;\n    this.wtSettings = wtSettings;\n\n    // legacy support\n    this.instance = this.dataAccessObject.wot; // TODO refactoring: it might be removed here, and provides legacy support through facade.\n    this.wot = this.dataAccessObject.wot;\n    this.TABLE = domBindings.rootTable;\n    removeTextNodes(this.TABLE);\n\n    // TODO refactoring, to recognize the legitimacy of moving them into domBidings\n    this.spreader = this.createSpreader(this.TABLE);\n    this.hider = this.createHider(this.spreader);\n    this.holder = this.createHolder(this.hider);\n    this.wtRootElement = this.holder.parentNode;\n    if (this.isMaster) {\n      this.alignOverlaysWithTrimmingContainer(); // todo wow, It calls method from child class (MasterTable).\n    }\n    this.fixTableDomTree();\n    this.rowFilter = null; // TODO refactoring, eliminate all (re)creations of this object, then updates state when needed.\n    this.columnFilter = null; // TODO refactoring, eliminate all (re)creations of this object, then updates state when needed.\n    this.correctHeaderWidth = false;\n    const origRowHeaderWidth = this.wtSettings.getSettingPure('rowHeaderWidth');\n\n    // Fix for jumping row headers (https://github.com/handsontable/handsontable/issues/3850)\n    this.wtSettings.update('rowHeaderWidth', () => this._modifyRowHeaderWidth(origRowHeaderWidth));\n    this.rowUtils = new RowUtils(this.dataAccessObject, this.wtSettings); // TODO refactoring, It can be passed through IOC.\n    this.columnUtils = new ColumnUtils(this.dataAccessObject, this.wtSettings); // TODO refactoring, It can be passed through IOC.\n\n    this.tableRenderer = new Renderer({\n      // TODO refactoring, It can be passed through IOC.\n      TABLE: this.TABLE,\n      THEAD: this.THEAD,\n      COLGROUP: this.COLGROUP,\n      TBODY: this.TBODY,\n      rowUtils: this.rowUtils,\n      columnUtils: this.columnUtils,\n      cellRenderer: this.wtSettings.getSettingPure('cellRenderer')\n    });\n  }\n\n  /**\n   * Returns a boolean that is true if this Table represents a specific overlay, identified by the overlay name.\n   * For MasterTable, it returns false.\n   *\n   * @param {string} overlayTypeName The overlay type.\n   * @returns {boolean}\n   */\n  is(overlayTypeName) {\n    // todo refactoring: eliminate all protected and private usages\n    return this.name === overlayTypeName;\n  }\n\n  /**\n   *\n   */\n  fixTableDomTree() {\n    const rootDocument = this.domBindings.rootDocument;\n    this.TBODY = this.TABLE.querySelector('tbody');\n    if (!this.TBODY) {\n      this.TBODY = rootDocument.createElement('tbody');\n      this.TABLE.appendChild(this.TBODY);\n    }\n    this.THEAD = this.TABLE.querySelector('thead');\n    if (!this.THEAD) {\n      this.THEAD = rootDocument.createElement('thead');\n      this.TABLE.insertBefore(this.THEAD, this.TBODY);\n    }\n    this.COLGROUP = this.TABLE.querySelector('colgroup');\n    if (!this.COLGROUP) {\n      this.COLGROUP = rootDocument.createElement('colgroup');\n      this.TABLE.insertBefore(this.COLGROUP, this.THEAD);\n    }\n  }\n\n  /**\n   * @param {HTMLTableElement} table An element to process.\n   * @returns {HTMLElement}\n   */\n  createSpreader(table) {\n    const parent = table.parentNode;\n    let spreader;\n    if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !hasClass(parent, 'wtHolder')) {\n      spreader = this.domBindings.rootDocument.createElement('div');\n      spreader.className = 'wtSpreader';\n      if (parent) {\n        // if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it\n        parent.insertBefore(spreader, table);\n      }\n      spreader.appendChild(table);\n    }\n    spreader.style.position = 'relative';\n    if (this.wtSettings.getSetting('ariaTags')) {\n      setAttribute(spreader, [A11Y_PRESENTATION()]);\n    }\n    return spreader;\n  }\n\n  /**\n   * @param {HTMLElement} spreader An element to the hider element is injected.\n   * @returns {HTMLElement}\n   */\n  createHider(spreader) {\n    const parent = spreader.parentNode;\n    let hider;\n    if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !hasClass(parent, 'wtHolder')) {\n      hider = this.domBindings.rootDocument.createElement('div');\n      hider.className = 'wtHider';\n      if (parent) {\n        // if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it\n        parent.insertBefore(hider, spreader);\n      }\n      hider.appendChild(spreader);\n    }\n    if (this.wtSettings.getSetting('ariaTags')) {\n      setAttribute(hider, [A11Y_PRESENTATION()]);\n    }\n    return hider;\n  }\n\n  /**\n   *\n   * @param {HTMLElement} hider An element to the holder element is injected.\n   * @returns {HTMLElement}\n   */\n  createHolder(hider) {\n    const parent = hider.parentNode;\n    let holder;\n    if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !hasClass(parent, 'wtHolder')) {\n      holder = this.domBindings.rootDocument.createElement('div');\n      holder.style.position = 'relative';\n      holder.className = 'wtHolder';\n      if (parent) {\n        // if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it\n        parent.insertBefore(holder, hider);\n      }\n      if (this.isMaster) {\n        holder.parentNode.className += 'ht_master handsontable';\n        holder.parentNode.setAttribute('dir', this.wtSettings.getSettingPure('rtlMode') ? 'rtl' : 'ltr');\n        if (this.wtSettings.getSetting('ariaTags')) {\n          setAttribute(holder.parentNode, [A11Y_PRESENTATION()]);\n        }\n      }\n      holder.appendChild(hider);\n    }\n    if (this.wtSettings.getSetting('ariaTags')) {\n      setAttribute(holder, [A11Y_PRESENTATION()]);\n    }\n    return holder;\n  }\n\n  /**\n   * Redraws the table.\n   *\n   * @param {boolean} [fastDraw=false] If TRUE, will try to avoid full redraw and only update the border positions.\n   *                                   If FALSE or UNDEFINED, will perform a full redraw.\n   * @returns {Table}\n   */\n  draw() {\n    let fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const {\n      wtSettings\n    } = this;\n    const {\n      wtOverlays,\n      wtViewport\n    } = this.dataAccessObject;\n    const totalRows = wtSettings.getSetting('totalRows');\n    const totalColumns = wtSettings.getSetting('totalColumns');\n    const rowHeaders = wtSettings.getSetting('rowHeaders');\n    const rowHeadersCount = rowHeaders.length;\n    const columnHeaders = wtSettings.getSetting('columnHeaders');\n    const columnHeadersCount = columnHeaders.length;\n    let runFastDraw = fastDraw;\n    if (this.isMaster) {\n      wtOverlays.beforeDraw();\n      this.holderOffset = offset(this.holder);\n      runFastDraw = wtViewport.createCalculators(runFastDraw);\n      if (rowHeadersCount && !wtSettings.getSetting('fixedColumnsStart')) {\n        const leftScrollPos = wtOverlays.inlineStartOverlay.getScrollPosition();\n        const previousState = this.correctHeaderWidth;\n        this.correctHeaderWidth = leftScrollPos !== 0;\n        if (previousState !== this.correctHeaderWidth) {\n          runFastDraw = false;\n        }\n      }\n    }\n    if (runFastDraw) {\n      if (this.isMaster) {\n        wtOverlays.refresh(true);\n      }\n    } else {\n      if (this.isMaster) {\n        this.tableOffset = offset(this.TABLE);\n      } else {\n        this.tableOffset = this.dataAccessObject.parentTableOffset;\n      }\n      const startRow = totalRows > 0 ? this.getFirstRenderedRow() : 0;\n      const startColumn = totalColumns > 0 ? this.getFirstRenderedColumn() : 0;\n      this.rowFilter = new RowFilter(startRow, totalRows, columnHeadersCount);\n      this.columnFilter = new ColumnFilter(startColumn, totalColumns, rowHeadersCount);\n      let performRedraw = true;\n\n      // Only master table rendering can be skipped\n      if (this.isMaster) {\n        this.alignOverlaysWithTrimmingContainer(); // todo It calls method from child class (MasterTable).\n        const skipRender = {};\n        this.wtSettings.getSetting('beforeDraw', true, skipRender);\n        performRedraw = skipRender.skipRender !== true;\n      }\n      if (performRedraw) {\n        this.tableRenderer.setHeaderContentRenderers(rowHeaders, columnHeaders);\n        if (this.is(CLONE_BOTTOM) || this.is(CLONE_BOTTOM_INLINE_START_CORNER)) {\n          // do NOT render headers on the bottom or bottom-left corner overlay\n          this.tableRenderer.setHeaderContentRenderers(rowHeaders, []);\n        }\n        this.resetOversizedRows();\n        this.tableRenderer.setActiveOverlayName(this.name).setViewportSize(this.getRenderedRowsCount(), this.getRenderedColumnsCount()).setFilters(this.rowFilter, this.columnFilter).render();\n        let workspaceWidth;\n        if (this.isMaster) {\n          workspaceWidth = this.dataAccessObject.workspaceWidth;\n          wtViewport.containerWidth = null;\n          this.markOversizedColumnHeaders();\n        }\n        this.adjustColumnHeaderHeights();\n        if (this.isMaster || this.is(CLONE_BOTTOM)) {\n          this.markOversizedRows();\n        }\n        if (this.isMaster) {\n          if (!this.wtSettings.getSetting('externalRowCalculator')) {\n            wtViewport.createVisibleCalculators();\n          }\n          wtOverlays.refresh(false);\n          wtOverlays.applyToDOM();\n          const hiderWidth = outerWidth(this.hider);\n          const tableWidth = outerWidth(this.TABLE);\n          if (hiderWidth !== 0 && tableWidth !== hiderWidth) {\n            // Recalculate the column widths, if width changes made in the overlays removed the scrollbar, thus changing the viewport width.\n            this.columnUtils.calculateWidths();\n            this.tableRenderer.renderer.colGroup.render();\n          }\n          if (workspaceWidth !== wtViewport.getWorkspaceWidth()) {\n            // workspace width changed though to shown/hidden vertical scrollbar. Let's reapply stretching\n            wtViewport.containerWidth = null;\n            this.columnUtils.calculateWidths();\n            this.tableRenderer.renderer.colGroup.render();\n          }\n          this.wtSettings.getSetting('onDraw', true);\n        } else if (this.is(CLONE_BOTTOM)) {\n          this.dataAccessObject.cloneSource.wtOverlays.adjustElementsSize();\n        }\n      }\n    }\n    let positionChanged = false;\n    if (this.isMaster) {\n      positionChanged = wtOverlays.topOverlay.resetFixedPosition();\n      if (wtOverlays.bottomOverlay.clone) {\n        positionChanged = wtOverlays.bottomOverlay.resetFixedPosition() || positionChanged;\n      }\n      positionChanged = wtOverlays.inlineStartOverlay.resetFixedPosition() || positionChanged;\n      if (wtOverlays.topInlineStartCornerOverlay) {\n        wtOverlays.topInlineStartCornerOverlay.resetFixedPosition();\n      }\n      if (wtOverlays.bottomInlineStartCornerOverlay && wtOverlays.bottomInlineStartCornerOverlay.clone) {\n        wtOverlays.bottomInlineStartCornerOverlay.resetFixedPosition();\n      }\n    }\n    if (positionChanged) {\n      // It refreshes the cells borders caused by a 1px shift (introduced by overlays which add or\n      // remove `innerBorderTop` and `innerBorderInlineStart` CSS classes to the DOM element. This happens\n      // when there is a switch between rendering from 0 to N rows/columns and vice versa).\n      wtOverlays.refreshAll(); // `refreshAll()` internally already calls `refreshSelections()` method\n      wtOverlays.adjustElementsSize();\n    } else {\n      this.dataAccessObject.selectionManager.setActiveOverlay(this.facadeGetter()).render(runFastDraw);\n    }\n    if (this.isMaster) {\n      wtOverlays.afterDraw();\n    }\n    this.dataAccessObject.drawn = true;\n    return this;\n  }\n\n  /**\n   * @param {number} col The visual column index.\n   */\n  markIfOversizedColumnHeader(col) {\n    const sourceColIndex = this.columnFilter.renderedToSource(col);\n    let level = this.wtSettings.getSetting('columnHeaders').length;\n    const defaultRowHeight = this.wtSettings.getSetting('defaultRowHeight');\n    let previousColHeaderHeight;\n    let currentHeader;\n    let currentHeaderHeight;\n    const columnHeaderHeightSetting = this.wtSettings.getSetting('columnHeaderHeight') || [];\n    while (level) {\n      level -= 1;\n      previousColHeaderHeight = this.getColumnHeaderHeight(level);\n      currentHeader = this.getColumnHeader(sourceColIndex, level);\n      if (!currentHeader) {\n        /* eslint-disable no-continue */\n        continue;\n      }\n      currentHeaderHeight = innerHeight(currentHeader);\n      if (!previousColHeaderHeight && defaultRowHeight < currentHeaderHeight || previousColHeaderHeight < currentHeaderHeight) {\n        this.dataAccessObject.wtViewport.oversizedColumnHeaders[level] = currentHeaderHeight;\n      }\n      if (Array.isArray(columnHeaderHeightSetting)) {\n        if (columnHeaderHeightSetting[level] !== null && columnHeaderHeightSetting[level] !== undefined) {\n          this.dataAccessObject.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting[level];\n        }\n      } else if (!isNaN(columnHeaderHeightSetting)) {\n        this.dataAccessObject.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting;\n      }\n      if (this.dataAccessObject.wtViewport.oversizedColumnHeaders[level] < (columnHeaderHeightSetting[level] || columnHeaderHeightSetting)) {\n        this.dataAccessObject.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting[level] || columnHeaderHeightSetting; // eslint-disable-line max-len\n      }\n    }\n  }\n\n  /**\n   *\n   */\n  adjustColumnHeaderHeights() {\n    const {\n      wtSettings\n    } = this;\n    const children = this.THEAD.childNodes;\n    const oversizedColumnHeaders = this.dataAccessObject.wtViewport.oversizedColumnHeaders;\n    const columnHeaders = wtSettings.getSetting('columnHeaders');\n    for (let i = 0, len = columnHeaders.length; i < len; i++) {\n      if (oversizedColumnHeaders[i]) {\n        if (!children[i] || children[i].childNodes.length === 0) {\n          return;\n        }\n        children[i].childNodes[0].style.height = `${oversizedColumnHeaders[i]}px`;\n      }\n    }\n  }\n\n  /**\n   * Resets cache of row heights. The cache should be cached for each render cycle in a case\n   * when new cell values have content which increases/decreases cell height.\n   */\n  resetOversizedRows() {\n    const {\n      wtSettings\n    } = this;\n    const {\n      wtViewport\n    } = this.dataAccessObject;\n    if (!this.isMaster && !this.is(CLONE_BOTTOM)) {\n      return;\n    }\n    if (!wtSettings.getSetting('externalRowCalculator')) {\n      const rowsToRender = this.getRenderedRowsCount();\n\n      // Reset the oversized row cache for rendered rows\n      for (let visibleRowIndex = 0; visibleRowIndex < rowsToRender; visibleRowIndex++) {\n        const sourceRow = this.rowFilter.renderedToSource(visibleRowIndex);\n        if (wtViewport.oversizedRows && wtViewport.oversizedRows[sourceRow]) {\n          wtViewport.oversizedRows[sourceRow] = undefined;\n        }\n      }\n    }\n  }\n\n  /**\n   * Get cell element at coords.\n   * Negative coords.row or coords.col are used to retrieve header cells. If there are multiple header levels, the\n   * negative value corresponds to the distance from the working area. For example, when there are 3 levels of column\n   * headers, coords.col=-1 corresponds to the most inner header element, while coords.col=-3 corresponds to the\n   * outmost header element.\n   *\n   * In case an element for the coords is not rendered, the method returns an error code.\n   * To produce the error code, the input parameters are validated in the order in which they\n   * are given. Thus, if both the row and the column coords are out of the rendered bounds,\n   * the method returns the error code for the row.\n   *\n   * @param {CellCoords} coords The cell coordinates.\n   * @returns {HTMLElement|number} HTMLElement on success or Number one of the exit codes on error:\n   *  -1 row before viewport\n   *  -2 row after viewport\n   *  -3 column before viewport\n   *  -4 column after viewport.\n   */\n  getCell(coords) {\n    let row = coords.row;\n    let column = coords.col;\n    const hookResult = this.wtSettings.getSetting('onModifyGetCellCoords', row, column);\n    if (hookResult && Array.isArray(hookResult)) {\n      [row, column] = hookResult;\n    }\n    if (this.isRowBeforeRenderedRows(row)) {\n      // row before rendered rows\n      return -1;\n    } else if (this.isRowAfterRenderedRows(row)) {\n      // row after rendered rows\n      return -2;\n    } else if (this.isColumnBeforeRenderedColumns(column)) {\n      // column before rendered columns\n      return -3;\n    } else if (this.isColumnAfterRenderedColumns(column)) {\n      // column after rendered columns\n      return -4;\n    }\n    const TR = this.getRow(row);\n    if (!TR && row >= 0) {\n      throw new Error('TR was expected to be rendered but is not');\n    }\n    const TD = TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(column)];\n    if (!TD && column >= 0) {\n      throw new Error('TD or TH was expected to be rendered but is not');\n    }\n    return TD;\n  }\n\n  /**\n   * Get the DOM element of the row with the provided index.\n   *\n   * @param {number} rowIndex Row index.\n   * @returns {HTMLTableRowElement|boolean} Return the row's DOM element or `false` if the row with the provided\n   * index doesn't exist.\n   */\n  getRow(rowIndex) {\n    let renderedRowIndex = null;\n    let parentElement = null;\n    if (rowIndex < 0) {\n      var _this$rowFilter;\n      renderedRowIndex = (_this$rowFilter = this.rowFilter) === null || _this$rowFilter === void 0 ? void 0 : _this$rowFilter.sourceRowToVisibleColHeadedRow(rowIndex);\n      parentElement = this.THEAD;\n    } else {\n      var _this$rowFilter2;\n      renderedRowIndex = (_this$rowFilter2 = this.rowFilter) === null || _this$rowFilter2 === void 0 ? void 0 : _this$rowFilter2.sourceToRendered(rowIndex);\n      parentElement = this.TBODY;\n    }\n    if (renderedRowIndex !== undefined && parentElement !== undefined) {\n      if (parentElement.childNodes.length < renderedRowIndex + 1) {\n        return false;\n      } else {\n        return parentElement.childNodes[renderedRowIndex];\n      }\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * GetColumnHeader.\n   *\n   * @param {number} col Column index.\n   * @param {number} [level=0] Header level (0 = most distant to the table).\n   * @returns {object} HTMLElement on success or undefined on error.\n   */\n  getColumnHeader(col) {\n    let level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const TR = this.THEAD.childNodes[level];\n    return TR === null || TR === void 0 ? void 0 : TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(col)];\n  }\n\n  /**\n   * Gets all columns headers (TH elements) from the table.\n   *\n   * @param {number} column A source column index.\n   * @returns {HTMLTableCellElement[]}\n   */\n  getColumnHeaders(column) {\n    const THs = [];\n    const visibleColumn = this.columnFilter.sourceColumnToVisibleRowHeadedColumn(column);\n    this.THEAD.childNodes.forEach(TR => {\n      const TH = TR.childNodes[visibleColumn];\n      if (TH) {\n        THs.push(TH);\n      }\n    });\n    return THs;\n  }\n\n  /**\n   * GetRowHeader.\n   *\n   * @param {number} row Row index.\n   * @param {number} [level=0] Header level (0 = most distant to the table).\n   * @returns {HTMLElement} HTMLElement on success or Number one of the exit codes on error: `null table doesn't have\n   *   row headers`.\n   */\n  getRowHeader(row) {\n    let level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const rowHeadersCount = this.wtSettings.getSetting('rowHeaders').length;\n    if (level >= rowHeadersCount) {\n      return;\n    }\n    const renderedRow = this.rowFilter.sourceToRendered(row);\n    const visibleRow = renderedRow < 0 ? this.rowFilter.sourceRowToVisibleColHeadedRow(row) : renderedRow;\n    const parentElement = renderedRow < 0 ? this.THEAD : this.TBODY;\n    const TR = parentElement.childNodes[visibleRow];\n    return TR === null || TR === void 0 ? void 0 : TR.childNodes[level];\n  }\n\n  /**\n   * Gets all rows headers (TH elements) from the table.\n   *\n   * @param {number} row A source row index.\n   * @returns {HTMLTableCellElement[]}\n   */\n  getRowHeaders(row) {\n    const THs = [];\n    const rowHeadersCount = this.wtSettings.getSetting('rowHeaders').length;\n    for (let renderedRowIndex = 0; renderedRowIndex < rowHeadersCount; renderedRowIndex++) {\n      const TR = this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];\n      const TH = TR === null || TR === void 0 ? void 0 : TR.childNodes[renderedRowIndex];\n      if (TH) {\n        THs.push(TH);\n      }\n    }\n    return THs;\n  }\n\n  /**\n   * Returns cell coords object for a given TD (or a child element of a TD element).\n   *\n   * @param {HTMLTableCellElement} TD A cell DOM element (or a child of one).\n   * @returns {CellCoords|null} The coordinates of the provided TD element (or the closest TD element) or null, if the\n   *   provided element is not applicable.\n   */\n  getCoords(TD) {\n    let cellElement = TD;\n    if (cellElement.nodeName !== 'TD' && cellElement.nodeName !== 'TH') {\n      cellElement = closest(cellElement, ['TD', 'TH']);\n    }\n    if (cellElement === null) {\n      return null;\n    }\n    const TR = cellElement.parentNode;\n    const CONTAINER = TR.parentNode;\n    let row = index(TR);\n    let col = cellElement.cellIndex;\n    if (overlayContainsElement(CLONE_TOP_INLINE_START_CORNER, cellElement, this.wtRootElement) || overlayContainsElement(CLONE_TOP, cellElement, this.wtRootElement)) {\n      if (CONTAINER.nodeName === 'THEAD') {\n        row -= CONTAINER.childNodes.length;\n      }\n    } else if (overlayContainsElement(CLONE_BOTTOM_INLINE_START_CORNER, cellElement, this.wtRootElement) || overlayContainsElement(CLONE_BOTTOM, cellElement, this.wtRootElement)) {\n      const totalRows = this.wtSettings.getSetting('totalRows');\n      row = totalRows - CONTAINER.childNodes.length + row;\n    } else if (CONTAINER === this.THEAD) {\n      row = this.rowFilter.visibleColHeadedRowToSourceRow(row);\n    } else {\n      row = this.rowFilter.renderedToSource(row);\n    }\n    if (overlayContainsElement(CLONE_TOP_INLINE_START_CORNER, cellElement, this.wtRootElement) || overlayContainsElement(CLONE_INLINE_START, cellElement, this.wtRootElement) || overlayContainsElement(CLONE_BOTTOM_INLINE_START_CORNER, cellElement, this.wtRootElement)) {\n      col = this.columnFilter.offsettedTH(col);\n    } else {\n      col = this.columnFilter.visibleRowHeadedColumnToSourceColumn(col);\n    }\n    return this.wot.createCellCoords(row, col);\n  }\n\n  /**\n   * Check if any of the rendered rows is higher than expected, and if so, cache them.\n   */\n  markOversizedRows() {\n    if (this.wtSettings.getSetting('externalRowCalculator')) {\n      return;\n    }\n    let rowCount = this.TBODY.childNodes.length;\n    const expectedTableHeight = rowCount * this.wtSettings.getSetting('defaultRowHeight');\n    const actualTableHeight = innerHeight(this.TBODY) - 1;\n    let previousRowHeight;\n    let rowInnerHeight;\n    let sourceRowIndex;\n    let currentTr;\n    let rowHeader;\n    if (expectedTableHeight === actualTableHeight && !this.wtSettings.getSetting('fixedRowsBottom')) {\n      // If the actual table height equals rowCount * default single row height, no row is oversized -> no need to iterate over them\n      return;\n    }\n    while (rowCount) {\n      rowCount -= 1;\n      sourceRowIndex = this.rowFilter.renderedToSource(rowCount);\n      previousRowHeight = this.getRowHeight(sourceRowIndex);\n      currentTr = this.getTrForRow(sourceRowIndex);\n      rowHeader = currentTr.querySelector('th');\n      if (rowHeader) {\n        rowInnerHeight = innerHeight(rowHeader);\n      } else {\n        rowInnerHeight = innerHeight(currentTr) - 1;\n      }\n      if (!previousRowHeight && this.wtSettings.getSetting('defaultRowHeight') < rowInnerHeight || previousRowHeight < rowInnerHeight) {\n        rowInnerHeight += 1;\n        this.dataAccessObject.wtViewport.oversizedRows[sourceRowIndex] = rowInnerHeight;\n      }\n    }\n  }\n\n  /**\n   * @param {number} row The visual row index.\n   * @returns {HTMLTableElement}\n   */\n  getTrForRow(row) {\n    return this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];\n  }\n\n  /**\n   * Checks if the column index (negative value from -1 to N) is rendered.\n   *\n   * @param {number} column The column index (negative value from -1 to N).\n   * @returns {boolean}\n   */\n  isColumnHeaderRendered(column) {\n    if (column >= 0) {\n      return false;\n    }\n    const rowHeaders = this.wtSettings.getSetting('rowHeaders');\n    const rowHeadersCount = rowHeaders.length;\n    return Math.abs(column) <= rowHeadersCount;\n  }\n\n  /**\n   * Checks if the row index (negative value from -1 to N) is rendered.\n   *\n   * @param {number} row The row index (negative value from -1 to N).\n   * @returns {boolean}\n   */\n  isRowHeaderRendered(row) {\n    if (row >= 0) {\n      return false;\n    }\n    const columnHeaders = this.wtSettings.getSetting('columnHeaders');\n    const columnHeadersCount = columnHeaders.length;\n    return Math.abs(row) <= columnHeadersCount;\n  }\n\n  /* eslint-disable jsdoc/require-description-complete-sentence */\n  /**\n   * Check if the given row index is lower than the index of the first row that\n   * is currently rendered and return TRUE in that case, or FALSE otherwise.\n   *\n   * Negative row index is used to check the columns' headers.\n   *\n   *  Headers\n   *           +--------------+                                     │\n   *       -3  │    │    │    │                                     │\n   *           +--------------+                                     │\n   *       -2  │    │    │    │                                     │ TRUE\n   *           +--------------+                                     │\n   *       -1  │    │    │    │                                     │\n   *  Cells  +==================+                                   │\n   *        0  ┇    ┇    ┇    ┇ <--- For fixedRowsTop: 1            │\n   *           +--------------+      the master overlay do       ---+ first rendered row (index 1)\n   *        1  │ A2 │ B2 │ C2 │      not render the first row.      │\n   *           +--------------+                                     │ FALSE\n   *        2  │ A3 │ B3 │ C3 │                                     │\n   *           +--------------+                                  ---+ last rendered row\n   *                                                                │\n   *                                                                │ FALSE\n   *\n   * @param {number} row The visual row index.\n   * @memberof Table#\n   * @function isRowBeforeRenderedRows\n   * @returns {boolean}\n   */\n  /* eslint-enable jsdoc/require-description-complete-sentence */\n  isRowBeforeRenderedRows(row) {\n    const first = this.getFirstRenderedRow();\n\n    // Check the headers only in case when the first rendered row is -1 or 0.\n    // This is an indication that the overlay is placed on the most top position.\n    if (row < 0 && first <= 0) {\n      return !this.isRowHeaderRendered(row);\n    }\n    return row < first;\n  }\n\n  /* eslint-disable jsdoc/require-description-complete-sentence */\n  /**\n   * Check if the given column index is greater than the index of the last column that\n   * is currently rendered and return TRUE in that case, or FALSE otherwise.\n   *\n   * The negative row index is used to check the columns' headers. However,\n   * keep in mind that for negative indexes, the method always returns FALSE as\n   * it is not possible to render headers partially. The \"after\" index can not be\n   * lower than -1.\n   *\n   *  Headers\n   *           +--------------+                                     │\n   *       -3  │    │    │    │                                     │\n   *           +--------------+                                     │\n   *       -2  │    │    │    │                                     │ FALSE\n   *           +--------------+                                     │\n   *       -1  │    │    │    │                                     │\n   *  Cells  +==================+                                   │\n   *        0  ┇    ┇    ┇    ┇ <--- For fixedRowsTop: 1            │\n   *           +--------------+      the master overlay do       ---+ first rendered row (index 1)\n   *        1  │ A2 │ B2 │ C2 │      not render the first rows      │\n   *           +--------------+                                     │ FALSE\n   *        2  │ A3 │ B3 │ C3 │                                     │\n   *           +--------------+                                  ---+ last rendered row\n   *                                                                │\n   *                                                                │ TRUE\n   *\n   * @param {number} row The visual row index.\n   * @memberof Table#\n   * @function isRowAfterRenderedRows\n   * @returns {boolean}\n   */\n  /* eslint-enable jsdoc/require-description-complete-sentence */\n  isRowAfterRenderedRows(row) {\n    return row > this.getLastRenderedRow();\n  }\n\n  /* eslint-disable jsdoc/require-description-complete-sentence */\n  /**\n   * Check if the given column index is lower than the index of the first column that\n   * is currently rendered and return TRUE in that case, or FALSE otherwise.\n   *\n   * Negative column index is used to check the rows' headers.\n   *\n   *                            For fixedColumnsStart: 1 the master overlay\n   *                            do not render this first columns.\n   *  Headers    -3   -2   -1    |\n   *           +----+----+----║┄ ┄ +------+------+\n   *           │    │    │    ║    │  B1  │  C1  │\n   *           +--------------║┄ ┄ --------------│\n   *           │    │    │    ║    │  B2  │  C2  │\n   *           +--------------║┄ ┄ --------------│\n   *           │    │    │    ║    │  B3  │  C3  │\n   *           +----+----+----║┄ ┄ +------+------+\n   *                               ╷             ╷\n   *      -------------------------+-------------+---------------->\n   *          TRUE             first    FALSE   last         FALSE\n   *                           rendered         rendered\n   *                           column           column\n   *\n   * @param {number} column The visual column index.\n   * @memberof Table#\n   * @function isColumnBeforeRenderedColumns\n   * @returns {boolean}\n   */\n  /* eslint-enable jsdoc/require-description-complete-sentence */\n  isColumnBeforeRenderedColumns(column) {\n    const first = this.getFirstRenderedColumn();\n\n    // Check the headers only in case when the first rendered column is -1 or 0.\n    // This is an indication that the overlay is placed on the most left position.\n    if (column < 0 && first <= 0) {\n      return !this.isColumnHeaderRendered(column);\n    }\n    return column < first;\n  }\n\n  /* eslint-disable jsdoc/require-description-complete-sentence */\n  /**\n   * Check if the given column index is greater than the index of the last column that\n   * is currently rendered and return TRUE in that case, or FALSE otherwise.\n   *\n   * The negative column index is used to check the rows' headers. However,\n   * keep in mind that for negative indexes, the method always returns FALSE as\n   * it is not possible to render headers partially. The \"after\" index can not be\n   * lower than -1.\n   *\n   *                            For fixedColumnsStart: 1 the master overlay\n   *                            do not render this first columns.\n   *  Headers    -3   -2   -1    |\n   *           +----+----+----║┄ ┄ +------+------+\n   *           │    │    │    ║    │  B1  │  C1  │\n   *           +--------------║┄ ┄ --------------│\n   *           │    │    │    ║    │  B2  │  C2  │\n   *           +--------------║┄ ┄ --------------│\n   *           │    │    │    ║    │  B3  │  C3  │\n   *           +----+----+----║┄ ┄ +------+------+\n   *                               ╷             ╷\n   *      -------------------------+-------------+---------------->\n   *          FALSE             first    FALSE   last         TRUE\n   *                           rendered         rendered\n   *                           column           column\n   *\n   * @param {number} column The visual column index.\n   * @memberof Table#\n   * @function isColumnAfterRenderedColumns\n   * @returns {boolean}\n   */\n  /* eslint-enable jsdoc/require-description-complete-sentence */\n  isColumnAfterRenderedColumns(column) {\n    return this.columnFilter && column > this.getLastRenderedColumn();\n  }\n  isColumnAfterViewport(column) {\n    return this.columnFilter && column > this.getLastVisibleColumn();\n  }\n  isRowAfterViewport(row) {\n    return this.rowFilter && row > this.getLastVisibleRow();\n  }\n  isColumnBeforeViewport(column) {\n    return this.columnFilter && this.columnFilter.sourceToRendered(column) < 0 && column >= 0;\n  }\n  isLastRowFullyVisible() {\n    return this.getLastVisibleRow() === this.getLastRenderedRow();\n  }\n  isLastColumnFullyVisible() {\n    return this.getLastVisibleColumn() === this.getLastRenderedColumn();\n  }\n  allRowsInViewport() {\n    return this.wtSettings.getSetting('totalRows') === this.getVisibleRowsCount();\n  }\n  allColumnsInViewport() {\n    return this.wtSettings.getSetting('totalColumns') === this.getVisibleColumnsCount();\n  }\n\n  /**\n   * Checks if any of the row's cells content exceeds its initial height, and if so, returns the oversized height.\n   *\n   * @param {number} sourceRow The physical row index.\n   * @returns {number}\n   */\n  getRowHeight(sourceRow) {\n    return this.rowUtils.getHeight(sourceRow);\n  }\n\n  /**\n   * @param {number} level The column level.\n   * @returns {number}\n   */\n  getColumnHeaderHeight(level) {\n    return this.columnUtils.getHeaderHeight(level);\n  }\n\n  /**\n   * @param {number} sourceColumn The physical column index.\n   * @returns {number}\n   */\n  getColumnWidth(sourceColumn) {\n    return this.columnUtils.getWidth(sourceColumn);\n  }\n\n  /**\n   * @param {number} sourceColumn The physical column index.\n   * @returns {number}\n   */\n  getStretchedColumnWidth(sourceColumn) {\n    return this.columnUtils.getStretchedColumnWidth(sourceColumn);\n  }\n\n  /**\n   * Checks if the table has defined size. It returns `true` when the table has width and height\n   * set bigger than `0px`.\n   *\n   * @returns {boolean}\n   */\n  hasDefinedSize() {\n    return this.hasTableHeight && this.hasTableWidth;\n  }\n\n  /**\n   * Gets table's width. The returned width is the width of the rendered cells that fit in the\n   * current viewport. The value may change depends on the viewport position (scroll position).\n   *\n   * @returns {number}\n   */\n  getWidth() {\n    return outerWidth(this.TABLE);\n  }\n\n  /**\n   * Gets table's height. The returned height is the height of the rendered cells that fit in the\n   * current viewport. The value may change depends on the viewport position (scroll position).\n   *\n   * @returns {number}\n   */\n  getHeight() {\n    return outerHeight(this.TABLE);\n  }\n\n  /**\n   * Gets table's total width. The returned width is the width of all rendered cells (including headers)\n   * that can be displayed in the table.\n   *\n   * @returns {number}\n   */\n  getTotalWidth() {\n    const width = outerWidth(this.hider);\n\n    // when the overlay's table does not have any cells the hider returns 0, get then width from the table element\n    return width !== 0 ? width : this.getWidth();\n  }\n\n  /**\n   * Gets table's total height. The returned height is the height of all rendered cells (including headers)\n   * that can be displayed in the table.\n   *\n   * @returns {number}\n   */\n  getTotalHeight() {\n    const height = outerHeight(this.hider);\n\n    // when the overlay's table does not have any cells the hider returns 0, get then height from the table element\n    return height !== 0 ? height : this.getHeight();\n  }\n\n  /**\n   * Checks if the table is visible. It returns `true` when the holder element (or its parents)\n   * has CSS 'display' property different than 'none'.\n   *\n   * @returns {boolean}\n   */\n  isVisible() {\n    return isVisible(this.TABLE);\n  }\n\n  /**\n   * Modify row header widths provided by user in class contructor.\n   *\n   * @private\n   * @param {Function} rowHeaderWidthFactory The function which can provide default width values for rows..\n   * @returns {number}\n   */\n  _modifyRowHeaderWidth(rowHeaderWidthFactory) {\n    let widths = isFunction(rowHeaderWidthFactory) ? rowHeaderWidthFactory() : null;\n    if (Array.isArray(widths)) {\n      widths = [...widths];\n      widths[widths.length - 1] = this._correctRowHeaderWidth(widths[widths.length - 1]);\n    } else {\n      widths = this._correctRowHeaderWidth(widths);\n    }\n    return widths;\n  }\n\n  /**\n   * Correct row header width if necessary.\n   *\n   * @private\n   * @param {number} width The width to process.\n   * @returns {number}\n   */\n  _correctRowHeaderWidth(width) {\n    let rowHeaderWidth = width;\n    if (typeof width !== 'number') {\n      rowHeaderWidth = this.wtSettings.getSetting('defaultColumnWidth');\n    }\n    if (this.correctHeaderWidth) {\n      rowHeaderWidth += 1;\n    }\n    return rowHeaderWidth;\n  }\n}\nexport default Table;"],"mappings":"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,CAACC,GAAG,CAACpD,GAAG,CAAC,IAAIhF,kBAAkB;IAC5C;;IAEA;IACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACE;EAAA;IAAA9B,GAAA;IAAAzE,KAAA,EACA,SAAA4L,uBAAuBA,CAACL,GAAG,EAAE;MAC3B,IAAMsD,KAAK,GAAG,IAAI,CAACzH,mBAAmB,CAAC,CAAC;;MAExC;MACA;MACA,IAAImE,GAAG,GAAG,CAAC,IAAIsD,KAAK,IAAI,CAAC,EAAE;QACzB,OAAO,CAAC,IAAI,CAACD,mBAAmB,CAACrD,GAAG,CAAC;MACvC;MACA,OAAOA,GAAG,GAAGsD,KAAK;IACpB;;IAEA;IACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACE;EAAA;IAAApK,GAAA;IAAAzE,KAAA,EACA,SAAA6L,sBAAsBA,CAACN,GAAG,EAAE;MAC1B,OAAOA,GAAG,GAAG,IAAI,CAACuD,kBAAkB,CAAC,CAAC;IACxC;;IAEA;IACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACE;EAAA;IAAArK,GAAA;IAAAzE,KAAA,EACA,SAAA8L,6BAA6BA,CAACN,MAAM,EAAE;MACpC,IAAMqD,KAAK,GAAG,IAAI,CAACvH,sBAAsB,CAAC,CAAC;;MAE3C;MACA;MACA,IAAIkE,MAAM,GAAG,CAAC,IAAIqD,KAAK,IAAI,CAAC,EAAE;QAC5B,OAAO,CAAC,IAAI,CAACJ,sBAAsB,CAACjD,MAAM,CAAC;MAC7C;MACA,OAAOA,MAAM,GAAGqD,KAAK;IACvB;;IAEA;IACA;AACF;AA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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}