{"ast":null,"code":"import _objectSpread from \"/Users/priyadeliwala/Desktop/sales-dashboard/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _slicedToArray from \"/Users/priyadeliwala/Desktop/sales-dashboard/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"/Users/priyadeliwala/Desktop/sales-dashboard/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/priyadeliwala/Desktop/sales-dashboard/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nfunction _classPrivateFieldInitSpec(e, t, a) {\n  _checkPrivateRedeclaration(e, t), t.set(e, a);\n}\nfunction _checkPrivateRedeclaration(e, t) {\n  if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n}\nfunction _classPrivateFieldGet(s, a) {\n  return s.get(_assertClassBrand(s, a));\n}\nfunction _classPrivateFieldSet(s, a, r) {\n  return s.set(_assertClassBrand(s, a), r), r;\n}\nfunction _assertClassBrand(e, t, n) {\n  if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;\n  throw new TypeError(\"Private element is not present on this object\");\n}\nimport { arrayEach } from \"../../../helpers/array.mjs\";\nimport TreeNode from \"../../../utils/dataStructures/tree.mjs\";\n/* eslint-disable jsdoc/require-description-complete-sentence */\n/**\n * @private\n * @class HeadersTree\n *\n * The header tree class keeps nested header settings in the tree\n * structure for easier node manipulation (e.q collapse or expand column).\n * That trees represent the current state of the nested headers. From the\n * trees, the matrix is generated for nested header renderers.\n *\n * The second role of the module is validation. While building the tree,\n * there is check whether the configuration contains overlapping\n * headers. If true, then the exception is thrown.\n *\n * The tree is static; it means that its column indexing never changes\n * even when a collapsing header is performed. The structure is based\n * on visual column indexes.\n *\n * For example, for that header configuration:\n *   +----+----+----+----+----+\n *   │ A1                │ A2 │\n *   +----+----+----+----+----+\n *   │ B1           │ B2 │ B3 │\n *   +----+----+----+----+----+\n *   │ C1      │ C2 │ C3 │ C4 │\n *   +----+----+----+----+----+\n *\n * The tree structures look like:\n *                (0)                      (4)           // a visual column index\n *                 │                        │\n *        .------(A1)------.              (A2)--.\n *   .--(B1)--.           (B2)--.              (B3)--.\n *  (C1)     (C2)              (C3)                 (C4)\n *\n */\n/* eslint-enable jsdoc/require-description-complete-sentence */\nvar _rootNodes = /*#__PURE__*/new WeakMap();\nvar _rootsIndex = /*#__PURE__*/new WeakMap();\nvar _sourceSettings = /*#__PURE__*/new WeakMap();\nvar HeadersTree = /*#__PURE__*/function () {\n  function HeadersTree(sourceSettings) {\n    _classCallCheck(this, HeadersTree);\n    /**\n     * The collection of nested headers settings structured into trees. The root trees are stored\n     * under the visual column index.\n     *\n     * @private\n     * @type {Map<number, TreeNode>}\n     */\n    _classPrivateFieldInitSpec(this, _rootNodes, new Map());\n    /**\n     * A map that translates the visual column indexes that intersect the range\n     * defined by the header colspan width to the root index.\n     *\n     * @private\n     * @type {Map<number, number>}\n     */\n    _classPrivateFieldInitSpec(this, _rootsIndex, new Map());\n    /**\n     * The instance of the SourceSettings class.\n     *\n     * @private\n     * @type {SourceSettings}\n     */\n    _classPrivateFieldInitSpec(this, _sourceSettings, null);\n    _classPrivateFieldSet(_sourceSettings, this, sourceSettings);\n  }\n\n  /**\n   * Gets an array of the all root nodes.\n   *\n   * @returns {TreeNode[]}\n   */\n  return _createClass(HeadersTree, [{\n    key: \"getRoots\",\n    value: function getRoots() {\n      return Array.from(_classPrivateFieldGet(_rootNodes, this).values());\n    }\n\n    /**\n     * Gets a root node by specified visual column index.\n     *\n     * @param {number} columnIndex A visual column index.\n     * @returns {TreeNode|undefined}\n     */\n  }, {\n    key: \"getRootByColumn\",\n    value: function getRootByColumn(columnIndex) {\n      var node;\n      if (_classPrivateFieldGet(_rootsIndex, this).has(columnIndex)) {\n        node = _classPrivateFieldGet(_rootNodes, this).get(_classPrivateFieldGet(_rootsIndex, this).get(columnIndex));\n      }\n      return node;\n    }\n\n    /**\n     * Gets a tree node by its position in the grid settings.\n     *\n     * @param {number} headerLevel Header level index (there is support only for positive values).\n     * @param {number} columnIndex A visual column index.\n     * @returns {TreeNode|undefined}\n     */\n  }, {\n    key: \"getNode\",\n    value: function getNode(headerLevel, columnIndex) {\n      var rootNode = this.getRootByColumn(columnIndex);\n      if (!rootNode) {\n        return;\n      }\n\n      // Normalize the visual column index to a 0-based system for a specific \"box\" defined\n      // by root node colspan width.\n      var normColumnIndex = columnIndex - _classPrivateFieldGet(_rootsIndex, this).get(columnIndex);\n      var columnCursor = 0;\n      var treeNode;\n\n      // Collect all parent nodes that depend on the collapsed node.\n      rootNode.walkDown(function (node) {\n        var _node$data = node.data,\n          origColspan = _node$data.origColspan,\n          nodeHeaderLevel = _node$data.headerLevel;\n        if (headerLevel === nodeHeaderLevel) {\n          if (normColumnIndex >= columnCursor && normColumnIndex <= columnCursor + origColspan - 1) {\n            treeNode = node;\n            treeNode.data.isRoot = columnIndex === treeNode.data.columnIndex;\n            return false; // Cancel tree traversing.\n          }\n          columnCursor += origColspan;\n        }\n      });\n      return treeNode;\n    }\n\n    /**\n     * Builds (or rebuilds if called again) root nodes indexes.\n     */\n  }, {\n    key: \"rebuildTreeIndex\",\n    value: function rebuildTreeIndex() {\n      var _this = this;\n      var columnIndex = 0;\n      _classPrivateFieldGet(_rootsIndex, this).clear();\n      arrayEach(_classPrivateFieldGet(_rootNodes, this), function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n          colspan = _ref2[1].data.colspan;\n        // Map tree range (colspan range/width) into visual column index of the root node.\n        for (var i = columnIndex; i < columnIndex + colspan; i++) {\n          _classPrivateFieldGet(_rootsIndex, _this).set(i, columnIndex);\n        }\n        columnIndex += colspan;\n      });\n    }\n\n    /**\n     * Builds trees based on SourceSettings class. Calling a method causes clearing the tree state built\n     * from the previous call.\n     */\n  }, {\n    key: \"buildTree\",\n    value: function buildTree() {\n      this.clear();\n      var columnsCount = _classPrivateFieldGet(_sourceSettings, this).getColumnsCount();\n      var columnIndex = 0;\n      while (columnIndex < columnsCount) {\n        var columnSettings = _classPrivateFieldGet(_sourceSettings, this).getHeaderSettings(0, columnIndex);\n        var rootNode = new TreeNode();\n        _classPrivateFieldGet(_rootNodes, this).set(columnIndex, rootNode);\n        this.buildLeaves(rootNode, columnIndex, 0, columnSettings.origColspan);\n        columnIndex += columnSettings.origColspan;\n      }\n      this.rebuildTreeIndex();\n    }\n\n    /**\n     * Builds leaves for specified tree node.\n     *\n     * @param {TreeNode} parentNode A node to which the leaves applies.\n     * @param {number} columnIndex A visual column index.\n     * @param {number} headerLevel Currently processed header level.\n     * @param {number} [extractionLength=1] Determines column extraction length for node children.\n     */\n  }, {\n    key: \"buildLeaves\",\n    value: function buildLeaves(parentNode, columnIndex, headerLevel) {\n      var _this2 = this;\n      var extractionLength = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n      var columnsSettings = _classPrivateFieldGet(_sourceSettings, this).getHeadersSettings(headerLevel, columnIndex, extractionLength);\n      headerLevel += 1;\n      arrayEach(columnsSettings, function (columnSettings) {\n        var nodeData = _objectSpread(_objectSpread({}, columnSettings), {}, {\n          /**\n           * The header level (tree node depth level).\n           *\n           * @type {number}\n           */\n          headerLevel: headerLevel - 1,\n          /**\n           * A visual column index.\n           *\n           * @type {number}\n           */\n          columnIndex: columnIndex\n        });\n        var node;\n        if (headerLevel === 1) {\n          // fill the root node\n          parentNode.data = nodeData;\n          node = parentNode;\n        } else {\n          node = new TreeNode(nodeData);\n          parentNode.addChild(node);\n        }\n        if (headerLevel < _classPrivateFieldGet(_sourceSettings, _this2).getLayersCount()) {\n          _this2.buildLeaves(node, columnIndex, headerLevel, columnSettings.origColspan);\n        }\n        columnIndex += columnSettings.origColspan;\n      });\n    }\n\n    /**\n     * Clears the tree to the initial state.\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      _classPrivateFieldGet(_rootNodes, this).clear();\n      _classPrivateFieldGet(_rootsIndex, this).clear();\n    }\n  }]);\n}();\nexport { HeadersTree as default };","map":{"version":3,"names":["_classPrivateFieldInitSpec","e","t","a","_checkPrivateRedeclaration","set","has","TypeError","_classPrivateFieldGet","s","get","_assertClassBrand","_classPrivateFieldSet","r","n","arguments","length","arrayEach","TreeNode","_rootNodes","WeakMap","_rootsIndex","_sourceSettings","HeadersTree","sourceSettings","_classCallCheck","Map","_createClass","key","value","getRoots","Array","from","values","getRootByColumn","columnIndex","node","getNode","headerLevel","rootNode","normColumnIndex","columnCursor","treeNode","walkDown","_node$data","data","origColspan","nodeHeaderLevel","isRoot","rebuildTreeIndex","_this","clear","_ref","_ref2","_slicedToArray","colspan","i","buildTree","columnsCount","getColumnsCount","columnSettings","getHeaderSettings","buildLeaves","parentNode","_this2","extractionLength","undefined","columnsSettings","getHeadersSettings","nodeData","_objectSpread","addChild","getLayersCount","default"],"sources":["/Users/priyadeliwala/node_modules/handsontable/plugins/nestedHeaders/stateManager/headersTree.mjs"],"sourcesContent":["import \"core-js/modules/es.error.cause.js\";\nfunction _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }\nfunction _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); }\nfunction _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }\nfunction _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }\nfunction _assertClassBrand(e, t, n) { if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError(\"Private element is not present on this object\"); }\nimport { arrayEach } from \"../../../helpers/array.mjs\";\nimport TreeNode from \"../../../utils/dataStructures/tree.mjs\";\n/* eslint-disable jsdoc/require-description-complete-sentence */\n/**\n * @private\n * @class HeadersTree\n *\n * The header tree class keeps nested header settings in the tree\n * structure for easier node manipulation (e.q collapse or expand column).\n * That trees represent the current state of the nested headers. From the\n * trees, the matrix is generated for nested header renderers.\n *\n * The second role of the module is validation. While building the tree,\n * there is check whether the configuration contains overlapping\n * headers. If true, then the exception is thrown.\n *\n * The tree is static; it means that its column indexing never changes\n * even when a collapsing header is performed. The structure is based\n * on visual column indexes.\n *\n * For example, for that header configuration:\n *   +----+----+----+----+----+\n *   │ A1                │ A2 │\n *   +----+----+----+----+----+\n *   │ B1           │ B2 │ B3 │\n *   +----+----+----+----+----+\n *   │ C1      │ C2 │ C3 │ C4 │\n *   +----+----+----+----+----+\n *\n * The tree structures look like:\n *                (0)                      (4)           // a visual column index\n *                 │                        │\n *        .------(A1)------.              (A2)--.\n *   .--(B1)--.           (B2)--.              (B3)--.\n *  (C1)     (C2)              (C3)                 (C4)\n *\n */\n/* eslint-enable jsdoc/require-description-complete-sentence */\nvar _rootNodes = /*#__PURE__*/new WeakMap();\nvar _rootsIndex = /*#__PURE__*/new WeakMap();\nvar _sourceSettings = /*#__PURE__*/new WeakMap();\nexport default class HeadersTree {\n  constructor(sourceSettings) {\n    /**\n     * The collection of nested headers settings structured into trees. The root trees are stored\n     * under the visual column index.\n     *\n     * @private\n     * @type {Map<number, TreeNode>}\n     */\n    _classPrivateFieldInitSpec(this, _rootNodes, new Map());\n    /**\n     * A map that translates the visual column indexes that intersect the range\n     * defined by the header colspan width to the root index.\n     *\n     * @private\n     * @type {Map<number, number>}\n     */\n    _classPrivateFieldInitSpec(this, _rootsIndex, new Map());\n    /**\n     * The instance of the SourceSettings class.\n     *\n     * @private\n     * @type {SourceSettings}\n     */\n    _classPrivateFieldInitSpec(this, _sourceSettings, null);\n    _classPrivateFieldSet(_sourceSettings, this, sourceSettings);\n  }\n\n  /**\n   * Gets an array of the all root nodes.\n   *\n   * @returns {TreeNode[]}\n   */\n  getRoots() {\n    return Array.from(_classPrivateFieldGet(_rootNodes, this).values());\n  }\n\n  /**\n   * Gets a root node by specified visual column index.\n   *\n   * @param {number} columnIndex A visual column index.\n   * @returns {TreeNode|undefined}\n   */\n  getRootByColumn(columnIndex) {\n    let node;\n    if (_classPrivateFieldGet(_rootsIndex, this).has(columnIndex)) {\n      node = _classPrivateFieldGet(_rootNodes, this).get(_classPrivateFieldGet(_rootsIndex, this).get(columnIndex));\n    }\n    return node;\n  }\n\n  /**\n   * Gets a tree node by its position in the grid settings.\n   *\n   * @param {number} headerLevel Header level index (there is support only for positive values).\n   * @param {number} columnIndex A visual column index.\n   * @returns {TreeNode|undefined}\n   */\n  getNode(headerLevel, columnIndex) {\n    const rootNode = this.getRootByColumn(columnIndex);\n    if (!rootNode) {\n      return;\n    }\n\n    // Normalize the visual column index to a 0-based system for a specific \"box\" defined\n    // by root node colspan width.\n    const normColumnIndex = columnIndex - _classPrivateFieldGet(_rootsIndex, this).get(columnIndex);\n    let columnCursor = 0;\n    let treeNode;\n\n    // Collect all parent nodes that depend on the collapsed node.\n    rootNode.walkDown(node => {\n      const {\n        data: {\n          origColspan,\n          headerLevel: nodeHeaderLevel\n        }\n      } = node;\n      if (headerLevel === nodeHeaderLevel) {\n        if (normColumnIndex >= columnCursor && normColumnIndex <= columnCursor + origColspan - 1) {\n          treeNode = node;\n          treeNode.data.isRoot = columnIndex === treeNode.data.columnIndex;\n          return false; // Cancel tree traversing.\n        }\n        columnCursor += origColspan;\n      }\n    });\n    return treeNode;\n  }\n\n  /**\n   * Builds (or rebuilds if called again) root nodes indexes.\n   */\n  rebuildTreeIndex() {\n    let columnIndex = 0;\n    _classPrivateFieldGet(_rootsIndex, this).clear();\n    arrayEach(_classPrivateFieldGet(_rootNodes, this), _ref => {\n      let [, {\n        data: {\n          colspan\n        }\n      }] = _ref;\n      // Map tree range (colspan range/width) into visual column index of the root node.\n      for (let i = columnIndex; i < columnIndex + colspan; i++) {\n        _classPrivateFieldGet(_rootsIndex, this).set(i, columnIndex);\n      }\n      columnIndex += colspan;\n    });\n  }\n\n  /**\n   * Builds trees based on SourceSettings class. Calling a method causes clearing the tree state built\n   * from the previous call.\n   */\n  buildTree() {\n    this.clear();\n    const columnsCount = _classPrivateFieldGet(_sourceSettings, this).getColumnsCount();\n    let columnIndex = 0;\n    while (columnIndex < columnsCount) {\n      const columnSettings = _classPrivateFieldGet(_sourceSettings, this).getHeaderSettings(0, columnIndex);\n      const rootNode = new TreeNode();\n      _classPrivateFieldGet(_rootNodes, this).set(columnIndex, rootNode);\n      this.buildLeaves(rootNode, columnIndex, 0, columnSettings.origColspan);\n      columnIndex += columnSettings.origColspan;\n    }\n    this.rebuildTreeIndex();\n  }\n\n  /**\n   * Builds leaves for specified tree node.\n   *\n   * @param {TreeNode} parentNode A node to which the leaves applies.\n   * @param {number} columnIndex A visual column index.\n   * @param {number} headerLevel Currently processed header level.\n   * @param {number} [extractionLength=1] Determines column extraction length for node children.\n   */\n  buildLeaves(parentNode, columnIndex, headerLevel) {\n    let extractionLength = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n    const columnsSettings = _classPrivateFieldGet(_sourceSettings, this).getHeadersSettings(headerLevel, columnIndex, extractionLength);\n    headerLevel += 1;\n    arrayEach(columnsSettings, columnSettings => {\n      const nodeData = {\n        ...columnSettings,\n        /**\n         * The header level (tree node depth level).\n         *\n         * @type {number}\n         */\n        headerLevel: headerLevel - 1,\n        /**\n         * A visual column index.\n         *\n         * @type {number}\n         */\n        columnIndex\n      };\n      let node;\n      if (headerLevel === 1) {\n        // fill the root node\n        parentNode.data = nodeData;\n        node = parentNode;\n      } else {\n        node = new TreeNode(nodeData);\n        parentNode.addChild(node);\n      }\n      if (headerLevel < _classPrivateFieldGet(_sourceSettings, this).getLayersCount()) {\n        this.buildLeaves(node, columnIndex, headerLevel, columnSettings.origColspan);\n      }\n      columnIndex += columnSettings.origColspan;\n    });\n  }\n\n  /**\n   * Clears the tree to the initial state.\n   */\n  clear() {\n    _classPrivateFieldGet(_rootNodes, this).clear();\n    _classPrivateFieldGet(_rootsIndex, this).clear();\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}